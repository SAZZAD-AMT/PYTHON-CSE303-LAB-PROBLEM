"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CppDocGen = exports.CasingType = exports.CommentType = exports.SpecialCase = void 0;
const moment = require("moment");
const vscode_1 = require("vscode");
const templates = require("../../templatedString");
const util_1 = require("../../util");
const CppParser = require("./CppParser");
const CppToken_1 = require("./CppToken");
var SpecialCase;
(function (SpecialCase) {
    SpecialCase[SpecialCase["none"] = 0] = "none";
    SpecialCase[SpecialCase["constructor"] = 1] = "constructor";
    SpecialCase[SpecialCase["destructor"] = 2] = "destructor";
    SpecialCase[SpecialCase["getter"] = 3] = "getter";
    SpecialCase[SpecialCase["setter"] = 4] = "setter";
    SpecialCase[SpecialCase["factoryMethod"] = 5] = "factoryMethod";
})(SpecialCase = exports.SpecialCase || (exports.SpecialCase = {}));
var CommentType;
(function (CommentType) {
    CommentType[CommentType["method"] = 0] = "method";
    CommentType[CommentType["file"] = 1] = "file";
})(CommentType = exports.CommentType || (exports.CommentType = {}));
var CasingType;
(function (CasingType) {
    CasingType[CasingType["Pascal"] = 0] = "Pascal";
    CasingType[CasingType["camel"] = 1] = "camel";
    CasingType[CasingType["snake"] = 2] = "snake";
    CasingType[CasingType["SCREAMING_SNAKE"] = 3] = "SCREAMING_SNAKE";
    CasingType[CasingType["UPPER"] = 4] = "UPPER";
    CasingType[CasingType["uncertain"] = 5] = "uncertain";
})(CasingType = exports.CasingType || (exports.CasingType = {}));
class CppDocGen {
    /**
     * @param  {TextEditor} actEdit Active editor window
     * @param  {Position} cursorPosition Where the cursor of the user currently is
     * @param  {string[]} templateParams The template parameters of the declaration.
     * @param  {CppArgument} func The type and name of the function to generate doxygen.
     *                          Doesn't contain anything if it is not a function.
     * @param  {CppArgument[]} params The parameters of the function. Doesn't contain anything if it is not a function.
     * @param  {boolean} vscodeAutoGeneratedComment Set this to true if VS Code inserted an autogenerated comment closer
     *                                              on the next line after the comment.
     */
    constructor(actEdit, cursorPosition, cfg, templateParams, func, params, specialCase, commentType, casingType, vscodeAutoGeneratedComment) {
        this.activeEditor = actEdit;
        this.cfg = cfg;
        this.templateParams = templateParams;
        this.func = func;
        this.params = params;
        this.specialCase = specialCase;
        this.commentType = commentType;
        this.smartTextLength = 0;
        this.casingType = casingType;
        this.vscodeAutoGeneratedComment = vscodeAutoGeneratedComment;
    }
    /**
     * @inheritdoc
     */
    GenerateDoc(rangeToReplace, gitConfig) {
        let comment = "";
        this.gitConfig = gitConfig;
        if (this.commentType === CommentType.file) {
            comment = this.generateFileDescription();
        }
        else if (this.commentType === CommentType.method) {
            comment = this.generateComment();
        }
        // overwrite any autogenerated comment closer
        let modifiedRangeToReplace = rangeToReplace;
        if (this.vscodeAutoGeneratedComment) {
            const newPos = new vscode_1.Position(modifiedRangeToReplace.end.line + 1, modifiedRangeToReplace.end.character);
            modifiedRangeToReplace = new vscode_1.Range(rangeToReplace.start, newPos);
        }
        this.activeEditor.edit((editBuilder) => {
            editBuilder.replace(modifiedRangeToReplace, comment); // Insert the comment
        });
        // Set cursor to first DoxyGen command.
        this.moveCursurToFirstDoxyCommand(comment, modifiedRangeToReplace.start.line, modifiedRangeToReplace.start.character);
    }
    /***************************************************************************
                                    Implementation
     ***************************************************************************/
    getSmartText() {
        if (!this.cfg.Generic.generateSmartText) {
            return "";
        }
        let val = "";
        let text = "";
        switch (this.specialCase) {
            case SpecialCase.constructor: {
                if (this.func.name === null) {
                    return "";
                }
                else {
                    const ctorText = this.func.name.trim();
                    this.casingType = CppParser.default.checkCasing(ctorText, 0);
                    val = this.splitCasing(ctorText).trim();
                    text = this.cfg.Cpp.ctorText;
                    break;
                }
            }
            case SpecialCase.destructor: {
                if (this.func.name === null) {
                    return "";
                }
                else {
                    const dtorText = this.func.name.replace("~", "").trim();
                    this.casingType = CppParser.default.checkCasing(dtorText, 0);
                    val = this.splitCasing(dtorText).trim();
                    text = this.cfg.Cpp.dtorText;
                    break;
                }
            }
            case SpecialCase.getter: {
                val = this.splitCasing(this.func.name.trim()).trim().substr(3).trim();
                text = this.cfg.C.getterText;
                break;
            }
            case SpecialCase.setter: {
                val = this.splitCasing(this.func.name.trim()).trim().substr(3).trim();
                text = this.cfg.C.setterText;
                break;
            }
            case SpecialCase.factoryMethod: {
                val = this.splitCasing(this.func.name.trim()).trim().substr(6).trim();
                text = this.cfg.C.factoryMethodText;
                break;
            }
            case SpecialCase.none:
            default: {
                return "";
            }
        }
        const str = templates.getTemplatedString(text, { toReplace: this.cfg.nameTemplateReplace, with: val });
        this.smartTextLength = str.length;
        return str;
    }
    generateBrief(lines) {
        lines.push(...templates.getTemplatedString(this.cfg.Generic.briefTemplate, { toReplace: this.cfg.textTemplateReplace, with: this.getSmartText() }).split("\n"));
    }
    generateReturnParams() {
        const params = [];
        // Check if return type is a pointer
        const ptrReturnIndex = this.func.type.nodes
            .findIndex((n) => n instanceof CppToken_1.CppToken && n.type === CppToken_1.CppTokenType.Pointer);
        // Special case for void functions.
        const voidReturnIndex = this.func.type.nodes
            .findIndex((n) => n instanceof CppToken_1.CppToken && n.type === CppToken_1.CppTokenType.Symbol && n.value === "void");
        // Special case for bool return type.
        const boolReturnIndex = this.func.type.nodes
            .findIndex((n) => n instanceof CppToken_1.CppToken && n.type === CppToken_1.CppTokenType.Symbol && n.value === "bool");
        if (boolReturnIndex !== -1 && this.cfg.Generic.boolReturnsTrueFalse === true) {
            params.push("true");
            params.push("false");
        }
        else if (voidReturnIndex !== -1 && ptrReturnIndex !== -1) {
            params.push(this.cfg.Generic.includeTypeAtReturn === true ? this.func.type.Yield() : "");
        }
        else if (voidReturnIndex === -1 && this.func.type.nodes.length > 0) {
            params.push(this.cfg.Generic.includeTypeAtReturn === true ? this.func.type.Yield() : "");
        }
        else {
            if (this.cfg.Generic.includeTypeAtReturn === false) {
                return [];
            }
        }
        if (this.cfg.Generic.includeTypeAtReturn === false) {
            return [""];
        }
        return params;
    }
    generateAuthorTag(lines) {
        if (this.cfg.Generic.authorTag.trim().length !== 0) {
            const authorInfo = this.getAuthorInfo();
            // Allow substitution of {author} and {email} only
            lines.push(...templates.getMultiTemplatedString(this.cfg.Generic.authorTag, [
                { toReplace: this.cfg.authorTemplateReplace, with: authorInfo.authorName },
                { toReplace: this.cfg.emailTemplateReplace, with: authorInfo.authorEmail },
            ]).split("\n"));
        }
    }
    generateFilenameFromTemplate(lines) {
        if (this.cfg.File.fileTemplate.trim().length !== 0) {
            templates.generateFromTemplate(lines, this.cfg.nameTemplateReplace, this.cfg.File.fileTemplate, [this.activeEditor.document.fileName.replace(/^.*[\\\/]/, "")]);
        }
    }
    generateVersionTag(lines) {
        if (this.cfg.File.versionTag.trim().length !== 0) {
            lines.push(...templates.getIndentedTemplate(this.cfg.File.versionTag).split("\n"));
        }
    }
    generateCopyrightTag(lines) {
        // This currently only supports year substitution
        this.cfg.File.copyrightTag.forEach((element) => {
            templates.generateFromTemplate(lines, this.cfg.yearTemplateReplace, element, [moment().format("YYYY")]);
        });
    }
    /**
     * Generate those tags shared between File comment and function comment
     */
    generateCommonTag(lines, tags) {
        switch (tags) {
            case "brief": {
                this.insertBrief(lines);
                break;
            }
            case "empty": {
                lines.push("");
                break;
            }
            case "version": {
                this.generateVersionTag(lines);
                break;
            }
            case "author": {
                this.generateAuthorTag(lines);
                break;
            }
            case "date": {
                this.generateDateFromTemplate(lines);
                break;
            }
            case "copyright": {
                this.generateCopyrightTag(lines);
                break;
            }
            default: {
                break;
            }
        }
    }
    generateCustomTag(lines, target = CommentType.file) {
        let dateFormat = "YYYY-MM-DD"; // Default to ISO standard if not defined
        if (this.cfg.Generic.dateFormat.trim().length !== 0) {
            dateFormat = this.cfg.Generic.dateFormat; // Overwrite with user format
        }
        // Have to check this setting, otherwise {author} and {email} will get incorrect result
        // if useGitUserName and useGitUserEmail is used
        const authorInfo = this.getAuthorInfo();
        const targetTagArray = target === CommentType.file ? this.cfg.File.customTag : this.cfg.Generic.customTags;
        // For each line of the customTag
        targetTagArray.forEach((element) => {
            if (element !== "custom") { // Prevent recursive expansion
                // Allow any of date, year, author, email to be replaced
                lines.push(...templates.getMultiTemplatedString(element, [
                    { toReplace: this.cfg.authorTemplateReplace, with: authorInfo.authorName },
                    { toReplace: this.cfg.emailTemplateReplace, with: authorInfo.authorEmail },
                    { toReplace: this.cfg.dateTemplateReplace, with: moment().format(dateFormat) },
                    { toReplace: this.cfg.yearTemplateReplace, with: moment().format("YYYY") },
                    { toReplace: "{file}", with: this.activeEditor.document.fileName.replace(/^.*[\\\/]/, "") },
                ]).split("\n"));
            }
        });
    }
    generateDateFromTemplate(lines) {
        if (this.cfg.Generic.dateTemplate.trim().length !== 0 &&
            this.cfg.Generic.dateFormat.trim().length !== 0) {
            templates.generateFromTemplate(lines, this.cfg.dateTemplateReplace, this.cfg.Generic.dateTemplate, [moment().format(this.cfg.Generic.dateFormat)]);
        }
    }
    insertFirstLine(lines) {
        if (this.cfg.C.firstLine.trim().length !== 0) {
            lines.unshift(this.cfg.C.firstLine);
        }
    }
    insertBrief(lines) {
        if (this.cfg.Generic.briefTemplate.trim().length !== 0) {
            this.generateBrief(lines);
        }
    }
    insertLastLine(lines) {
        if (this.cfg.C.lastLine.trim().length !== 0) {
            lines.push(this.cfg.C.lastLine);
        }
    }
    generateFileDescription() {
        let lines = [];
        this.cfg.File.fileOrder.forEach((element) => {
            switch (element) {
                case "file": {
                    this.generateFilenameFromTemplate(lines);
                    break;
                }
                case "custom": {
                    this.generateCustomTag(lines, CommentType.file);
                    break;
                }
                default: {
                    this.generateCommonTag(lines, element);
                }
            }
        });
        lines = lines.map((line) => `${this.cfg.C.commentPrefix}${line}`);
        this.insertFirstLine(lines);
        this.insertLastLine(lines);
        return lines.join("\n");
    }
    generateComment() {
        let lines = [];
        this.cfg.Generic.order.forEach((element) => {
            switch (element) {
                case "tparam": {
                    if (this.cfg.Cpp.tparamTemplate.trim().length !== 0 && this.templateParams.length > 0) {
                        templates.generateFromTemplate(lines, this.cfg.paramTemplateReplace, this.cfg.Cpp.tparamTemplate, this.templateParams);
                    }
                    break;
                }
                case "param": {
                    if (this.cfg.Generic.paramTemplate.trim().length !== 0 && this.params.length > 0) {
                        const paramNames = this.params.map((p) => p.name);
                        templates.generateFromTemplate(lines, this.cfg.paramTemplateReplace, this.cfg.Generic.paramTemplate, paramNames);
                    }
                    break;
                }
                case "return": {
                    if (this.cfg.Generic.returnTemplate.trim().length !== 0 && this.func.type !== null) {
                        const returnParams = this.generateReturnParams();
                        templates.generateFromTemplate(lines, this.cfg.typeTemplateReplace, this.cfg.Generic.returnTemplate, returnParams);
                    }
                    break;
                }
                case "custom": {
                    this.generateCustomTag(lines, CommentType.method);
                    break;
                }
                default: {
                    this.generateCommonTag(lines, element);
                }
            }
        });
        lines = lines.map((line) => `${this.cfg.C.commentPrefix}${line}`);
        this.insertFirstLine(lines);
        this.insertLastLine(lines);
        return lines.join(`\n${util_1.getIndentation(this.activeEditor)}`);
    }
    moveCursurToFirstDoxyCommand(comment, baseLine, baseCharacter) {
        // Find first offset of a new line in the comment. Since that's when the line where the first param starts.
        let line = baseLine;
        let character = comment.indexOf("\n");
        // If a first line is included find the 2nd line with a newline.
        if (this.cfg.C.firstLine.trim().length !== 0) {
            line++;
            const oldCharacter = character;
            character = comment.indexOf("\n", oldCharacter + 1) - oldCharacter;
        }
        // If newline is not found means no first param was found so Set to base line before the newline.
        if (character < 0) {
            line = baseLine;
            character = baseCharacter;
        }
        const to = new vscode_1.Position(line, character);
        this.activeEditor.selection = new vscode_1.Selection(to, to);
    }
    splitCasing(text) {
        if (!this.cfg.Generic.splitCasingSmartText) {
            return text;
        }
        let txt = text;
        let vals = [];
        switch (this.casingType) {
            case CasingType.SCREAMING_SNAKE: {
                txt = txt.toLowerCase();
            }
            case CasingType.snake: {
                vals = txt.split("_");
                break;
            }
            case CasingType.Pascal: {
                txt = txt.replace(/([A-Z0-9])/g, " $1");
                vals.push(txt);
                break;
            }
            case CasingType.camel: {
                txt = txt.replace(/([a-zA-Z0-9])(?=[A-Z])/g, "$1 ");
                vals.push(txt);
                break;
            }
            case CasingType.UPPER:
            case CasingType.uncertain:
            default: {
                return text;
            }
        }
        return vals.join(" ");
    }
    /**
     * Get author info, possibly using info from git config
     */
    getAuthorInfo() {
        let authorName = this.cfg.Generic.authorName;
        let authorEmail = this.cfg.Generic.authorEmail;
        // Check if set to use the git username
        if (this.cfg.Generic.useGitUserName === true) {
            authorName = this.gitConfig.UserName;
        }
        // Check if set to use the git email
        if (this.cfg.Generic.useGitUserEmail === true) {
            authorEmail = this.gitConfig.UserEmail;
        }
        return {
            authorEmail,
            authorName,
        };
    }
}
exports.CppDocGen = CppDocGen;
//# sourceMappingURL=CppDocGen.js.map