/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 3255:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 3255;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 9118:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 9118;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 7492:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 7492;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 1509:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(4917);
const inherits = __webpack_require__(1669).inherits;
const promisify = __webpack_require__(930);
const EventEmitter = __webpack_require__(8614).EventEmitter;

module.exports = Agent;

function isAgent(v) {
  return v && typeof v.addRequest === 'function';
}

/**
 * Base `http.Agent` implementation.
 * No pooling/keep-alive is implemented by default.
 *
 * @param {Function} callback
 * @api public
 */
function Agent(callback, _opts) {
  if (!(this instanceof Agent)) {
    return new Agent(callback, _opts);
  }

  EventEmitter.call(this);

  // The callback gets promisified if it has 3 parameters
  // (i.e. it has a callback function) lazily
  this._promisifiedCallback = false;

  let opts = _opts;
  if ('function' === typeof callback) {
    this.callback = callback;
  } else if (callback) {
    opts = callback;
  }

  // timeout for the socket to be returned from the callback
  this.timeout = (opts && opts.timeout) || null;

  this.options = opts;
}
inherits(Agent, EventEmitter);

/**
 * Override this function in your subclass!
 */
Agent.prototype.callback = function callback(req, opts) {
  throw new Error(
    '"agent-base" has no default implementation, you must subclass and override `callback()`'
  );
};

/**
 * Called by node-core's "_http_client.js" module when creating
 * a new HTTP request with this Agent instance.
 *
 * @api public
 */
Agent.prototype.addRequest = function addRequest(req, _opts) {
  const ownOpts = Object.assign({}, _opts);

  // Set default `host` for HTTP to localhost
  if (null == ownOpts.host) {
    ownOpts.host = 'localhost';
  }

  // Set default `port` for HTTP if none was explicitly specified
  if (null == ownOpts.port) {
    ownOpts.port = ownOpts.secureEndpoint ? 443 : 80;
  }

  const opts = Object.assign({}, this.options, ownOpts);

  if (opts.host && opts.path) {
    // If both a `host` and `path` are specified then it's most likely the
    // result of a `url.parse()` call... we need to remove the `path` portion so
    // that `net.connect()` doesn't attempt to open that as a unix socket file.
    delete opts.path;
  }

  delete opts.agent;
  delete opts.hostname;
  delete opts._defaultAgent;
  delete opts.defaultPort;
  delete opts.createConnection;

  // Hint to use "Connection: close"
  // XXX: non-documented `http` module API :(
  req._last = true;
  req.shouldKeepAlive = false;

  // Create the `stream.Duplex` instance
  let timeout;
  let timedOut = false;
  const timeoutMs = this.timeout;
  const freeSocket = this.freeSocket;

  function onerror(err) {
    if (req._hadError) return;
    req.emit('error', err);
    // For Safety. Some additional errors might fire later on
    // and we need to make sure we don't double-fire the error event.
    req._hadError = true;
  }

  function ontimeout() {
    timeout = null;
    timedOut = true;
    const err = new Error(
      'A "socket" was not created for HTTP request before ' + timeoutMs + 'ms'
    );
    err.code = 'ETIMEOUT';
    onerror(err);
  }

  function callbackError(err) {
    if (timedOut) return;
    if (timeout != null) {
      clearTimeout(timeout);
      timeout = null;
    }
    onerror(err);
  }

  function onsocket(socket) {
    if (timedOut) return;
    if (timeout != null) {
      clearTimeout(timeout);
      timeout = null;
    }
    if (isAgent(socket)) {
      // `socket` is actually an http.Agent instance, so relinquish
      // responsibility for this `req` to the Agent from here on
      socket.addRequest(req, opts);
    } else if (socket) {
      function onfree() {
        freeSocket(socket, opts);
      }
      socket.on('free', onfree);
      req.onSocket(socket);
    } else {
      const err = new Error(
        'no Duplex stream was returned to agent-base for `' + req.method + ' ' + req.path + '`'
      );
      onerror(err);
    }
  }

  if (!this._promisifiedCallback && this.callback.length >= 3) {
    // Legacy callback function - convert to a Promise
    this.callback = promisify(this.callback, this);
    this._promisifiedCallback = true;
  }

  if (timeoutMs > 0) {
    timeout = setTimeout(ontimeout, timeoutMs);
  }

  try {
    Promise.resolve(this.callback(req, opts)).then(onsocket, callbackError);
  } catch (err) {
    Promise.reject(err).catch(callbackError);
  }
};

Agent.prototype.freeSocket = function freeSocket(socket, opts) {
  // TODO reuse sockets
  socket.destroy();
};


/***/ }),

/***/ 4917:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const url = __webpack_require__(8835);
const https = __webpack_require__(7211);

/**
 * This currently needs to be applied to all Node.js versions
 * in order to determine if the `req` is an HTTP or HTTPS request.
 *
 * There is currently no PR attempting to move this property upstream.
 */
const patchMarker = "__agent_base_https_request_patched__";
if (!https.request[patchMarker]) {
  https.request = (function(request) {
    return function(_options, cb) {
      let options;
      if (typeof _options === 'string') {
        options = url.parse(_options);
      } else {
        options = Object.assign({}, _options);
      }
      if (null == options.port) {
        options.port = 443;
      }
      options.secureEndpoint = true;
      return request.call(https, options, cb);
    };
  })(https.request);
  https.request[patchMarker] = true;
}

/**
 * This is needed for Node.js >= 9.0.0 to make sure `https.get()` uses the
 * patched `https.request()`.
 *
 * Ref: https://github.com/nodejs/node/commit/5118f31
 */
https.get = function (_url, _options, cb) {
    let options;
    if (typeof _url === 'string' && _options && typeof _options !== 'function') {
      options = Object.assign({}, url.parse(_url), _options);
    } else if (!_options && !cb) {
      options = _url;
    } else if (!cb) {
      options = _url;
      cb = _options;
    }

  const req = https.request(options, cb);
  req.end();
  return req;
};


/***/ }),

/***/ 8813:
/***/ ((module) => {

/**
 * Default minimum size of a run.
 */
const DEFAULT_MIN_MERGE = 32

/**
 * Minimum ordered subsequece required to do galloping.
 */
const DEFAULT_MIN_GALLOPING = 7

/**
 * Default tmp storage length. Can increase depending on the size of the
 * smallest run to merge.
 */
const DEFAULT_TMP_STORAGE_LENGTH = 256

/**
 * Pre-computed powers of 10 for efficient lexicographic comparison of
 * small integers.
 */
const POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9]

let results

/**
 * Estimate the logarithm base 10 of a small integer.
 *
 * @param {number} x - The integer to estimate the logarithm of.
 * @return {number} - The estimated logarithm of the integer.
 */
const log10 = x => x < 1e5
  ? x < 1e2
    ? x < 1e1
      ? 0
      : 1
    : x < 1e4
      ? x < 1e3
        ? 2
        : 3
      : 4
  : x < 1e7
    ? x < 1e6
      ? 5
      : 6
    : x < 1e9
      ? x < 1e8
        ? 7
        : 8
      : 9

/**
 * Default alphabetical comparison of items.
 *
 * @param {string|object|number} a - First element to compare.
 * @param {string|object|number} b - Second element to compare.
 * @return {number} - A positive number if a.toString() > b.toString(), a
 * negative number if .toString() < b.toString(), 0 otherwise.
 */
function alphabeticalCompare (a, b) {
  if (a === b) {
    return 0
  }

  if (~ ~ a === a && ~ ~ b === b) {
    if (a === 0 || b === 0) {
      return a < b ? - 1 : 1
    }

    if (a < 0 || b < 0) {
      if (b >= 0) {
        return - 1
      }

      if (a >= 0) {
        return 1
      }

      a = - a
      b = - b
    }

    const al = log10(a)
    const bl = log10(b)

    let t = 0

    if (al < bl) {
      a *= POWERS_OF_TEN[bl - al - 1]
      b /= 10
      t = - 1
    } else if (al > bl) {
      b *= POWERS_OF_TEN[al - bl - 1]
      a /= 10
      t = 1
    }

    if (a === b) {
      return t
    }

    return a < b ? - 1 : 1
  }

  const aStr = String(a)
  const bStr = String(b)

  if (aStr === bStr) {
    return 0
  }

  return aStr < bStr ? - 1 : 1
}

/**
 * Compute minimum run length for TimSort
 *
 * @param {number} n - The size of the array to sort.
 */
function minRunLength (n) {
  let r = 0

  while (n >= DEFAULT_MIN_MERGE) {
    r |= (n & 1)
    n >>= 1
  }

  return n + r
}

/**
 * Counts the length of a monotonically ascending or strictly monotonically
 * descending sequence (run) starting at array[lo] in the range [lo, hi). If
 * the run is descending it is made ascending.
 *
 * @param {array} array - The array to reverse.
 * @param {number} lo - First element in the range (inclusive).
 * @param {number} hi - Last element in the range.
 * @param {function} compare - Item comparison function.
 * @return {number} - The length of the run.
 */
function makeAscendingRun (array, lo, hi, compare) {
  let runHi = lo + 1

  if (runHi === hi) {
    return 1
  }

  // Descending
  if (compare(array[runHi ++], array[lo]) < 0) {
    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
      runHi ++
    }

    reverseRun(array, lo, runHi)
    reverseRun(results, lo, runHi)
    // Ascending
  } else {
    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
      runHi ++
    }
  }

  return runHi - lo
}

/**
 * Reverse an array in the range [lo, hi).
 *
 * @param {array} array - The array to reverse.
 * @param {number} lo - First element in the range (inclusive).
 * @param {number} hi - Last element in the range.
 */
function reverseRun (array, lo, hi) {
  hi --

  while (lo < hi) {
    const t = array[lo]
    array[lo ++] = array[hi]
    array[hi --] = t
  }
}

/**
 * Perform the binary sort of the array in the range [lo, hi) where start is
 * the first element possibly out of order.
 *
 * @param {array} array - The array to sort.
 * @param {number} lo - First element in the range (inclusive).
 * @param {number} hi - Last element in the range.
 * @param {number} start - First element possibly out of order.
 * @param {function} compare - Item comparison function.
 */
function binaryInsertionSort (array, lo, hi, start, compare) {
  if (start === lo) {
    start ++
  }

  for (; start < hi; start ++) {
    const pivot = array[start]
    const pivotIndex = results[start]

    // Ranges of the array where pivot belongs
    let left = lo
    let right = start

    /*
     *   pivot >= array[i] for i in [lo, left)
     *   pivot <  array[i] for i in  in [right, start)
     */
    while (left < right) {
      const mid = (left + right) >>> 1

      if (compare(pivot, array[mid]) < 0) {
        right = mid
      } else {
        left = mid + 1
      }
    }

    /*
     * Move elements right to make room for the pivot. If there are elements
     * equal to pivot, left points to the first slot after them: this is also
     * a reason for which TimSort is stable
     */
    let n = start - left
    // Switch is just an optimization for small arrays
    switch (n) {
    case 3:
      array[left + 3] = array[left + 2]
      results[left + 3] = results[left + 2]
      /* falls through */
    case 2:
      array[left + 2] = array[left + 1]
      results[left + 2] = results[left + 1]
      /* falls through */
    case 1:
      array[left + 1] = array[left]
      results[left + 1] = results[left]
      break
    default:
      while (n > 0) {
        array[left + n] = array[left + n - 1]
        results[left + n] = results[left + n - 1]
        n --
      }
    }

    array[left] = pivot
    results[left] = pivotIndex
  }
}

/**
 * Find the position at which to insert a value in a sorted range. If the range
 * contains elements equal to the value the leftmost element index is returned
 * (for stability).
 *
 * @param {number} value - Value to insert.
 * @param {array} array - The array in which to insert value.
 * @param {number} start - First element in the range.
 * @param {number} length - Length of the range.
 * @param {number} hint - The index at which to begin the search.
 * @param {function} compare - Item comparison function.
 * @return {number} - The index where to insert value.
 */
function gallopLeft (value, array, start, length, hint, compare) {
  let lastOffset = 0
  let maxOffset = 0
  let offset = 1

  if (compare(value, array[start + hint]) > 0) {
    maxOffset = length - hint

    while (
      offset < maxOffset
      && compare(value, array[start + hint + offset]) > 0
    ) {
      lastOffset = offset
      offset = (offset << 1) + 1

      if (offset <= 0) {
        offset = maxOffset
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset
    }

    // Make offsets relative to start
    lastOffset += hint
    offset += hint

    // value <= array[start + hint]
  } else {
    maxOffset = hint + 1
    while (
      offset < maxOffset
      && compare(value, array[start + hint - offset]) <= 0
    ) {
      lastOffset = offset
      offset = (offset << 1) + 1

      if (offset <= 0) {
        offset = maxOffset
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset
    }

    // Make offsets relative to start
    const tmp = lastOffset
    lastOffset = hint - offset
    offset = hint - tmp
  }

  /*
   * Now array[start+lastOffset] < value <= array[start+offset], so value
   * belongs somewhere in the range (start + lastOffset, start + offset]. Do a
   * binary search, with invariant array[start + lastOffset - 1] < value <=
   * array[start + offset].
   */
  lastOffset ++
  while (lastOffset < offset) {
    const m = lastOffset + ((offset - lastOffset) >>> 1)

    if (compare(value, array[start + m]) > 0) {
      lastOffset = m + 1
    } else {
      offset = m
    }
  }
  return offset
}

/**
 * Find the position at which to insert a value in a sorted range. If the range
 * contains elements equal to the value the rightmost element index is returned
 * (for stability).
 *
 * @param {number} value - Value to insert.
 * @param {array} array - The array in which to insert value.
 * @param {number} start - First element in the range.
 * @param {number} length - Length of the range.
 * @param {number} hint - The index at which to begin the search.
 * @param {function} compare - Item comparison function.
 * @return {number} - The index where to insert value.
 */
function gallopRight (value, array, start, length, hint, compare) {
  let lastOffset = 0
  let maxOffset = 0
  let offset = 1

  if (compare(value, array[start + hint]) < 0) {
    maxOffset = hint + 1

    while (
      offset < maxOffset
      && compare(value, array[start + hint - offset]) < 0
    ) {
      lastOffset = offset
      offset = (offset << 1) + 1

      if (offset <= 0) {
        offset = maxOffset
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset
    }

    // Make offsets relative to start
    const tmp = lastOffset
    lastOffset = hint - offset
    offset = hint - tmp

    // value >= array[start + hint]
  } else {
    maxOffset = length - hint

    while (
      offset < maxOffset
      && compare(value, array[start + hint + offset]) >= 0
    ) {
      lastOffset = offset
      offset = (offset << 1) + 1

      if (offset <= 0) {
        offset = maxOffset
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset
    }

    // Make offsets relative to start
    lastOffset += hint
    offset += hint
  }

  /*
   * Now array[start+lastOffset] < value <= array[start+offset], so value
   * belongs somewhere in the range (start + lastOffset, start + offset]. Do a
   * binary search, with invariant array[start + lastOffset - 1] < value <=
   * array[start + offset].
   */
  lastOffset ++

  while (lastOffset < offset) {
    const m = lastOffset + ((offset - lastOffset) >>> 1)

    if (compare(value, array[start + m]) < 0) {
      offset = m
    } else {
      lastOffset = m + 1
    }
  }

  return offset
}

class TimSort {
  constructor (array, compare) {
    this.array = array
    this.compare = compare

    const {length} = array

    this.length = length
    this.minGallop = DEFAULT_MIN_GALLOPING

    this.tmpStorageLength = length < 2 * DEFAULT_TMP_STORAGE_LENGTH
      ? length >>> 1
      : DEFAULT_TMP_STORAGE_LENGTH

    this.tmp = new Array(this.tmpStorageLength)
    this.tmpIndex = new Array(this.tmpStorageLength)

    this.stackLength = length < 120
      ? 5
      : length < 1542
        ? 10
        : length < 119151
          ? 19
          : 40

    this.runStart = new Array(this.stackLength)
    this.runLength = new Array(this.stackLength)

    this.stackSize = 0
  }

  /**
   * Push a new run on TimSort's stack.
   *
   * @param {number} runStart - Start index of the run in the original array.
   * @param {number} runLength - Length of the run;
   */
  pushRun (runStart, runLength) {
    this.runStart[this.stackSize] = runStart
    this.runLength[this.stackSize] = runLength
    this.stackSize += 1
  }

  /**
   * Merge runs on TimSort's stack so that the following holds for all i:
   * 1) runLength[i - 3] > runLength[i - 2] + runLength[i - 1]
   * 2) runLength[i - 2] > runLength[i - 1]
   */
  mergeRuns () {
    while (this.stackSize > 1) {
      let n = this.stackSize - 2

      if (
        (
          n >= 1
          && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1]
        )
        || (
          n >= 2
          && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]
        )
      ) {
        if (this.runLength[n - 1] < this.runLength[n + 1]) {
          n --
        }
      } else if (this.runLength[n] > this.runLength[n + 1]) {
        break
      }
      this.mergeAt(n)
    }
  }

  /**
   * Merge all runs on TimSort's stack until only one remains.
   */
  forceMergeRuns () {
    while (this.stackSize > 1) {
      let n = this.stackSize - 2

      if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
        n --
      }

      this.mergeAt(n)
    }
  }

  /**
   * Merge the runs on the stack at positions i and i+1. Must be always be called
   * with i=stackSize-2 or i=stackSize-3 (that is, we merge on top of the stack).
   *
   * @param {number} i - Index of the run to merge in TimSort's stack.
   */
  mergeAt (i) {
    const {compare} = this
    const {array} = this

    let start1 = this.runStart[i]
    let length1 = this.runLength[i]
    const start2 = this.runStart[i + 1]
    let length2 = this.runLength[i + 1]

    this.runLength[i] = length1 + length2

    if (i === this.stackSize - 3) {
      this.runStart[i + 1] = this.runStart[i + 2]
      this.runLength[i + 1] = this.runLength[i + 2]
    }

    this.stackSize --

    /*
     * Find where the first element in the second run goes in run1. Previous
     * elements in run1 are already in place
     */
    const k = gallopRight(array[start2], array, start1, length1, 0, compare)
    start1 += k
    length1 -= k

    if (length1 === 0) {
      return
    }

    /*
     * Find where the last element in the first run goes in run2. Next elements
     * in run2 are already in place
     */
    length2 = gallopLeft(
      array[start1 + length1 - 1],
      array,
      start2,
      length2,
      length2 - 1,
      compare
    )

    if (length2 === 0) {
      return
    }

    /*
     * Merge remaining runs. A tmp array with length = min(length1, length2) is
     * used
     */
    if (length1 <= length2) {
      this.mergeLow(start1, length1, start2, length2)
    } else {
      this.mergeHigh(start1, length1, start2, length2)
    }
  }

  /**
   * Merge two adjacent runs in a stable way. The runs must be such that the
   * first element of run1 is bigger than the first element in run2 and the
   * last element of run1 is greater than all the elements in run2.
   * The method should be called when run1.length <= run2.length as it uses
   * TimSort temporary array to store run1. Use mergeHigh if run1.length >
   * run2.length.
   *
   * @param {number} start1 - First element in run1.
   * @param {number} length1 - Length of run1.
   * @param {number} start2 - First element in run2.
   * @param {number} length2 - Length of run2.
   */
  mergeLow (start1, length1, start2, length2) {
    const {compare} = this
    const {array} = this
    const {tmp} = this
    const {tmpIndex} = this
    let i = 0

    for (i = 0; i < length1; i ++) {
      tmp[i] = array[start1 + i]
      tmpIndex[i] = results[start1 + i]
    }

    let cursor1 = 0
    let cursor2 = start2
    let dest = start1

    array[dest] = array[cursor2]
    results[dest] = results[cursor2]

    dest ++
    cursor2 ++

    if (-- length2 === 0) {
      for (i = 0; i < length1; i ++) {
        array[dest + i] = tmp[cursor1 + i]
        results[dest + i] = tmpIndex[cursor1 + i]
      }
      return
    }

    if (length1 === 1) {
      for (i = 0; i < length2; i ++) {
        array[dest + i] = array[cursor2 + i]
        results[dest + i] = results[cursor2 + i]
      }
      array[dest + length2] = tmp[cursor1]
      results[dest + length2] = tmpIndex[cursor1]
      return
    }

    let {minGallop} = this

    while (true) {
      let count1 = 0
      let count2 = 0
      let exit = false

      do {
        if (compare(array[cursor2], tmp[cursor1]) < 0) {
          array[dest] = array[cursor2]
          results[dest] = results[cursor2]
          dest ++
          cursor2 ++
          count2 ++
          count1 = 0

          if (-- length2 === 0) {
            exit = true
            break
          }
        } else {
          array[dest] = tmp[cursor1]
          results[dest] = tmpIndex[cursor1]
          dest ++
          cursor1 ++
          count1 ++
          count2 = 0
          if (-- length1 === 1) {
            exit = true
            break
          }
        }
      } while ((count1 | count2) < minGallop)

      if (exit) {
        break
      }

      do {
        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare)

        if (count1 !== 0) {
          for (i = 0; i < count1; i ++) {
            array[dest + i] = tmp[cursor1 + i]
            results[dest + i] = tmpIndex[cursor1 + i]
          }

          dest += count1
          cursor1 += count1
          length1 -= count1
          if (length1 <= 1) {
            exit = true
            break
          }
        }

        array[dest] = array[cursor2]
        results[dest] = results[cursor2]

        dest ++
        cursor2 ++

        if (-- length2 === 0) {
          exit = true
          break
        }

        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare)

        if (count2 !== 0) {
          for (i = 0; i < count2; i ++) {
            array[dest + i] = array[cursor2 + i]
            results[dest + i] = results[cursor2 + i]
          }

          dest += count2
          cursor2 += count2
          length2 -= count2

          if (length2 === 0) {
            exit = true
            break
          }
        }
        array[dest] = tmp[cursor1]
        results[dest] = tmpIndex[cursor1]
        dest ++
        cursor1 ++

        if (-- length1 === 1) {
          exit = true
          break
        }

        minGallop --
      } while (
        count1 >= DEFAULT_MIN_GALLOPING
        || count2 >= DEFAULT_MIN_GALLOPING
      )

      if (exit) {
        break
      }

      if (minGallop < 0) {
        minGallop = 0
      }

      minGallop += 2
    }

    this.minGallop = minGallop

    if (minGallop < 1) {
      this.minGallop = 1
    }

    if (length1 === 1) {
      for (i = 0; i < length2; i ++) {
        array[dest + i] = array[cursor2 + i]
        results[dest + i] = results[cursor2 + i]
      }
      array[dest + length2] = tmp[cursor1]
      results[dest + length2] = tmpIndex[cursor1]
    } else if (length1 === 0) {
      throw new Error('mergeLow preconditions were not respected')
    } else {
      for (i = 0; i < length1; i ++) {
        array[dest + i] = tmp[cursor1 + i]
        results[dest + i] = tmpIndex[cursor1 + i]
      }
    }
  }

  /**
   * Merge two adjacent runs in a stable way. The runs must be such that the
   * first element of run1 is bigger than the first element in run2 and the
   * last element of run1 is greater than all the elements in run2.
   * The method should be called when run1.length > run2.length as it uses
   * TimSort temporary array to store run2. Use mergeLow if run1.length <=
   * run2.length.
   *
   * @param {number} start1 - First element in run1.
   * @param {number} length1 - Length of run1.
   * @param {number} start2 - First element in run2.
   * @param {number} length2 - Length of run2.
   */
  mergeHigh (start1, length1, start2, length2) {
    const {compare} = this
    const {array} = this
    const {tmp} = this
    const {tmpIndex} = this
    let i = 0

    for (i = 0; i < length2; i ++) {
      tmp[i] = array[start2 + i]
      tmpIndex[i] = results[start2 + i]
    }

    let cursor1 = start1 + length1 - 1
    let cursor2 = length2 - 1
    let dest = start2 + length2 - 1
    let customCursor = 0
    let customDest = 0

    array[dest] = array[cursor1]
    results[dest] = results[cursor1]

    dest --
    cursor1 --

    if (-- length1 === 0) {
      customCursor = dest - (length2 - 1)

      for (i = 0; i < length2; i ++) {
        array[customCursor + i] = tmp[i]
        results[customCursor + i] = tmpIndex[i]
      }

      return
    }

    if (length2 === 1) {
      dest -= length1
      cursor1 -= length1
      customDest = dest + 1
      customCursor = cursor1 + 1

      for (i = length1 - 1; i >= 0; i --) {
        array[customDest + i] = array[customCursor + i]
        results[customDest + i] = results[customCursor + i]
      }

      array[dest] = tmp[cursor2]
      results[dest] = tmpIndex[cursor2]
      return
    }

    let {minGallop} = this

    while (true) {
      let count1 = 0
      let count2 = 0
      let exit = false

      do {
        if (compare(tmp[cursor2], array[cursor1]) < 0) {
          array[dest] = array[cursor1]
          results[dest] = results[cursor1]
          dest --
          cursor1 --
          count1 ++
          count2 = 0
          if (-- length1 === 0) {
            exit = true
            break
          }
        } else {
          array[dest] = tmp[cursor2]
          results[dest] = tmpIndex[cursor2]
          dest --
          cursor2 --
          count2 ++
          count1 = 0
          if (-- length2 === 1) {
            exit = true
            break
          }
        }
      } while ((count1 | count2) < minGallop)

      if (exit) {
        break
      }

      do {
        count1 = length1 - gallopRight(
          tmp[cursor2],
          array,
          start1,
          length1,
          length1 - 1,
          compare
        )

        if (count1 !== 0) {
          dest -= count1
          cursor1 -= count1
          length1 -= count1
          customDest = dest + 1
          customCursor = cursor1 + 1

          for (i = count1 - 1; i >= 0; i --) {
            array[customDest + i] = array[customCursor + i]
            results[customDest + i] = results[customCursor + i]
          }

          if (length1 === 0) {
            exit = true
            break
          }
        }

        array[dest] = tmp[cursor2]
        results[dest] = tmpIndex[cursor2]
        dest --
        cursor2 --

        if (-- length2 === 1) {
          exit = true
          break
        }

        count2 = length2 - gallopLeft(
          array[cursor1],
          tmp,
          0,
          length2,
          length2 - 1,
          compare
        )

        if (count2 !== 0) {
          dest -= count2
          cursor2 -= count2
          length2 -= count2
          customDest = dest + 1
          customCursor = cursor2 + 1

          for (i = 0; i < count2; i ++) {
            array[customDest + i] = tmp[customCursor + i]
            results[customDest + i] = tmpIndex[customCursor + i]
          }

          if (length2 <= 1) {
            exit = true
            break
          }
        }

        array[dest] = array[cursor1]
        results[dest] = results[cursor1]
        dest --
        cursor1 --

        if (-- length1 === 0) {
          exit = true
          break
        }

        minGallop --
      } while (
        count1 >= DEFAULT_MIN_GALLOPING
        || count2 >= DEFAULT_MIN_GALLOPING
      )

      if (exit) {
        break
      }

      if (minGallop < 0) {
        minGallop = 0
      }

      minGallop += 2
    }

    this.minGallop = minGallop

    if (minGallop < 1) {
      this.minGallop = 1
    }

    if (length2 === 1) {
      dest -= length1
      cursor1 -= length1
      customDest = dest + 1
      customCursor = cursor1 + 1

      for (i = length1 - 1; i >= 0; i --) {
        array[customDest + i] = array[customCursor + i]
        results[customDest + i] = results[customCursor + i]
      }

      array[dest] = tmp[cursor2]
      results[dest] = tmpIndex[cursor2]
    } else if (length2 === 0) {
      throw new Error('mergeHigh preconditions were not respected')
    } else {
      customCursor = dest - (length2 - 1)
      for (i = 0; i < length2; i ++) {
        array[customCursor + i] = tmp[i]
        results[customCursor + i] = tmpIndex[i]
      }
    }
  }
}

/**
 * Sort an array in the range [lo, hi) using TimSort.
 *
 * @param {array} array - The array to sort.
 * @param {function=} compare - Item comparison function. Default is
 *     alphabetical
 * @param {number} lo - First element in the range (inclusive).
 * @param {number} hi - Last element in the range.
 *     comparator.
 */
function sort (array, compare, lo, hi) {
  if (!Array.isArray(array)) {
    throw new TypeError(
      `The "array" argument must be an array. Received ${array}`
    )
  }

  results = []

  const {length} = array

  let i = 0

  while (i < length) {
    results[i] = i ++
  }

  /*
   * Handle the case where a comparison function is not provided. We do
   * lexicographic sorting
   */
  if (!compare) {
    compare = alphabeticalCompare
  } else if (typeof compare !== 'function') {
    hi = lo
    lo = compare
    compare = alphabeticalCompare
  }

  if (!lo) {
    lo = 0
  }
  if (!hi) {
    hi = length
  }

  let remaining = hi - lo

  // The array is already sorted
  if (remaining < 2) {
    return results
  }

  let runLength = 0
  // On small arrays binary sort can be used directly
  if (remaining < DEFAULT_MIN_MERGE) {
    runLength = makeAscendingRun(array, lo, hi, compare)
    binaryInsertionSort(array, lo, hi, lo + runLength, compare)
    return results
  }

  const ts = new TimSort(array, compare)

  const minRun = minRunLength(remaining)

  do {
    runLength = makeAscendingRun(array, lo, hi, compare)
    if (runLength < minRun) {
      let force = remaining
      if (force > minRun) {
        force = minRun
      }

      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare)
      runLength = force
    }
    // Push new run and merge if necessary
    ts.pushRun(lo, runLength)
    ts.mergeRuns()

    // Go find next run
    remaining -= runLength
    lo += runLength
  } while (remaining !== 0)

  // Force merging of remaining runs
  ts.forceMergeRuns()

  return results
}

module.exports = {
  sort
}


/***/ }),

/***/ 1240:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(1310);

/***/ }),

/***/ 5956:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3114);
var settle = __webpack_require__(6969);
var buildFullPath = __webpack_require__(3866);
var buildURL = __webpack_require__(2485);
var http = __webpack_require__(8605);
var https = __webpack_require__(7211);
var httpFollow = __webpack_require__(6874).http;
var httpsFollow = __webpack_require__(6874).https;
var url = __webpack_require__(8835);
var zlib = __webpack_require__(8761);
var VERSION = __webpack_require__(9739).version;
var createError = __webpack_require__(7407);
var enhanceError = __webpack_require__(9119);
var defaults = __webpack_require__(551);
var Cancel = __webpack_require__(8773);

var isHttps = /https:?/;

/**
 *
 * @param {http.ClientRequestArgs} options
 * @param {AxiosProxyConfig} proxy
 * @param {string} location
 */
function setProxy(options, proxy, location) {
  options.hostname = proxy.host;
  options.host = proxy.host;
  options.port = proxy.port;
  options.path = location;

  // Basic proxy authorization
  if (proxy.auth) {
    var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');
    options.headers['Proxy-Authorization'] = 'Basic ' + base64;
  }

  // If a proxy is used, any redirects must also pass through the proxy
  options.beforeRedirect = function beforeRedirect(redirection) {
    redirection.headers.host = redirection.host;
    setProxy(redirection, proxy, redirection.href);
  };
}

/*eslint consistent-return:0*/
module.exports = function httpAdapter(config) {
  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }
    var resolve = function resolve(value) {
      done();
      resolvePromise(value);
    };
    var reject = function reject(value) {
      done();
      rejectPromise(value);
    };
    var data = config.data;
    var headers = config.headers;
    var headerNames = {};

    Object.keys(headers).forEach(function storeLowerName(name) {
      headerNames[name.toLowerCase()] = name;
    });

    // Set User-Agent (required by some servers)
    // See https://github.com/axios/axios/issues/69
    if ('user-agent' in headerNames) {
      // User-Agent is specified; handle case where no UA header is desired
      if (!headers[headerNames['user-agent']]) {
        delete headers[headerNames['user-agent']];
      }
      // Otherwise, use specified value
    } else {
      // Only set header if it hasn't been set in config
      headers['User-Agent'] = 'axios/' + VERSION;
    }

    if (data && !utils.isStream(data)) {
      if (Buffer.isBuffer(data)) {
        // Nothing to do...
      } else if (utils.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils.isString(data)) {
        data = Buffer.from(data, 'utf-8');
      } else {
        return reject(createError(
          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
          config
        ));
      }

      // Add Content-Length header if data exists
      if (!headerNames['content-length']) {
        headers['Content-Length'] = data.length;
      }
    }

    // HTTP basic authentication
    var auth = undefined;
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      auth = username + ':' + password;
    }

    // Parse url
    var fullPath = buildFullPath(config.baseURL, config.url);
    var parsed = url.parse(fullPath);
    var protocol = parsed.protocol || 'http:';

    if (!auth && parsed.auth) {
      var urlAuth = parsed.auth.split(':');
      var urlUsername = urlAuth[0] || '';
      var urlPassword = urlAuth[1] || '';
      auth = urlUsername + ':' + urlPassword;
    }

    if (auth && headerNames.authorization) {
      delete headers[headerNames.authorization];
    }

    var isHttpsRequest = isHttps.test(protocol);
    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;

    var options = {
      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ''),
      method: config.method.toUpperCase(),
      headers: headers,
      agent: agent,
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth: auth
    };

    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname;
      options.port = parsed.port;
    }

    var proxy = config.proxy;
    if (!proxy && proxy !== false) {
      var proxyEnv = protocol.slice(0, -1) + '_proxy';
      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
      if (proxyUrl) {
        var parsedProxyUrl = url.parse(proxyUrl);
        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
        var shouldProxy = true;

        if (noProxyEnv) {
          var noProxy = noProxyEnv.split(',').map(function trim(s) {
            return s.trim();
          });

          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
            if (!proxyElement) {
              return false;
            }
            if (proxyElement === '*') {
              return true;
            }
            if (proxyElement[0] === '.' &&
                parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
              return true;
            }

            return parsed.hostname === proxyElement;
          });
        }

        if (shouldProxy) {
          proxy = {
            host: parsedProxyUrl.hostname,
            port: parsedProxyUrl.port,
            protocol: parsedProxyUrl.protocol
          };

          if (parsedProxyUrl.auth) {
            var proxyUrlAuth = parsedProxyUrl.auth.split(':');
            proxy.auth = {
              username: proxyUrlAuth[0],
              password: proxyUrlAuth[1]
            };
          }
        }
      }
    }

    if (proxy) {
      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');
      setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
    }

    var transport;
    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsProxy ? https : http;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      transport = isHttpsProxy ? httpsFollow : httpFollow;
    }

    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    }

    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }

    // Create the request
    var req = transport.request(options, function handleResponse(res) {
      if (req.aborted) return;

      // uncompress the response body transparently if required
      var stream = res;

      // return the last request in case of redirects
      var lastRequest = res.req || req;


      // if no content, is HEAD request or decompress disabled we should not decompress
      if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {
        switch (res.headers['content-encoding']) {
        /*eslint default-case:0*/
        case 'gzip':
        case 'compress':
        case 'deflate':
        // add the unzipper to the body stream processing pipeline
          stream = stream.pipe(zlib.createUnzip());

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        }
      }

      var response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: res.headers,
        config: config,
        request: lastRequest
      };

      if (config.responseType === 'stream') {
        response.data = stream;
        settle(resolve, reject, response);
      } else {
        var responseBuffer = [];
        var totalResponseBytes = 0;
        stream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;

          // make sure the content length is not over the maxContentLength if specified
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            stream.destroy();
            reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
              config, null, lastRequest));
          }
        });

        stream.on('error', function handleStreamError(err) {
          if (req.aborted) return;
          reject(enhanceError(err, config, null, lastRequest));
        });

        stream.on('end', function handleStreamEnd() {
          var responseData = Buffer.concat(responseBuffer);
          if (config.responseType !== 'arraybuffer') {
            responseData = responseData.toString(config.responseEncoding);
            if (!config.responseEncoding || config.responseEncoding === 'utf8') {
              responseData = utils.stripBOM(responseData);
            }
          }

          response.data = responseData;
          settle(resolve, reject, response);
        });
      }
    });

    // Handle errors
    req.on('error', function handleRequestError(err) {
      if (req.aborted && err.code !== 'ERR_FR_TOO_MANY_REDIRECTS') return;
      reject(enhanceError(err, config, null, req));
    });

    // Handle request timeout
    if (config.timeout) {
      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
      var timeout = parseInt(config.timeout, 10);

      if (isNaN(timeout)) {
        reject(createError(
          'error trying to parse `config.timeout` to int',
          config,
          'ERR_PARSE_TIMEOUT',
          req
        ));

        return;
      }

      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
      // And then these socket which be hang up will devoring CPU little by little.
      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
      req.setTimeout(timeout, function handleRequestTimeout() {
        req.abort();
        var transitional = config.transitional || defaults.transitional;
        reject(createError(
          'timeout of ' + timeout + 'ms exceeded',
          config,
          transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
          req
        ));
      });
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (req.aborted) return;

        req.abort();
        reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }


    // Send the request
    if (utils.isStream(data)) {
      data.on('error', function handleStreamError(err) {
        reject(enhanceError(err, config, null, req));
      }).pipe(req);
    } else {
      req.end(data);
    }
  });
};


/***/ }),

/***/ 9888:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3114);
var settle = __webpack_require__(6969);
var cookies = __webpack_require__(9355);
var buildURL = __webpack_require__(2485);
var buildFullPath = __webpack_require__(3866);
var parseHeaders = __webpack_require__(9235);
var isURLSameOrigin = __webpack_require__(6330);
var createError = __webpack_require__(7407);
var defaults = __webpack_require__(551);
var Cancel = __webpack_require__(8773);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      var transitional = config.transitional || defaults.transitional;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ 1310:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3114);
var bind = __webpack_require__(6395);
var Axios = __webpack_require__(2507);
var mergeConfig = __webpack_require__(4338);
var defaults = __webpack_require__(551);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(8773);
axios.CancelToken = __webpack_require__(2676);
axios.isCancel = __webpack_require__(5934);
axios.VERSION = __webpack_require__(9739).version;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(9682);

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(6711);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ 8773:
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ 2676:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(8773);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;

  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;

  // eslint-disable-next-line func-names
  this.promise.then(function(cancel) {
    if (!token._listeners) return;

    var i;
    var l = token._listeners.length;

    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });

  // eslint-disable-next-line func-names
  this.promise.then = function(onfulfilled) {
    var _resolve;
    // eslint-disable-next-line func-names
    var promise = new Promise(function(resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Subscribe to the cancel signal
 */

CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};

/**
 * Unsubscribe from the cancel signal
 */

CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ 5934:
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ 2507:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3114);
var buildURL = __webpack_require__(2485);
var InterceptorManager = __webpack_require__(7263);
var dispatchRequest = __webpack_require__(6348);
var mergeConfig = __webpack_require__(4338);
var validator = __webpack_require__(6933);

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ 7263:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3114);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ 3866:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(3103);
var combineURLs = __webpack_require__(6426);

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ 7407:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(9119);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ 6348:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3114);
var transformData = __webpack_require__(3757);
var isCancel = __webpack_require__(5934);
var defaults = __webpack_require__(551);
var Cancel = __webpack_require__(8773);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new Cancel('canceled');
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ 9119:
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  };
  return error;
};


/***/ }),

/***/ 4338:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3114);

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};


/***/ }),

/***/ 6969:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(7407);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ 3757:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3114);
var defaults = __webpack_require__(551);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),

/***/ 551:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3114);
var normalizeHeaderName = __webpack_require__(6950);
var enhanceError = __webpack_require__(9119);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(9888);
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(5956);
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ 9739:
/***/ ((module) => {

module.exports = {
  "version": "0.22.0"
};

/***/ }),

/***/ 6395:
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ 2485:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3114);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ 6426:
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ 9355:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3114);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ 3103:
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ 6711:
/***/ ((module) => {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ 6330:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3114);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ 6950:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3114);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ 9235:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3114);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ 9682:
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ 6933:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var VERSION = __webpack_require__(9739).version;

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),

/***/ 3114:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(6395);

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ 7055:
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ 1759:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ 9158:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var concatMap = __webpack_require__(1897);
var balanced = __webpack_require__(7055);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ 7791:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = __webpack_require__(4293).Buffer;

var CRC_TABLE = [
  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
  0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
  0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
  0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
  0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
  0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
  0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
  0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
  0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
  0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
  0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
  0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
  0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
  0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
  0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
  0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
  0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
  0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
  0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
  0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
  0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
  0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
  0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
  0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
  0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
  0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
  0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
  0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
  0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
  0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
  0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
  0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
  0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
  0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
  0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
  0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
  0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
  0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
  0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
  0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
  0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
  0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
  0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
  0x2d02ef8d
];

if (typeof Int32Array !== 'undefined') {
  CRC_TABLE = new Int32Array(CRC_TABLE);
}

function ensureBuffer(input) {
  if (Buffer.isBuffer(input)) {
    return input;
  }

  var hasNewBufferAPI =
      typeof Buffer.alloc === "function" &&
      typeof Buffer.from === "function";

  if (typeof input === "number") {
    return hasNewBufferAPI ? Buffer.alloc(input) : new Buffer(input);
  }
  else if (typeof input === "string") {
    return hasNewBufferAPI ? Buffer.from(input) : new Buffer(input);
  }
  else {
    throw new Error("input must be buffer, number, or string, received " +
                    typeof input);
  }
}

function bufferizeInt(num) {
  var tmp = ensureBuffer(4);
  tmp.writeInt32BE(num, 0);
  return tmp;
}

function _crc32(buf, previous) {
  buf = ensureBuffer(buf);
  if (Buffer.isBuffer(previous)) {
    previous = previous.readUInt32BE(0);
  }
  var crc = ~~previous ^ -1;
  for (var n = 0; n < buf.length; n++) {
    crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ (crc >>> 8);
  }
  return (crc ^ -1);
}

function crc32() {
  return bufferizeInt(_crc32.apply(null, arguments));
}
crc32.signed = function () {
  return _crc32.apply(null, arguments);
};
crc32.unsigned = function () {
  return _crc32.apply(null, arguments) >>> 0;
};

module.exports = crc32;


/***/ }),

/***/ 3422:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {isArray} = __webpack_require__(1276)
const {sort} = __webpack_require__(8813)

const {
  SYMBOL_PREFIXES,

  UNDEFINED,

  symbol,
  copy_comments,
  swap_comments
} = __webpack_require__(4796)


const reverse_comments = array => {
  const {length} = array
  let i = 0
  const max = length / 2

  for (; i < max; i ++) {
    swap_comments(array, i, length - i - 1)
  }
}

const move_comment = (target, source, i, offset, remove) => {
  copy_comments(target, source, i + offset, i, remove)
}

const move_comments = (
  // `Array` target array
  target,
  // `Array` source array
  source,
  // `number` start index
  start,
  // `number` number of indexes to move
  count,
  // `number` offset to move
  offset,
  // `boolean` whether should remove the comments from source
  remove
) => {
  if (offset > 0) {
    let i = count
    //         |   count   | offset |
    // source: -------------
    // target:          -------------
    //         | remove |
    // => remove === offset

    // From [count - 1, 0]
    while (i -- > 0) {
      move_comment(target, source, start + i, offset, remove)
    }
    return
  }

  let i = 0
  // | remove  |  count    |
  //           -------------
  // -------------
  //             | offset  |

  // From [0, count - 1]
  while (i < count) {
    const ii = i ++
    move_comment(target, source, start + ii, offset, remove)
  }
}

const remove_comments = (array, key) => {
  SYMBOL_PREFIXES.forEach(prefix => {
    const prop = symbol(prefix, key)
    delete array[prop]
  })
}

const get_mapped = (map, key) => {
  let mapped = key

  while (mapped in map) {
    mapped = map[mapped]
  }

  return mapped
}


class CommentArray extends Array {
  // - deleteCount + items.length

  // We should avoid `splice(begin, deleteCount, ...items)`,
  // because `splice(0, undefined)` is not equivalent to `splice(0)`,
  // as well as:
  // - slice
  splice (...args) {
    const {length} = this
    const ret = super.splice(...args)

    // #16
    // If no element removed, we might still need to move comments,
    //   because splice could add new items

    // if (!ret.length) {
    //   return ret
    // }

    // JavaScript syntax is silly
    // eslint-disable-next-line prefer-const
    let [begin, deleteCount, ...items] = args

    if (begin < 0) {
      begin += length
    }

    if (arguments.length === 1) {
      deleteCount = length - begin
    } else {
      deleteCount = Math.min(length - begin, deleteCount)
    }

    const {
      length: item_length
    } = items

    // itemsToDelete: -
    // itemsToAdd: +
    //        |    dc      |  count   |
    // =======-------------============
    // =======++++++============
    //        | il |
    const offset = item_length - deleteCount
    const start = begin + deleteCount
    const count = length - start

    move_comments(this, this, start, count, offset, true)

    return ret
  }

  slice (...args) {
    const {length} = this
    const array = super.slice(...args)
    if (!array.length) {
      return new CommentArray()
    }

    let [begin, before] = args

    // Ref:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
    if (before === UNDEFINED) {
      before = length
    } else if (before < 0) {
      before += length
    }

    if (begin < 0) {
      begin += length
    } else if (begin === UNDEFINED) {
      begin = 0
    }

    move_comments(array, this, begin, before - begin, - begin)

    return array
  }

  unshift (...items) {
    const {length} = this
    const ret = super.unshift(...items)
    const {
      length: items_length
    } = items

    if (items_length > 0) {
      move_comments(this, this, 0, length, items_length, true)
    }

    return ret
  }

  shift () {
    const ret = super.shift()
    const {length} = this

    remove_comments(this, 0)
    move_comments(this, this, 1, length, - 1, true)

    return ret
  }

  reverse () {
    super.reverse()

    reverse_comments(this)

    return this
  }

  pop () {
    const ret = super.pop()

    // Removes comments
    remove_comments(this, this.length)

    return ret
  }

  concat (...items) {
    let {length} = this
    const ret = super.concat(...items)

    if (!items.length) {
      return ret
    }

    move_comments(ret, this, 0, this.length, 0)

    items.forEach(item => {
      const prev = length
      length += isArray(item)
        ? item.length
        : 1

      if (!(item instanceof CommentArray)) {
        return
      }

      move_comments(ret, item, 0, item.length, prev)
    })

    return ret
  }

  sort (...args) {
    const result = sort(
      this,
      // Make sure there is no more than one argument
      ...args.slice(0, 1)
    )

    // For example,
    // if we sort ['b', 'd', 'c', 'a'],
    // then `result` will be [3, 0, 2, 1], and the array is ['a', 'b', 'c', 'd']

    // First, we swap index 0 (b) and index 3 (a), then the array comments are
    // ['a.comments', 'd.comments', 'c.comments', 'b.comments']
    // index 0 is finalized
    // index 3 is actually mapped to original index 0, we present as 0 -> 3

    // Then swap index 1 (d) and index 0 (-> 3, b)
    // 1 (index) -> 0 (new index) -> 3 (real_index)
    // ['d.comments', 'b.comments', 'c.comments', 'd.comments']
    // index 1 is finalized
    // index 3 is contains the item of original index 1
    // - we present as 1 -> 3
    // - it is ok that we don't remove mapping 0 -> 3

    // Then index 2 should be skipped

    // Then swap index 3 (d) and index 1 (-> 3, b), skipped

    const map = Object.create(null)

    result.forEach((source_index, index) => {
      if (source_index === index) {
        return
      }

      const real_source_index = get_mapped(map, source_index)

      if (real_source_index === index) {
        return
      }

      // The item of index `index` gets the final value
      // delete map[index]
      map[index] = real_source_index

      swap_comments(this, index, real_source_index)
    })

    return this
  }
}


module.exports = {
  CommentArray
}


/***/ }),

/***/ 4796:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const hasOwnProperty = __webpack_require__(1714)
const {isObject, isArray} = __webpack_require__(1276)


const PREFIX_BEFORE = 'before'
const PREFIX_AFTER_PROP = 'after-prop'
const PREFIX_AFTER_COLON = 'after-colon'
const PREFIX_AFTER_VALUE = 'after-value'
const PREFIX_AFTER = 'after'

const PREFIX_BEFORE_ALL = 'before-all'
const PREFIX_AFTER_ALL = 'after-all'

const BRACKET_OPEN = '['
const BRACKET_CLOSE = ']'
const CURLY_BRACKET_OPEN = '{'
const CURLY_BRACKET_CLOSE = '}'
const COMMA = ','
const EMPTY = ''
const MINUS = '-'

const SYMBOL_PREFIXES = [
  PREFIX_BEFORE,
  PREFIX_AFTER_PROP,
  PREFIX_AFTER_COLON,
  PREFIX_AFTER_VALUE,
  PREFIX_AFTER
]

const NON_PROP_SYMBOL_KEYS = [
  PREFIX_BEFORE,
  PREFIX_BEFORE_ALL,
  PREFIX_AFTER_ALL
].map(Symbol.for)

const COLON = ':'
const UNDEFINED = undefined


const symbol = (prefix, key) => Symbol.for(prefix + COLON + key)

const define = (target, key, value) => Object.defineProperty(target, key, {
  value,
  writable: true,
  configurable: true
})

const copy_comments_by_kind = (
  target, source, target_key, source_key, prefix, remove_source
) => {
  const source_prop = symbol(prefix, source_key)
  if (!hasOwnProperty(source, source_prop)) {
    return
  }

  const target_prop = target_key === source_key
    ? source_prop
    : symbol(prefix, target_key)

  define(target, target_prop, source[source_prop])

  if (remove_source) {
    delete source[source_prop]
  }
}

const copy_comments = (
  target, source, target_key, source_key, remove_source
) => {
  SYMBOL_PREFIXES.forEach(prefix => {
    copy_comments_by_kind(
      target, source, target_key, source_key, prefix, remove_source
    )
  })
}

const swap_comments = (array, from, to) => {
  if (from === to) {
    return
  }

  SYMBOL_PREFIXES.forEach(prefix => {
    const target_prop = symbol(prefix, to)
    if (!hasOwnProperty(array, target_prop)) {
      copy_comments_by_kind(array, array, to, from, prefix, true)
      return
    }

    const comments = array[target_prop]
    delete array[target_prop]

    copy_comments_by_kind(array, array, to, from, prefix, true)
    define(array, symbol(prefix, from), comments)
  })
}

const assign_non_prop_comments = (target, source) => {
  NON_PROP_SYMBOL_KEYS.forEach(key => {
    const comments = source[key]

    if (comments) {
      define(target, key, comments)
    }
  })
}

// Assign keys and comments
const assign = (target, source, keys) => {
  keys.forEach(key => {
    if (!hasOwnProperty(source, key)) {
      return
    }

    target[key] = source[key]
    copy_comments(target, source, key, key)
  })

  return target
}


module.exports = {
  SYMBOL_PREFIXES,

  PREFIX_BEFORE,
  PREFIX_AFTER_PROP,
  PREFIX_AFTER_COLON,
  PREFIX_AFTER_VALUE,
  PREFIX_AFTER,

  PREFIX_BEFORE_ALL,
  PREFIX_AFTER_ALL,

  BRACKET_OPEN,
  BRACKET_CLOSE,
  CURLY_BRACKET_OPEN,
  CURLY_BRACKET_CLOSE,

  COLON,
  COMMA,
  MINUS,
  EMPTY,

  UNDEFINED,

  symbol,
  define,
  copy_comments,
  swap_comments,
  assign_non_prop_comments,

  assign (target, source, keys) {
    if (!isObject(target)) {
      throw new TypeError('Cannot convert undefined or null to object')
    }

    if (!isObject(source)) {
      return target
    }

    if (keys === UNDEFINED) {
      keys = Object.keys(source)
      // We assign non-property comments
      // if argument `keys` is not specified
      assign_non_prop_comments(target, source)
    } else if (!isArray(keys)) {
      throw new TypeError('keys must be array or undefined')
    } else if (keys.length === 0) {
      // Or argument `keys` is an empty array
      assign_non_prop_comments(target, source)
    }

    return assign(target, source, keys)
  }
}


/***/ }),

/***/ 634:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {parse, tokenize} = __webpack_require__(2677)
const stringify = __webpack_require__(5415)
const {CommentArray} = __webpack_require__(3422)
const {assign} = __webpack_require__(4796)

module.exports = {
  parse,
  stringify,
  tokenize,

  CommentArray,
  assign
}


/***/ }),

/***/ 2677:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// JSON formatting

const esprima = __webpack_require__(2058)

const {
  CommentArray,
} = __webpack_require__(3422)

const {
  PREFIX_BEFORE,
  PREFIX_AFTER_PROP,
  PREFIX_AFTER_COLON,
  PREFIX_AFTER_VALUE,
  PREFIX_AFTER,

  PREFIX_BEFORE_ALL,
  PREFIX_AFTER_ALL,

  BRACKET_OPEN,
  BRACKET_CLOSE,
  CURLY_BRACKET_OPEN,
  CURLY_BRACKET_CLOSE,

  COLON,
  COMMA,
  MINUS,
  EMPTY,

  UNDEFINED,

  define,
  assign_non_prop_comments
} = __webpack_require__(4796)

const tokenize = code => esprima.tokenize(code, {
  comment: true,
  loc: true
})

const previous_hosts = []
let comments_host = null
let unassigned_comments = null

const previous_props = []
let last_prop

let remove_comments = false
let inline = false
let tokens = null
let last = null
let current = null
let index
let reviver = null

const clean = () => {
  previous_props.length =
  previous_hosts.length = 0

  last = null
  last_prop = UNDEFINED
}

const free = () => {
  clean()

  tokens.length = 0

  unassigned_comments =
  comments_host =
  tokens =
  last =
  current =
  reviver = null
}

const symbolFor = prefix => Symbol.for(
  last_prop !== UNDEFINED
    ? prefix + COLON + last_prop
    : prefix
)

const transform = (k, v) => reviver
  ? reviver(k, v)
  : v

const unexpected = () => {
  const error = new SyntaxError(`Unexpected token ${current.value.slice(0, 1)}`)
  Object.assign(error, current.loc.start)

  throw error
}

const unexpected_end = () => {
  const error = new SyntaxError('Unexpected end of JSON input')
  Object.assign(error, last
    ? last.loc.end
    // Empty string
    : {
      line: 1,
      column: 0
    })

  throw error
}

// Move the reader to the next
const next = () => {
  const new_token = tokens[++ index]
  inline = current
    && new_token
    && current.loc.end.line === new_token.loc.start.line
    || false

  last = current
  current = new_token
}

const type = () => {
  if (!current) {
    unexpected_end()
  }

  return current.type === 'Punctuator'
    ? current.value
    : current.type
}

const is = t => type() === t

const expect = a => {
  if (!is(a)) {
    unexpected()
  }
}

const set_comments_host = new_host => {
  previous_hosts.push(comments_host)
  comments_host = new_host
}

const restore_comments_host = () => {
  comments_host = previous_hosts.pop()
}

const assign_after_comments = () => {
  if (!unassigned_comments) {
    return
  }

  const after_comments = []

  for (const comment of unassigned_comments) {
    // If the comment is inline, then it is an after-comma comment
    if (comment.inline) {
      after_comments.push(comment)
    // Otherwise, all comments are before:<next-prop> comment
    } else {
      break
    }
  }

  const {length} = after_comments
  if (!length) {
    return
  }

  if (length === unassigned_comments.length) {
    // If unassigned_comments are all consumed
    unassigned_comments = null
  } else {
    unassigned_comments.splice(0, length)
  }

  define(comments_host, symbolFor(PREFIX_AFTER), after_comments)
}

const assign_comments = prefix => {
  if (!unassigned_comments) {
    return
  }

  define(comments_host, symbolFor(prefix), unassigned_comments)

  unassigned_comments = null
}

const parse_comments = prefix => {
  const comments = []

  while (
    current
    && (
      is('LineComment')
      || is('BlockComment')
    )
  ) {
    const comment = {
      ...current,
      inline
    }

    // delete comment.loc
    comments.push(comment)

    next()
  }

  if (remove_comments) {
    return
  }

  if (!comments.length) {
    return
  }

  if (prefix) {
    define(comments_host, symbolFor(prefix), comments)
    return
  }

  unassigned_comments = comments
}

const set_prop = (prop, push) => {
  if (push) {
    previous_props.push(last_prop)
  }

  last_prop = prop
}

const restore_prop = () => {
  last_prop = previous_props.pop()
}

const parse_object = () => {
  const obj = {}
  set_comments_host(obj)
  set_prop(UNDEFINED, true)

  let started = false
  let name

  parse_comments()

  while (!is(CURLY_BRACKET_CLOSE)) {
    if (started) {
      assign_comments(PREFIX_AFTER_VALUE)

      // key-value pair delimiter
      expect(COMMA)
      next()
      parse_comments()

      assign_after_comments()

      // If there is a trailing comma, we might reach the end
      // ```
      // {
      //   "a": 1,
      // }
      // ```
      if (is(CURLY_BRACKET_CLOSE)) {
        break
      }
    }

    started = true
    expect('String')
    name = JSON.parse(current.value)

    set_prop(name)
    assign_comments(PREFIX_BEFORE)

    next()
    parse_comments(PREFIX_AFTER_PROP)

    expect(COLON)

    next()
    parse_comments(PREFIX_AFTER_COLON)

    obj[name] = transform(name, walk())
    parse_comments()
  }

  if (started) {
    // If there are properties,
    // then the unassigned comments are after comments
    assign_comments(PREFIX_AFTER)
  }

  // bypass }
  next()
  last_prop = undefined

  if (!started) {
    // Otherwise, they are before comments
    assign_comments(PREFIX_BEFORE)
  }

  restore_comments_host()
  restore_prop()

  return obj
}

const parse_array = () => {
  const array = new CommentArray()
  set_comments_host(array)
  set_prop(UNDEFINED, true)

  let started = false
  let i = 0

  parse_comments()

  while (!is(BRACKET_CLOSE)) {
    if (started) {
      assign_comments(PREFIX_AFTER_VALUE)
      expect(COMMA)
      next()
      parse_comments()

      assign_after_comments()

      if (is(BRACKET_CLOSE)) {
        break
      }
    }

    started = true

    set_prop(i)
    assign_comments(PREFIX_BEFORE)

    array[i] = transform(i, walk())
    i ++

    parse_comments()
  }

  if (started) {
    assign_comments(PREFIX_AFTER)
  }

  next()
  last_prop = undefined

  if (!started) {
    assign_comments(PREFIX_BEFORE)
  }

  restore_comments_host()
  restore_prop()

  return array
}

function walk () {
  let tt = type()

  if (tt === CURLY_BRACKET_OPEN) {
    next()
    return parse_object()
  }

  if (tt === BRACKET_OPEN) {
    next()
    return parse_array()
  }

  let negative = EMPTY

  // -1
  if (tt === MINUS) {
    next()
    tt = type()
    negative = MINUS
  }

  let v

  switch (tt) {
  case 'String':
  case 'Boolean':
  case 'Null':
  case 'Numeric':
    v = current.value
    next()
    return JSON.parse(negative + v)
  default:
  }
}

const isObject = subject => Object(subject) === subject

const parse = (code, rev, no_comments) => {
  // Clean variables in closure
  clean()

  tokens = tokenize(code)
  reviver = rev
  remove_comments = no_comments

  if (!tokens.length) {
    unexpected_end()
  }

  index = - 1
  next()

  set_comments_host({})

  parse_comments(PREFIX_BEFORE_ALL)

  let result = walk()

  parse_comments(PREFIX_AFTER_ALL)

  if (current) {
    unexpected()
  }

  if (!no_comments && result !== null) {
    if (!isObject(result)) {
      // 1 -> new Number(1)
      // true -> new Boolean(1)
      // "foo" -> new String("foo")

      // eslint-disable-next-line no-new-object
      result = new Object(result)
    }

    assign_non_prop_comments(result, comments_host)
  }

  restore_comments_host()

  // reviver
  result = transform('', result)

  free()

  return result
}

module.exports = {
  parse,
  tokenize
}


/***/ }),

/***/ 5415:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  isArray, isObject, isFunction, isNumber, isString
} = __webpack_require__(1276)
const repeat = __webpack_require__(652)

const {
  PREFIX_BEFORE_ALL,
  PREFIX_BEFORE,
  PREFIX_AFTER_PROP,
  PREFIX_AFTER_COLON,
  PREFIX_AFTER_VALUE,
  PREFIX_AFTER,
  PREFIX_AFTER_ALL,

  BRACKET_OPEN,
  BRACKET_CLOSE,
  CURLY_BRACKET_OPEN,
  CURLY_BRACKET_CLOSE,
  COLON,
  COMMA,
  EMPTY,

  UNDEFINED
} = __webpack_require__(4796)

// eslint-disable-next-line no-control-regex, no-misleading-character-class
const ESCAPABLE = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g

// String constants
const SPACE = ' '
const LF = '\n'
const STR_NULL = 'null'

// Symbol tags
const BEFORE = prop => `${PREFIX_BEFORE}:${prop}`
const AFTER_PROP = prop => `${PREFIX_AFTER_PROP}:${prop}`
const AFTER_COLON = prop => `${PREFIX_AFTER_COLON}:${prop}`
const AFTER_VALUE = prop => `${PREFIX_AFTER_VALUE}:${prop}`
const AFTER = prop => `${PREFIX_AFTER}:${prop}`

// table of character substitutions
const meta = {
  '\b': '\\b',
  '\t': '\\t',
  '\n': '\\n',
  '\f': '\\f',
  '\r': '\\r',
  '"': '\\"',
  '\\': '\\\\'
}

const escape = string => {
  ESCAPABLE.lastIndex = 0

  if (!ESCAPABLE.test(string)) {
    return string
  }

  return string.replace(ESCAPABLE, a => {
    const c = meta[a]
    return typeof c === 'string'
      ? c
      : a
  })
}

// Escape no control characters, no quote characters,
// and no backslash characters,
// then we can safely slap some quotes around it.
const quote = string => `"${escape(string)}"`
const comment_stringify = (value, line) => line
  ? `//${value}`
  : `/*${value}*/`

// display_block `boolean` whether the
//   WHOLE block of comments is always a block group
const process_comments = (host, symbol_tag, deeper_gap, display_block) => {
  const comments = host[Symbol.for(symbol_tag)]
  if (!comments || !comments.length) {
    return EMPTY
  }

  let is_line_comment = false

  const str = comments.reduce((prev, {
    inline,
    type,
    value
  }) => {
    const delimiter = inline
      ? SPACE
      : LF + deeper_gap

    is_line_comment = type === 'LineComment'

    return prev + delimiter + comment_stringify(value, is_line_comment)
  }, EMPTY)


  return display_block
  // line comment should always end with a LF
  || is_line_comment
    ? str + LF + deeper_gap
    : str
}

let replacer = null
let indent = EMPTY

const clean = () => {
  replacer = null
  indent = EMPTY
}

const join = (one, two, gap) =>
  one
    ? two
      // Symbol.for('before') and Symbol.for('before:prop')
      // might both exist if user mannually add comments to the object
      // and make a mistake.
      // SO, we are not to only trimRight but trim for both sides
      ? one + two.trim() + LF + gap
      : one.trimRight() + LF + gap
    : two
      ? two.trimRight() + LF + gap
      : EMPTY

const join_content = (inside, value, gap) => {
  const comment = process_comments(value, PREFIX_BEFORE, gap + indent, true)

  return join(comment, inside, gap)
}

// | deeper_gap   |
// | gap | indent |
//       [
//                "foo",
//                "bar"
//       ]
const array_stringify = (value, gap) => {
  const deeper_gap = gap + indent

  const {length} = value

  // From the item to before close
  let inside = EMPTY
  let after_comma = EMPTY

  // Never use Array.prototype.forEach,
  // that we should iterate all items
  for (let i = 0; i < length; i ++) {
    if (i !== 0) {
      inside += COMMA
    }

    const before = join(
      after_comma,
      process_comments(value, BEFORE(i), deeper_gap),
      deeper_gap
    )

    inside += before || (LF + deeper_gap)

    // JSON.stringify([undefined])  => [null]
    inside += stringify(i, value, deeper_gap) || STR_NULL

    inside += process_comments(value, AFTER_VALUE(i), deeper_gap)

    after_comma = process_comments(value, AFTER(i), deeper_gap)
  }

  inside += join(
    after_comma,
    process_comments(value, PREFIX_AFTER, deeper_gap),
    deeper_gap
  )

  return BRACKET_OPEN
   + join_content(inside, value, gap)
   + BRACKET_CLOSE
}

// | deeper_gap   |
// | gap | indent |
//       {
//                "foo": 1,
//                "bar": 2
//       }
const object_stringify = (value, gap) => {
  // Due to a specification blunder in ECMAScript, typeof null is 'object',
  // so watch out for that case.
  if (!value) {
    return 'null'
  }

  const deeper_gap = gap + indent

  // From the first element to before close
  let inside = EMPTY
  let after_comma = EMPTY
  let first = true

  const keys = isArray(replacer)
    ? replacer
    : Object.keys(value)

  const iteratee = key => {
    // Stringified value
    const sv = stringify(key, value, deeper_gap)

    // If a value is undefined, then the key-value pair should be ignored
    if (sv === UNDEFINED) {
      return
    }

    // The treat ment
    if (!first) {
      inside += COMMA
    }

    first = false

    const before = join(
      after_comma,
      process_comments(value, BEFORE(key), deeper_gap),
      deeper_gap
    )

    inside += before || (LF + deeper_gap)

    inside += quote(key)
    + process_comments(value, AFTER_PROP(key), deeper_gap)
    + COLON
    + process_comments(value, AFTER_COLON(key), deeper_gap)
    + SPACE
    + sv
    + process_comments(value, AFTER_VALUE(key), deeper_gap)

    after_comma = process_comments(value, AFTER(key), deeper_gap)
  }

  keys.forEach(iteratee)

  // if (after_comma) {
  //   inside += COMMA
  // }

  inside += join(
    after_comma,
    process_comments(value, PREFIX_AFTER, deeper_gap),
    deeper_gap
  )

  return CURLY_BRACKET_OPEN
  + join_content(inside, value, gap)
  + CURLY_BRACKET_CLOSE
}

// @param {string} key
// @param {Object} holder
// @param {function()|Array} replacer
// @param {string} indent
// @param {string} gap
function stringify (key, holder, gap) {
  let value = holder[key]

  // If the value has a toJSON method, call it to obtain a replacement value.
  if (isObject(value) && isFunction(value.toJSON)) {
    value = value.toJSON(key)
  }

  // If we were called with a replacer function, then call the replacer to
  // obtain a replacement value.
  if (isFunction(replacer)) {
    value = replacer.call(holder, key, value)
  }

  switch (typeof value) {
  case 'string':
    return quote(value)

  case 'number':
    // JSON numbers must be finite. Encode non-finite numbers as null.
    return Number.isFinite(value) ? String(value) : STR_NULL

  case 'boolean':
  case 'null':

    // If the value is a boolean or null, convert it to a string. Note:
    // typeof null does not produce 'null'. The case is included here in
    // the remote chance that this gets fixed someday.
    return String(value)

  // If the type is 'object', we might be dealing with an object or an array or
  // null.
  case 'object':
    return isArray(value)
      ? array_stringify(value, gap)
      : object_stringify(value, gap)

  // undefined
  default:
    // JSON.stringify(undefined) === undefined
    // JSON.stringify('foo', () => undefined) === undefined
  }
}

const get_indent = space => isString(space)
  // If the space parameter is a string, it will be used as the indent string.
  ? space
  : isNumber(space)
    ? repeat(SPACE, space)
    : EMPTY

const {toString} = Object.prototype
const PRIMITIVE_OBJECT_TYPES = [
  '[object Number]',
  '[object String]',
  '[object Boolean]'
]

const is_primitive_object = subject => {
  if (typeof subject !== 'object') {
    return false
  }

  const str = toString.call(subject)
  return PRIMITIVE_OBJECT_TYPES.includes(str)
}

// @param {function()|Array} replacer
// @param {string|number} space
module.exports = (value, replacer_, space) => {
  // The stringify method takes a value and an optional replacer, and an optional
  // space parameter, and returns a JSON text. The replacer can be a function
  // that can replace values, or an array of strings that will select the keys.
  // A default replacer method can be provided. Use of the space parameter can
  // produce text that is more easily readable.

  // If the space parameter is a number, make an indent string containing that
  // many spaces.
  const indent_ = get_indent(space)

  if (!indent_) {
    return JSON.stringify(value, replacer_)
  }

  // vanilla `JSON.parse` allow invalid replacer
  if (!isFunction(replacer_) && !isArray(replacer_)) {
    replacer_ = null
  }

  replacer = replacer_
  indent = indent_

  const str = is_primitive_object(value)
    ? JSON.stringify(value)
    : stringify('', {'': value}, EMPTY)

  clean()

  return isObject(value)
    ? process_comments(value, PREFIX_BEFORE_ALL, EMPTY).trimLeft()
      + str
      + process_comments(value, PREFIX_AFTER_ALL, EMPTY).trimRight()
    : str
}


/***/ }),

/***/ 1897:
/***/ ((module) => {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ 1276:
/***/ ((__unused_webpack_module, exports) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


/***/ }),

/***/ 2708:
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
function log(...args) {
	// This hackery is required for IE8/9, where
	// the `console.log` function doesn't have 'apply'
	return typeof console === 'object' &&
		console.log &&
		console.log(...args);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(347)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ 347:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(8632);

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ 5514:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(2708);
} else {
	module.exports = __webpack_require__(3018);
}


/***/ }),

/***/ 3018:
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(3867);
const util = __webpack_require__(1669);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(7581);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.format(...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(347)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.replace(/\s*\n\s*/g, ' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ 102:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = LRUCache

// This will be a proper iterable 'Map' in engines that support it,
// or a fakey-fake PseudoMap in older versions.
var Map = __webpack_require__(5637)
var util = __webpack_require__(1669)

// A linked list to keep track of recently-used-ness
var Yallist = __webpack_require__(1434)

// use symbols if possible, otherwise just _props
var hasSymbol = typeof Symbol === 'function' && process.env._nodeLRUCacheForceNoSymbol !== '1'
var makeSymbol
if (hasSymbol) {
  makeSymbol = function (key) {
    return Symbol(key)
  }
} else {
  makeSymbol = function (key) {
    return '_' + key
  }
}

var MAX = makeSymbol('max')
var LENGTH = makeSymbol('length')
var LENGTH_CALCULATOR = makeSymbol('lengthCalculator')
var ALLOW_STALE = makeSymbol('allowStale')
var MAX_AGE = makeSymbol('maxAge')
var DISPOSE = makeSymbol('dispose')
var NO_DISPOSE_ON_SET = makeSymbol('noDisposeOnSet')
var LRU_LIST = makeSymbol('lruList')
var CACHE = makeSymbol('cache')

function naiveLength () { return 1 }

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
function LRUCache (options) {
  if (!(this instanceof LRUCache)) {
    return new LRUCache(options)
  }

  if (typeof options === 'number') {
    options = { max: options }
  }

  if (!options) {
    options = {}
  }

  var max = this[MAX] = options.max
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!max ||
      !(typeof max === 'number') ||
      max <= 0) {
    this[MAX] = Infinity
  }

  var lc = options.length || naiveLength
  if (typeof lc !== 'function') {
    lc = naiveLength
  }
  this[LENGTH_CALCULATOR] = lc

  this[ALLOW_STALE] = options.stale || false
  this[MAX_AGE] = options.maxAge || 0
  this[DISPOSE] = options.dispose
  this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
  this.reset()
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, 'max', {
  set: function (mL) {
    if (!mL || !(typeof mL === 'number') || mL <= 0) {
      mL = Infinity
    }
    this[MAX] = mL
    trim(this)
  },
  get: function () {
    return this[MAX]
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'allowStale', {
  set: function (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  },
  get: function () {
    return this[ALLOW_STALE]
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'maxAge', {
  set: function (mA) {
    if (!mA || !(typeof mA === 'number') || mA < 0) {
      mA = 0
    }
    this[MAX_AGE] = mA
    trim(this)
  },
  get: function () {
    return this[MAX_AGE]
  },
  enumerable: true
})

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, 'lengthCalculator', {
  set: function (lC) {
    if (typeof lC !== 'function') {
      lC = naiveLength
    }
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(function (hit) {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      }, this)
    }
    trim(this)
  },
  get: function () { return this[LENGTH_CALCULATOR] },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'length', {
  get: function () { return this[LENGTH] },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'itemCount', {
  get: function () { return this[LRU_LIST].length },
  enumerable: true
})

LRUCache.prototype.rforEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this[LRU_LIST].tail; walker !== null;) {
    var prev = walker.prev
    forEachStep(this, fn, walker, thisp)
    walker = prev
  }
}

function forEachStep (self, fn, node, thisp) {
  var hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE]) {
      hit = undefined
    }
  }
  if (hit) {
    fn.call(thisp, hit.value, hit.key, self)
  }
}

LRUCache.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this[LRU_LIST].head; walker !== null;) {
    var next = walker.next
    forEachStep(this, fn, walker, thisp)
    walker = next
  }
}

LRUCache.prototype.keys = function () {
  return this[LRU_LIST].toArray().map(function (k) {
    return k.key
  }, this)
}

LRUCache.prototype.values = function () {
  return this[LRU_LIST].toArray().map(function (k) {
    return k.value
  }, this)
}

LRUCache.prototype.reset = function () {
  if (this[DISPOSE] &&
      this[LRU_LIST] &&
      this[LRU_LIST].length) {
    this[LRU_LIST].forEach(function (hit) {
      this[DISPOSE](hit.key, hit.value)
    }, this)
  }

  this[CACHE] = new Map() // hash of items by key
  this[LRU_LIST] = new Yallist() // list of items in order of use recency
  this[LENGTH] = 0 // length of items in the list
}

LRUCache.prototype.dump = function () {
  return this[LRU_LIST].map(function (hit) {
    if (!isStale(this, hit)) {
      return {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }
    }
  }, this).toArray().filter(function (h) {
    return h
  })
}

LRUCache.prototype.dumpLru = function () {
  return this[LRU_LIST]
}

/* istanbul ignore next */
LRUCache.prototype.inspect = function (n, opts) {
  var str = 'LRUCache {'
  var extras = false

  var as = this[ALLOW_STALE]
  if (as) {
    str += '\n  allowStale: true'
    extras = true
  }

  var max = this[MAX]
  if (max && max !== Infinity) {
    if (extras) {
      str += ','
    }
    str += '\n  max: ' + util.inspect(max, opts)
    extras = true
  }

  var maxAge = this[MAX_AGE]
  if (maxAge) {
    if (extras) {
      str += ','
    }
    str += '\n  maxAge: ' + util.inspect(maxAge, opts)
    extras = true
  }

  var lc = this[LENGTH_CALCULATOR]
  if (lc && lc !== naiveLength) {
    if (extras) {
      str += ','
    }
    str += '\n  length: ' + util.inspect(this[LENGTH], opts)
    extras = true
  }

  var didFirst = false
  this[LRU_LIST].forEach(function (item) {
    if (didFirst) {
      str += ',\n  '
    } else {
      if (extras) {
        str += ',\n'
      }
      didFirst = true
      str += '\n  '
    }
    var key = util.inspect(item.key).split('\n').join('\n  ')
    var val = { value: item.value }
    if (item.maxAge !== maxAge) {
      val.maxAge = item.maxAge
    }
    if (lc !== naiveLength) {
      val.length = item.length
    }
    if (isStale(this, item)) {
      val.stale = true
    }

    val = util.inspect(val, opts).split('\n').join('\n  ')
    str += key + ' => ' + val
  })

  if (didFirst || extras) {
    str += '\n'
  }
  str += '}'

  return str
}

LRUCache.prototype.set = function (key, value, maxAge) {
  maxAge = maxAge || this[MAX_AGE]

  var now = maxAge ? Date.now() : 0
  var len = this[LENGTH_CALCULATOR](value, key)

  if (this[CACHE].has(key)) {
    if (len > this[MAX]) {
      del(this, this[CACHE].get(key))
      return false
    }

    var node = this[CACHE].get(key)
    var item = node.value

    // dispose of the old one before overwriting
    // split out into 2 ifs for better coverage tracking
    if (this[DISPOSE]) {
      if (!this[NO_DISPOSE_ON_SET]) {
        this[DISPOSE](key, item.value)
      }
    }

    item.now = now
    item.maxAge = maxAge
    item.value = value
    this[LENGTH] += len - item.length
    item.length = len
    this.get(key)
    trim(this)
    return true
  }

  var hit = new Entry(key, value, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > this[MAX]) {
    if (this[DISPOSE]) {
      this[DISPOSE](key, value)
    }
    return false
  }

  this[LENGTH] += hit.length
  this[LRU_LIST].unshift(hit)
  this[CACHE].set(key, this[LRU_LIST].head)
  trim(this)
  return true
}

LRUCache.prototype.has = function (key) {
  if (!this[CACHE].has(key)) return false
  var hit = this[CACHE].get(key).value
  if (isStale(this, hit)) {
    return false
  }
  return true
}

LRUCache.prototype.get = function (key) {
  return get(this, key, true)
}

LRUCache.prototype.peek = function (key) {
  return get(this, key, false)
}

LRUCache.prototype.pop = function () {
  var node = this[LRU_LIST].tail
  if (!node) return null
  del(this, node)
  return node.value
}

LRUCache.prototype.del = function (key) {
  del(this, this[CACHE].get(key))
}

LRUCache.prototype.load = function (arr) {
  // reset the cache
  this.reset()

  var now = Date.now()
  // A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l--) {
    var hit = arr[l]
    var expiresAt = hit.e || 0
    if (expiresAt === 0) {
      // the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
    } else {
      var maxAge = expiresAt - now
      // dont add already expired items
      if (maxAge > 0) {
        this.set(hit.k, hit.v, maxAge)
      }
    }
  }
}

LRUCache.prototype.prune = function () {
  var self = this
  this[CACHE].forEach(function (value, key) {
    get(self, key, false)
  })
}

function get (self, key, doUse) {
  var node = self[CACHE].get(key)
  if (node) {
    var hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE]) hit = undefined
    } else {
      if (doUse) {
        self[LRU_LIST].unshiftNode(node)
      }
    }
    if (hit) hit = hit.value
  }
  return hit
}

function isStale (self, hit) {
  if (!hit || (!hit.maxAge && !self[MAX_AGE])) {
    return false
  }
  var stale = false
  var diff = Date.now() - hit.now
  if (hit.maxAge) {
    stale = diff > hit.maxAge
  } else {
    stale = self[MAX_AGE] && (diff > self[MAX_AGE])
  }
  return stale
}

function trim (self) {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

function del (self, node) {
  if (node) {
    var hit = node.value
    if (self[DISPOSE]) {
      self[DISPOSE](hit.key, hit.value)
    }
    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, length, now, maxAge) {
  this.key = key
  this.value = value
  this.length = length
  this.now = now
  this.maxAge = maxAge || 0
}


/***/ }),

/***/ 1434:
/***/ ((module) => {

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}


/***/ }),

/***/ 4650:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"editorconfig","version":"0.15.3","description":"EditorConfig File Locator and Interpreter for Node.js","keywords":["editorconfig","core"],"main":"src/index.js","contributors":["Hong Xu (topbug.net)","Jed Mao (https://github.com/jedmao/)","Trey Hunner (http://treyhunner.com)"],"directories":{"bin":"./bin","lib":"./lib"},"scripts":{"clean":"rimraf dist","prebuild":"npm run clean","build":"tsc","pretest":"npm run lint && npm run build && npm run copy && cmake .","test":"ctest .","pretest:ci":"npm run pretest","test:ci":"ctest -VV --output-on-failure .","lint":"npm run eclint && npm run tslint","eclint":"eclint check --indent_size ignore \\"src/**\\"","tslint":"tslint --project tsconfig.json --exclude package.json","copy":"cpy .npmignore LICENSE README.md CHANGELOG.md dist && cpy bin/* dist/bin && cpy src/lib/fnmatch*.* dist/src/lib","prepub":"npm run lint && npm run build && npm run copy","pub":"npm publish ./dist"},"repository":{"type":"git","url":"git://github.com/editorconfig/editorconfig-core-js.git"},"bugs":"https://github.com/editorconfig/editorconfig-core-js/issues","author":"EditorConfig Team","license":"MIT","dependencies":{"commander":"^2.19.0","lru-cache":"^4.1.5","semver":"^5.6.0","sigmund":"^1.0.1"},"devDependencies":{"@types/mocha":"^5.2.6","@types/node":"^10.12.29","@types/semver":"^5.5.0","cpy-cli":"^2.0.0","eclint":"^2.8.1","mocha":"^5.2.0","rimraf":"^2.6.3","should":"^13.2.3","tslint":"^5.13.1","typescript":"^3.3.3333"}}');

/***/ }),

/***/ 9138:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var fs = __importStar(__webpack_require__(5747));
var path = __importStar(__webpack_require__(5622));
var semver = __importStar(__webpack_require__(2751));
var fnmatch_1 = __importDefault(__webpack_require__(8582));
var ini_1 = __webpack_require__(5345);
exports.parseString = ini_1.parseString;
var package_json_1 = __importDefault(__webpack_require__(4650));
var knownProps = {
    end_of_line: true,
    indent_style: true,
    indent_size: true,
    insert_final_newline: true,
    trim_trailing_whitespace: true,
    charset: true,
};
function fnmatch(filepath, glob) {
    var matchOptions = { matchBase: true, dot: true, noext: true };
    glob = glob.replace(/\*\*/g, '{*,**/**/**}');
    return fnmatch_1.default(filepath, glob, matchOptions);
}
function getConfigFileNames(filepath, options) {
    var paths = [];
    do {
        filepath = path.dirname(filepath);
        paths.push(path.join(filepath, options.config));
    } while (filepath !== options.root);
    return paths;
}
function processMatches(matches, version) {
    // Set indent_size to 'tab' if indent_size is unspecified and
    // indent_style is set to 'tab'.
    if ('indent_style' in matches
        && matches.indent_style === 'tab'
        && !('indent_size' in matches)
        && semver.gte(version, '0.10.0')) {
        matches.indent_size = 'tab';
    }
    // Set tab_width to indent_size if indent_size is specified and
    // tab_width is unspecified
    if ('indent_size' in matches
        && !('tab_width' in matches)
        && matches.indent_size !== 'tab') {
        matches.tab_width = matches.indent_size;
    }
    // Set indent_size to tab_width if indent_size is 'tab'
    if ('indent_size' in matches
        && 'tab_width' in matches
        && matches.indent_size === 'tab') {
        matches.indent_size = matches.tab_width;
    }
    return matches;
}
function processOptions(options, filepath) {
    if (options === void 0) { options = {}; }
    return {
        config: options.config || '.editorconfig',
        version: options.version || package_json_1.default.version,
        root: path.resolve(options.root || path.parse(filepath).root),
    };
}
function buildFullGlob(pathPrefix, glob) {
    switch (glob.indexOf('/')) {
        case -1:
            glob = '**/' + glob;
            break;
        case 0:
            glob = glob.substring(1);
            break;
        default:
            break;
    }
    return path.join(pathPrefix, glob);
}
function extendProps(props, options) {
    if (props === void 0) { props = {}; }
    if (options === void 0) { options = {}; }
    for (var key in options) {
        if (options.hasOwnProperty(key)) {
            var value = options[key];
            var key2 = key.toLowerCase();
            var value2 = value;
            if (knownProps[key2]) {
                value2 = value.toLowerCase();
            }
            try {
                value2 = JSON.parse(value);
            }
            catch (e) { }
            if (typeof value === 'undefined' || value === null) {
                // null and undefined are values specific to JSON (no special meaning
                // in editorconfig) & should just be returned as regular strings.
                value2 = String(value);
            }
            props[key2] = value2;
        }
    }
    return props;
}
function parseFromConfigs(configs, filepath, options) {
    return processMatches(configs
        .reverse()
        .reduce(function (matches, file) {
        var pathPrefix = path.dirname(file.name);
        file.contents.forEach(function (section) {
            var glob = section[0];
            var options2 = section[1];
            if (!glob) {
                return;
            }
            var fullGlob = buildFullGlob(pathPrefix, glob);
            if (!fnmatch(filepath, fullGlob)) {
                return;
            }
            matches = extendProps(matches, options2);
        });
        return matches;
    }, {}), options.version);
}
function getConfigsForFiles(files) {
    var configs = [];
    for (var i in files) {
        if (files.hasOwnProperty(i)) {
            var file = files[i];
            var contents = ini_1.parseString(file.contents);
            configs.push({
                name: file.name,
                contents: contents,
            });
            if ((contents[0][1].root || '').toLowerCase() === 'true') {
                break;
            }
        }
    }
    return configs;
}
function readConfigFiles(filepaths) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, Promise.all(filepaths.map(function (name) { return new Promise(function (resolve) {
                    fs.readFile(name, 'utf8', function (err, data) {
                        resolve({
                            name: name,
                            contents: err ? '' : data,
                        });
                    });
                }); }))];
        });
    });
}
function readConfigFilesSync(filepaths) {
    var files = [];
    var file;
    filepaths.forEach(function (filepath) {
        try {
            file = fs.readFileSync(filepath, 'utf8');
        }
        catch (e) {
            file = '';
        }
        files.push({
            name: filepath,
            contents: file,
        });
    });
    return files;
}
function opts(filepath, options) {
    if (options === void 0) { options = {}; }
    var resolvedFilePath = path.resolve(filepath);
    return [
        resolvedFilePath,
        processOptions(options, resolvedFilePath),
    ];
}
function parseFromFiles(filepath, files, options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var _a, resolvedFilePath, processedOptions;
        return __generator(this, function (_b) {
            _a = opts(filepath, options), resolvedFilePath = _a[0], processedOptions = _a[1];
            return [2 /*return*/, files.then(getConfigsForFiles)
                    .then(function (configs) { return parseFromConfigs(configs, resolvedFilePath, processedOptions); })];
        });
    });
}
exports.parseFromFiles = parseFromFiles;
function parseFromFilesSync(filepath, files, options) {
    if (options === void 0) { options = {}; }
    var _a = opts(filepath, options), resolvedFilePath = _a[0], processedOptions = _a[1];
    return parseFromConfigs(getConfigsForFiles(files), resolvedFilePath, processedOptions);
}
exports.parseFromFilesSync = parseFromFilesSync;
function parse(_filepath, _options) {
    if (_options === void 0) { _options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var _a, resolvedFilePath, processedOptions, filepaths;
        return __generator(this, function (_b) {
            _a = opts(_filepath, _options), resolvedFilePath = _a[0], processedOptions = _a[1];
            filepaths = getConfigFileNames(resolvedFilePath, processedOptions);
            return [2 /*return*/, readConfigFiles(filepaths)
                    .then(getConfigsForFiles)
                    .then(function (configs) { return parseFromConfigs(configs, resolvedFilePath, processedOptions); })];
        });
    });
}
exports.parse = parse;
function parseSync(_filepath, _options) {
    if (_options === void 0) { _options = {}; }
    var _a = opts(_filepath, _options), resolvedFilePath = _a[0], processedOptions = _a[1];
    var filepaths = getConfigFileNames(resolvedFilePath, processedOptions);
    var files = readConfigFilesSync(filepaths);
    return parseFromConfigs(getConfigsForFiles(files), resolvedFilePath, processedOptions);
}
exports.parseSync = parseSync;


/***/ }),

/***/ 8582:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
// Based on minimatch.js by isaacs <https://npmjs.org/package/minimatch>

  var platform = typeof process === "object" ? process.platform : "win32"

  if (module) module.exports = minimatch
  else exports.minimatch = minimatch

  minimatch.Minimatch = Minimatch

  var LRU = __webpack_require__(102)
    , cache = minimatch.cache = new LRU({max: 100})
    , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
    , sigmund = __webpack_require__(2462)

  var path = __webpack_require__(5622)
    // any single thing other than /
    // don't need to escape / when using new RegExp()
    , qmark = "[^/]"

    // * => any number of characters
    , star = qmark + "*?"

    // ** when dots are allowed.  Anything goes, except .. and .
    // not (^ or / followed by one or two dots followed by $ or /),
    // followed by anything, any number of times.
    , twoStarDot = "(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?"

    // not a ^ or / followed by a dot,
    // followed by anything, any number of times.
    , twoStarNoDot = "(?:(?!(?:\\\/|^)\\.).)*?"

    // characters that need to be escaped in RegExp.
    , reSpecials = charSet("().*{}+?[]^$\\!")

// "abc" -> { a:true, b:true, c:true }
  function charSet (s) {
    return s.split("").reduce(function (set, c) {
      set[c] = true
      return set
    }, {})
  }

// normalizes slashes.
  var slashSplit = /\/+/

  minimatch.monkeyPatch = monkeyPatch
  function monkeyPatch () {
    var desc = Object.getOwnPropertyDescriptor(String.prototype, "match")
    var orig = desc.value
    desc.value = function (p) {
      if (p instanceof Minimatch) return p.match(this)
      return orig.call(this, p)
    }
    Object.defineProperty(String.prototype, desc)
  }

  minimatch.filter = filter
  function filter (pattern, options) {
    options = options || {}
    return function (p, i, list) {
      return minimatch(p, pattern, options)
    }
  }

  function ext (a, b) {
    a = a || {}
    b = b || {}
    var t = {}
    Object.keys(b).forEach(function (k) {
      t[k] = b[k]
    })
    Object.keys(a).forEach(function (k) {
      t[k] = a[k]
    })
    return t
  }

  minimatch.defaults = function (def) {
    if (!def || !Object.keys(def).length) return minimatch

    var orig = minimatch

    var m = function minimatch (p, pattern, options) {
      return orig.minimatch(p, pattern, ext(def, options))
    }

    m.Minimatch = function Minimatch (pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options))
    }

    return m
  }

  Minimatch.defaults = function (def) {
    if (!def || !Object.keys(def).length) return Minimatch
    return minimatch.defaults(def).Minimatch
  }


  function minimatch (p, pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required")
    }

    if (!options) options = {}

        // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false
    }

    // "" only matches ""
    if (pattern.trim() === "") return p === ""

    return new Minimatch(pattern, options).match(p)
  }

  function Minimatch (pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options, cache)
    }

    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required")
    }

    if (!options) options = {}

        // windows: need to use /, not \
        // On other platforms, \ is a valid (albeit bad) filename char.
    if (platform === "win32") {
      pattern = pattern.split("\\").join("/")
    }

    // lru storage.
    // these things aren't particularly big, but walking down the string
    // and turning it into a regexp can get pretty costly.
    var cacheKey = pattern + "\n" + sigmund(options)
    var cached = minimatch.cache.get(cacheKey)
    if (cached) return cached
    minimatch.cache.set(cacheKey, this)

    this.options = options
    this.set = []
    this.pattern = pattern
    this.regexp = null
    this.negate = false
    this.comment = false
    this.empty = false

      // make the set of regexps etc.
    this.make()
  }

  Minimatch.prototype.make = make
  function make () {
    // don't do it more than once.
    if (this._made) return

    var pattern = this.pattern
    var options = this.options

      // empty patterns and comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true
      return
    }
    if (!pattern) {
      this.empty = true
      return
    }

    // step 1: figure out negation, etc.
    this.parseNegate()

      // step 2: expand braces
    var set = this.globSet = this.braceExpand()

    if (options.debug) console.error(this.pattern, set)

        // step 3: now we have a set, so turn each one into a series of path-portion
        // matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
    set = this.globParts = set.map(function (s) {
        return s.split(slashSplit)
      })

    if (options.debug) console.error(this.pattern, set)

        // glob --> regexps
    set = set.map(function (s, si, set) {
      return s.map(this.parse, this)
    }, this)

    if (options.debug) console.error(this.pattern, set)

        // filter out everything that didn't compile properly.
    set = set.filter(function (s) {
      return -1 === s.indexOf(false)
    })

    if (options.debug) console.error(this.pattern, set)

    this.set = set
  }

  Minimatch.prototype.parseNegate = parseNegate
  function parseNegate () {
    var pattern = this.pattern
      , negate = false
      , options = this.options
      , negateOffset = 0

    if (options.nonegate) return

    for ( var i = 0, l = pattern.length
      ; i < l && pattern.charAt(i) === "!"
      ; i ++) {
      negate = !negate
      negateOffset ++
    }

    if (negateOffset) this.pattern = pattern.substr(negateOffset)
    this.negate = negate
  }

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
  minimatch.braceExpand = function (pattern, options) {
    return new Minimatch(pattern, options).braceExpand()
  }

  Minimatch.prototype.braceExpand = braceExpand
  function braceExpand (pattern, options) {
    options = options || this.options
    pattern = typeof pattern === "undefined"
        ? this.pattern : pattern

    if (typeof pattern === "undefined") {
      throw new Error("undefined pattern")
    }

    if (options.nobrace ||
      !pattern.match(/\{.*\}/)) {
      // shortcut. no need to expand.
      return [pattern]
    }

    var escaping = false

      // examples and comments refer to this crazy pattern:
      // a{b,c{d,e},{f,g}h}x{y,z}
      // expected:
      // abxy
      // abxz
      // acdxy
      // acdxz
      // acexy
      // acexz
      // afhxy
      // afhxz
      // aghxy
      // aghxz

      // everything before the first \{ is just a prefix.
      // So, we pluck that off, and work with the rest,
      // and then prepend it to everything we find.
    if (pattern.charAt(0) !== "{") {
      // console.error(pattern)
      var prefix = null
      for (var i = 0, l = pattern.length; i < l; i ++) {
        var c = pattern.charAt(i)
          // console.error(i, c)
        if (c === "\\") {
          escaping = !escaping
        } else if (c === "{" && !escaping) {
          prefix = pattern.substr(0, i)
          break
        }
      }

      // actually no sets, all { were escaped.
      if (prefix === null) {
        // console.error("no sets")
        return [pattern]
      }

      var tail = braceExpand(pattern.substr(i), options)
      return tail.map(function (t) {
        return prefix + t
      })
    }

    // now we have something like:
    // {b,c{d,e},{f,g}h}x{y,z}
    // walk through the set, expanding each part, until
    // the set ends.  then, we'll expand the suffix.
    // If the set only has a single member, then'll put the {} back

    // first, handle numeric sets, since they're easier
    var numset = pattern.match(/^\{(-?[0-9]+)\.\.(-?[0-9]+)\}/)
    if (numset) {
      // console.error("numset", numset[1], numset[2])
      var suf = braceExpand(pattern.substr(numset[0].length), options)
        , start = +numset[1]
        , end = +numset[2]
        , inc = start > end ? -1 : 1
        , set = []
      for (var i = start; i != (end + inc); i += inc) {
        // append all the suffixes
        for (var ii = 0, ll = suf.length; ii < ll; ii ++) {
          set.push(i + suf[ii])
        }
      }
      return set
    }

    // ok, walk through the set
    // We hope, somewhat optimistically, that there
    // will be a } at the end.
    // If the closing brace isn't found, then the pattern is
    // interpreted as braceExpand("\\" + pattern) so that
    // the leading \{ will be interpreted literally.
    var i = 1 // skip the \{
      , depth = 1
      , set = []
      , member = ""
      , sawEnd = false
      , escaping = false

    function addMember () {
      set.push(member)
      member = ""
    }

    // console.error("Entering for")
    FOR: for (i = 1, l = pattern.length; i < l; i ++) {
        var c = pattern.charAt(i)
          // console.error("", i, c)

        if (escaping) {
          escaping = false
          member += "\\" + c
        } else {
          switch (c) {
            case "\\":
              escaping = true
              continue

            case "{":
              depth ++
              member += "{"
              continue

            case "}":
              depth --
                // if this closes the actual set, then we're done
              if (depth === 0) {
                addMember()
                  // pluck off the close-brace
                i ++
                break FOR
              } else {
                member += c
                continue
              }

            case ",":
              if (depth === 1) {
                addMember()
              } else {
                member += c
              }
              continue

            default:
              member += c
              continue
          } // switch
        } // else
      } // for

    // now we've either finished the set, and the suffix is
    // pattern.substr(i), or we have *not* closed the set,
    // and need to escape the leading brace
    if (depth !== 0) {
      // console.error("didn't close", pattern)
      return braceExpand("\\" + pattern, options)
    }

    // x{y,z} -> ["xy", "xz"]
    // console.error("set", set)
    // console.error("suffix", pattern.substr(i))
    var suf = braceExpand(pattern.substr(i), options)
      // ["b", "c{d,e}","{f,g}h"] ->
      //   [["b"], ["cd", "ce"], ["fh", "gh"]]
    var addBraces = set.length === 1
      // console.error("set pre-expanded", set)
    set = set.map(function (p) {
      return braceExpand(p, options)
    })
      // console.error("set expanded", set)


      // [["b"], ["cd", "ce"], ["fh", "gh"]] ->
      //   ["b", "cd", "ce", "fh", "gh"]
    set = set.reduce(function (l, r) {
      return l.concat(r)
    })

    if (addBraces) {
      set = set.map(function (s) {
        return "{" + s + "}"
      })
    }

    // now attach the suffixes.
    var ret = []
    for (var i = 0, l = set.length; i < l; i ++) {
      for (var ii = 0, ll = suf.length; ii < ll; ii ++) {
        ret.push(set[i] + suf[ii])
      }
    }
    return ret
  }

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
  Minimatch.prototype.parse = parse
  var SUBPARSE = {}
  function parse (pattern, isSub) {
    var options = this.options

      // shortcuts
    if (!options.noglobstar && pattern === "**") return GLOBSTAR
    if (pattern === "") return ""

    var re = ""
      , hasMagic = !!options.nocase
      , escaping = false
      // ? => one single character
      , patternListStack = []
      , plType
      , stateChar
      , inClass = false
      , reClassStart = -1
      , classStart = -1
      // . and .. never match anything that doesn't start with .,
      // even when options.dot is set.
      , patternStart = pattern.charAt(0) === "." ? "" // anything
        // not (start or / followed by . or .. followed by / or end)
        : options.dot ? "(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))"
          : "(?!\\.)"

    function clearStateChar () {
      if (stateChar) {
        // we had some state-tracking character
        // that wasn't consumed by this pass.
        switch (stateChar) {
          case "*":
            re += star
            hasMagic = true
            break
          case "?":
            re += qmark
            hasMagic = true
            break
          default:
            re += "\\"+stateChar
            break
        }
        stateChar = false
      }
    }

    for ( var i = 0, len = pattern.length, c
      ; (i < len) && (c = pattern.charAt(i))
      ; i ++ ) {

      if (options.debug) {
        console.error("%s\t%s %s %j", pattern, i, re, c)
      }

      // skip over any that are escaped.
      if (escaping && reSpecials[c]) {
        re += "\\" + c
        escaping = false
        continue
      }

      SWITCH: switch (c) {
          case "/":
            // completely not allowed, even escaped.
            // Should already be path-split by now.
            return false

          case "\\":
            clearStateChar()
            escaping = true
            continue

          // the various stateChar values
          // for the "extglob" stuff.
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            if (options.debug) {
              console.error("%s\t%s %s %j <-- stateChar", pattern, i, re, c)
            }

            // all of those are literals inside a class, except that
            // the glob [!a] means [^a] in regexp
            if (inClass) {
              if (c === "!" && i === classStart + 1) c = "^"
              re += c
              continue
            }

            // if we already have a stateChar, then it means
            // that there was something like ** or +? in there.
            // Handle the stateChar, then proceed with this one.
            clearStateChar()
            stateChar = c
              // if extglob is disabled, then +(asdf|foo) isn't a thing.
              // just clear the statechar *now*, rather than even diving into
              // the patternList stuff.
            if (options.noext) clearStateChar()
            continue

          case "(":
            if (inClass) {
              re += "("
              continue
            }

            if (!stateChar) {
              re += "\\("
              continue
            }

            plType = stateChar
            patternListStack.push({ type: plType
              , start: i - 1
              , reStart: re.length })
              // negation is (?:(?!js)[^/]*)
            re += stateChar === "!" ? "(?:(?!" : "(?:"
            stateChar = false
            continue

          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)"
              continue
            }

            hasMagic = true
            re += ")"
            plType = patternListStack.pop().type
              // negation is (?:(?!js)[^/]*)
              // The others are (?:<pattern>)<type>
            switch (plType) {
              case "!":
                re += "[^/]*?)"
                break
              case "?":
              case "+":
              case "*": re += plType
              case "@": break // the default anyway
            }
            continue

          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|"
              escaping = false
              continue
            }

            re += "|"
            continue

          // these are mostly the same in regexp and glob
          case "[":
            // swallow any state-tracking char before the [
            clearStateChar()

            if (inClass) {
              re += "\\" + c
              continue
            }

            inClass = true
            classStart = i
            reClassStart = re.length
            re += c
            continue

          case "]":
            //  a right bracket shall lose its special
            //  meaning and represent itself in
            //  a bracket expression if it occurs
            //  first in the list.  -- POSIX.2 2.8.3.2
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c
              escaping = false
              continue
            }

            // finish up the class.
            hasMagic = true
            inClass = false
            re += c
            continue

          default:
            // swallow any state char that wasn't consumed
            clearStateChar()

            if (escaping) {
              // no need
              escaping = false
            } else if (reSpecials[c]
              && !(c === "^" && inClass)) {
              re += "\\"
            }

            re += c

        } // switch
    } // for


    // handle the case where we left a class open.
    // "[abc" is valid, equivalent to "\[abc"
    if (inClass) {
      // split where the last [ was, and escape it
      // this is a huge pita.  We now have to re-walk
      // the contents of the would-be class to re-translate
      // any characters that were passed through as-is
      var cs = pattern.substr(classStart + 1)
        , sp = this.parse(cs, SUBPARSE)
      re = re.substr(0, reClassStart) + "\\[" + sp[0]
      hasMagic = hasMagic || sp[1]
    }

    // handle the case where we had a +( thing at the *end*
    // of the pattern.
    // each pattern list stack adds 3 chars, and we need to go through
    // and escape any | chars that were passed through as-is for the regexp.
    // Go through and escape them, taking care not to double-escape any
    // | chars that were already escaped.
    var pl
    while (pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + 3)
        // maybe some even number of \, then maybe 1 \, followed by a |
      tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
        if (!$2) {
          // the | isn't already escaped, so escape it.
          $2 = "\\"
        }

        // need to escape all those slashes *again*, without escaping the
        // one that we need for escaping the | character.  As it works out,
        // escaping an even number of slashes can be done by simply repeating
        // it exactly after itself.  That's why this trick works.
        //
        // I am sorry that you have to see this.
        return $1 + $1 + $2 + "|"
      })

        // console.error("tail=%j\n   %s", tail, tail)
      var t = pl.type === "*" ? star
          : pl.type === "?" ? qmark
            : "\\" + pl.type

      hasMagic = true
      re = re.slice(0, pl.reStart)
        + t + "\\("
        + tail
    }

    // handle trailing things that only matter at the very end.
    clearStateChar()
    if (escaping) {
      // trailing \\
      re += "\\\\"
    }

    // only need to apply the nodot start if the re starts with
    // something that could conceivably capture a dot
    var addPatternStart = false
    switch (re.charAt(0)) {
      case ".":
      case "[":
      case "(": addPatternStart = true
    }

    // if the re is not "" at this point, then we need to make sure
    // it doesn't match against an empty path part.
    // Otherwise a/* will match a/, which it should not.
    if (re !== "" && hasMagic) re = "(?=.)" + re

    if (addPatternStart) re = patternStart + re

        // parsing just a piece of a larger pattern.
    if (isSub === SUBPARSE) {
      return [ re, hasMagic ]
    }

    // skip the regexp for non-magical patterns
    // unescape anything in it, though, so that it'll be
    // an exact match against a file etc.
    if (!hasMagic) {
      return globUnescape(pattern)
    }

    var flags = options.nocase ? "i" : ""
      , regExp = new RegExp("^" + re + "$", flags)

    regExp._glob = pattern
    regExp._src = re

    return regExp
  }

  minimatch.makeRe = function (pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe()
  }

  Minimatch.prototype.makeRe = makeRe
  function makeRe () {
    if (this.regexp || this.regexp === false) return this.regexp

        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
    var set = this.set

    if (!set.length) return this.regexp = false
    var options = this.options

    var twoStar = options.noglobstar ? star
        : options.dot ? twoStarDot
          : twoStarNoDot
      , flags = options.nocase ? "i" : ""

    var re = set.map(function (pattern) {
      return pattern.map(function (p) {
        return (p === GLOBSTAR) ? twoStar
            : (typeof p === "string") ? regExpEscape(p)
              : p._src
      }).join("\\\/")
    }).join("|")

      // must match entire pattern
      // ending in a * or ** will make it less strict.
    re = "^(?:" + re + ")$"

      // can match anything, as long as it's not this.
    if (this.negate) re = "^(?!" + re + ").*$"

    try {
      return this.regexp = new RegExp(re, flags)
    } catch (ex) {
        return this.regexp = false
      }
  }

  minimatch.match = function (list, pattern, options) {
    var mm = new Minimatch(pattern, options)
    list = list.filter(function (f) {
      return mm.match(f)
    })
    if (options.nonull && !list.length) {
      list.push(pattern)
    }
    return list
  }

  Minimatch.prototype.match = match
  function match (f, partial) {
    // console.error("match", f, this.pattern)
    // short-circuit in the case of busted things.
    // comments, etc.
    if (this.comment) return false
    if (this.empty) return f === ""

    if (f === "/" && partial) return true

    var options = this.options

      // windows: need to use /, not \
      // On other platforms, \ is a valid (albeit bad) filename char.
    if (platform === "win32") {
      f = f.split("\\").join("/")
    }

    // treat the test path as a set of pathparts.
    f = f.split(slashSplit)
    if (options.debug) {
      console.error(this.pattern, "split", f)
    }

    // just ONE of the pattern sets in this.set needs to match
    // in order for it to be valid.  If negating, then just one
    // match means that we have failed.
    // Either way, return on the first hit.

    var set = this.set
      // console.error(this.pattern, "set", set)

    for (var i = 0, l = set.length; i < l; i ++) {
      var pattern = set[i]
      var hit = this.matchOne(f, pattern, partial)
      if (hit) {
        if (options.flipNegate) return true
        return !this.negate
      }
    }

    // didn't get any hits.  this is success if it's a negative
    // pattern, failure otherwise.
    if (options.flipNegate) return false
    return this.negate
  }

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
  Minimatch.prototype.matchOne = function (file, pattern, partial) {
    var options = this.options

    if (options.debug) {
      console.error("matchOne",
      { "this": this
        , file: file
        , pattern: pattern })
    }

    if (options.matchBase && pattern.length === 1) {
      file = path.basename(file.join("/")).split("/")
    }

    if (options.debug) {
      console.error("matchOne", file.length, pattern.length)
    }

    for ( var fi = 0
        , pi = 0
        , fl = file.length
        , pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi ++, pi ++ ) {

      if (options.debug) {
        console.error("matchOne loop")
      }
      var p = pattern[pi]
        , f = file[fi]

      if (options.debug) {
        console.error(pattern, p, f)
      }

      // should be impossible.
      // some invalid regexp stuff in the set.
      if (p === false) return false

      if (p === GLOBSTAR) {
        if (options.debug)
          console.error('GLOBSTAR', [pattern, p, f])

            // "**"
            // a/**/b/**/c would match the following:
            // a/b/x/y/z/c
            // a/x/y/z/b/c
            // a/b/x/b/x/c
            // a/b/c
            // To do this, take the rest of the pattern after
            // the **, and see if it would match the file remainder.
            // If so, return success.
            // If not, the ** "swallows" a segment, and try again.
            // This is recursively awful.
            //
            // a/**/b/**/c matching a/b/x/y/z/c
            // - a matches a
            // - doublestar
            //   - matchOne(b/x/y/z/c, b/**/c)
            //     - b matches b
            //     - doublestar
            //       - matchOne(x/y/z/c, c) -> no
            //       - matchOne(y/z/c, c) -> no
            //       - matchOne(z/c, c) -> no
            //       - matchOne(c, c) yes, hit
        var fr = fi
          , pr = pi + 1
        if (pr === pl) {
          if (options.debug)
            console.error('** at the end')
              // a ** at the end will just swallow the rest.
              // We have found a match.
              // however, it will not swallow /.x, unless
              // options.dot is set.
              // . and .. are *never* matched by **, for explosively
              // exponential reasons.
          for ( ; fi < fl; fi ++) {
            if (file[fi] === "." || file[fi] === ".." ||
            (!options.dot && file[fi].charAt(0) === ".")) return false
          }
          return true
        }

        // ok, let's see if we can swallow whatever we can.
        WHILE: while (fr < fl) {
            var swallowee = file[fr]

            if (options.debug) {
              console.error('\nglobstar while',
                file, fr, pattern, pr, swallowee)
            }

            // XXX remove this slice.  Just pass the start index.
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              if (options.debug)
                console.error('globstar found match!', fr, fl, swallowee)
                  // found a match.
              return true
            } else {
              // can't swallow "." or ".." ever.
              // can only swallow ".foo" when explicitly asked.
              if (swallowee === "." || swallowee === ".." ||
              (!options.dot && swallowee.charAt(0) === ".")) {
                if (options.debug)
                  console.error("dot detected!", file, fr, pattern, pr)
                break WHILE
              }

              // ** swallows a segment, and continue.
              if (options.debug)
                console.error('globstar swallow a segment, and continue')
              fr ++
            }
          }
        // no match was found.
        // However, in partial mode, we can't say this is necessarily over.
        // If there's more *pattern* left, then
        if (partial) {
          // ran out of file
          // console.error("\n>>> no match, partial?", file, fr, pattern, pr)
          if (fr === fl) return true
        }
        return false
      }

      // something other than **
      // non-magic patterns just have to match exactly
      // patterns with magic have been turned into regexps.
      var hit
      if (typeof p === "string") {
        if (options.nocase) {
          hit = f.toLowerCase() === p.toLowerCase()
        } else {
          hit = f === p
        }
        if (options.debug) {
          console.error("string match", p, f, hit)
        }
      } else {
        hit = f.match(p)
        if (options.debug) {
          console.error("pattern match", p, f, hit)
        }
      }

      if (!hit) return false
    }

    // Note: ending in / means that we'll get a final ""
    // at the end of the pattern.  This can only match a
    // corresponding "" at the end of the file.
    // If the file ends in /, then it can only match a
    // a pattern that ends in /, unless the pattern just
    // doesn't have any more for it. But, a/b/ should *not*
    // match "a/b/*", even though "" matches against the
    // [^/]*? pattern, except in partial mode, where it might
    // simply not be reached yet.
    // However, a/b/ should still satisfy a/*

    // now either we fell off the end of the pattern, or we're done.
    if (fi === fl && pi === pl) {
      // ran out of pattern and filename at the same time.
      // an exact hit!
      return true
    } else if (fi === fl) {
      // ran out of file, but still had pattern left.
      // this is ok if we're doing the match as part of
      // a glob fs traversal.
      return partial
    } else if (pi === pl) {
      // ran out of pattern, still have file left.
      // this is only acceptable if we're on the very last
      // empty segment of a file with a trailing slash.
      // a/* should match a/b/
      var emptyFileEnd = (fi === fl - 1) && (file[fi] === "")
      return emptyFileEnd
    }

    // should be unreachable.
    throw new Error("wtf?")
  }


// replace stuff like \* with *
  function globUnescape (s) {
    return s.replace(/\\(.)/g, "$1")
  }


  function regExpEscape (s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
  }


/***/ }),

/***/ 5345:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Based on iniparser by shockie <https://npmjs.org/package/iniparser>
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var fs = __importStar(__webpack_require__(5747));
/**
 * define the possible values:
 * section: [section]
 * param: key=value
 * comment: ;this is a comment
 */
var regex = {
    section: /^\s*\[(([^#;]|\\#|\\;)+)\]\s*([#;].*)?$/,
    param: /^\s*([\w\.\-\_]+)\s*[=:]\s*(.*?)\s*([#;].*)?$/,
    comment: /^\s*[#;].*$/,
};
/**
 * Parses an .ini file
 * @param file The location of the .ini file
 */
function parse(file) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    fs.readFile(file, 'utf8', function (err, data) {
                        if (err) {
                            reject(err);
                            return;
                        }
                        resolve(parseString(data));
                    });
                })];
        });
    });
}
exports.parse = parse;
function parseSync(file) {
    return parseString(fs.readFileSync(file, 'utf8'));
}
exports.parseSync = parseSync;
function parseString(data) {
    var sectionBody = {};
    var sectionName = null;
    var value = [[sectionName, sectionBody]];
    var lines = data.split(/\r\n|\r|\n/);
    lines.forEach(function (line) {
        var match;
        if (regex.comment.test(line)) {
            return;
        }
        if (regex.param.test(line)) {
            match = line.match(regex.param);
            sectionBody[match[1]] =
                match[2];
        }
        else if (regex.section.test(line)) {
            match = line.match(regex.section);
            sectionName = match[1];
            sectionBody = {};
            value.push([sectionName, sectionBody]);
        }
    });
    return value;
}
exports.parseString = parseString;


/***/ }),

/***/ 8531:
/***/ (function(module) {

/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.8+1e68dce6
 */

(function (global, factory) {
	 true ? module.exports = factory() :
	0;
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && "function" === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    var then$$1 = void 0;
    try {
      then$$1 = value.then;
    } catch (error) {
      reject(promise, error);
      return;
    }
    handleMaybeThenable(promise, value, then$$1);
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = true;

  if (hasCallback) {
    try {
      value = callback(detail);
    } catch (e) {
      succeeded = false;
      error = e;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (succeeded === false) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = void 0;
      var error = void 0;
      var didError = false;
      try {
        _then = entry.then;
      } catch (e) {
        didError = true;
        error = e;
      }

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        if (didError) {
          reject(promise, error);
        } else {
          handleMaybeThenable(promise, entry, _then);
        }
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    if (isFunction(callback)) {
      return promise.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          throw reason;
        });
      });
    }

    return promise.then(callback, callback);
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));



//# sourceMappingURL=es6-promise.map


/***/ }),

/***/ 1295:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* global self, window, module, global, require */
module.exports = function () {

    "use strict";

    var globalObject = void 0;

    function isFunction(x) {
        return typeof x === "function";
    }

    // Seek the global object
    if (global !== undefined) {
        globalObject = global;
    } else if (window !== undefined && window.document) {
        globalObject = window;
    } else {
        globalObject = self;
    }

    // Test for any native promise implementation, and if that
    // implementation appears to conform to the specificaton.
    // This code mostly nicked from the es6-promise module polyfill
    // and then fooled with.
    var hasPromiseSupport = function () {

        // No promise object at all, and it's a non-starter
        if (!globalObject.hasOwnProperty("Promise")) {
            return false;
        }

        // There is a Promise object. Does it conform to the spec?
        var P = globalObject.Promise;

        // Some of these methods are missing from
        // Firefox/Chrome experimental implementations
        if (!P.hasOwnProperty("resolve") || !P.hasOwnProperty("reject")) {
            return false;
        }

        if (!P.hasOwnProperty("all") || !P.hasOwnProperty("race")) {
            return false;
        }

        // Older version of the spec had a resolver object
        // as the arg rather than a function
        return function () {

            var resolve = void 0;

            var p = new globalObject.Promise(function (r) {
                resolve = r;
            });

            if (p) {
                return isFunction(resolve);
            }

            return false;
        }();
    }();

    // Export the native Promise implementation if it
    // looks like it matches the spec
    if (hasPromiseSupport) {
        return globalObject.Promise;
    }

    //  Otherwise, return the es6-promise polyfill by @jaffathecake.
    return __webpack_require__(8531).Promise;
}();

/***/ }),

/***/ 930:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* global module, require */
module.exports = function () {

    "use strict";

    // Get a promise object. This may be native, or it may be polyfilled

    var ES6Promise = __webpack_require__(1295);

    /**
     * thatLooksLikeAPromiseToMe()
     *
     * Duck-types a promise.
     *
     * @param {object} o
     * @return {bool} True if this resembles a promise
     */
    function thatLooksLikeAPromiseToMe(o) {
        return o && typeof o.then === "function" && typeof o.catch === "function";
    }

    /**
     * promisify()
     *
     * Transforms callback-based function -- func(arg1, arg2 .. argN, callback) -- into
     * an ES6-compatible Promise. Promisify provides a default callback of the form (error, result)
     * and rejects when `error` is truthy. You can also supply settings object as the second argument.
     *
     * @param {function} original - The function to promisify
     * @param {object} settings - Settings object
     * @param {object} settings.thisArg - A `this` context to use. If not set, assume `settings` _is_ `thisArg`
     * @param {bool} settings.multiArgs - Should multiple arguments be returned as an array?
     * @return {function} A promisified version of `original`
     */
    return function promisify(original, settings) {

        return function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            var returnMultipleArguments = settings && settings.multiArgs;

            var target = void 0;
            if (settings && settings.thisArg) {
                target = settings.thisArg;
            } else if (settings) {
                target = settings;
            }

            // Return the promisified function
            return new ES6Promise(function (resolve, reject) {

                // Append the callback bound to the context
                args.push(function callback(err) {

                    if (err) {
                        return reject(err);
                    }

                    for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                        values[_key2 - 1] = arguments[_key2];
                    }

                    if (false === !!returnMultipleArguments) {
                        return resolve(values[0]);
                    }

                    resolve(values);
                });

                // Call the function
                var response = original.apply(target, args);

                // If it looks like original already returns a promise,
                // then just resolve with that promise. Hopefully, the callback function we added will just be ignored.
                if (thatLooksLikeAPromiseToMe(response)) {
                    resolve(response);
                }
            });
        };
    };
}();

/***/ }),

/***/ 4419:
/***/ ((module) => {

"use strict";


const matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;

module.exports = string => {
	if (typeof string !== 'string') {
		throw new TypeError('Expected a string');
	}

	return string.replace(matchOperatorsRegex, '\\$&');
};


/***/ }),

/***/ 2058:
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __nested_webpack_require_583__(moduleId) {

/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_583__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_583__.m = modules;

/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_583__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_583__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_583__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __nested_webpack_require_1808__) {

	"use strict";
	/*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	var comment_handler_1 = __nested_webpack_require_1808__(1);
	var jsx_parser_1 = __nested_webpack_require_1808__(3);
	var parser_1 = __nested_webpack_require_1808__(8);
	var tokenizer_1 = __nested_webpack_require_1808__(15);
	function parse(code, options, delegate) {
	    var commentHandler = null;
	    var proxyDelegate = function (node, metadata) {
	        if (delegate) {
	            delegate(node, metadata);
	        }
	        if (commentHandler) {
	            commentHandler.visit(node, metadata);
	        }
	    };
	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
	    var collectComment = false;
	    if (options) {
	        collectComment = (typeof options.comment === 'boolean' && options.comment);
	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
	        if (collectComment || attachComment) {
	            commentHandler = new comment_handler_1.CommentHandler();
	            commentHandler.attach = attachComment;
	            options.comment = true;
	            parserDelegate = proxyDelegate;
	        }
	    }
	    var isModule = false;
	    if (options && typeof options.sourceType === 'string') {
	        isModule = (options.sourceType === 'module');
	    }
	    var parser;
	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
	    }
	    else {
	        parser = new parser_1.Parser(code, options, parserDelegate);
	    }
	    var program = isModule ? parser.parseModule() : parser.parseScript();
	    var ast = program;
	    if (collectComment && commentHandler) {
	        ast.comments = commentHandler.comments;
	    }
	    if (parser.config.tokens) {
	        ast.tokens = parser.tokens;
	    }
	    if (parser.config.tolerant) {
	        ast.errors = parser.errorHandler.errors;
	    }
	    return ast;
	}
	exports.parse = parse;
	function parseModule(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'module';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseModule = parseModule;
	function parseScript(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'script';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseScript = parseScript;
	function tokenize(code, options, delegate) {
	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
	    var tokens;
	    tokens = [];
	    try {
	        while (true) {
	            var token = tokenizer.getNextToken();
	            if (!token) {
	                break;
	            }
	            if (delegate) {
	                token = delegate(token);
	            }
	            tokens.push(token);
	        }
	    }
	    catch (e) {
	        tokenizer.errorHandler.tolerate(e);
	    }
	    if (tokenizer.errorHandler.tolerant) {
	        tokens.errors = tokenizer.errors();
	    }
	    return tokens;
	}
	exports.tokenize = tokenize;
	var syntax_1 = __nested_webpack_require_1808__(2);
	exports.Syntax = syntax_1.Syntax;
	// Sync with *.json manifests.
	exports.version = '4.0.1';


/***/ },
/* 1 */
/***/ function(module, exports, __nested_webpack_require_6456__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __nested_webpack_require_6456__(2);
	var CommentHandler = (function () {
	    function CommentHandler() {
	        this.attach = false;
	        this.comments = [];
	        this.stack = [];
	        this.leading = [];
	        this.trailing = [];
	    }
	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
	        //  innnerComments for properties empty block
	        //  `function a() {/** comments **\/}`
	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
	            var innerComments = [];
	            for (var i = this.leading.length - 1; i >= 0; --i) {
	                var entry = this.leading[i];
	                if (metadata.end.offset >= entry.start) {
	                    innerComments.unshift(entry.comment);
	                    this.leading.splice(i, 1);
	                    this.trailing.splice(i, 1);
	                }
	            }
	            if (innerComments.length) {
	                node.innerComments = innerComments;
	            }
	        }
	    };
	    CommentHandler.prototype.findTrailingComments = function (metadata) {
	        var trailingComments = [];
	        if (this.trailing.length > 0) {
	            for (var i = this.trailing.length - 1; i >= 0; --i) {
	                var entry_1 = this.trailing[i];
	                if (entry_1.start >= metadata.end.offset) {
	                    trailingComments.unshift(entry_1.comment);
	                }
	            }
	            this.trailing.length = 0;
	            return trailingComments;
	        }
	        var entry = this.stack[this.stack.length - 1];
	        if (entry && entry.node.trailingComments) {
	            var firstComment = entry.node.trailingComments[0];
	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
	                trailingComments = entry.node.trailingComments;
	                delete entry.node.trailingComments;
	            }
	        }
	        return trailingComments;
	    };
	    CommentHandler.prototype.findLeadingComments = function (metadata) {
	        var leadingComments = [];
	        var target;
	        while (this.stack.length > 0) {
	            var entry = this.stack[this.stack.length - 1];
	            if (entry && entry.start >= metadata.start.offset) {
	                target = entry.node;
	                this.stack.pop();
	            }
	            else {
	                break;
	            }
	        }
	        if (target) {
	            var count = target.leadingComments ? target.leadingComments.length : 0;
	            for (var i = count - 1; i >= 0; --i) {
	                var comment = target.leadingComments[i];
	                if (comment.range[1] <= metadata.start.offset) {
	                    leadingComments.unshift(comment);
	                    target.leadingComments.splice(i, 1);
	                }
	            }
	            if (target.leadingComments && target.leadingComments.length === 0) {
	                delete target.leadingComments;
	            }
	            return leadingComments;
	        }
	        for (var i = this.leading.length - 1; i >= 0; --i) {
	            var entry = this.leading[i];
	            if (entry.start <= metadata.start.offset) {
	                leadingComments.unshift(entry.comment);
	                this.leading.splice(i, 1);
	            }
	        }
	        return leadingComments;
	    };
	    CommentHandler.prototype.visitNode = function (node, metadata) {
	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
	            return;
	        }
	        this.insertInnerComments(node, metadata);
	        var trailingComments = this.findTrailingComments(metadata);
	        var leadingComments = this.findLeadingComments(metadata);
	        if (leadingComments.length > 0) {
	            node.leadingComments = leadingComments;
	        }
	        if (trailingComments.length > 0) {
	            node.trailingComments = trailingComments;
	        }
	        this.stack.push({
	            node: node,
	            start: metadata.start.offset
	        });
	    };
	    CommentHandler.prototype.visitComment = function (node, metadata) {
	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
	        var comment = {
	            type: type,
	            value: node.value
	        };
	        if (node.range) {
	            comment.range = node.range;
	        }
	        if (node.loc) {
	            comment.loc = node.loc;
	        }
	        this.comments.push(comment);
	        if (this.attach) {
	            var entry = {
	                comment: {
	                    type: type,
	                    value: node.value,
	                    range: [metadata.start.offset, metadata.end.offset]
	                },
	                start: metadata.start.offset
	            };
	            if (node.loc) {
	                entry.comment.loc = node.loc;
	            }
	            node.type = type;
	            this.leading.push(entry);
	            this.trailing.push(entry);
	        }
	    };
	    CommentHandler.prototype.visit = function (node, metadata) {
	        if (node.type === 'LineComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (node.type === 'BlockComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (this.attach) {
	            this.visitNode(node, metadata);
	        }
	    };
	    return CommentHandler;
	}());
	exports.CommentHandler = CommentHandler;


/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Syntax = {
	    AssignmentExpression: 'AssignmentExpression',
	    AssignmentPattern: 'AssignmentPattern',
	    ArrayExpression: 'ArrayExpression',
	    ArrayPattern: 'ArrayPattern',
	    ArrowFunctionExpression: 'ArrowFunctionExpression',
	    AwaitExpression: 'AwaitExpression',
	    BlockStatement: 'BlockStatement',
	    BinaryExpression: 'BinaryExpression',
	    BreakStatement: 'BreakStatement',
	    CallExpression: 'CallExpression',
	    CatchClause: 'CatchClause',
	    ClassBody: 'ClassBody',
	    ClassDeclaration: 'ClassDeclaration',
	    ClassExpression: 'ClassExpression',
	    ConditionalExpression: 'ConditionalExpression',
	    ContinueStatement: 'ContinueStatement',
	    DoWhileStatement: 'DoWhileStatement',
	    DebuggerStatement: 'DebuggerStatement',
	    EmptyStatement: 'EmptyStatement',
	    ExportAllDeclaration: 'ExportAllDeclaration',
	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	    ExportNamedDeclaration: 'ExportNamedDeclaration',
	    ExportSpecifier: 'ExportSpecifier',
	    ExpressionStatement: 'ExpressionStatement',
	    ForStatement: 'ForStatement',
	    ForOfStatement: 'ForOfStatement',
	    ForInStatement: 'ForInStatement',
	    FunctionDeclaration: 'FunctionDeclaration',
	    FunctionExpression: 'FunctionExpression',
	    Identifier: 'Identifier',
	    IfStatement: 'IfStatement',
	    ImportDeclaration: 'ImportDeclaration',
	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	    ImportSpecifier: 'ImportSpecifier',
	    Literal: 'Literal',
	    LabeledStatement: 'LabeledStatement',
	    LogicalExpression: 'LogicalExpression',
	    MemberExpression: 'MemberExpression',
	    MetaProperty: 'MetaProperty',
	    MethodDefinition: 'MethodDefinition',
	    NewExpression: 'NewExpression',
	    ObjectExpression: 'ObjectExpression',
	    ObjectPattern: 'ObjectPattern',
	    Program: 'Program',
	    Property: 'Property',
	    RestElement: 'RestElement',
	    ReturnStatement: 'ReturnStatement',
	    SequenceExpression: 'SequenceExpression',
	    SpreadElement: 'SpreadElement',
	    Super: 'Super',
	    SwitchCase: 'SwitchCase',
	    SwitchStatement: 'SwitchStatement',
	    TaggedTemplateExpression: 'TaggedTemplateExpression',
	    TemplateElement: 'TemplateElement',
	    TemplateLiteral: 'TemplateLiteral',
	    ThisExpression: 'ThisExpression',
	    ThrowStatement: 'ThrowStatement',
	    TryStatement: 'TryStatement',
	    UnaryExpression: 'UnaryExpression',
	    UpdateExpression: 'UpdateExpression',
	    VariableDeclaration: 'VariableDeclaration',
	    VariableDeclarator: 'VariableDeclarator',
	    WhileStatement: 'WhileStatement',
	    WithStatement: 'WithStatement',
	    YieldExpression: 'YieldExpression'
	};


/***/ },
/* 3 */
/***/ function(module, exports, __nested_webpack_require_15019__) {

	"use strict";
/* istanbul ignore next */
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var character_1 = __nested_webpack_require_15019__(4);
	var JSXNode = __nested_webpack_require_15019__(5);
	var jsx_syntax_1 = __nested_webpack_require_15019__(6);
	var Node = __nested_webpack_require_15019__(7);
	var parser_1 = __nested_webpack_require_15019__(8);
	var token_1 = __nested_webpack_require_15019__(13);
	var xhtml_entities_1 = __nested_webpack_require_15019__(14);
	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
	token_1.TokenName[101 /* Text */] = 'JSXText';
	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
	function getQualifiedElementName(elementName) {
	    var qualifiedName;
	    switch (elementName.type) {
	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
	            var id = elementName;
	            qualifiedName = id.name;
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
	            var ns = elementName;
	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
	                getQualifiedElementName(ns.name);
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
	            var expr = elementName;
	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
	                getQualifiedElementName(expr.property);
	            break;
	        /* istanbul ignore next */
	        default:
	            break;
	    }
	    return qualifiedName;
	}
	var JSXParser = (function (_super) {
	    __extends(JSXParser, _super);
	    function JSXParser(code, options, delegate) {
	        return _super.call(this, code, options, delegate) || this;
	    }
	    JSXParser.prototype.parsePrimaryExpression = function () {
	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
	    };
	    JSXParser.prototype.startJSX = function () {
	        // Unwind the scanner before the lookahead token.
	        this.scanner.index = this.startMarker.index;
	        this.scanner.lineNumber = this.startMarker.line;
	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
	    };
	    JSXParser.prototype.finishJSX = function () {
	        // Prime the next lookahead.
	        this.nextToken();
	    };
	    JSXParser.prototype.reenterJSX = function () {
	        this.startJSX();
	        this.expectJSX('}');
	        // Pop the closing '}' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	    };
	    JSXParser.prototype.createJSXNode = function () {
	        this.collectComments();
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.createJSXChildNode = function () {
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
	        var result = '&';
	        var valid = true;
	        var terminated = false;
	        var numeric = false;
	        var hex = false;
	        while (!this.scanner.eof() && valid && !terminated) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === quote) {
	                break;
	            }
	            terminated = (ch === ';');
	            result += ch;
	            ++this.scanner.index;
	            if (!terminated) {
	                switch (result.length) {
	                    case 2:
	                        // e.g. '&#123;'
	                        numeric = (ch === '#');
	                        break;
	                    case 3:
	                        if (numeric) {
	                            // e.g. '&#x41;'
	                            hex = (ch === 'x');
	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
	                            numeric = numeric && !hex;
	                        }
	                        break;
	                    default:
	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
	                        break;
	                }
	            }
	        }
	        if (valid && terminated && result.length > 2) {
	            // e.g. '&#x41;' becomes just '#x41'
	            var str = result.substr(1, result.length - 2);
	            if (numeric && str.length > 1) {
	                result = String.fromCharCode(parseInt(str.substr(1), 10));
	            }
	            else if (hex && str.length > 2) {
	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
	            }
	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
	                result = xhtml_entities_1.XHTMLEntities[str];
	            }
	        }
	        return result;
	    };
	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
	    JSXParser.prototype.lexJSX = function () {
	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
	        // < > / : = { }
	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
	            var value = this.scanner.source[this.scanner.index++];
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index - 1,
	                end: this.scanner.index
	            };
	        }
	        // " '
	        if (cp === 34 || cp === 39) {
	            var start = this.scanner.index;
	            var quote = this.scanner.source[this.scanner.index++];
	            var str = '';
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source[this.scanner.index++];
	                if (ch === quote) {
	                    break;
	                }
	                else if (ch === '&') {
	                    str += this.scanXHTMLEntity(quote);
	                }
	                else {
	                    str += ch;
	                }
	            }
	            return {
	                type: 8 /* StringLiteral */,
	                value: str,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // ... or .
	        if (cp === 46) {
	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
	            var start = this.scanner.index;
	            this.scanner.index += value.length;
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // `
	        if (cp === 96) {
	            // Only placeholder, since it will be rescanned as a real assignment expression.
	            return {
	                type: 10 /* Template */,
	                value: '',
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index,
	                end: this.scanner.index
	            };
	        }
	        // Identifer can not contain backslash (char code 92).
	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
	            var start = this.scanner.index;
	            ++this.scanner.index;
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
	                    ++this.scanner.index;
	                }
	                else if (ch === 45) {
	                    // Hyphen (char code 45) can be part of an identifier.
	                    ++this.scanner.index;
	                }
	                else {
	                    break;
	                }
	            }
	            var id = this.scanner.source.slice(start, this.scanner.index);
	            return {
	                type: 100 /* Identifier */,
	                value: id,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        return this.scanner.lex();
	    };
	    JSXParser.prototype.nextJSXToken = function () {
	        this.collectComments();
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = this.lexJSX();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        if (this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.nextJSXText = function () {
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var start = this.scanner.index;
	        var text = '';
	        while (!this.scanner.eof()) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === '{' || ch === '<') {
	                break;
	            }
	            ++this.scanner.index;
	            text += ch;
	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.scanner.lineNumber;
	                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
	                    ++this.scanner.index;
	                }
	                this.scanner.lineStart = this.scanner.index;
	            }
	        }
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = {
	            type: 101 /* Text */,
	            value: text,
	            lineNumber: this.scanner.lineNumber,
	            lineStart: this.scanner.lineStart,
	            start: start,
	            end: this.scanner.index
	        };
	        if ((text.length > 0) && this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.peekJSXToken = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.lexJSX();
	        this.scanner.restoreState(state);
	        return next;
	    };
	    // Expect the next JSX token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    JSXParser.prototype.expectJSX = function (value) {
	        var token = this.nextJSXToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next JSX token matches the specified punctuator.
	    JSXParser.prototype.matchJSX = function (value) {
	        var next = this.peekJSXToken();
	        return next.type === 7 /* Punctuator */ && next.value === value;
	    };
	    JSXParser.prototype.parseJSXIdentifier = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 100 /* Identifier */) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
	    };
	    JSXParser.prototype.parseJSXElementName = function () {
	        var node = this.createJSXNode();
	        var elementName = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = elementName;
	            this.expectJSX(':');
	            var name_1 = this.parseJSXIdentifier();
	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
	        }
	        else if (this.matchJSX('.')) {
	            while (this.matchJSX('.')) {
	                var object = elementName;
	                this.expectJSX('.');
	                var property = this.parseJSXIdentifier();
	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
	            }
	        }
	        return elementName;
	    };
	    JSXParser.prototype.parseJSXAttributeName = function () {
	        var node = this.createJSXNode();
	        var attributeName;
	        var identifier = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = identifier;
	            this.expectJSX(':');
	            var name_2 = this.parseJSXIdentifier();
	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
	        }
	        else {
	            attributeName = identifier;
	        }
	        return attributeName;
	    };
	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 8 /* StringLiteral */) {
	            this.throwUnexpectedToken(token);
	        }
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.finishJSX();
	        if (this.match('}')) {
	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
	        }
	        var expression = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXAttributeValue = function () {
	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
	    };
	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
	        var node = this.createJSXNode();
	        var name = this.parseJSXAttributeName();
	        var value = null;
	        if (this.matchJSX('=')) {
	            this.expectJSX('=');
	            value = this.parseJSXAttributeValue();
	        }
	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
	    };
	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.expectJSX('...');
	        this.finishJSX();
	        var argument = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
	    };
	    JSXParser.prototype.parseJSXAttributes = function () {
	        var attributes = [];
	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
	                this.parseJSXNameValueAttribute();
	            attributes.push(attribute);
	        }
	        return attributes;
	    };
	    JSXParser.prototype.parseJSXOpeningElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXBoundaryElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        if (this.matchJSX('/')) {
	            this.expectJSX('/');
	            var name_3 = this.parseJSXElementName();
	            this.expectJSX('>');
	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
	        }
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXEmptyExpression = function () {
	        var node = this.createJSXChildNode();
	        this.collectComments();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
	    };
	    JSXParser.prototype.parseJSXExpressionContainer = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        var expression;
	        if (this.matchJSX('}')) {
	            expression = this.parseJSXEmptyExpression();
	            this.expectJSX('}');
	        }
	        else {
	            this.finishJSX();
	            expression = this.parseAssignmentExpression();
	            this.reenterJSX();
	        }
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXChildren = function () {
	        var children = [];
	        while (!this.scanner.eof()) {
	            var node = this.createJSXChildNode();
	            var token = this.nextJSXText();
	            if (token.start < token.end) {
	                var raw = this.getTokenRaw(token);
	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
	                children.push(child);
	            }
	            if (this.scanner.source[this.scanner.index] === '{') {
	                var container = this.parseJSXExpressionContainer();
	                children.push(container);
	            }
	            else {
	                break;
	            }
	        }
	        return children;
	    };
	    JSXParser.prototype.parseComplexJSXElement = function (el) {
	        var stack = [];
	        while (!this.scanner.eof()) {
	            el.children = el.children.concat(this.parseJSXChildren());
	            var node = this.createJSXChildNode();
	            var element = this.parseJSXBoundaryElement();
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
	                var opening = element;
	                if (opening.selfClosing) {
	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
	                    el.children.push(child);
	                }
	                else {
	                    stack.push(el);
	                    el = { node: node, opening: opening, closing: null, children: [] };
	                }
	            }
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
	                el.closing = element;
	                var open_1 = getQualifiedElementName(el.opening.name);
	                var close_1 = getQualifiedElementName(el.closing.name);
	                if (open_1 !== close_1) {
	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
	                }
	                if (stack.length > 0) {
	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
	                    el = stack[stack.length - 1];
	                    el.children.push(child);
	                    stack.pop();
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        return el;
	    };
	    JSXParser.prototype.parseJSXElement = function () {
	        var node = this.createJSXNode();
	        var opening = this.parseJSXOpeningElement();
	        var children = [];
	        var closing = null;
	        if (!opening.selfClosing) {
	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
	            children = el.children;
	            closing = el.closing;
	        }
	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
	    };
	    JSXParser.prototype.parseJSXRoot = function () {
	        // Pop the opening '<' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	        this.startJSX();
	        var element = this.parseJSXElement();
	        this.finishJSX();
	        return element;
	    };
	    JSXParser.prototype.isStartOfExpression = function () {
	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
	    };
	    return JSXParser;
	}(parser_1.Parser));
	exports.JSXParser = JSXParser;


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// See also tools/generate-unicode-regex.js.
	var Regex = {
	    // Unicode v8.0.0 NonAsciiIdentifierStart:
	    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
	    // Unicode v8.0.0 NonAsciiIdentifierPart:
	    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	};
	exports.Character = {
	    /* tslint:disable:no-bitwise */
	    fromCodePoint: function (cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    },
	    // https://tc39.github.io/ecma262/#sec-white-space
	    isWhiteSpace: function (cp) {
	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
	    },
	    // https://tc39.github.io/ecma262/#sec-line-terminators
	    isLineTerminator: function (cp) {
	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
	    },
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    isIdentifierStart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
	    },
	    isIdentifierPart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp >= 0x30 && cp <= 0x39) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
	    },
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    isDecimalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39); // 0..9
	    },
	    isHexDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39) ||
	            (cp >= 0x41 && cp <= 0x46) ||
	            (cp >= 0x61 && cp <= 0x66); // a..f
	    },
	    isOctalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x37); // 0..7
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports, __nested_webpack_require_54354__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var jsx_syntax_1 = __nested_webpack_require_54354__(6);
	/* tslint:disable:max-classes-per-file */
	var JSXClosingElement = (function () {
	    function JSXClosingElement(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
	        this.name = name;
	    }
	    return JSXClosingElement;
	}());
	exports.JSXClosingElement = JSXClosingElement;
	var JSXElement = (function () {
	    function JSXElement(openingElement, children, closingElement) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
	        this.openingElement = openingElement;
	        this.children = children;
	        this.closingElement = closingElement;
	    }
	    return JSXElement;
	}());
	exports.JSXElement = JSXElement;
	var JSXEmptyExpression = (function () {
	    function JSXEmptyExpression() {
	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
	    }
	    return JSXEmptyExpression;
	}());
	exports.JSXEmptyExpression = JSXEmptyExpression;
	var JSXExpressionContainer = (function () {
	    function JSXExpressionContainer(expression) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
	        this.expression = expression;
	    }
	    return JSXExpressionContainer;
	}());
	exports.JSXExpressionContainer = JSXExpressionContainer;
	var JSXIdentifier = (function () {
	    function JSXIdentifier(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
	        this.name = name;
	    }
	    return JSXIdentifier;
	}());
	exports.JSXIdentifier = JSXIdentifier;
	var JSXMemberExpression = (function () {
	    function JSXMemberExpression(object, property) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
	        this.object = object;
	        this.property = property;
	    }
	    return JSXMemberExpression;
	}());
	exports.JSXMemberExpression = JSXMemberExpression;
	var JSXAttribute = (function () {
	    function JSXAttribute(name, value) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
	        this.name = name;
	        this.value = value;
	    }
	    return JSXAttribute;
	}());
	exports.JSXAttribute = JSXAttribute;
	var JSXNamespacedName = (function () {
	    function JSXNamespacedName(namespace, name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
	        this.namespace = namespace;
	        this.name = name;
	    }
	    return JSXNamespacedName;
	}());
	exports.JSXNamespacedName = JSXNamespacedName;
	var JSXOpeningElement = (function () {
	    function JSXOpeningElement(name, selfClosing, attributes) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
	        this.name = name;
	        this.selfClosing = selfClosing;
	        this.attributes = attributes;
	    }
	    return JSXOpeningElement;
	}());
	exports.JSXOpeningElement = JSXOpeningElement;
	var JSXSpreadAttribute = (function () {
	    function JSXSpreadAttribute(argument) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
	        this.argument = argument;
	    }
	    return JSXSpreadAttribute;
	}());
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	var JSXText = (function () {
	    function JSXText(value, raw) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
	        this.value = value;
	        this.raw = raw;
	    }
	    return JSXText;
	}());
	exports.JSXText = JSXText;


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSXSyntax = {
	    JSXAttribute: 'JSXAttribute',
	    JSXClosingElement: 'JSXClosingElement',
	    JSXElement: 'JSXElement',
	    JSXEmptyExpression: 'JSXEmptyExpression',
	    JSXExpressionContainer: 'JSXExpressionContainer',
	    JSXIdentifier: 'JSXIdentifier',
	    JSXMemberExpression: 'JSXMemberExpression',
	    JSXNamespacedName: 'JSXNamespacedName',
	    JSXOpeningElement: 'JSXOpeningElement',
	    JSXSpreadAttribute: 'JSXSpreadAttribute',
	    JSXText: 'JSXText'
	};


/***/ },
/* 7 */
/***/ function(module, exports, __nested_webpack_require_58416__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __nested_webpack_require_58416__(2);
	/* tslint:disable:max-classes-per-file */
	var ArrayExpression = (function () {
	    function ArrayExpression(elements) {
	        this.type = syntax_1.Syntax.ArrayExpression;
	        this.elements = elements;
	    }
	    return ArrayExpression;
	}());
	exports.ArrayExpression = ArrayExpression;
	var ArrayPattern = (function () {
	    function ArrayPattern(elements) {
	        this.type = syntax_1.Syntax.ArrayPattern;
	        this.elements = elements;
	    }
	    return ArrayPattern;
	}());
	exports.ArrayPattern = ArrayPattern;
	var ArrowFunctionExpression = (function () {
	    function ArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = false;
	    }
	    return ArrowFunctionExpression;
	}());
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	var AssignmentExpression = (function () {
	    function AssignmentExpression(operator, left, right) {
	        this.type = syntax_1.Syntax.AssignmentExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentExpression;
	}());
	exports.AssignmentExpression = AssignmentExpression;
	var AssignmentPattern = (function () {
	    function AssignmentPattern(left, right) {
	        this.type = syntax_1.Syntax.AssignmentPattern;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentPattern;
	}());
	exports.AssignmentPattern = AssignmentPattern;
	var AsyncArrowFunctionExpression = (function () {
	    function AsyncArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = true;
	    }
	    return AsyncArrowFunctionExpression;
	}());
	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
	var AsyncFunctionDeclaration = (function () {
	    function AsyncFunctionDeclaration(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionDeclaration;
	}());
	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
	var AsyncFunctionExpression = (function () {
	    function AsyncFunctionExpression(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionExpression;
	}());
	exports.AsyncFunctionExpression = AsyncFunctionExpression;
	var AwaitExpression = (function () {
	    function AwaitExpression(argument) {
	        this.type = syntax_1.Syntax.AwaitExpression;
	        this.argument = argument;
	    }
	    return AwaitExpression;
	}());
	exports.AwaitExpression = AwaitExpression;
	var BinaryExpression = (function () {
	    function BinaryExpression(operator, left, right) {
	        var logical = (operator === '||' || operator === '&&');
	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return BinaryExpression;
	}());
	exports.BinaryExpression = BinaryExpression;
	var BlockStatement = (function () {
	    function BlockStatement(body) {
	        this.type = syntax_1.Syntax.BlockStatement;
	        this.body = body;
	    }
	    return BlockStatement;
	}());
	exports.BlockStatement = BlockStatement;
	var BreakStatement = (function () {
	    function BreakStatement(label) {
	        this.type = syntax_1.Syntax.BreakStatement;
	        this.label = label;
	    }
	    return BreakStatement;
	}());
	exports.BreakStatement = BreakStatement;
	var CallExpression = (function () {
	    function CallExpression(callee, args) {
	        this.type = syntax_1.Syntax.CallExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return CallExpression;
	}());
	exports.CallExpression = CallExpression;
	var CatchClause = (function () {
	    function CatchClause(param, body) {
	        this.type = syntax_1.Syntax.CatchClause;
	        this.param = param;
	        this.body = body;
	    }
	    return CatchClause;
	}());
	exports.CatchClause = CatchClause;
	var ClassBody = (function () {
	    function ClassBody(body) {
	        this.type = syntax_1.Syntax.ClassBody;
	        this.body = body;
	    }
	    return ClassBody;
	}());
	exports.ClassBody = ClassBody;
	var ClassDeclaration = (function () {
	    function ClassDeclaration(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassDeclaration;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassDeclaration;
	}());
	exports.ClassDeclaration = ClassDeclaration;
	var ClassExpression = (function () {
	    function ClassExpression(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassExpression;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassExpression;
	}());
	exports.ClassExpression = ClassExpression;
	var ComputedMemberExpression = (function () {
	    function ComputedMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = true;
	        this.object = object;
	        this.property = property;
	    }
	    return ComputedMemberExpression;
	}());
	exports.ComputedMemberExpression = ComputedMemberExpression;
	var ConditionalExpression = (function () {
	    function ConditionalExpression(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.ConditionalExpression;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return ConditionalExpression;
	}());
	exports.ConditionalExpression = ConditionalExpression;
	var ContinueStatement = (function () {
	    function ContinueStatement(label) {
	        this.type = syntax_1.Syntax.ContinueStatement;
	        this.label = label;
	    }
	    return ContinueStatement;
	}());
	exports.ContinueStatement = ContinueStatement;
	var DebuggerStatement = (function () {
	    function DebuggerStatement() {
	        this.type = syntax_1.Syntax.DebuggerStatement;
	    }
	    return DebuggerStatement;
	}());
	exports.DebuggerStatement = DebuggerStatement;
	var Directive = (function () {
	    function Directive(expression, directive) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	        this.directive = directive;
	    }
	    return Directive;
	}());
	exports.Directive = Directive;
	var DoWhileStatement = (function () {
	    function DoWhileStatement(body, test) {
	        this.type = syntax_1.Syntax.DoWhileStatement;
	        this.body = body;
	        this.test = test;
	    }
	    return DoWhileStatement;
	}());
	exports.DoWhileStatement = DoWhileStatement;
	var EmptyStatement = (function () {
	    function EmptyStatement() {
	        this.type = syntax_1.Syntax.EmptyStatement;
	    }
	    return EmptyStatement;
	}());
	exports.EmptyStatement = EmptyStatement;
	var ExportAllDeclaration = (function () {
	    function ExportAllDeclaration(source) {
	        this.type = syntax_1.Syntax.ExportAllDeclaration;
	        this.source = source;
	    }
	    return ExportAllDeclaration;
	}());
	exports.ExportAllDeclaration = ExportAllDeclaration;
	var ExportDefaultDeclaration = (function () {
	    function ExportDefaultDeclaration(declaration) {
	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
	        this.declaration = declaration;
	    }
	    return ExportDefaultDeclaration;
	}());
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	var ExportNamedDeclaration = (function () {
	    function ExportNamedDeclaration(declaration, specifiers, source) {
	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
	        this.declaration = declaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ExportNamedDeclaration;
	}());
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	var ExportSpecifier = (function () {
	    function ExportSpecifier(local, exported) {
	        this.type = syntax_1.Syntax.ExportSpecifier;
	        this.exported = exported;
	        this.local = local;
	    }
	    return ExportSpecifier;
	}());
	exports.ExportSpecifier = ExportSpecifier;
	var ExpressionStatement = (function () {
	    function ExpressionStatement(expression) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	    }
	    return ExpressionStatement;
	}());
	exports.ExpressionStatement = ExpressionStatement;
	var ForInStatement = (function () {
	    function ForInStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForInStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	        this.each = false;
	    }
	    return ForInStatement;
	}());
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = (function () {
	    function ForOfStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForOfStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	    }
	    return ForOfStatement;
	}());
	exports.ForOfStatement = ForOfStatement;
	var ForStatement = (function () {
	    function ForStatement(init, test, update, body) {
	        this.type = syntax_1.Syntax.ForStatement;
	        this.init = init;
	        this.test = test;
	        this.update = update;
	        this.body = body;
	    }
	    return ForStatement;
	}());
	exports.ForStatement = ForStatement;
	var FunctionDeclaration = (function () {
	    function FunctionDeclaration(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionDeclaration;
	}());
	exports.FunctionDeclaration = FunctionDeclaration;
	var FunctionExpression = (function () {
	    function FunctionExpression(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionExpression;
	}());
	exports.FunctionExpression = FunctionExpression;
	var Identifier = (function () {
	    function Identifier(name) {
	        this.type = syntax_1.Syntax.Identifier;
	        this.name = name;
	    }
	    return Identifier;
	}());
	exports.Identifier = Identifier;
	var IfStatement = (function () {
	    function IfStatement(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.IfStatement;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return IfStatement;
	}());
	exports.IfStatement = IfStatement;
	var ImportDeclaration = (function () {
	    function ImportDeclaration(specifiers, source) {
	        this.type = syntax_1.Syntax.ImportDeclaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ImportDeclaration;
	}());
	exports.ImportDeclaration = ImportDeclaration;
	var ImportDefaultSpecifier = (function () {
	    function ImportDefaultSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
	        this.local = local;
	    }
	    return ImportDefaultSpecifier;
	}());
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	var ImportNamespaceSpecifier = (function () {
	    function ImportNamespaceSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
	        this.local = local;
	    }
	    return ImportNamespaceSpecifier;
	}());
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	var ImportSpecifier = (function () {
	    function ImportSpecifier(local, imported) {
	        this.type = syntax_1.Syntax.ImportSpecifier;
	        this.local = local;
	        this.imported = imported;
	    }
	    return ImportSpecifier;
	}());
	exports.ImportSpecifier = ImportSpecifier;
	var LabeledStatement = (function () {
	    function LabeledStatement(label, body) {
	        this.type = syntax_1.Syntax.LabeledStatement;
	        this.label = label;
	        this.body = body;
	    }
	    return LabeledStatement;
	}());
	exports.LabeledStatement = LabeledStatement;
	var Literal = (function () {
	    function Literal(value, raw) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	    }
	    return Literal;
	}());
	exports.Literal = Literal;
	var MetaProperty = (function () {
	    function MetaProperty(meta, property) {
	        this.type = syntax_1.Syntax.MetaProperty;
	        this.meta = meta;
	        this.property = property;
	    }
	    return MetaProperty;
	}());
	exports.MetaProperty = MetaProperty;
	var MethodDefinition = (function () {
	    function MethodDefinition(key, computed, value, kind, isStatic) {
	        this.type = syntax_1.Syntax.MethodDefinition;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.static = isStatic;
	    }
	    return MethodDefinition;
	}());
	exports.MethodDefinition = MethodDefinition;
	var Module = (function () {
	    function Module(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'module';
	    }
	    return Module;
	}());
	exports.Module = Module;
	var NewExpression = (function () {
	    function NewExpression(callee, args) {
	        this.type = syntax_1.Syntax.NewExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return NewExpression;
	}());
	exports.NewExpression = NewExpression;
	var ObjectExpression = (function () {
	    function ObjectExpression(properties) {
	        this.type = syntax_1.Syntax.ObjectExpression;
	        this.properties = properties;
	    }
	    return ObjectExpression;
	}());
	exports.ObjectExpression = ObjectExpression;
	var ObjectPattern = (function () {
	    function ObjectPattern(properties) {
	        this.type = syntax_1.Syntax.ObjectPattern;
	        this.properties = properties;
	    }
	    return ObjectPattern;
	}());
	exports.ObjectPattern = ObjectPattern;
	var Property = (function () {
	    function Property(kind, key, computed, value, method, shorthand) {
	        this.type = syntax_1.Syntax.Property;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.method = method;
	        this.shorthand = shorthand;
	    }
	    return Property;
	}());
	exports.Property = Property;
	var RegexLiteral = (function () {
	    function RegexLiteral(value, raw, pattern, flags) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	        this.regex = { pattern: pattern, flags: flags };
	    }
	    return RegexLiteral;
	}());
	exports.RegexLiteral = RegexLiteral;
	var RestElement = (function () {
	    function RestElement(argument) {
	        this.type = syntax_1.Syntax.RestElement;
	        this.argument = argument;
	    }
	    return RestElement;
	}());
	exports.RestElement = RestElement;
	var ReturnStatement = (function () {
	    function ReturnStatement(argument) {
	        this.type = syntax_1.Syntax.ReturnStatement;
	        this.argument = argument;
	    }
	    return ReturnStatement;
	}());
	exports.ReturnStatement = ReturnStatement;
	var Script = (function () {
	    function Script(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'script';
	    }
	    return Script;
	}());
	exports.Script = Script;
	var SequenceExpression = (function () {
	    function SequenceExpression(expressions) {
	        this.type = syntax_1.Syntax.SequenceExpression;
	        this.expressions = expressions;
	    }
	    return SequenceExpression;
	}());
	exports.SequenceExpression = SequenceExpression;
	var SpreadElement = (function () {
	    function SpreadElement(argument) {
	        this.type = syntax_1.Syntax.SpreadElement;
	        this.argument = argument;
	    }
	    return SpreadElement;
	}());
	exports.SpreadElement = SpreadElement;
	var StaticMemberExpression = (function () {
	    function StaticMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = false;
	        this.object = object;
	        this.property = property;
	    }
	    return StaticMemberExpression;
	}());
	exports.StaticMemberExpression = StaticMemberExpression;
	var Super = (function () {
	    function Super() {
	        this.type = syntax_1.Syntax.Super;
	    }
	    return Super;
	}());
	exports.Super = Super;
	var SwitchCase = (function () {
	    function SwitchCase(test, consequent) {
	        this.type = syntax_1.Syntax.SwitchCase;
	        this.test = test;
	        this.consequent = consequent;
	    }
	    return SwitchCase;
	}());
	exports.SwitchCase = SwitchCase;
	var SwitchStatement = (function () {
	    function SwitchStatement(discriminant, cases) {
	        this.type = syntax_1.Syntax.SwitchStatement;
	        this.discriminant = discriminant;
	        this.cases = cases;
	    }
	    return SwitchStatement;
	}());
	exports.SwitchStatement = SwitchStatement;
	var TaggedTemplateExpression = (function () {
	    function TaggedTemplateExpression(tag, quasi) {
	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
	        this.tag = tag;
	        this.quasi = quasi;
	    }
	    return TaggedTemplateExpression;
	}());
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	var TemplateElement = (function () {
	    function TemplateElement(value, tail) {
	        this.type = syntax_1.Syntax.TemplateElement;
	        this.value = value;
	        this.tail = tail;
	    }
	    return TemplateElement;
	}());
	exports.TemplateElement = TemplateElement;
	var TemplateLiteral = (function () {
	    function TemplateLiteral(quasis, expressions) {
	        this.type = syntax_1.Syntax.TemplateLiteral;
	        this.quasis = quasis;
	        this.expressions = expressions;
	    }
	    return TemplateLiteral;
	}());
	exports.TemplateLiteral = TemplateLiteral;
	var ThisExpression = (function () {
	    function ThisExpression() {
	        this.type = syntax_1.Syntax.ThisExpression;
	    }
	    return ThisExpression;
	}());
	exports.ThisExpression = ThisExpression;
	var ThrowStatement = (function () {
	    function ThrowStatement(argument) {
	        this.type = syntax_1.Syntax.ThrowStatement;
	        this.argument = argument;
	    }
	    return ThrowStatement;
	}());
	exports.ThrowStatement = ThrowStatement;
	var TryStatement = (function () {
	    function TryStatement(block, handler, finalizer) {
	        this.type = syntax_1.Syntax.TryStatement;
	        this.block = block;
	        this.handler = handler;
	        this.finalizer = finalizer;
	    }
	    return TryStatement;
	}());
	exports.TryStatement = TryStatement;
	var UnaryExpression = (function () {
	    function UnaryExpression(operator, argument) {
	        this.type = syntax_1.Syntax.UnaryExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = true;
	    }
	    return UnaryExpression;
	}());
	exports.UnaryExpression = UnaryExpression;
	var UpdateExpression = (function () {
	    function UpdateExpression(operator, argument, prefix) {
	        this.type = syntax_1.Syntax.UpdateExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = prefix;
	    }
	    return UpdateExpression;
	}());
	exports.UpdateExpression = UpdateExpression;
	var VariableDeclaration = (function () {
	    function VariableDeclaration(declarations, kind) {
	        this.type = syntax_1.Syntax.VariableDeclaration;
	        this.declarations = declarations;
	        this.kind = kind;
	    }
	    return VariableDeclaration;
	}());
	exports.VariableDeclaration = VariableDeclaration;
	var VariableDeclarator = (function () {
	    function VariableDeclarator(id, init) {
	        this.type = syntax_1.Syntax.VariableDeclarator;
	        this.id = id;
	        this.init = init;
	    }
	    return VariableDeclarator;
	}());
	exports.VariableDeclarator = VariableDeclarator;
	var WhileStatement = (function () {
	    function WhileStatement(test, body) {
	        this.type = syntax_1.Syntax.WhileStatement;
	        this.test = test;
	        this.body = body;
	    }
	    return WhileStatement;
	}());
	exports.WhileStatement = WhileStatement;
	var WithStatement = (function () {
	    function WithStatement(object, body) {
	        this.type = syntax_1.Syntax.WithStatement;
	        this.object = object;
	        this.body = body;
	    }
	    return WithStatement;
	}());
	exports.WithStatement = WithStatement;
	var YieldExpression = (function () {
	    function YieldExpression(argument, delegate) {
	        this.type = syntax_1.Syntax.YieldExpression;
	        this.argument = argument;
	        this.delegate = delegate;
	    }
	    return YieldExpression;
	}());
	exports.YieldExpression = YieldExpression;


/***/ },
/* 8 */
/***/ function(module, exports, __nested_webpack_require_80491__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __nested_webpack_require_80491__(9);
	var error_handler_1 = __nested_webpack_require_80491__(10);
	var messages_1 = __nested_webpack_require_80491__(11);
	var Node = __nested_webpack_require_80491__(7);
	var scanner_1 = __nested_webpack_require_80491__(12);
	var syntax_1 = __nested_webpack_require_80491__(2);
	var token_1 = __nested_webpack_require_80491__(13);
	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
	var Parser = (function () {
	    function Parser(code, options, delegate) {
	        if (options === void 0) { options = {}; }
	        this.config = {
	            range: (typeof options.range === 'boolean') && options.range,
	            loc: (typeof options.loc === 'boolean') && options.loc,
	            source: null,
	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
	            comment: (typeof options.comment === 'boolean') && options.comment,
	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
	        };
	        if (this.config.loc && options.source && options.source !== null) {
	            this.config.source = String(options.source);
	        }
	        this.delegate = delegate;
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = this.config.tolerant;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = this.config.comment;
	        this.operatorPrecedence = {
	            ')': 0,
	            ';': 0,
	            ',': 0,
	            '=': 0,
	            ']': 0,
	            '||': 1,
	            '&&': 2,
	            '|': 3,
	            '^': 4,
	            '&': 5,
	            '==': 6,
	            '!=': 6,
	            '===': 6,
	            '!==': 6,
	            '<': 7,
	            '>': 7,
	            '<=': 7,
	            '>=': 7,
	            '<<': 8,
	            '>>': 8,
	            '>>>': 8,
	            '+': 9,
	            '-': 9,
	            '*': 11,
	            '/': 11,
	            '%': 11
	        };
	        this.lookahead = {
	            type: 2 /* EOF */,
	            value: '',
	            lineNumber: this.scanner.lineNumber,
	            lineStart: 0,
	            start: 0,
	            end: 0
	        };
	        this.hasLineTerminator = false;
	        this.context = {
	            isModule: false,
	            await: false,
	            allowIn: true,
	            allowStrictDirective: true,
	            allowYield: true,
	            firstCoverInitializedNameError: null,
	            isAssignmentTarget: false,
	            isBindingElement: false,
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            labelSet: {},
	            strict: false
	        };
	        this.tokens = [];
	        this.startMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.lastMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.nextToken();
	        this.lastMarker = {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    }
	    Parser.prototype.throwError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.lastMarker.line;
	        var column = this.lastMarker.column + 1;
	        throw this.errorHandler.createError(index, line, column, msg);
	    };
	    Parser.prototype.tolerateError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.scanner.lineNumber;
	        var column = this.lastMarker.column + 1;
	        this.errorHandler.tolerateError(index, line, column, msg);
	    };
	    // Throw an exception because of the token.
	    Parser.prototype.unexpectedTokenError = function (token, message) {
	        var msg = message || messages_1.Messages.UnexpectedToken;
	        var value;
	        if (token) {
	            if (!message) {
	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
	                                    messages_1.Messages.UnexpectedToken;
	                if (token.type === 4 /* Keyword */) {
	                    if (this.scanner.isFutureReservedWord(token.value)) {
	                        msg = messages_1.Messages.UnexpectedReserved;
	                    }
	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
	                        msg = messages_1.Messages.StrictReservedWord;
	                    }
	                }
	            }
	            value = token.value;
	        }
	        else {
	            value = 'ILLEGAL';
	        }
	        msg = msg.replace('%0', value);
	        if (token && typeof token.lineNumber === 'number') {
	            var index = token.start;
	            var line = token.lineNumber;
	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
	            var column = token.start - lastMarkerLineStart + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	        else {
	            var index = this.lastMarker.index;
	            var line = this.lastMarker.line;
	            var column = this.lastMarker.column + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	    };
	    Parser.prototype.throwUnexpectedToken = function (token, message) {
	        throw this.unexpectedTokenError(token, message);
	    };
	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
	    };
	    Parser.prototype.collectComments = function () {
	        if (!this.config.comment) {
	            this.scanner.scanComments();
	        }
	        else {
	            var comments = this.scanner.scanComments();
	            if (comments.length > 0 && this.delegate) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var node = void 0;
	                    node = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
	                    };
	                    if (this.config.range) {
	                        node.range = e.range;
	                    }
	                    if (this.config.loc) {
	                        node.loc = e.loc;
	                    }
	                    var metadata = {
	                        start: {
	                            line: e.loc.start.line,
	                            column: e.loc.start.column,
	                            offset: e.range[0]
	                        },
	                        end: {
	                            line: e.loc.end.line,
	                            column: e.loc.end.column,
	                            offset: e.range[1]
	                        }
	                    };
	                    this.delegate(node, metadata);
	                }
	            }
	        }
	    };
	    // From internal representation to an external structure
	    Parser.prototype.getTokenRaw = function (token) {
	        return this.scanner.source.slice(token.start, token.end);
	    };
	    Parser.prototype.convertToken = function (token) {
	        var t = {
	            type: token_1.TokenName[token.type],
	            value: this.getTokenRaw(token)
	        };
	        if (this.config.range) {
	            t.range = [token.start, token.end];
	        }
	        if (this.config.loc) {
	            t.loc = {
	                start: {
	                    line: this.startMarker.line,
	                    column: this.startMarker.column
	                },
	                end: {
	                    line: this.scanner.lineNumber,
	                    column: this.scanner.index - this.scanner.lineStart
	                }
	            };
	        }
	        if (token.type === 9 /* RegularExpression */) {
	            var pattern = token.pattern;
	            var flags = token.flags;
	            t.regex = { pattern: pattern, flags: flags };
	        }
	        return t;
	    };
	    Parser.prototype.nextToken = function () {
	        var token = this.lookahead;
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        this.collectComments();
	        if (this.scanner.index !== this.startMarker.index) {
	            this.startMarker.index = this.scanner.index;
	            this.startMarker.line = this.scanner.lineNumber;
	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        }
	        var next = this.scanner.lex();
	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
	            if (this.scanner.isStrictModeReservedWord(next.value)) {
	                next.type = 4 /* Keyword */;
	            }
	        }
	        this.lookahead = next;
	        if (this.config.tokens && next.type !== 2 /* EOF */) {
	            this.tokens.push(this.convertToken(next));
	        }
	        return token;
	    };
	    Parser.prototype.nextRegexToken = function () {
	        this.collectComments();
	        var token = this.scanner.scanRegExp();
	        if (this.config.tokens) {
	            // Pop the previous token, '/' or '/='
	            // This is added from the lookahead token.
	            this.tokens.pop();
	            this.tokens.push(this.convertToken(token));
	        }
	        // Prime the next lookahead.
	        this.lookahead = token;
	        this.nextToken();
	        return token;
	    };
	    Parser.prototype.createNode = function () {
	        return {
	            index: this.startMarker.index,
	            line: this.startMarker.line,
	            column: this.startMarker.column
	        };
	    };
	    Parser.prototype.startNode = function (token, lastLineStart) {
	        if (lastLineStart === void 0) { lastLineStart = 0; }
	        var column = token.start - token.lineStart;
	        var line = token.lineNumber;
	        if (column < 0) {
	            column += lastLineStart;
	            line--;
	        }
	        return {
	            index: token.start,
	            line: line,
	            column: column
	        };
	    };
	    Parser.prototype.finalize = function (marker, node) {
	        if (this.config.range) {
	            node.range = [marker.index, this.lastMarker.index];
	        }
	        if (this.config.loc) {
	            node.loc = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column
	                }
	            };
	            if (this.config.source) {
	                node.loc.source = this.config.source;
	            }
	        }
	        if (this.delegate) {
	            var metadata = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                    offset: marker.index
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column,
	                    offset: this.lastMarker.index
	                }
	            };
	            this.delegate(node, metadata);
	        }
	        return node;
	    };
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    Parser.prototype.expect = function (value) {
	        var token = this.nextToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
	    Parser.prototype.expectCommaSeparator = function () {
	        if (this.config.tolerant) {
	            var token = this.lookahead;
	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
	                this.nextToken();
	            }
	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
	                this.nextToken();
	                this.tolerateUnexpectedToken(token);
	            }
	            else {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
	            }
	        }
	        else {
	            this.expect(',');
	        }
	    };
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	    Parser.prototype.expectKeyword = function (keyword) {
	        var token = this.nextToken();
	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next token matches the specified punctuator.
	    Parser.prototype.match = function (value) {
	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
	    };
	    // Return true if the next token matches the specified keyword
	    Parser.prototype.matchKeyword = function (keyword) {
	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	    Parser.prototype.matchContextualKeyword = function (keyword) {
	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token is an assignment operator
	    Parser.prototype.matchAssign = function () {
	        if (this.lookahead.type !== 7 /* Punctuator */) {
	            return false;
	        }
	        var op = this.lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '**=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    };
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        if (this.context.firstCoverInitializedNameError !== null) {
	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
	        }
	        this.context.isBindingElement = previousIsBindingElement;
	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.consumeSemicolon = function () {
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else if (!this.hasLineTerminator) {
	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.lastMarker.index = this.startMarker.index;
	            this.lastMarker.line = this.startMarker.line;
	            this.lastMarker.column = this.startMarker.column;
	        }
	    };
	    // https://tc39.github.io/ecma262/#sec-primary-expression
	    Parser.prototype.parsePrimaryExpression = function () {
	        var node = this.createNode();
	        var expr;
	        var token, raw;
	        switch (this.lookahead.type) {
	            case 3 /* Identifier */:
	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
	                    this.tolerateUnexpectedToken(this.lookahead);
	                }
	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
	                break;
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	                if (this.context.strict && this.lookahead.octal) {
	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
	                }
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 1 /* BooleanLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
	                break;
	            case 5 /* NullLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(null, raw));
	                break;
	            case 10 /* Template */:
	                expr = this.parseTemplateLiteral();
	                break;
	            case 7 /* Punctuator */:
	                switch (this.lookahead.value) {
	                    case '(':
	                        this.context.isBindingElement = false;
	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
	                        break;
	                    case '[':
	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
	                        break;
	                    case '{':
	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
	                        break;
	                    case '/':
	                    case '/=':
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                        this.scanner.index = this.startMarker.index;
	                        token = this.nextRegexToken();
	                        raw = this.getTokenRaw(token);
	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
	                        break;
	                    default:
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                }
	                break;
	            case 4 /* Keyword */:
	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
	                    expr = this.parseIdentifierName();
	                }
	                else if (!this.context.strict && this.matchKeyword('let')) {
	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
	                }
	                else {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    if (this.matchKeyword('function')) {
	                        expr = this.parseFunctionExpression();
	                    }
	                    else if (this.matchKeyword('this')) {
	                        this.nextToken();
	                        expr = this.finalize(node, new Node.ThisExpression());
	                    }
	                    else if (this.matchKeyword('class')) {
	                        expr = this.parseClassExpression();
	                    }
	                    else {
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                    }
	                }
	                break;
	            default:
	                expr = this.throwUnexpectedToken(this.nextToken());
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-array-initializer
	    Parser.prototype.parseSpreadElement = function () {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
	        return this.finalize(node, new Node.SpreadElement(arg));
	    };
	    Parser.prototype.parseArrayInitializer = function () {
	        var node = this.createNode();
	        var elements = [];
	        this.expect('[');
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else if (this.match('...')) {
	                var element = this.parseSpreadElement();
	                if (!this.match(']')) {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    this.expect(',');
	                }
	                elements.push(element);
	            }
	            else {
	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayExpression(elements));
	    };
	    // https://tc39.github.io/ecma262/#sec-object-initializer
	    Parser.prototype.parsePropertyMethod = function (params) {
	        this.context.isAssignmentTarget = false;
	        this.context.isBindingElement = false;
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = params.simple;
	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
	        if (this.context.strict && params.firstRestricted) {
	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
	        }
	        if (this.context.strict && params.stricted) {
	            this.tolerateUnexpectedToken(params.stricted, params.message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        return body;
	    };
	    Parser.prototype.parsePropertyMethodFunction = function () {
	        var isGenerator = false;
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        var previousAwait = this.context.await;
	        this.context.allowYield = false;
	        this.context.await = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        this.context.await = previousAwait;
	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
	    };
	    Parser.prototype.parseObjectPropertyKey = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        var key;
	        switch (token.type) {
	            case 8 /* StringLiteral */:
	            case 6 /* NumericLiteral */:
	                if (this.context.strict && token.octal) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
	                }
	                var raw = this.getTokenRaw(token);
	                key = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 3 /* Identifier */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 4 /* Keyword */:
	                key = this.finalize(node, new Node.Identifier(token.value));
	                break;
	            case 7 /* Punctuator */:
	                if (token.value === '[') {
	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    this.expect(']');
	                }
	                else {
	                    key = this.throwUnexpectedToken(token);
	                }
	                break;
	            default:
	                key = this.throwUnexpectedToken(token);
	        }
	        return key;
	    };
	    Parser.prototype.isPropertyKey = function (key, value) {
	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
	            (key.type === syntax_1.Syntax.Literal && key.value === value);
	    };
	    Parser.prototype.parseObjectProperty = function (hasProto) {
	        var node = this.createNode();
	        var token = this.lookahead;
	        var kind;
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var shorthand = false;
	        var isAsync = false;
	        if (token.type === 3 /* Identifier */) {
	            var id = token.value;
	            this.nextToken();
	            computed = this.match('[');
	            isAsync = !this.hasLineTerminator && (id === 'async') &&
	                !this.match(':') && !this.match('(') && !this.match('*') && !this.match(',');
	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
	        }
	        else if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
	            kind = 'get';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.context.allowYield = false;
	            value = this.parseGetterMethod();
	        }
	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
	            kind = 'set';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseSetterMethod();
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        else {
	            if (!key) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            kind = 'init';
	            if (this.match(':') && !isAsync) {
	                if (!computed && this.isPropertyKey(key, '__proto__')) {
	                    if (hasProto.value) {
	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
	                    }
	                    hasProto.value = true;
	                }
	                this.nextToken();
	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
	            }
	            else if (this.match('(')) {
	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	                method = true;
	            }
	            else if (token.type === 3 /* Identifier */) {
	                var id = this.finalize(node, new Node.Identifier(token.value));
	                if (this.match('=')) {
	                    this.context.firstCoverInitializedNameError = this.lookahead;
	                    this.nextToken();
	                    shorthand = true;
	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
	                }
	                else {
	                    shorthand = true;
	                    value = id;
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectInitializer = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var properties = [];
	        var hasProto = { value: false };
	        while (!this.match('}')) {
	            properties.push(this.parseObjectProperty(hasProto));
	            if (!this.match('}')) {
	                this.expectCommaSeparator();
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectExpression(properties));
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literals
	    Parser.prototype.parseTemplateHead = function () {
	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateElement = function () {
	        if (this.lookahead.type !== 10 /* Template */) {
	            this.throwUnexpectedToken();
	        }
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateLiteral = function () {
	        var node = this.createNode();
	        var expressions = [];
	        var quasis = [];
	        var quasi = this.parseTemplateHead();
	        quasis.push(quasi);
	        while (!quasi.tail) {
	            expressions.push(this.parseExpression());
	            quasi = this.parseTemplateElement();
	            quasis.push(quasi);
	        }
	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
	    };
	    // https://tc39.github.io/ecma262/#sec-grouping-operator
	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	            case syntax_1.Syntax.MemberExpression:
	            case syntax_1.Syntax.RestElement:
	            case syntax_1.Syntax.AssignmentPattern:
	                break;
	            case syntax_1.Syntax.SpreadElement:
	                expr.type = syntax_1.Syntax.RestElement;
	                this.reinterpretExpressionAsPattern(expr.argument);
	                break;
	            case syntax_1.Syntax.ArrayExpression:
	                expr.type = syntax_1.Syntax.ArrayPattern;
	                for (var i = 0; i < expr.elements.length; i++) {
	                    if (expr.elements[i] !== null) {
	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectExpression:
	                expr.type = syntax_1.Syntax.ObjectPattern;
	                for (var i = 0; i < expr.properties.length; i++) {
	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
	                }
	                break;
	            case syntax_1.Syntax.AssignmentExpression:
	                expr.type = syntax_1.Syntax.AssignmentPattern;
	                delete expr.operator;
	                this.reinterpretExpressionAsPattern(expr.left);
	                break;
	            default:
	                // Allow other node type for tolerant parsing.
	                break;
	        }
	    };
	    Parser.prototype.parseGroupExpression = function () {
	        var expr;
	        this.expect('(');
	        if (this.match(')')) {
	            this.nextToken();
	            if (!this.match('=>')) {
	                this.expect('=>');
	            }
	            expr = {
	                type: ArrowParameterPlaceHolder,
	                params: [],
	                async: false
	            };
	        }
	        else {
	            var startToken = this.lookahead;
	            var params = [];
	            if (this.match('...')) {
	                expr = this.parseRestElement(params);
	                this.expect(')');
	                if (!this.match('=>')) {
	                    this.expect('=>');
	                }
	                expr = {
	                    type: ArrowParameterPlaceHolder,
	                    params: [expr],
	                    async: false
	                };
	            }
	            else {
	                var arrow = false;
	                this.context.isBindingElement = true;
	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                if (this.match(',')) {
	                    var expressions = [];
	                    this.context.isAssignmentTarget = false;
	                    expressions.push(expr);
	                    while (this.lookahead.type !== 2 /* EOF */) {
	                        if (!this.match(',')) {
	                            break;
	                        }
	                        this.nextToken();
	                        if (this.match(')')) {
	                            this.nextToken();
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else if (this.match('...')) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            expressions.push(this.parseRestElement(params));
	                            this.expect(')');
	                            if (!this.match('=>')) {
	                                this.expect('=>');
	                            }
	                            this.context.isBindingElement = false;
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else {
	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        if (arrow) {
	                            break;
	                        }
	                    }
	                    if (!arrow) {
	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	                    }
	                }
	                if (!arrow) {
	                    this.expect(')');
	                    if (this.match('=>')) {
	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: [expr],
	                                async: false
	                            };
	                        }
	                        if (!arrow) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
	                                for (var i = 0; i < expr.expressions.length; i++) {
	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
	                                }
	                            }
	                            else {
	                                this.reinterpretExpressionAsPattern(expr);
	                            }
	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: parameters,
	                                async: false
	                            };
	                        }
	                    }
	                    this.context.isBindingElement = false;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
	    Parser.prototype.parseArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.isIdentifierName = function (token) {
	        return token.type === 3 /* Identifier */ ||
	            token.type === 4 /* Keyword */ ||
	            token.type === 1 /* BooleanLiteral */ ||
	            token.type === 5 /* NullLiteral */;
	    };
	    Parser.prototype.parseIdentifierName = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (!this.isIdentifierName(token)) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseNewExpression = function () {
	        var node = this.createNode();
	        var id = this.parseIdentifierName();
	        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
	        var expr;
	        if (this.match('.')) {
	            this.nextToken();
	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
	                var property = this.parseIdentifierName();
	                expr = new Node.MetaProperty(id, property);
	            }
	            else {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
	            var args = this.match('(') ? this.parseArguments() : [];
	            expr = new Node.NewExpression(callee, args);
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return this.finalize(node, expr);
	    };
	    Parser.prototype.parseAsyncArgument = function () {
	        var arg = this.parseAssignmentExpression();
	        this.context.firstCoverInitializedNameError = null;
	        return arg;
	    };
	    Parser.prototype.parseAsyncArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAsyncArgument);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
	        var startToken = this.lookahead;
	        var maybeAsync = this.matchContextualKeyword('async');
	        var previousAllowIn = this.context.allowIn;
	        this.context.allowIn = true;
	        var expr;
	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
	            expr = this.createNode();
	            this.nextToken();
	            expr = this.finalize(expr, new Node.Super());
	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        }
	        while (true) {
	            if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.match('(')) {
	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = false;
	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
	                if (asyncArrow && this.match('=>')) {
	                    for (var i = 0; i < args.length; ++i) {
	                        this.reinterpretExpressionAsPattern(args[i]);
	                    }
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: args,
	                        async: true
	                    };
	                }
	            }
	            else if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        this.context.allowIn = previousAllowIn;
	        return expr;
	    };
	    Parser.prototype.parseSuper = function () {
	        var node = this.createNode();
	        this.expectKeyword('super');
	        if (!this.match('[') && !this.match('.')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        return this.finalize(node, new Node.Super());
	    };
	    Parser.prototype.parseLeftHandSideExpression = function () {
	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
	        var node = this.startNode(this.lookahead);
	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        while (true) {
	            if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-update-expressions
	    Parser.prototype.parseUpdateExpression = function () {
	        var expr;
	        var startToken = this.lookahead;
	        if (this.match('++') || this.match('--')) {
	            var node = this.startNode(startToken);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
	            }
	            if (!this.context.isAssignmentTarget) {
	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	            }
	            var prefix = true;
	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
	                if (this.match('++') || this.match('--')) {
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
	                    }
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    var operator = this.nextToken().value;
	                    var prefix = false;
	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-unary-operators
	    Parser.prototype.parseAwaitExpression = function () {
	        var node = this.createNode();
	        this.nextToken();
	        var argument = this.parseUnaryExpression();
	        return this.finalize(node, new Node.AwaitExpression(argument));
	    };
	    Parser.prototype.parseUnaryExpression = function () {
	        var expr;
	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
	            var node = this.startNode(this.lookahead);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
	                this.tolerateError(messages_1.Messages.StrictDelete);
	            }
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else if (this.context.await && this.matchContextualKeyword('await')) {
	            expr = this.parseAwaitExpression();
	        }
	        else {
	            expr = this.parseUpdateExpression();
	        }
	        return expr;
	    };
	    Parser.prototype.parseExponentiationExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-exp-operator
	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
	    // https://tc39.github.io/ecma262/#sec-additive-operators
	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
	    // https://tc39.github.io/ecma262/#sec-relational-operators
	    // https://tc39.github.io/ecma262/#sec-equality-operators
	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
	    Parser.prototype.binaryPrecedence = function (token) {
	        var op = token.value;
	        var precedence;
	        if (token.type === 7 /* Punctuator */) {
	            precedence = this.operatorPrecedence[op] || 0;
	        }
	        else if (token.type === 4 /* Keyword */) {
	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
	        }
	        else {
	            precedence = 0;
	        }
	        return precedence;
	    };
	    Parser.prototype.parseBinaryExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
	        var token = this.lookahead;
	        var prec = this.binaryPrecedence(token);
	        if (prec > 0) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var markers = [startToken, this.lookahead];
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            var stack = [left, token.value, right];
	            var precedences = [prec];
	            while (true) {
	                prec = this.binaryPrecedence(this.lookahead);
	                if (prec <= 0) {
	                    break;
	                }
	                // Reduce: make a binary expression from the three topmost entries.
	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
	                    right = stack.pop();
	                    var operator = stack.pop();
	                    precedences.pop();
	                    left = stack.pop();
	                    markers.pop();
	                    var node = this.startNode(markers[markers.length - 1]);
	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
	                }
	                // Shift.
	                stack.push(this.nextToken().value);
	                precedences.push(prec);
	                markers.push(this.lookahead);
	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
	            }
	            // Final reduce to clean-up the stack.
	            var i = stack.length - 1;
	            expr = stack[i];
	            var lastMarker = markers.pop();
	            while (i > 1) {
	                var marker = markers.pop();
	                var lastLineStart = lastMarker && lastMarker.lineStart;
	                var node = this.startNode(marker, lastLineStart);
	                var operator = stack[i - 1];
	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
	                i -= 2;
	                lastMarker = marker;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-conditional-operator
	    Parser.prototype.parseConditionalExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
	        if (this.match('?')) {
	            this.nextToken();
	            var previousAllowIn = this.context.allowIn;
	            this.context.allowIn = true;
	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowIn = previousAllowIn;
	            this.expect(':');
	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-assignment-operators
	    Parser.prototype.checkPatternParam = function (options, param) {
	        switch (param.type) {
	            case syntax_1.Syntax.Identifier:
	                this.validateParam(options, param, param.name);
	                break;
	            case syntax_1.Syntax.RestElement:
	                this.checkPatternParam(options, param.argument);
	                break;
	            case syntax_1.Syntax.AssignmentPattern:
	                this.checkPatternParam(options, param.left);
	                break;
	            case syntax_1.Syntax.ArrayPattern:
	                for (var i = 0; i < param.elements.length; i++) {
	                    if (param.elements[i] !== null) {
	                        this.checkPatternParam(options, param.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectPattern:
	                for (var i = 0; i < param.properties.length; i++) {
	                    this.checkPatternParam(options, param.properties[i].value);
	                }
	                break;
	            default:
	                break;
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	    };
	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
	        var params = [expr];
	        var options;
	        var asyncArrow = false;
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	                break;
	            case ArrowParameterPlaceHolder:
	                params = expr.params;
	                asyncArrow = expr.async;
	                break;
	            default:
	                return null;
	        }
	        options = {
	            simple: true,
	            paramSet: {}
	        };
	        for (var i = 0; i < params.length; ++i) {
	            var param = params[i];
	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                    param.right.type = syntax_1.Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	            }
	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.checkPatternParam(options, param);
	            params[i] = param;
	        }
	        if (this.context.strict || !this.context.allowYield) {
	            for (var i = 0; i < params.length; ++i) {
	                var param = params[i];
	                if (param.type === syntax_1.Syntax.YieldExpression) {
	                    this.throwUnexpectedToken(this.lookahead);
	                }
	            }
	        }
	        if (options.message === messages_1.Messages.StrictParamDupe) {
	            var token = this.context.strict ? options.stricted : options.firstRestricted;
	            this.throwUnexpectedToken(token, options.message);
	        }
	        return {
	            simple: options.simple,
	            params: params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.parseAssignmentExpression = function () {
	        var expr;
	        if (!this.context.allowYield && this.matchKeyword('yield')) {
	            expr = this.parseYieldExpression();
	        }
	        else {
	            var startToken = this.lookahead;
	            var token = startToken;
	            expr = this.parseConditionalExpression();
	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
	                    var arg = this.parsePrimaryExpression();
	                    this.reinterpretExpressionAsPattern(arg);
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: [arg],
	                        async: true
	                    };
	                }
	            }
	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                var isAsync = expr.async;
	                var list = this.reinterpretAsCoverFormalsList(expr);
	                if (list) {
	                    if (this.hasLineTerminator) {
	                        this.tolerateUnexpectedToken(this.lookahead);
	                    }
	                    this.context.firstCoverInitializedNameError = null;
	                    var previousStrict = this.context.strict;
	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
	                    this.context.allowStrictDirective = list.simple;
	                    var previousAllowYield = this.context.allowYield;
	                    var previousAwait = this.context.await;
	                    this.context.allowYield = true;
	                    this.context.await = isAsync;
	                    var node = this.startNode(startToken);
	                    this.expect('=>');
	                    var body = void 0;
	                    if (this.match('{')) {
	                        var previousAllowIn = this.context.allowIn;
	                        this.context.allowIn = true;
	                        body = this.parseFunctionSourceElements();
	                        this.context.allowIn = previousAllowIn;
	                    }
	                    else {
	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    }
	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
	                    if (this.context.strict && list.firstRestricted) {
	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
	                    }
	                    if (this.context.strict && list.stricted) {
	                        this.tolerateUnexpectedToken(list.stricted, list.message);
	                    }
	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
	                    this.context.strict = previousStrict;
	                    this.context.allowStrictDirective = previousAllowStrictDirective;
	                    this.context.allowYield = previousAllowYield;
	                    this.context.await = previousAwait;
	                }
	            }
	            else {
	                if (this.matchAssign()) {
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
	                        var id = expr;
	                        if (this.scanner.isRestrictedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
	                        }
	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	                        }
	                    }
	                    if (!this.match('=')) {
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                    }
	                    else {
	                        this.reinterpretExpressionAsPattern(expr);
	                    }
	                    token = this.nextToken();
	                    var operator = token.value;
	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
	                    this.context.firstCoverInitializedNameError = null;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-comma-operator
	    Parser.prototype.parseExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        if (this.match(',')) {
	            var expressions = [];
	            expressions.push(expr);
	            while (this.lookahead.type !== 2 /* EOF */) {
	                if (!this.match(',')) {
	                    break;
	                }
	                this.nextToken();
	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	            }
	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-block
	    Parser.prototype.parseStatementListItem = function () {
	        var statement;
	        this.context.isAssignmentTarget = true;
	        this.context.isBindingElement = true;
	        if (this.lookahead.type === 4 /* Keyword */) {
	            switch (this.lookahead.value) {
	                case 'export':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
	                    }
	                    statement = this.parseExportDeclaration();
	                    break;
	                case 'import':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
	                    }
	                    statement = this.parseImportDeclaration();
	                    break;
	                case 'const':
	                    statement = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'function':
	                    statement = this.parseFunctionDeclaration();
	                    break;
	                case 'class':
	                    statement = this.parseClassDeclaration();
	                    break;
	                case 'let':
	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
	                    break;
	                default:
	                    statement = this.parseStatement();
	                    break;
	            }
	        }
	        else {
	            statement = this.parseStatement();
	        }
	        return statement;
	    };
	    Parser.prototype.parseBlock = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var block = [];
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            block.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.BlockStatement(block));
	    };
	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
	    Parser.prototype.parseLexicalBinding = function (kind, options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, kind);
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (kind === 'const') {
	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
	                if (this.match('=')) {
	                    this.nextToken();
	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                }
	                else {
	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
	                }
	            }
	        }
	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
	            this.expect('=');
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseBindingList = function (kind, options) {
	        var list = [this.parseLexicalBinding(kind, options)];
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseLexicalBinding(kind, options));
	        }
	        return list;
	    };
	    Parser.prototype.isLexicalDeclaration = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.scanner.lex();
	        this.scanner.restoreState(state);
	        return (next.type === 3 /* Identifier */) ||
	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
	            (next.type === 4 /* Keyword */ && next.value === 'yield');
	    };
	    Parser.prototype.parseLexicalDeclaration = function (options) {
	        var node = this.createNode();
	        var kind = this.nextToken().value;
	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	        var declarations = this.parseBindingList(kind, options);
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
	    };
	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
	    Parser.prototype.parseBindingRestElement = function (params, kind) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params, kind);
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseArrayPattern = function (params, kind) {
	        var node = this.createNode();
	        this.expect('[');
	        var elements = [];
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else {
	                if (this.match('...')) {
	                    elements.push(this.parseBindingRestElement(params, kind));
	                    break;
	                }
	                else {
	                    elements.push(this.parsePatternWithDefault(params, kind));
	                }
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayPattern(elements));
	    };
	    Parser.prototype.parsePropertyPattern = function (params, kind) {
	        var node = this.createNode();
	        var computed = false;
	        var shorthand = false;
	        var method = false;
	        var key;
	        var value;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            var keyToken = this.lookahead;
	            key = this.parseVariableIdentifier();
	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
	            if (this.match('=')) {
	                params.push(keyToken);
	                shorthand = true;
	                this.nextToken();
	                var expr = this.parseAssignmentExpression();
	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
	            }
	            else if (!this.match(':')) {
	                params.push(keyToken);
	                shorthand = true;
	                value = init;
	            }
	            else {
	                this.expect(':');
	                value = this.parsePatternWithDefault(params, kind);
	            }
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.expect(':');
	            value = this.parsePatternWithDefault(params, kind);
	        }
	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectPattern = function (params, kind) {
	        var node = this.createNode();
	        var properties = [];
	        this.expect('{');
	        while (!this.match('}')) {
	            properties.push(this.parsePropertyPattern(params, kind));
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectPattern(properties));
	    };
	    Parser.prototype.parsePattern = function (params, kind) {
	        var pattern;
	        if (this.match('[')) {
	            pattern = this.parseArrayPattern(params, kind);
	        }
	        else if (this.match('{')) {
	            pattern = this.parseObjectPattern(params, kind);
	        }
	        else {
	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
	            }
	            params.push(this.lookahead);
	            pattern = this.parseVariableIdentifier(kind);
	        }
	        return pattern;
	    };
	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
	        var startToken = this.lookahead;
	        var pattern = this.parsePattern(params, kind);
	        if (this.match('=')) {
	            this.nextToken();
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = true;
	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowYield = previousAllowYield;
	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
	        }
	        return pattern;
	    };
	    // https://tc39.github.io/ecma262/#sec-variable-statement
	    Parser.prototype.parseVariableIdentifier = function (kind) {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
	            if (this.context.strict) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else if (!this.context.allowYield) {
	                this.throwUnexpectedToken(token);
	            }
	        }
	        else if (token.type !== 3 /* Identifier */) {
	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else {
	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
	                    this.throwUnexpectedToken(token);
	                }
	            }
	        }
	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
	            this.tolerateUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseVariableDeclaration = function (options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, 'var');
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (this.match('=')) {
	            this.nextToken();
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
	            this.expect('=');
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseVariableDeclarationList = function (options) {
	        var opt = { inFor: options.inFor };
	        var list = [];
	        list.push(this.parseVariableDeclaration(opt));
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseVariableDeclaration(opt));
	        }
	        return list;
	    };
	    Parser.prototype.parseVariableStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('var');
	        var declarations = this.parseVariableDeclarationList({ inFor: false });
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
	    };
	    // https://tc39.github.io/ecma262/#sec-empty-statement
	    Parser.prototype.parseEmptyStatement = function () {
	        var node = this.createNode();
	        this.expect(';');
	        return this.finalize(node, new Node.EmptyStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-expression-statement
	    Parser.prototype.parseExpressionStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ExpressionStatement(expr));
	    };
	    // https://tc39.github.io/ecma262/#sec-if-statement
	    Parser.prototype.parseIfClause = function () {
	        if (this.context.strict && this.matchKeyword('function')) {
	            this.tolerateError(messages_1.Messages.StrictFunction);
	        }
	        return this.parseStatement();
	    };
	    Parser.prototype.parseIfStatement = function () {
	        var node = this.createNode();
	        var consequent;
	        var alternate = null;
	        this.expectKeyword('if');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            consequent = this.parseIfClause();
	            if (this.matchKeyword('else')) {
	                this.nextToken();
	                alternate = this.parseIfClause();
	            }
	        }
	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
	    };
	    // https://tc39.github.io/ecma262/#sec-do-while-statement
	    Parser.prototype.parseDoWhileStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('do');
	        var previousInIteration = this.context.inIteration;
	        this.context.inIteration = true;
	        var body = this.parseStatement();
	        this.context.inIteration = previousInIteration;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	        }
	        else {
	            this.expect(')');
	            if (this.match(';')) {
	                this.nextToken();
	            }
	        }
	        return this.finalize(node, new Node.DoWhileStatement(body, test));
	    };
	    // https://tc39.github.io/ecma262/#sec-while-statement
	    Parser.prototype.parseWhileStatement = function () {
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.parseStatement();
	            this.context.inIteration = previousInIteration;
	        }
	        return this.finalize(node, new Node.WhileStatement(test, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-for-statement
	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
	    Parser.prototype.parseForStatement = function () {
	        var init = null;
	        var test = null;
	        var update = null;
	        var forIn = true;
	        var left, right;
	        var node = this.createNode();
	        this.expectKeyword('for');
	        this.expect('(');
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else {
	            if (this.matchKeyword('var')) {
	                init = this.createNode();
	                this.nextToken();
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                var declarations = this.parseVariableDeclarationList({ inFor: true });
	                this.context.allowIn = previousAllowIn;
	                if (declarations.length === 1 && this.matchKeyword('in')) {
	                    var decl = declarations[0];
	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
	                    }
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.expect(';');
	                }
	            }
	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
	                init = this.createNode();
	                var kind = this.nextToken().value;
	                if (!this.context.strict && this.lookahead.value === 'in') {
	                    init = this.finalize(init, new Node.Identifier(kind));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else {
	                    var previousAllowIn = this.context.allowIn;
	                    this.context.allowIn = false;
	                    var declarations = this.parseBindingList(kind, { inFor: true });
	                    this.context.allowIn = previousAllowIn;
	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseExpression();
	                        init = null;
	                    }
	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    }
	                    else {
	                        this.consumeSemicolon();
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                    }
	                }
	            }
	            else {
	                var initStartToken = this.lookahead;
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                this.context.allowIn = previousAllowIn;
	                if (this.matchKeyword('in')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (this.matchContextualKeyword('of')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    if (this.match(',')) {
	                        var initSeq = [init];
	                        while (this.match(',')) {
	                            this.nextToken();
	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
	                    }
	                    this.expect(';');
	                }
	            }
	        }
	        if (typeof left === 'undefined') {
	            if (!this.match(';')) {
	                test = this.parseExpression();
	            }
	            this.expect(';');
	            if (!this.match(')')) {
	                update = this.parseExpression();
	            }
	        }
	        var body;
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.isolateCoverGrammar(this.parseStatement);
	            this.context.inIteration = previousInIteration;
	        }
	        return (typeof left === 'undefined') ?
	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
	                this.finalize(node, new Node.ForOfStatement(left, right, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-continue-statement
	    Parser.prototype.parseContinueStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('continue');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            label = id;
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration) {
	            this.throwError(messages_1.Messages.IllegalContinue);
	        }
	        return this.finalize(node, new Node.ContinueStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-break-statement
	    Parser.prototype.parseBreakStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('break');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	            label = id;
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
	            this.throwError(messages_1.Messages.IllegalBreak);
	        }
	        return this.finalize(node, new Node.BreakStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-return-statement
	    Parser.prototype.parseReturnStatement = function () {
	        if (!this.context.inFunctionBody) {
	            this.tolerateError(messages_1.Messages.IllegalReturn);
	        }
	        var node = this.createNode();
	        this.expectKeyword('return');
	        var hasArgument = (!this.match(';') && !this.match('}') &&
	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */) ||
	            this.lookahead.type === 8 /* StringLiteral */ ||
	            this.lookahead.type === 10 /* Template */;
	        var argument = hasArgument ? this.parseExpression() : null;
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ReturnStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-with-statement
	    Parser.prototype.parseWithStatement = function () {
	        if (this.context.strict) {
	            this.tolerateError(messages_1.Messages.StrictModeWith);
	        }
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('with');
	        this.expect('(');
	        var object = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            body = this.parseStatement();
	        }
	        return this.finalize(node, new Node.WithStatement(object, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-switch-statement
	    Parser.prototype.parseSwitchCase = function () {
	        var node = this.createNode();
	        var test;
	        if (this.matchKeyword('default')) {
	            this.nextToken();
	            test = null;
	        }
	        else {
	            this.expectKeyword('case');
	            test = this.parseExpression();
	        }
	        this.expect(':');
	        var consequent = [];
	        while (true) {
	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
	                break;
	            }
	            consequent.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.SwitchCase(test, consequent));
	    };
	    Parser.prototype.parseSwitchStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('switch');
	        this.expect('(');
	        var discriminant = this.parseExpression();
	        this.expect(')');
	        var previousInSwitch = this.context.inSwitch;
	        this.context.inSwitch = true;
	        var cases = [];
	        var defaultFound = false;
	        this.expect('{');
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            var clause = this.parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	        this.expect('}');
	        this.context.inSwitch = previousInSwitch;
	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
	    };
	    // https://tc39.github.io/ecma262/#sec-labelled-statements
	    Parser.prototype.parseLabelledStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var statement;
	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
	            this.nextToken();
	            var id = expr;
	            var key = '$' + id.name;
	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
	            }
	            this.context.labelSet[key] = true;
	            var body = void 0;
	            if (this.matchKeyword('class')) {
	                this.tolerateUnexpectedToken(this.lookahead);
	                body = this.parseClassDeclaration();
	            }
	            else if (this.matchKeyword('function')) {
	                var token = this.lookahead;
	                var declaration = this.parseFunctionDeclaration();
	                if (this.context.strict) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
	                }
	                else if (declaration.generator) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
	                }
	                body = declaration;
	            }
	            else {
	                body = this.parseStatement();
	            }
	            delete this.context.labelSet[key];
	            statement = new Node.LabeledStatement(id, body);
	        }
	        else {
	            this.consumeSemicolon();
	            statement = new Node.ExpressionStatement(expr);
	        }
	        return this.finalize(node, statement);
	    };
	    // https://tc39.github.io/ecma262/#sec-throw-statement
	    Parser.prototype.parseThrowStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('throw');
	        if (this.hasLineTerminator) {
	            this.throwError(messages_1.Messages.NewlineAfterThrow);
	        }
	        var argument = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ThrowStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-try-statement
	    Parser.prototype.parseCatchClause = function () {
	        var node = this.createNode();
	        this.expectKeyword('catch');
	        this.expect('(');
	        if (this.match(')')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        var params = [];
	        var param = this.parsePattern(params);
	        var paramMap = {};
	        for (var i = 0; i < params.length; i++) {
	            var key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(param.name)) {
	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
	            }
	        }
	        this.expect(')');
	        var body = this.parseBlock();
	        return this.finalize(node, new Node.CatchClause(param, body));
	    };
	    Parser.prototype.parseFinallyClause = function () {
	        this.expectKeyword('finally');
	        return this.parseBlock();
	    };
	    Parser.prototype.parseTryStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('try');
	        var block = this.parseBlock();
	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
	        if (!handler && !finalizer) {
	            this.throwError(messages_1.Messages.NoCatchOrFinally);
	        }
	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
	    };
	    // https://tc39.github.io/ecma262/#sec-debugger-statement
	    Parser.prototype.parseDebuggerStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('debugger');
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.DebuggerStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
	    Parser.prototype.parseStatement = function () {
	        var statement;
	        switch (this.lookahead.type) {
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	            case 10 /* Template */:
	            case 9 /* RegularExpression */:
	                statement = this.parseExpressionStatement();
	                break;
	            case 7 /* Punctuator */:
	                var value = this.lookahead.value;
	                if (value === '{') {
	                    statement = this.parseBlock();
	                }
	                else if (value === '(') {
	                    statement = this.parseExpressionStatement();
	                }
	                else if (value === ';') {
	                    statement = this.parseEmptyStatement();
	                }
	                else {
	                    statement = this.parseExpressionStatement();
	                }
	                break;
	            case 3 /* Identifier */:
	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
	                break;
	            case 4 /* Keyword */:
	                switch (this.lookahead.value) {
	                    case 'break':
	                        statement = this.parseBreakStatement();
	                        break;
	                    case 'continue':
	                        statement = this.parseContinueStatement();
	                        break;
	                    case 'debugger':
	                        statement = this.parseDebuggerStatement();
	                        break;
	                    case 'do':
	                        statement = this.parseDoWhileStatement();
	                        break;
	                    case 'for':
	                        statement = this.parseForStatement();
	                        break;
	                    case 'function':
	                        statement = this.parseFunctionDeclaration();
	                        break;
	                    case 'if':
	                        statement = this.parseIfStatement();
	                        break;
	                    case 'return':
	                        statement = this.parseReturnStatement();
	                        break;
	                    case 'switch':
	                        statement = this.parseSwitchStatement();
	                        break;
	                    case 'throw':
	                        statement = this.parseThrowStatement();
	                        break;
	                    case 'try':
	                        statement = this.parseTryStatement();
	                        break;
	                    case 'var':
	                        statement = this.parseVariableStatement();
	                        break;
	                    case 'while':
	                        statement = this.parseWhileStatement();
	                        break;
	                    case 'with':
	                        statement = this.parseWithStatement();
	                        break;
	                    default:
	                        statement = this.parseExpressionStatement();
	                        break;
	                }
	                break;
	            default:
	                statement = this.throwUnexpectedToken(this.lookahead);
	        }
	        return statement;
	    };
	    // https://tc39.github.io/ecma262/#sec-function-definitions
	    Parser.prototype.parseFunctionSourceElements = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var body = this.parseDirectivePrologues();
	        var previousLabelSet = this.context.labelSet;
	        var previousInIteration = this.context.inIteration;
	        var previousInSwitch = this.context.inSwitch;
	        var previousInFunctionBody = this.context.inFunctionBody;
	        this.context.labelSet = {};
	        this.context.inIteration = false;
	        this.context.inSwitch = false;
	        this.context.inFunctionBody = true;
	        while (this.lookahead.type !== 2 /* EOF */) {
	            if (this.match('}')) {
	                break;
	            }
	            body.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        this.context.labelSet = previousLabelSet;
	        this.context.inIteration = previousInIteration;
	        this.context.inSwitch = previousInSwitch;
	        this.context.inFunctionBody = previousInFunctionBody;
	        return this.finalize(node, new Node.BlockStatement(body));
	    };
	    Parser.prototype.validateParam = function (options, param, name) {
	        var key = '$' + name;
	        if (this.context.strict) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        else if (!options.firstRestricted) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            else if (this.scanner.isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictReservedWord;
	            }
	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        /* istanbul ignore next */
	        if (typeof Object.defineProperty === 'function') {
	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
	        }
	        else {
	            options.paramSet[key] = true;
	        }
	    };
	    Parser.prototype.parseRestElement = function (params) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params);
	        if (this.match('=')) {
	            this.throwError(messages_1.Messages.DefaultRestParameter);
	        }
	        if (!this.match(')')) {
	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
	        }
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseFormalParameter = function (options) {
	        var params = [];
	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
	        for (var i = 0; i < params.length; i++) {
	            this.validateParam(options, params[i], params[i].value);
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	        options.params.push(param);
	    };
	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
	        var options;
	        options = {
	            simple: true,
	            params: [],
	            firstRestricted: firstRestricted
	        };
	        this.expect('(');
	        if (!this.match(')')) {
	            options.paramSet = {};
	            while (this.lookahead.type !== 2 /* EOF */) {
	                this.parseFormalParameter(options);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expect(',');
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return {
	            simple: options.simple,
	            params: options.params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.matchAsyncFunction = function () {
	        var match = this.matchContextualKeyword('async');
	        if (match) {
	            var state = this.scanner.saveState();
	            this.scanner.scanComments();
	            var next = this.scanner.lex();
	            this.scanner.restoreState(state);
	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
	        }
	        return match;
	    };
	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted = null;
	        if (!identifierIsOptional || !this.match('(')) {
	            var token = this.lookahead;
	            id = this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
	    };
	    Parser.prototype.parseFunctionExpression = function () {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted;
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        if (!this.match('(')) {
	            var token = this.lookahead;
	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
	    Parser.prototype.parseDirective = function () {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
	        this.consumeSemicolon();
	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
	    };
	    Parser.prototype.parseDirectivePrologues = function () {
	        var firstRestricted = null;
	        var body = [];
	        while (true) {
	            var token = this.lookahead;
	            if (token.type !== 8 /* StringLiteral */) {
	                break;
	            }
	            var statement = this.parseDirective();
	            body.push(statement);
	            var directive = statement.directive;
	            if (typeof directive !== 'string') {
	                break;
	            }
	            if (directive === 'use strict') {
	                this.context.strict = true;
	                if (firstRestricted) {
	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
	                }
	                if (!this.context.allowStrictDirective) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
	                }
	            }
	            else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	        return body;
	    };
	    // https://tc39.github.io/ecma262/#sec-method-definitions
	    Parser.prototype.qualifiedPropertyName = function (token) {
	        switch (token.type) {
	            case 3 /* Identifier */:
	            case 8 /* StringLiteral */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 4 /* Keyword */:
	                return true;
	            case 7 /* Punctuator */:
	                return token.value === '[';
	            default:
	                break;
	        }
	        return false;
	    };
	    Parser.prototype.parseGetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length > 0) {
	            this.tolerateError(messages_1.Messages.BadGetterArity);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseSetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length !== 1) {
	            this.tolerateError(messages_1.Messages.BadSetterArity);
	        }
	        else if (formalParameters.params[0] instanceof Node.RestElement) {
	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseGeneratorMethod = function () {
	        var node = this.createNode();
	        var isGenerator = true;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        this.context.allowYield = false;
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
	    Parser.prototype.isStartOfExpression = function () {
	        var start = true;
	        var value = this.lookahead.value;
	        switch (this.lookahead.type) {
	            case 7 /* Punctuator */:
	                start = (value === '[') || (value === '(') || (value === '{') ||
	                    (value === '+') || (value === '-') ||
	                    (value === '!') || (value === '~') ||
	                    (value === '++') || (value === '--') ||
	                    (value === '/') || (value === '/='); // regular expression literal
	                break;
	            case 4 /* Keyword */:
	                start = (value === 'class') || (value === 'delete') ||
	                    (value === 'function') || (value === 'let') || (value === 'new') ||
	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
	                    (value === 'void') || (value === 'yield');
	                break;
	            default:
	                break;
	        }
	        return start;
	    };
	    Parser.prototype.parseYieldExpression = function () {
	        var node = this.createNode();
	        this.expectKeyword('yield');
	        var argument = null;
	        var delegate = false;
	        if (!this.hasLineTerminator) {
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = false;
	            delegate = this.match('*');
	            if (delegate) {
	                this.nextToken();
	                argument = this.parseAssignmentExpression();
	            }
	            else if (this.isStartOfExpression()) {
	                argument = this.parseAssignmentExpression();
	            }
	            this.context.allowYield = previousAllowYield;
	        }
	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
	    };
	    // https://tc39.github.io/ecma262/#sec-class-definitions
	    Parser.prototype.parseClassElement = function (hasConstructor) {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var kind = '';
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var isStatic = false;
	        var isAsync = false;
	        if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            var id = key;
	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
	                token = this.lookahead;
	                isStatic = true;
	                computed = this.match('[');
	                if (this.match('*')) {
	                    this.nextToken();
	                }
	                else {
	                    key = this.parseObjectPropertyKey();
	                }
	            }
	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
	                var punctuator = this.lookahead.value;
	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
	                    isAsync = true;
	                    token = this.lookahead;
	                    key = this.parseObjectPropertyKey();
	                    if (token.type === 3 /* Identifier */ && token.value === 'constructor') {
	                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
	                    }
	                }
	            }
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */) {
	            if (token.value === 'get' && lookaheadPropertyKey) {
	                kind = 'get';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                this.context.allowYield = false;
	                value = this.parseGetterMethod();
	            }
	            else if (token.value === 'set' && lookaheadPropertyKey) {
	                kind = 'set';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                value = this.parseSetterMethod();
	            }
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        if (!kind && key && this.match('(')) {
	            kind = 'init';
	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	            method = true;
	        }
	        if (!kind) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        if (kind === 'init') {
	            kind = 'method';
	        }
	        if (!computed) {
	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
	            }
	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
	                if (kind !== 'method' || !method || (value && value.generator)) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
	                }
	                if (hasConstructor.value) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
	                }
	                else {
	                    hasConstructor.value = true;
	                }
	                kind = 'constructor';
	            }
	        }
	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
	    };
	    Parser.prototype.parseClassElementList = function () {
	        var body = [];
	        var hasConstructor = { value: false };
	        this.expect('{');
	        while (!this.match('}')) {
	            if (this.match(';')) {
	                this.nextToken();
	            }
	            else {
	                body.push(this.parseClassElement(hasConstructor));
	            }
	        }
	        this.expect('}');
	        return body;
	    };
	    Parser.prototype.parseClassBody = function () {
	        var node = this.createNode();
	        var elementList = this.parseClassElementList();
	        return this.finalize(node, new Node.ClassBody(elementList));
	    };
	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
	    };
	    Parser.prototype.parseClassExpression = function () {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
	    };
	    // https://tc39.github.io/ecma262/#sec-scripts
	    // https://tc39.github.io/ecma262/#sec-modules
	    Parser.prototype.parseModule = function () {
	        this.context.strict = true;
	        this.context.isModule = true;
	        this.scanner.isModule = true;
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Module(body));
	    };
	    Parser.prototype.parseScript = function () {
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Script(body));
	    };
	    // https://tc39.github.io/ecma262/#sec-imports
	    Parser.prototype.parseModuleSpecifier = function () {
	        var node = this.createNode();
	        if (this.lookahead.type !== 8 /* StringLiteral */) {
	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
	        }
	        var token = this.nextToken();
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    // import {<foo as bar>} ...;
	    Parser.prototype.parseImportSpecifier = function () {
	        var node = this.createNode();
	        var imported;
	        var local;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            imported = this.parseVariableIdentifier();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	        }
	        else {
	            imported = this.parseIdentifierName();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
	    };
	    // {foo, bar as bas}
	    Parser.prototype.parseNamedImports = function () {
	        this.expect('{');
	        var specifiers = [];
	        while (!this.match('}')) {
	            specifiers.push(this.parseImportSpecifier());
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return specifiers;
	    };
	    // import <foo> ...;
	    Parser.prototype.parseImportDefaultSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
	    };
	    // import <* as foo> ...;
	    Parser.prototype.parseImportNamespaceSpecifier = function () {
	        var node = this.createNode();
	        this.expect('*');
	        if (!this.matchContextualKeyword('as')) {
	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
	        }
	        this.nextToken();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
	    };
	    Parser.prototype.parseImportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('import');
	        var src;
	        var specifiers = [];
	        if (this.lookahead.type === 8 /* StringLiteral */) {
	            // import 'foo';
	            src = this.parseModuleSpecifier();
	        }
	        else {
	            if (this.match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(this.parseNamedImports());
	            }
	            else if (this.match('*')) {
	                // import * as foo
	                specifiers.push(this.parseImportNamespaceSpecifier());
	            }
	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
	                // import foo
	                specifiers.push(this.parseImportDefaultSpecifier());
	                if (this.match(',')) {
	                    this.nextToken();
	                    if (this.match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(this.parseImportNamespaceSpecifier());
	                    }
	                    else if (this.match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(this.parseNamedImports());
	                    }
	                    else {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            src = this.parseModuleSpecifier();
	        }
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
	    };
	    // https://tc39.github.io/ecma262/#sec-exports
	    Parser.prototype.parseExportSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        var exported = local;
	        if (this.matchContextualKeyword('as')) {
	            this.nextToken();
	            exported = this.parseIdentifierName();
	        }
	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
	    };
	    Parser.prototype.parseExportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('export');
	        var exportDeclaration;
	        if (this.matchKeyword('default')) {
	            // export default ...
	            this.nextToken();
	            if (this.matchKeyword('function')) {
	                // export default function foo () {}
	                // export default function () {}
	                var declaration = this.parseFunctionDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchKeyword('class')) {
	                // export default class foo {}
	                var declaration = this.parseClassDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchContextualKeyword('async')) {
	                // export default async function f () {}
	                // export default async function () {}
	                // export default async x => x
	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else {
	                if (this.matchContextualKeyword('from')) {
	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
	                }
	                // export default {};
	                // export default [];
	                // export default (1 + 2);
	                var declaration = this.match('{') ? this.parseObjectInitializer() :
	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
	                this.consumeSemicolon();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	        }
	        else if (this.match('*')) {
	            // export * from 'foo';
	            this.nextToken();
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            var src = this.parseModuleSpecifier();
	            this.consumeSemicolon();
	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
	        }
	        else if (this.lookahead.type === 4 /* Keyword */) {
	            // export var f = 1;
	            var declaration = void 0;
	            switch (this.lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = this.parseStatementListItem();
	                    break;
	                default:
	                    this.throwUnexpectedToken(this.lookahead);
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else if (this.matchAsyncFunction()) {
	            var declaration = this.parseFunctionDeclaration();
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else {
	            var specifiers = [];
	            var source = null;
	            var isExportFromIdentifier = false;
	            this.expect('{');
	            while (!this.match('}')) {
	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
	                specifiers.push(this.parseExportSpecifier());
	                if (!this.match('}')) {
	                    this.expect(',');
	                }
	            }
	            this.expect('}');
	            if (this.matchContextualKeyword('from')) {
	                // export {default} from 'foo';
	                // export {foo} from 'foo';
	                this.nextToken();
	                source = this.parseModuleSpecifier();
	                this.consumeSemicolon();
	            }
	            else if (isExportFromIdentifier) {
	                // export {default}; // missing fromClause
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            else {
	                // export {foo};
	                this.consumeSemicolon();
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
	        }
	        return exportDeclaration;
	    };
	    return Parser;
	}());
	exports.Parser = Parser;


/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.
	Object.defineProperty(exports, "__esModule", { value: true });
	function assert(condition, message) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error('ASSERT: ' + message);
	    }
	}
	exports.assert = assert;


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:max-classes-per-file */
	Object.defineProperty(exports, "__esModule", { value: true });
	var ErrorHandler = (function () {
	    function ErrorHandler() {
	        this.errors = [];
	        this.tolerant = false;
	    }
	    ErrorHandler.prototype.recordError = function (error) {
	        this.errors.push(error);
	    };
	    ErrorHandler.prototype.tolerate = function (error) {
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    ErrorHandler.prototype.constructError = function (msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        }
	        catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        }
	        /* istanbul ignore next */
	        return error;
	    };
	    ErrorHandler.prototype.createError = function (index, line, col, description) {
	        var msg = 'Line ' + line + ': ' + description;
	        var error = this.constructError(msg, col);
	        error.index = index;
	        error.lineNumber = line;
	        error.description = description;
	        return error;
	    };
	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
	        throw this.createError(index, line, col, description);
	    };
	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
	        var error = this.createError(index, line, col, description);
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    return ErrorHandler;
	}());
	exports.ErrorHandler = ErrorHandler;


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// Error messages should be identical to V8.
	exports.Messages = {
	    BadGetterArity: 'Getter must not have any formal parameters',
	    BadSetterArity: 'Setter must have exactly one formal parameter',
	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
	    ConstructorIsAsync: 'Class constructor may not be an async method',
	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
	    DefaultRestParameter: 'Unexpected token =',
	    DuplicateBinding: 'Duplicate binding %0',
	    DuplicateConstructor: 'A class may only have one constructor',
	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
	    IllegalBreak: 'Illegal break statement',
	    IllegalContinue: 'Illegal continue statement',
	    IllegalExportDeclaration: 'Unexpected token',
	    IllegalImportDeclaration: 'Unexpected token',
	    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
	    IllegalReturn: 'Illegal return statement',
	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	    InvalidModuleSpecifier: 'Unexpected token',
	    InvalidRegExp: 'Invalid regular expression',
	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
	    MissingFromClause: 'Unexpected token',
	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	    NewlineAfterThrow: 'Illegal newline after throw',
	    NoAsAfterImportNamespace: 'Unexpected token',
	    NoCatchOrFinally: 'Missing catch or finally after try',
	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	    Redeclaration: '%0 \'%1\' has already been declared',
	    StaticPrototype: 'Classes may not have static property named prototype',
	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictModeWith: 'Strict mode code may not include a with statement',
	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	    StrictReservedWord: 'Use of future reserved word in strict mode',
	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	    UnexpectedEOS: 'Unexpected end of input',
	    UnexpectedIdentifier: 'Unexpected identifier',
	    UnexpectedNumber: 'Unexpected number',
	    UnexpectedReserved: 'Unexpected reserved word',
	    UnexpectedString: 'Unexpected string',
	    UnexpectedTemplate: 'Unexpected quasi %0',
	    UnexpectedToken: 'Unexpected token %0',
	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
	    UnknownLabel: 'Undefined label \'%0\'',
	    UnterminatedRegExp: 'Invalid regular expression: missing /'
	};


/***/ },
/* 12 */
/***/ function(module, exports, __nested_webpack_require_226595__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __nested_webpack_require_226595__(9);
	var character_1 = __nested_webpack_require_226595__(4);
	var messages_1 = __nested_webpack_require_226595__(11);
	function hexValue(ch) {
	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
	}
	function octalValue(ch) {
	    return '01234567'.indexOf(ch);
	}
	var Scanner = (function () {
	    function Scanner(code, handler) {
	        this.source = code;
	        this.errorHandler = handler;
	        this.trackComment = false;
	        this.isModule = false;
	        this.length = code.length;
	        this.index = 0;
	        this.lineNumber = (code.length > 0) ? 1 : 0;
	        this.lineStart = 0;
	        this.curlyStack = [];
	    }
	    Scanner.prototype.saveState = function () {
	        return {
	            index: this.index,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart
	        };
	    };
	    Scanner.prototype.restoreState = function (state) {
	        this.index = state.index;
	        this.lineNumber = state.lineNumber;
	        this.lineStart = state.lineStart;
	    };
	    Scanner.prototype.eof = function () {
	        return this.index >= this.length;
	    };
	    Scanner.prototype.throwUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    // https://tc39.github.io/ecma262/#sec-comments
	    Scanner.prototype.skipSingleLineComment = function (offset) {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - offset;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - offset
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            ++this.index;
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (this.trackComment) {
	                    loc.end = {
	                        line: this.lineNumber,
	                        column: this.index - this.lineStart - 1
	                    };
	                    var entry = {
	                        multiLine: false,
	                        slice: [start + offset, this.index - 1],
	                        range: [start, this.index - 1],
	                        loc: loc
	                    };
	                    comments.push(entry);
	                }
	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                return comments;
	            }
	        }
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: false,
	                slice: [start + offset, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        return comments;
	    };
	    Scanner.prototype.skipMultiLineComment = function () {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - 2;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - 2
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                ++this.index;
	                this.lineStart = this.index;
	            }
	            else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
	                    this.index += 2;
	                    if (this.trackComment) {
	                        loc.end = {
	                            line: this.lineNumber,
	                            column: this.index - this.lineStart
	                        };
	                        var entry = {
	                            multiLine: true,
	                            slice: [start + 2, this.index - 2],
	                            range: [start, this.index],
	                            loc: loc
	                        };
	                        comments.push(entry);
	                    }
	                    return comments;
	                }
	                ++this.index;
	            }
	            else {
	                ++this.index;
	            }
	        }
	        // Ran off the end of the file - the whole thing is a comment
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: true,
	                slice: [start + 2, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        this.tolerateUnexpectedToken();
	        return comments;
	    };
	    Scanner.prototype.scanComments = function () {
	        var comments;
	        if (this.trackComment) {
	            comments = [];
	        }
	        var start = (this.index === 0);
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isWhiteSpace(ch)) {
	                ++this.index;
	            }
	            else if (character_1.Character.isLineTerminator(ch)) {
	                ++this.index;
	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                start = true;
	            }
	            else if (ch === 0x2F) {
	                ch = this.source.charCodeAt(this.index + 1);
	                if (ch === 0x2F) {
	                    this.index += 2;
	                    var comment = this.skipSingleLineComment(2);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                    start = true;
	                }
	                else if (ch === 0x2A) {
	                    this.index += 2;
	                    var comment = this.skipMultiLineComment();
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (start && ch === 0x2D) {
	                // U+003E is '>'
	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    this.index += 3;
	                    var comment = this.skipSingleLineComment(3);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (ch === 0x3C && !this.isModule) {
	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
	                    this.index += 4; // `<!--`
	                    var comment = this.skipSingleLineComment(4);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        return comments;
	    };
	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
	    Scanner.prototype.isFutureReservedWord = function (id) {
	        switch (id) {
	            case 'enum':
	            case 'export':
	            case 'import':
	            case 'super':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isStrictModeReservedWord = function (id) {
	        switch (id) {
	            case 'implements':
	            case 'interface':
	            case 'package':
	            case 'private':
	            case 'protected':
	            case 'public':
	            case 'static':
	            case 'yield':
	            case 'let':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isRestrictedWord = function (id) {
	        return id === 'eval' || id === 'arguments';
	    };
	    // https://tc39.github.io/ecma262/#sec-keywords
	    Scanner.prototype.isKeyword = function (id) {
	        switch (id.length) {
	            case 2:
	                return (id === 'if') || (id === 'in') || (id === 'do');
	            case 3:
	                return (id === 'var') || (id === 'for') || (id === 'new') ||
	                    (id === 'try') || (id === 'let');
	            case 4:
	                return (id === 'this') || (id === 'else') || (id === 'case') ||
	                    (id === 'void') || (id === 'with') || (id === 'enum');
	            case 5:
	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                    (id === 'class') || (id === 'super');
	            case 6:
	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                    (id === 'switch') || (id === 'export') || (id === 'import');
	            case 7:
	                return (id === 'default') || (id === 'finally') || (id === 'extends');
	            case 8:
	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
	            case 10:
	                return (id === 'instanceof');
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.codePointAt = function (i) {
	        var cp = this.source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            var second = this.source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                var first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	        return cp;
	    };
	    Scanner.prototype.scanHexEscape = function (prefix) {
	        var len = (prefix === 'u') ? 4 : 2;
	        var code = 0;
	        for (var i = 0; i < len; ++i) {
	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                code = code * 16 + hexValue(this.source[this.index++]);
	            }
	            else {
	                return null;
	            }
	        }
	        return String.fromCharCode(code);
	    };
	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
	        var ch = this.source[this.index];
	        var code = 0;
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            this.throwUnexpectedToken();
	        }
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
	                break;
	            }
	            code = code * 16 + hexValue(ch);
	        }
	        if (code > 0x10FFFF || ch !== '}') {
	            this.throwUnexpectedToken();
	        }
	        return character_1.Character.fromCodePoint(code);
	    };
	    Scanner.prototype.getIdentifier = function () {
	        var start = this.index++;
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            if (character_1.Character.isIdentifierPart(ch)) {
	                ++this.index;
	            }
	            else {
	                break;
	            }
	        }
	        return this.source.slice(start, this.index);
	    };
	    Scanner.prototype.getComplexIdentifier = function () {
	        var cp = this.codePointAt(this.index);
	        var id = character_1.Character.fromCodePoint(cp);
	        this.index += id.length;
	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        var ch;
	        if (cp === 0x5C) {
	            if (this.source.charCodeAt(this.index) !== 0x75) {
	                this.throwUnexpectedToken();
	            }
	            ++this.index;
	            if (this.source[this.index] === '{') {
	                ++this.index;
	                ch = this.scanUnicodeCodePointEscape();
	            }
	            else {
	                ch = this.scanHexEscape('u');
	                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	        while (!this.eof()) {
	            cp = this.codePointAt(this.index);
	            if (!character_1.Character.isIdentifierPart(cp)) {
	                break;
	            }
	            ch = character_1.Character.fromCodePoint(cp);
	            id += ch;
	            this.index += ch.length;
	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (this.source.charCodeAt(this.index) !== 0x75) {
	                    this.throwUnexpectedToken();
	                }
	                ++this.index;
	                if (this.source[this.index] === '{') {
	                    ++this.index;
	                    ch = this.scanUnicodeCodePointEscape();
	                }
	                else {
	                    ch = this.scanHexEscape('u');
	                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                        this.throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	        return id;
	    };
	    Scanner.prototype.octalToDecimal = function (ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0');
	        var code = octalValue(ch);
	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	            octal = true;
	            code = code * 8 + octalValue(this.source[this.index++]);
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                code = code * 8 + octalValue(this.source[this.index++]);
	            }
	        }
	        return {
	            code: code,
	            octal: octal
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    Scanner.prototype.scanIdentifier = function () {
	        var type;
	        var start = this.index;
	        // Backslash (U+005C) starts an escaped character.
	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = 3 /* Identifier */;
	        }
	        else if (this.isKeyword(id)) {
	            type = 4 /* Keyword */;
	        }
	        else if (id === 'null') {
	            type = 5 /* NullLiteral */;
	        }
	        else if (id === 'true' || id === 'false') {
	            type = 1 /* BooleanLiteral */;
	        }
	        else {
	            type = 3 /* Identifier */;
	        }
	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
	            var restore = this.index;
	            this.index = start;
	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
	            this.index = restore;
	        }
	        return {
	            type: type,
	            value: id,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-punctuators
	    Scanner.prototype.scanPunctuator = function () {
	        var start = this.index;
	        // Check for most common single-character punctuators.
	        var str = this.source[this.index];
	        switch (str) {
	            case '(':
	            case '{':
	                if (str === '{') {
	                    this.curlyStack.push('{');
	                }
	                ++this.index;
	                break;
	            case '.':
	                ++this.index;
	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
	                    // Spread operator: ...
	                    this.index += 2;
	                    str = '...';
	                }
	                break;
	            case '}':
	                ++this.index;
	                this.curlyStack.pop();
	                break;
	            case ')':
	            case ';':
	            case ',':
	            case '[':
	            case ']':
	            case ':':
	            case '?':
	            case '~':
	                ++this.index;
	                break;
	            default:
	                // 4-character punctuator.
	                str = this.source.substr(this.index, 4);
	                if (str === '>>>=') {
	                    this.index += 4;
	                }
	                else {
	                    // 3-character punctuators.
	                    str = str.substr(0, 3);
	                    if (str === '===' || str === '!==' || str === '>>>' ||
	                        str === '<<=' || str === '>>=' || str === '**=') {
	                        this.index += 3;
	                    }
	                    else {
	                        // 2-character punctuators.
	                        str = str.substr(0, 2);
	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
	                            this.index += 2;
	                        }
	                        else {
	                            // 1-character punctuators.
	                            str = this.source[this.index];
	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                                ++this.index;
	                            }
	                        }
	                    }
	                }
	        }
	        if (this.index === start) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 7 /* Punctuator */,
	            value: str,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    Scanner.prototype.scanHexLiteral = function (start) {
	        var num = '';
	        while (!this.eof()) {
	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt('0x' + num, 16),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanBinaryLiteral = function (start) {
	        var num = '';
	        var ch;
	        while (!this.eof()) {
	            ch = this.source[this.index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            // only 0b or 0B
	            this.throwUnexpectedToken();
	        }
	        if (!this.eof()) {
	            ch = this.source.charCodeAt(this.index);
	            /* istanbul ignore else */
	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
	                this.throwUnexpectedToken();
	            }
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 2),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
	        var num = '';
	        var octal = false;
	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
	            octal = true;
	            num = '0' + this.source[this.index++];
	        }
	        else {
	            ++this.index;
	        }
	        while (!this.eof()) {
	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (!octal && num.length === 0) {
	            // only 0o or 0O
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 8),
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.isImplicitOctalLiteral = function () {
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (var i = this.index + 1; i < this.length; ++i) {
	            var ch = this.source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                return true;
	            }
	        }
	        return true;
	    };
	    Scanner.prototype.scanNumericLiteral = function () {
	        var start = this.index;
	        var ch = this.source[start];
	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
	        var num = '';
	        if (ch !== '.') {
	            num = this.source[this.index++];
	            ch = this.source[this.index];
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (num === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++this.index;
	                    return this.scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++this.index;
	                    return this.scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return this.scanOctalLiteral(ch, start);
	                }
	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                    if (this.isImplicitOctalLiteral()) {
	                        return this.scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === '.') {
	            num += this.source[this.index++];
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === 'e' || ch === 'E') {
	            num += this.source[this.index++];
	            ch = this.source[this.index];
	            if (ch === '+' || ch === '-') {
	                num += this.source[this.index++];
	            }
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                    num += this.source[this.index++];
	                }
	            }
	            else {
	                this.throwUnexpectedToken();
	            }
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseFloat(num),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
	    Scanner.prototype.scanStringLiteral = function () {
	        var start = this.index;
	        var quote = this.source[start];
	        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
	        ++this.index;
	        var octal = false;
	        var str = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === quote) {
	                quote = '';
	                break;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                str += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var unescaped_1 = this.scanHexEscape(ch);
	                                if (unescaped_1 === null) {
	                                    this.throwUnexpectedToken();
	                                }
	                                str += unescaped_1;
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            str += unescaped;
	                            break;
	                        case 'n':
	                            str += '\n';
	                            break;
	                        case 'r':
	                            str += '\r';
	                            break;
	                        case 't':
	                            str += '\t';
	                            break;
	                        case 'b':
	                            str += '\b';
	                            break;
	                        case 'f':
	                            str += '\f';
	                            break;
	                        case 'v':
	                            str += '\x0B';
	                            break;
	                        case '8':
	                        case '9':
	                            str += ch;
	                            this.tolerateUnexpectedToken();
	                            break;
	                        default:
	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                var octToDec = this.octalToDecimal(ch);
	                                octal = octToDec.octal || octal;
	                                str += String.fromCharCode(octToDec.code);
	                            }
	                            else {
	                                str += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            }
	            else {
	                str += ch;
	            }
	        }
	        if (quote !== '') {
	            this.index = start;
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 8 /* StringLiteral */,
	            value: str,
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
	    Scanner.prototype.scanTemplate = function () {
	        var cooked = '';
	        var terminated = false;
	        var start = this.index;
	        var head = (this.source[start] === '`');
	        var tail = false;
	        var rawOffset = 2;
	        ++this.index;
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            }
	            else if (ch === '$') {
	                if (this.source[this.index] === '{') {
	                    this.curlyStack.push('${');
	                    ++this.index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'n':
	                            cooked += '\n';
	                            break;
	                        case 'r':
	                            cooked += '\r';
	                            break;
	                        case 't':
	                            cooked += '\t';
	                            break;
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                cooked += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var restore = this.index;
	                                var unescaped_2 = this.scanHexEscape(ch);
	                                if (unescaped_2 !== null) {
	                                    cooked += unescaped_2;
	                                }
	                                else {
	                                    this.index = restore;
	                                    cooked += ch;
	                                }
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            cooked += unescaped;
	                            break;
	                        case 'b':
	                            cooked += '\b';
	                            break;
	                        case 'f':
	                            cooked += '\f';
	                            break;
	                        case 'v':
	                            cooked += '\v';
	                            break;
	                        default:
	                            if (ch === '0') {
	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                                    // Illegal: \01 \02 and so on
	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                                }
	                                cooked += '\0';
	                            }
	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                // Illegal: \1 \2
	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                            }
	                            else {
	                                cooked += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.lineNumber;
	                if (ch === '\r' && this.source[this.index] === '\n') {
	                    ++this.index;
	                }
	                this.lineStart = this.index;
	                cooked += '\n';
	            }
	            else {
	                cooked += ch;
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken();
	        }
	        if (!head) {
	            this.curlyStack.pop();
	        }
	        return {
	            type: 10 /* Template */,
	            value: this.source.slice(start + 1, this.index - rawOffset),
	            cooked: cooked,
	            head: head,
	            tail: tail,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	    Scanner.prototype.testRegExp = function (pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF';
	        var tmp = pattern;
	        var self = this;
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                var codePoint = parseInt($1 || $2, 16);
	                if (codePoint > 0x10FFFF) {
	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	                }
	                if (codePoint <= 0xFFFF) {
	                    return String.fromCharCode(codePoint);
	                }
	                return astralSubstitute;
	            })
	                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
	        }
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        }
	        catch (e) {
	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	        }
	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        }
	        catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    };
	    Scanner.prototype.scanRegExpBody = function () {
	        var ch = this.source[this.index];
	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
	        var str = this.source[this.index++];
	        var classMarker = false;
	        var terminated = false;
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = this.source[this.index++];
	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	            }
	            else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            }
	            else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                }
	                else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	        }
	        // Exclude leading and trailing slash.
	        return str.substr(1, str.length - 2);
	    };
	    Scanner.prototype.scanRegExpFlags = function () {
	        var str = '';
	        var flags = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index];
	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	            ++this.index;
	            if (ch === '\\' && !this.eof()) {
	                ch = this.source[this.index];
	                if (ch === 'u') {
	                    ++this.index;
	                    var restore = this.index;
	                    var char = this.scanHexEscape('u');
	                    if (char !== null) {
	                        flags += char;
	                        for (str += '\\u'; restore < this.index; ++restore) {
	                            str += this.source[restore];
	                        }
	                    }
	                    else {
	                        this.index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    this.tolerateUnexpectedToken();
	                }
	                else {
	                    str += '\\';
	                    this.tolerateUnexpectedToken();
	                }
	            }
	            else {
	                flags += ch;
	                str += ch;
	            }
	        }
	        return flags;
	    };
	    Scanner.prototype.scanRegExp = function () {
	        var start = this.index;
	        var pattern = this.scanRegExpBody();
	        var flags = this.scanRegExpFlags();
	        var value = this.testRegExp(pattern, flags);
	        return {
	            type: 9 /* RegularExpression */,
	            value: '',
	            pattern: pattern,
	            flags: flags,
	            regex: value,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.lex = function () {
	        if (this.eof()) {
	            return {
	                type: 2 /* EOF */,
	                value: '',
	                lineNumber: this.lineNumber,
	                lineStart: this.lineStart,
	                start: this.index,
	                end: this.index
	            };
	        }
	        var cp = this.source.charCodeAt(this.index);
	        if (character_1.Character.isIdentifierStart(cp)) {
	            return this.scanIdentifier();
	        }
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return this.scanPunctuator();
	        }
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return this.scanStringLiteral();
	        }
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
	                return this.scanNumericLiteral();
	            }
	            return this.scanPunctuator();
	        }
	        if (character_1.Character.isDecimalDigit(cp)) {
	            return this.scanNumericLiteral();
	        }
	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
	            return this.scanTemplate();
	        }
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
	                return this.scanIdentifier();
	            }
	        }
	        return this.scanPunctuator();
	    };
	    return Scanner;
	}());
	exports.Scanner = Scanner;


/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TokenName = {};
	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
	exports.TokenName[2 /* EOF */] = '<end>';
	exports.TokenName[3 /* Identifier */] = 'Identifier';
	exports.TokenName[4 /* Keyword */] = 'Keyword';
	exports.TokenName[5 /* NullLiteral */] = 'Null';
	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
	exports.TokenName[8 /* StringLiteral */] = 'String';
	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
	exports.TokenName[10 /* Template */] = 'Template';


/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XHTMLEntities = {
	    quot: '\u0022',
	    amp: '\u0026',
	    apos: '\u0027',
	    gt: '\u003E',
	    nbsp: '\u00A0',
	    iexcl: '\u00A1',
	    cent: '\u00A2',
	    pound: '\u00A3',
	    curren: '\u00A4',
	    yen: '\u00A5',
	    brvbar: '\u00A6',
	    sect: '\u00A7',
	    uml: '\u00A8',
	    copy: '\u00A9',
	    ordf: '\u00AA',
	    laquo: '\u00AB',
	    not: '\u00AC',
	    shy: '\u00AD',
	    reg: '\u00AE',
	    macr: '\u00AF',
	    deg: '\u00B0',
	    plusmn: '\u00B1',
	    sup2: '\u00B2',
	    sup3: '\u00B3',
	    acute: '\u00B4',
	    micro: '\u00B5',
	    para: '\u00B6',
	    middot: '\u00B7',
	    cedil: '\u00B8',
	    sup1: '\u00B9',
	    ordm: '\u00BA',
	    raquo: '\u00BB',
	    frac14: '\u00BC',
	    frac12: '\u00BD',
	    frac34: '\u00BE',
	    iquest: '\u00BF',
	    Agrave: '\u00C0',
	    Aacute: '\u00C1',
	    Acirc: '\u00C2',
	    Atilde: '\u00C3',
	    Auml: '\u00C4',
	    Aring: '\u00C5',
	    AElig: '\u00C6',
	    Ccedil: '\u00C7',
	    Egrave: '\u00C8',
	    Eacute: '\u00C9',
	    Ecirc: '\u00CA',
	    Euml: '\u00CB',
	    Igrave: '\u00CC',
	    Iacute: '\u00CD',
	    Icirc: '\u00CE',
	    Iuml: '\u00CF',
	    ETH: '\u00D0',
	    Ntilde: '\u00D1',
	    Ograve: '\u00D2',
	    Oacute: '\u00D3',
	    Ocirc: '\u00D4',
	    Otilde: '\u00D5',
	    Ouml: '\u00D6',
	    times: '\u00D7',
	    Oslash: '\u00D8',
	    Ugrave: '\u00D9',
	    Uacute: '\u00DA',
	    Ucirc: '\u00DB',
	    Uuml: '\u00DC',
	    Yacute: '\u00DD',
	    THORN: '\u00DE',
	    szlig: '\u00DF',
	    agrave: '\u00E0',
	    aacute: '\u00E1',
	    acirc: '\u00E2',
	    atilde: '\u00E3',
	    auml: '\u00E4',
	    aring: '\u00E5',
	    aelig: '\u00E6',
	    ccedil: '\u00E7',
	    egrave: '\u00E8',
	    eacute: '\u00E9',
	    ecirc: '\u00EA',
	    euml: '\u00EB',
	    igrave: '\u00EC',
	    iacute: '\u00ED',
	    icirc: '\u00EE',
	    iuml: '\u00EF',
	    eth: '\u00F0',
	    ntilde: '\u00F1',
	    ograve: '\u00F2',
	    oacute: '\u00F3',
	    ocirc: '\u00F4',
	    otilde: '\u00F5',
	    ouml: '\u00F6',
	    divide: '\u00F7',
	    oslash: '\u00F8',
	    ugrave: '\u00F9',
	    uacute: '\u00FA',
	    ucirc: '\u00FB',
	    uuml: '\u00FC',
	    yacute: '\u00FD',
	    thorn: '\u00FE',
	    yuml: '\u00FF',
	    OElig: '\u0152',
	    oelig: '\u0153',
	    Scaron: '\u0160',
	    scaron: '\u0161',
	    Yuml: '\u0178',
	    fnof: '\u0192',
	    circ: '\u02C6',
	    tilde: '\u02DC',
	    Alpha: '\u0391',
	    Beta: '\u0392',
	    Gamma: '\u0393',
	    Delta: '\u0394',
	    Epsilon: '\u0395',
	    Zeta: '\u0396',
	    Eta: '\u0397',
	    Theta: '\u0398',
	    Iota: '\u0399',
	    Kappa: '\u039A',
	    Lambda: '\u039B',
	    Mu: '\u039C',
	    Nu: '\u039D',
	    Xi: '\u039E',
	    Omicron: '\u039F',
	    Pi: '\u03A0',
	    Rho: '\u03A1',
	    Sigma: '\u03A3',
	    Tau: '\u03A4',
	    Upsilon: '\u03A5',
	    Phi: '\u03A6',
	    Chi: '\u03A7',
	    Psi: '\u03A8',
	    Omega: '\u03A9',
	    alpha: '\u03B1',
	    beta: '\u03B2',
	    gamma: '\u03B3',
	    delta: '\u03B4',
	    epsilon: '\u03B5',
	    zeta: '\u03B6',
	    eta: '\u03B7',
	    theta: '\u03B8',
	    iota: '\u03B9',
	    kappa: '\u03BA',
	    lambda: '\u03BB',
	    mu: '\u03BC',
	    nu: '\u03BD',
	    xi: '\u03BE',
	    omicron: '\u03BF',
	    pi: '\u03C0',
	    rho: '\u03C1',
	    sigmaf: '\u03C2',
	    sigma: '\u03C3',
	    tau: '\u03C4',
	    upsilon: '\u03C5',
	    phi: '\u03C6',
	    chi: '\u03C7',
	    psi: '\u03C8',
	    omega: '\u03C9',
	    thetasym: '\u03D1',
	    upsih: '\u03D2',
	    piv: '\u03D6',
	    ensp: '\u2002',
	    emsp: '\u2003',
	    thinsp: '\u2009',
	    zwnj: '\u200C',
	    zwj: '\u200D',
	    lrm: '\u200E',
	    rlm: '\u200F',
	    ndash: '\u2013',
	    mdash: '\u2014',
	    lsquo: '\u2018',
	    rsquo: '\u2019',
	    sbquo: '\u201A',
	    ldquo: '\u201C',
	    rdquo: '\u201D',
	    bdquo: '\u201E',
	    dagger: '\u2020',
	    Dagger: '\u2021',
	    bull: '\u2022',
	    hellip: '\u2026',
	    permil: '\u2030',
	    prime: '\u2032',
	    Prime: '\u2033',
	    lsaquo: '\u2039',
	    rsaquo: '\u203A',
	    oline: '\u203E',
	    frasl: '\u2044',
	    euro: '\u20AC',
	    image: '\u2111',
	    weierp: '\u2118',
	    real: '\u211C',
	    trade: '\u2122',
	    alefsym: '\u2135',
	    larr: '\u2190',
	    uarr: '\u2191',
	    rarr: '\u2192',
	    darr: '\u2193',
	    harr: '\u2194',
	    crarr: '\u21B5',
	    lArr: '\u21D0',
	    uArr: '\u21D1',
	    rArr: '\u21D2',
	    dArr: '\u21D3',
	    hArr: '\u21D4',
	    forall: '\u2200',
	    part: '\u2202',
	    exist: '\u2203',
	    empty: '\u2205',
	    nabla: '\u2207',
	    isin: '\u2208',
	    notin: '\u2209',
	    ni: '\u220B',
	    prod: '\u220F',
	    sum: '\u2211',
	    minus: '\u2212',
	    lowast: '\u2217',
	    radic: '\u221A',
	    prop: '\u221D',
	    infin: '\u221E',
	    ang: '\u2220',
	    and: '\u2227',
	    or: '\u2228',
	    cap: '\u2229',
	    cup: '\u222A',
	    int: '\u222B',
	    there4: '\u2234',
	    sim: '\u223C',
	    cong: '\u2245',
	    asymp: '\u2248',
	    ne: '\u2260',
	    equiv: '\u2261',
	    le: '\u2264',
	    ge: '\u2265',
	    sub: '\u2282',
	    sup: '\u2283',
	    nsub: '\u2284',
	    sube: '\u2286',
	    supe: '\u2287',
	    oplus: '\u2295',
	    otimes: '\u2297',
	    perp: '\u22A5',
	    sdot: '\u22C5',
	    lceil: '\u2308',
	    rceil: '\u2309',
	    lfloor: '\u230A',
	    rfloor: '\u230B',
	    loz: '\u25CA',
	    spades: '\u2660',
	    clubs: '\u2663',
	    hearts: '\u2665',
	    diams: '\u2666',
	    lang: '\u27E8',
	    rang: '\u27E9'
	};


/***/ },
/* 15 */
/***/ function(module, exports, __nested_webpack_require_277122__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var error_handler_1 = __nested_webpack_require_277122__(10);
	var scanner_1 = __nested_webpack_require_277122__(12);
	var token_1 = __nested_webpack_require_277122__(13);
	var Reader = (function () {
	    function Reader() {
	        this.values = [];
	        this.curly = this.paren = -1;
	    }
	    // A function following one of those tokens is an expression.
	    Reader.prototype.beforeFunctionExpression = function (t) {
	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	            'return', 'case', 'delete', 'throw', 'void',
	            // assignment operators
	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
	            '&=', '|=', '^=', ',',
	            // binary/unary operators
	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
	    };
	    // Determine if forward slash (/) is an operator or part of a regular expression
	    // https://github.com/mozilla/sweet.js/wiki/design
	    Reader.prototype.isRegexStart = function () {
	        var previous = this.values[this.values.length - 1];
	        var regex = (previous !== null);
	        switch (previous) {
	            case 'this':
	            case ']':
	                regex = false;
	                break;
	            case ')':
	                var keyword = this.values[this.paren - 1];
	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
	                break;
	            case '}':
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                regex = false;
	                if (this.values[this.curly - 3] === 'function') {
	                    // Anonymous function, e.g. function(){} /42
	                    var check = this.values[this.curly - 4];
	                    regex = check ? !this.beforeFunctionExpression(check) : false;
	                }
	                else if (this.values[this.curly - 4] === 'function') {
	                    // Named function, e.g. function f(){} /42/
	                    var check = this.values[this.curly - 5];
	                    regex = check ? !this.beforeFunctionExpression(check) : true;
	                }
	                break;
	            default:
	                break;
	        }
	        return regex;
	    };
	    Reader.prototype.push = function (token) {
	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
	            if (token.value === '{') {
	                this.curly = this.values.length;
	            }
	            else if (token.value === '(') {
	                this.paren = this.values.length;
	            }
	            this.values.push(token.value);
	        }
	        else {
	            this.values.push(null);
	        }
	    };
	    return Reader;
	}());
	var Tokenizer = (function () {
	    function Tokenizer(code, config) {
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
	        this.buffer = [];
	        this.reader = new Reader();
	    }
	    Tokenizer.prototype.errors = function () {
	        return this.errorHandler.errors;
	    };
	    Tokenizer.prototype.getNextToken = function () {
	        if (this.buffer.length === 0) {
	            var comments = this.scanner.scanComments();
	            if (this.scanner.trackComment) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
	                    var comment = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: value
	                    };
	                    if (this.trackRange) {
	                        comment.range = e.range;
	                    }
	                    if (this.trackLoc) {
	                        comment.loc = e.loc;
	                    }
	                    this.buffer.push(comment);
	                }
	            }
	            if (!this.scanner.eof()) {
	                var loc = void 0;
	                if (this.trackLoc) {
	                    loc = {
	                        start: {
	                            line: this.scanner.lineNumber,
	                            column: this.scanner.index - this.scanner.lineStart
	                        },
	                        end: {}
	                    };
	                }
	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
	                this.reader.push(token);
	                var entry = {
	                    type: token_1.TokenName[token.type],
	                    value: this.scanner.source.slice(token.start, token.end)
	                };
	                if (this.trackRange) {
	                    entry.range = [token.start, token.end];
	                }
	                if (this.trackLoc) {
	                    loc.end = {
	                        line: this.scanner.lineNumber,
	                        column: this.scanner.index - this.scanner.lineStart
	                    };
	                    entry.loc = loc;
	                }
	                if (token.type === 9 /* RegularExpression */) {
	                    var pattern = token.pattern;
	                    var flags = token.flags;
	                    entry.regex = { pattern: pattern, flags: flags };
	                }
	                this.buffer.push(entry);
	            }
	        }
	        return this.buffer.shift();
	    };
	    return Tokenizer;
	}());
	exports.Tokenizer = Tokenizer;


/***/ }
/******/ ])
});
;

/***/ }),

/***/ 2530:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var fs = __webpack_require__(5747);
var util = __webpack_require__(1669);
var stream = __webpack_require__(2413);
var Readable = stream.Readable;
var Writable = stream.Writable;
var PassThrough = stream.PassThrough;
var Pend = __webpack_require__(277);
var EventEmitter = __webpack_require__(8614).EventEmitter;

exports.createFromBuffer = createFromBuffer;
exports.createFromFd = createFromFd;
exports.BufferSlicer = BufferSlicer;
exports.FdSlicer = FdSlicer;

util.inherits(FdSlicer, EventEmitter);
function FdSlicer(fd, options) {
  options = options || {};
  EventEmitter.call(this);

  this.fd = fd;
  this.pend = new Pend();
  this.pend.max = 1;
  this.refCount = 0;
  this.autoClose = !!options.autoClose;
}

FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
  var self = this;
  self.pend.go(function(cb) {
    fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {
      cb();
      callback(err, bytesRead, buffer);
    });
  });
};

FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
  var self = this;
  self.pend.go(function(cb) {
    fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {
      cb();
      callback(err, written, buffer);
    });
  });
};

FdSlicer.prototype.createReadStream = function(options) {
  return new ReadStream(this, options);
};

FdSlicer.prototype.createWriteStream = function(options) {
  return new WriteStream(this, options);
};

FdSlicer.prototype.ref = function() {
  this.refCount += 1;
};

FdSlicer.prototype.unref = function() {
  var self = this;
  self.refCount -= 1;

  if (self.refCount > 0) return;
  if (self.refCount < 0) throw new Error("invalid unref");

  if (self.autoClose) {
    fs.close(self.fd, onCloseDone);
  }

  function onCloseDone(err) {
    if (err) {
      self.emit('error', err);
    } else {
      self.emit('close');
    }
  }
};

util.inherits(ReadStream, Readable);
function ReadStream(context, options) {
  options = options || {};
  Readable.call(this, options);

  this.context = context;
  this.context.ref();

  this.start = options.start || 0;
  this.endOffset = options.end;
  this.pos = this.start;
  this.destroyed = false;
}

ReadStream.prototype._read = function(n) {
  var self = this;
  if (self.destroyed) return;

  var toRead = Math.min(self._readableState.highWaterMark, n);
  if (self.endOffset != null) {
    toRead = Math.min(toRead, self.endOffset - self.pos);
  }
  if (toRead <= 0) {
    self.destroyed = true;
    self.push(null);
    self.context.unref();
    return;
  }
  self.context.pend.go(function(cb) {
    if (self.destroyed) return cb();
    var buffer = new Buffer(toRead);
    fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {
      if (err) {
        self.destroy(err);
      } else if (bytesRead === 0) {
        self.destroyed = true;
        self.push(null);
        self.context.unref();
      } else {
        self.pos += bytesRead;
        self.push(buffer.slice(0, bytesRead));
      }
      cb();
    });
  });
};

ReadStream.prototype.destroy = function(err) {
  if (this.destroyed) return;
  err = err || new Error("stream destroyed");
  this.destroyed = true;
  this.emit('error', err);
  this.context.unref();
};

util.inherits(WriteStream, Writable);
function WriteStream(context, options) {
  options = options || {};
  Writable.call(this, options);

  this.context = context;
  this.context.ref();

  this.start = options.start || 0;
  this.endOffset = (options.end == null) ? Infinity : +options.end;
  this.bytesWritten = 0;
  this.pos = this.start;
  this.destroyed = false;

  this.on('finish', this.destroy.bind(this));
}

WriteStream.prototype._write = function(buffer, encoding, callback) {
  var self = this;
  if (self.destroyed) return;

  if (self.pos + buffer.length > self.endOffset) {
    var err = new Error("maximum file length exceeded");
    err.code = 'ETOOBIG';
    self.destroy();
    callback(err);
    return;
  }
  self.context.pend.go(function(cb) {
    if (self.destroyed) return cb();
    fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {
      if (err) {
        self.destroy();
        cb();
        callback(err);
      } else {
        self.bytesWritten += bytes;
        self.pos += bytes;
        self.emit('progress');
        cb();
        callback();
      }
    });
  });
};

WriteStream.prototype.destroy = function() {
  if (this.destroyed) return;
  this.destroyed = true;
  this.context.unref();
};

util.inherits(BufferSlicer, EventEmitter);
function BufferSlicer(buffer, options) {
  EventEmitter.call(this);

  options = options || {};
  this.refCount = 0;
  this.buffer = buffer;
  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
}

BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
  var end = position + length;
  var delta = end - this.buffer.length;
  var written = (delta > 0) ? delta : length;
  this.buffer.copy(buffer, offset, position, end);
  setImmediate(function() {
    callback(null, written);
  });
};

BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
  buffer.copy(this.buffer, position, offset, offset + length);
  setImmediate(function() {
    callback(null, length, buffer);
  });
};

BufferSlicer.prototype.createReadStream = function(options) {
  options = options || {};
  var readStream = new PassThrough(options);
  readStream.destroyed = false;
  readStream.start = options.start || 0;
  readStream.endOffset = options.end;
  // by the time this function returns, we'll be done.
  readStream.pos = readStream.endOffset || this.buffer.length;

  // respect the maxChunkSize option to slice up the chunk into smaller pieces.
  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
  var offset = 0;
  while (true) {
    var nextOffset = offset + this.maxChunkSize;
    if (nextOffset >= entireSlice.length) {
      // last chunk
      if (offset < entireSlice.length) {
        readStream.write(entireSlice.slice(offset, entireSlice.length));
      }
      break;
    }
    readStream.write(entireSlice.slice(offset, nextOffset));
    offset = nextOffset;
  }

  readStream.end();
  readStream.destroy = function() {
    readStream.destroyed = true;
  };
  return readStream;
};

BufferSlicer.prototype.createWriteStream = function(options) {
  var bufferSlicer = this;
  options = options || {};
  var writeStream = new Writable(options);
  writeStream.start = options.start || 0;
  writeStream.endOffset = (options.end == null) ? this.buffer.length : +options.end;
  writeStream.bytesWritten = 0;
  writeStream.pos = writeStream.start;
  writeStream.destroyed = false;
  writeStream._write = function(buffer, encoding, callback) {
    if (writeStream.destroyed) return;

    var end = writeStream.pos + buffer.length;
    if (end > writeStream.endOffset) {
      var err = new Error("maximum file length exceeded");
      err.code = 'ETOOBIG';
      writeStream.destroyed = true;
      callback(err);
      return;
    }
    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);

    writeStream.bytesWritten += buffer.length;
    writeStream.pos = end;
    writeStream.emit('progress');
    callback();
  };
  writeStream.destroy = function() {
    writeStream.destroyed = true;
  };
  return writeStream;
};

BufferSlicer.prototype.ref = function() {
  this.refCount += 1;
};

BufferSlicer.prototype.unref = function() {
  this.refCount -= 1;

  if (this.refCount < 0) {
    throw new Error("invalid unref");
  }
};

function createFromBuffer(buffer, options) {
  return new BufferSlicer(buffer, options);
}

function createFromFd(fd, options) {
  return new FdSlicer(fd, options);
}


/***/ }),

/***/ 829:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var debug;

module.exports = function () {
  if (!debug) {
    try {
      /* eslint global-require: off */
      debug = __webpack_require__(5514)("follow-redirects");
    }
    catch (error) { /* */ }
    if (typeof debug !== "function") {
      debug = function () { /* */ };
    }
  }
  debug.apply(null, arguments);
};


/***/ }),

/***/ 6874:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var url = __webpack_require__(8835);
var URL = url.URL;
var http = __webpack_require__(8605);
var https = __webpack_require__(7211);
var Writable = __webpack_require__(2413).Writable;
var assert = __webpack_require__(2357);
var debug = __webpack_require__(829);

// Create handlers that pass events from native requests
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = Object.create(null);
events.forEach(function (event) {
  eventHandlers[event] = function (arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});

// Error types with codes
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded"
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);

// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
  // Initialize the request
  Writable.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];

  // Attach a callback if passed
  if (responseCallback) {
    this.on("response", responseCallback);
  }

  // React to responses of native requests
  var self = this;
  this._onNativeResponse = function (response) {
    self._processResponse(response);
  };

  // Perform the first request
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);

RedirectableRequest.prototype.abort = function () {
  abortRequest(this._currentRequest);
  this.emit("abort");
};

// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function (data, encoding, callback) {
  // Writing is not allowed if end has been called
  if (this._ending) {
    throw new WriteAfterEndError();
  }

  // Validate input and shift parameters if necessary
  if (!(typeof data === "string" || typeof data === "object" && ("length" in data))) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (typeof encoding === "function") {
    callback = encoding;
    encoding = null;
  }

  // Ignore empty buffers, since writing them doesn't invoke the callback
  // https://github.com/nodejs/node/issues/22066
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  // Only write when we don't exceed the maximum body length
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data: data, encoding: encoding });
    this._currentRequest.write(data, encoding, callback);
  }
  // Error when we exceed the maximum body length
  else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};

// Ends the current native request
RedirectableRequest.prototype.end = function (data, encoding, callback) {
  // Shift parameters if necessary
  if (typeof data === "function") {
    callback = data;
    data = encoding = null;
  }
  else if (typeof encoding === "function") {
    callback = encoding;
    encoding = null;
  }

  // Write data if needed and end
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  }
  else {
    var self = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding, function () {
      self._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};

// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function (name, value) {
  this._options.headers[name] = value;
  this._currentRequest.setHeader(name, value);
};

// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function (name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};

// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
  var self = this;

  // Destroys the socket on timeout
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }

  // Sets up a timer to trigger a timeout event
  function startTimer(socket) {
    if (self._timeout) {
      clearTimeout(self._timeout);
    }
    self._timeout = setTimeout(function () {
      self.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }

  // Stops a timeout from triggering
  function clearTimer() {
    // Clear the timeout
    if (self._timeout) {
      clearTimeout(self._timeout);
      self._timeout = null;
    }

    // Clean up all attached listeners
    self.removeListener("abort", clearTimer);
    self.removeListener("error", clearTimer);
    self.removeListener("response", clearTimer);
    if (callback) {
      self.removeListener("timeout", callback);
    }
    if (!self.socket) {
      self._currentRequest.removeListener("socket", startTimer);
    }
  }

  // Attach callback if passed
  if (callback) {
    this.on("timeout", callback);
  }

  // Start the timer if or when the socket is opened
  if (this.socket) {
    startTimer(this.socket);
  }
  else {
    this._currentRequest.once("socket", startTimer);
  }

  // Clean up on events
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);

  return this;
};

// Proxy all other public ClientRequest methods
[
  "flushHeaders", "getHeader",
  "setNoDelay", "setSocketKeepAlive",
].forEach(function (method) {
  RedirectableRequest.prototype[method] = function (a, b) {
    return this._currentRequest[method](a, b);
  };
});

// Proxy all public ClientRequest properties
["aborted", "connection", "socket"].forEach(function (property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function () { return this._currentRequest[property]; },
  });
});

RedirectableRequest.prototype._sanitizeOptions = function (options) {
  // Ensure headers are always present
  if (!options.headers) {
    options.headers = {};
  }

  // Since http.request treats host as an alias of hostname,
  // but the url module interprets host as hostname plus port,
  // eliminate the host property to avoid confusion.
  if (options.host) {
    // Use hostname if set, because it has precedence
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }

  // Complete the URL object when necessary
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    }
    else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};


// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function () {
  // Load the native protocol
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    this.emit("error", new TypeError("Unsupported protocol " + protocol));
    return;
  }

  // If specified, use the agent corresponding to the protocol
  // (HTTP and HTTPS use different types of agents)
  if (this._options.agents) {
    var scheme = protocol.substr(0, protocol.length - 1);
    this._options.agent = this._options.agents[scheme];
  }

  // Create the native request
  var request = this._currentRequest =
        nativeProtocol.request(this._options, this._onNativeResponse);
  this._currentUrl = url.format(this._options);

  // Set up event handlers
  request._redirectable = this;
  for (var e = 0; e < events.length; e++) {
    request.on(events[e], eventHandlers[events[e]]);
  }

  // End a redirected request
  // (The first request must be ended explicitly with RedirectableRequest#end)
  if (this._isRedirect) {
    // Write the request entity and end.
    var i = 0;
    var self = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error) {
      // Only write if this request has not been redirected yet
      /* istanbul ignore else */
      if (request === self._currentRequest) {
        // Report any write errors
        /* istanbul ignore if */
        if (error) {
          self.emit("error", error);
        }
        // Write the next buffer if there are still left
        else if (i < buffers.length) {
          var buffer = buffers[i++];
          /* istanbul ignore else */
          if (!request.finished) {
            request.write(buffer.data, buffer.encoding, writeNext);
          }
        }
        // End the request if `end` has been called on us
        else if (self._ended) {
          request.end();
        }
      }
    }());
  }
};

// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function (response) {
  // Store the redirected response
  var statusCode = response.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode: statusCode,
    });
  }

  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
  // that further action needs to be taken by the user agent in order to
  // fulfill the request. If a Location header field is provided,
  // the user agent MAY automatically redirect its request to the URI
  // referenced by the Location field value,
  // even if the specific status code is not understood.
  var location = response.headers.location;
  if (location && this._options.followRedirects !== false &&
      statusCode >= 300 && statusCode < 400) {
    // Abort the current request
    abortRequest(this._currentRequest);
    // Discard the remainder of the response to avoid waiting for data
    response.destroy();

    // RFC7231§6.4: A client SHOULD detect and intervene
    // in cyclical redirections (i.e., "infinite" redirection loops).
    if (++this._redirectCount > this._options.maxRedirects) {
      this.emit("error", new TooManyRedirectsError());
      return;
    }

    // RFC7231§6.4: Automatic redirection needs to done with
    // care for methods not known to be safe, […]
    // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change
    // the request method from POST to GET for the subsequent request.
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
        // RFC7231§6.4.4: The 303 (See Other) status code indicates that
        // the server is redirecting the user agent to a different resource […]
        // A user agent can perform a retrieval request targeting that URI
        // (a GET or HEAD request if using HTTP) […]
        (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
      this._options.method = "GET";
      // Drop a possible entity and headers related to it
      this._requestBodyBuffers = [];
      removeMatchingHeaders(/^content-/i, this._options.headers);
    }

    // Drop the Host header, as the redirect might lead to a different host
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

    // If the redirect is relative, carry over the host of the last request
    var currentUrlParts = url.parse(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
      url.format(Object.assign(currentUrlParts, { host: currentHost }));

    // Determine the URL of the redirection
    var redirectUrl;
    try {
      redirectUrl = url.resolve(currentUrl, location);
    }
    catch (cause) {
      this.emit("error", new RedirectionError(cause));
      return;
    }

    // Create the redirected request
    debug("redirecting to", redirectUrl);
    this._isRedirect = true;
    var redirectUrlParts = url.parse(redirectUrl);
    Object.assign(this._options, redirectUrlParts);

    // Drop the confidential headers when redirecting to another domain
    if (!(redirectUrlParts.host === currentHost || isSubdomainOf(redirectUrlParts.host, currentHost))) {
      removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
    }

    // Evaluate the beforeRedirect callback
    if (typeof this._options.beforeRedirect === "function") {
      var responseDetails = { headers: response.headers };
      try {
        this._options.beforeRedirect.call(null, this._options, responseDetails);
      }
      catch (err) {
        this.emit("error", err);
        return;
      }
      this._sanitizeOptions(this._options);
    }

    // Perform the redirected request
    try {
      this._performRequest();
    }
    catch (cause) {
      this.emit("error", new RedirectionError(cause));
    }
  }
  else {
    // The response is not a redirect; return it as-is
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response);

    // Clean up
    this._requestBodyBuffers = [];
  }
};

// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
  // Default settings
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024,
  };

  // Wrap each protocol
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function (scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

    // Executes a request, following redirects
    function request(input, options, callback) {
      // Parse parameters
      if (typeof input === "string") {
        var urlStr = input;
        try {
          input = urlToOptions(new URL(urlStr));
        }
        catch (err) {
          /* istanbul ignore next */
          input = url.parse(urlStr);
        }
      }
      else if (URL && (input instanceof URL)) {
        input = urlToOptions(input);
      }
      else {
        callback = options;
        options = input;
        input = { protocol: protocol };
      }
      if (typeof options === "function") {
        callback = options;
        options = null;
      }

      // Set defaults
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength,
      }, input, options);
      options.nativeProtocols = nativeProtocols;

      assert.equal(options.protocol, protocol, "protocol mismatch");
      debug("options", options);
      return new RedirectableRequest(options, callback);
    }

    // Executes a GET request, following redirects
    function get(input, options, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }

    // Expose the properties on the wrapped protocol
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get, configurable: true, enumerable: true, writable: true },
    });
  });
  return exports;
}

/* istanbul ignore next */
function noop() { /* empty */ }

// from https://github.com/nodejs/node/blob/master/lib/internal/url.js
function urlToOptions(urlObject) {
  var options = {
    protocol: urlObject.protocol,
    hostname: urlObject.hostname.startsWith("[") ?
      /* istanbul ignore next */
      urlObject.hostname.slice(1, -1) :
      urlObject.hostname,
    hash: urlObject.hash,
    search: urlObject.search,
    pathname: urlObject.pathname,
    path: urlObject.pathname + urlObject.search,
    href: urlObject.href,
  };
  if (urlObject.port !== "") {
    options.port = Number(urlObject.port);
  }
  return options;
}

function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return (lastValue === null || typeof lastValue === "undefined") ?
    undefined : String(lastValue).trim();
}

function createErrorType(code, defaultMessage) {
  function CustomError(cause) {
    Error.captureStackTrace(this, this.constructor);
    if (!cause) {
      this.message = defaultMessage;
    }
    else {
      this.message = defaultMessage + ": " + cause.message;
      this.cause = cause;
    }
  }
  CustomError.prototype = new Error();
  CustomError.prototype.constructor = CustomError;
  CustomError.prototype.name = "Error [" + code + "]";
  CustomError.prototype.code = code;
  return CustomError;
}

function abortRequest(request) {
  for (var e = 0; e < events.length; e++) {
    request.removeListener(events[e], eventHandlers[events[e]]);
  }
  request.on("error", noop);
  request.abort();
}

function isSubdomainOf(subdomain, domain) {
  const dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}

// Exports
module.exports = wrap({ http: http, https: https });
module.exports.wrap = wrap;


/***/ }),

/***/ 3247:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = realpath
realpath.realpath = realpath
realpath.sync = realpathSync
realpath.realpathSync = realpathSync
realpath.monkeypatch = monkeypatch
realpath.unmonkeypatch = unmonkeypatch

var fs = __webpack_require__(5747)
var origRealpath = fs.realpath
var origRealpathSync = fs.realpathSync

var version = process.version
var ok = /^v[0-5]\./.test(version)
var old = __webpack_require__(5962)

function newError (er) {
  return er && er.syscall === 'realpath' && (
    er.code === 'ELOOP' ||
    er.code === 'ENOMEM' ||
    er.code === 'ENAMETOOLONG'
  )
}

function realpath (p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb)
  }

  if (typeof cache === 'function') {
    cb = cache
    cache = null
  }
  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb)
    } else {
      cb(er, result)
    }
  })
}

function realpathSync (p, cache) {
  if (ok) {
    return origRealpathSync(p, cache)
  }

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache)
    } else {
      throw er
    }
  }
}

function monkeypatch () {
  fs.realpath = realpath
  fs.realpathSync = realpathSync
}

function unmonkeypatch () {
  fs.realpath = origRealpath
  fs.realpathSync = origRealpathSync
}


/***/ }),

/***/ 5962:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var pathModule = __webpack_require__(5622);
var isWindows = process.platform === 'win32';
var fs = __webpack_require__(5747);

// JavaScript implementation of realpath, ported from node pre-v6

var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (DEBUG) {
    var backtrace = new Error;
    callback = debugCallback;
  } else
    callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
        var msg = 'fs: missing callback ' + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

var normalize = pathModule.normalize;

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}

exports.realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};


exports.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstat(base, function(err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs.stat(base, function(err) {
      if (err) return cb(err);

      fs.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};


/***/ }),

/***/ 73:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.alphasort = alphasort
exports.alphasorti = alphasorti
exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark
exports.isIgnored = isIgnored
exports.childrenIgnored = childrenIgnored

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var path = __webpack_require__(5622)
var minimatch = __webpack_require__(5076)
var isAbsolute = __webpack_require__(9991)
var Minimatch = minimatch.Minimatch

function alphasorti (a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase())
}

function alphasort (a, b) {
  return a.localeCompare(b)
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || []

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore]

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap)
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
    gmatcher = new Minimatch(gpattern, { dot: true })
  }

  return {
    matcher: new Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {}

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern
  }

  self.silent = !!options.silent
  self.pattern = pattern
  self.strict = options.strict !== false
  self.realpath = !!options.realpath
  self.realpathCache = options.realpathCache || Object.create(null)
  self.follow = !!options.follow
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir)
    self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess
  self.absolute = !!options.absolute

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  setupIgnores(self, options)

  self.changedCwd = false
  var cwd = process.cwd()
  if (!ownProp(options, "cwd"))
    self.cwd = cwd
  else {
    self.cwd = path.resolve(options.cwd)
    self.changedCwd = self.cwd !== cwd
  }

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/")

  // TODO: is an absolute `cwd` supposed to be resolved against `root`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
  if (process.platform === "win32")
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/")
  self.nomount = !!options.nomount

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true
  options.nocomment = true

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish (self) {
  var nou = self.nounique
  var all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i]
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i]
        if (nou)
          all.push(literal)
        else
          all[literal] = true
      }
    } else {
      // had matches
      var m = Object.keys(matches)
      if (nou)
        all.push.apply(all, m)
      else
        m.forEach(function (m) {
          all[m] = true
        })
    }
  }

  if (!nou)
    all = Object.keys(all)

  if (!self.nosort)
    all = all.sort(self.nocase ? alphasorti : alphasort)

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i])
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e))
        var c = self.cache[e] || self.cache[makeAbs(self, e)]
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c)
        return notDir
      })
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    })

  self.found = all
}

function mark (self, p) {
  var abs = makeAbs(self, p)
  var c = self.cache[abs]
  var m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c)
    var slash = p.slice(-1) === '/'

    if (isDir && !slash)
      m += '/'
    else if (!isDir && slash)
      m = m.slice(0, -1)

    if (m !== p) {
      var mabs = makeAbs(self, m)
      self.statCache[mabs] = self.statCache[abs]
      self.cache[mabs] = self.cache[abs]
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f
  if (f.charAt(0) === '/') {
    abs = path.join(self.root, f)
  } else if (isAbsolute(f) || f === '') {
    abs = f
  } else if (self.changedCwd) {
    abs = path.resolve(self.cwd, f)
  } else {
    abs = path.resolve(f)
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/')

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}


/***/ }),

/***/ 6825:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var fs = __webpack_require__(5747)
var rp = __webpack_require__(3247)
var minimatch = __webpack_require__(5076)
var Minimatch = minimatch.Minimatch
var inherits = __webpack_require__(1947)
var EE = __webpack_require__(8614).EventEmitter
var path = __webpack_require__(5622)
var assert = __webpack_require__(2357)
var isAbsolute = __webpack_require__(9991)
var globSync = __webpack_require__(4142)
var common = __webpack_require__(73)
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = __webpack_require__(8156)
var util = __webpack_require__(1669)
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

var once = __webpack_require__(8034)

function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add)
  var i = keys.length
  while (i--) {
    origin[keys[i]] = add[keys[i]]
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  this._processing = 0

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }
  sync = false

  function done () {
    --self._processing
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish()
        })
      } else {
        self._finish()
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0)
    return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next)

  function next () {
    if (--n === 0)
      self._finish()
  }
}

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index]
  if (!matchset)
    return cb()

  var found = Object.keys(matchset)
  var self = this
  var n = found.length

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null)
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p)
    rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true
      else if (er.syscall === 'stat')
        set[p] = true
      else
        self.emit('error', er) // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume')
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip _processing
  if (childrenIgnored(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e
      else
        e = prefix + e
    }
    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (isIgnored(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  var abs = isAbsolute(e) ? e : this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute)
    e = abs

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  var st = this.statCache[abs]
  if (st)
    this.emit('stat', e, st)

  this.emit('match', e)
}

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs
  var self = this
  var lstatcb = inflight(lstatkey, lstatcb_)

  if (lstatcb)
    fs.lstat(abs, lstatcb)

  function lstatcb_ (er, lstat) {
    if (er && er.code === 'ENOENT')
      return cb()

    var isSym = lstat && lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else
      self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this
  fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb)
    else
      self._readdirEntries(abs, entries, cb)
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        this.emit('error', error)
        this.abort()
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict) {
        this.emit('error', er)
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort()
      }
      if (!this.silent)
        console.error('glob error', er)
      break
  }

  return cb()
}

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs]
  var len = entries.length

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
  cb()
}

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE'
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this
  var statcb = inflight('stat\0' + abs, lstatcb_)
  if (statcb)
    fs.lstat(abs, statcb)

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return fs.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb)
        else
          self._stat2(f, abs, er, stat, cb)
      })
    } else {
      self._stat2(f, abs, er, lstat, cb)
    }
  }
}

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false
    return cb()
  }

  var needDir = f.slice(-1) === '/'
  this.statCache[abs] = stat

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
    return cb(null, false, stat)

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return cb()

  return cb(null, c, stat)
}


/***/ }),

/***/ 4142:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = globSync
globSync.GlobSync = GlobSync

var fs = __webpack_require__(5747)
var rp = __webpack_require__(3247)
var minimatch = __webpack_require__(5076)
var Minimatch = minimatch.Minimatch
var Glob = __webpack_require__(6825).Glob
var util = __webpack_require__(1669)
var path = __webpack_require__(5622)
var assert = __webpack_require__(2357)
var isAbsolute = __webpack_require__(9991)
var common = __webpack_require__(73)
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false)
  }
  this._finish()
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync)
  if (this.realpath) {
    var self = this
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null)
      for (var p in matchset) {
        try {
          p = self._makeAbs(p)
          var real = rp.realpathSync(p, self.realpathCache)
          set[real] = true
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true
          else
            throw er
        }
      }
    })
  }
  common.finish(this)
}


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip processing
  if (childrenIgnored(this, read))
    return

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix)
      newPattern = [prefix, e]
    else
      newPattern = [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}


GlobSync.prototype._emitMatch = function (index, e) {
  if (isIgnored(this, e))
    return

  var abs = this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute) {
    e = abs
  }

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  if (this.stat)
    this._stat(e)
}


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries
  var lstat
  var stat
  try {
    lstat = fs.lstatSync(abs)
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null
    }
  }

  var isSym = lstat && lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && lstat && !lstat.isDirectory())
    this.cache[abs] = 'FILE'
  else
    entries = this._readdir(abs, false)

  return entries
}

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries

  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries

  // mark and cache dir-ness
  return entries
}

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er)
      break
  }
}

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false)

  var len = entries.length
  var isSym = this.symlinks[abs]

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
}

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (!stat) {
    var lstat
    try {
      lstat = fs.lstatSync(abs)
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = fs.statSync(abs)
      } catch (er) {
        stat = lstat
      }
    } else {
      stat = lstat
    }
  }

  this.statCache[abs] = stat

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'

  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return false

  return c
}

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}


/***/ }),

/***/ 6275:
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ 1714:
/***/ ((module) => {

"use strict";

const hasOwnProp = Object.prototype.hasOwnProperty;

module.exports = (object, property) => hasOwnProp.call(object, property);


/***/ }),

/***/ 6638:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

var net = __webpack_require__(1631);
var tls = __webpack_require__(4016);
var url = __webpack_require__(8835);
var assert = __webpack_require__(2357);
var Agent = __webpack_require__(1509);
var inherits = __webpack_require__(1669).inherits;
var debug = __webpack_require__(6166)('https-proxy-agent');

/**
 * Module exports.
 */

module.exports = HttpsProxyAgent;

/**
 * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to the
 * specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
 *
 * @api public
 */

function HttpsProxyAgent(opts) {
	if (!(this instanceof HttpsProxyAgent)) return new HttpsProxyAgent(opts);
	if ('string' == typeof opts) opts = url.parse(opts);
	if (!opts)
		throw new Error(
			'an HTTP(S) proxy server `host` and `port` must be specified!'
		);
	debug('creating new HttpsProxyAgent instance: %o', opts);
	Agent.call(this, opts);

	var proxy = Object.assign({}, opts);

	// if `true`, then connect to the proxy server over TLS. defaults to `false`.
	this.secureProxy = proxy.protocol
		? /^https:?$/i.test(proxy.protocol)
		: false;

	// prefer `hostname` over `host`, and set the `port` if needed
	proxy.host = proxy.hostname || proxy.host;
	proxy.port = +proxy.port || (this.secureProxy ? 443 : 80);

	// ALPN is supported by Node.js >= v5.
	// attempt to negotiate http/1.1 for proxy servers that support http/2
	if (this.secureProxy && !('ALPNProtocols' in proxy)) {
		proxy.ALPNProtocols = ['http 1.1'];
	}

	if (proxy.host && proxy.path) {
		// if both a `host` and `path` are specified then it's most likely the
		// result of a `url.parse()` call... we need to remove the `path` portion so
		// that `net.connect()` doesn't attempt to open that as a unix socket file.
		delete proxy.path;
		delete proxy.pathname;
	}

	this.proxy = proxy;
	this.defaultPort = 443;
}
inherits(HttpsProxyAgent, Agent);

/**
 * Called when the node-core HTTP client library is creating a new HTTP request.
 *
 * @api public
 */

HttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {
	var proxy = this.proxy;

	// create a socket connection to the proxy server
	var socket;
	if (this.secureProxy) {
		socket = tls.connect(proxy);
	} else {
		socket = net.connect(proxy);
	}

	// we need to buffer any HTTP traffic that happens with the proxy before we get
	// the CONNECT response, so that if the response is anything other than an "200"
	// response code, then we can re-play the "data" events on the socket once the
	// HTTP parser is hooked up...
	var buffers = [];
	var buffersLength = 0;

	function read() {
		var b = socket.read();
		if (b) ondata(b);
		else socket.once('readable', read);
	}

	function cleanup() {
		socket.removeListener('end', onend);
		socket.removeListener('error', onerror);
		socket.removeListener('close', onclose);
		socket.removeListener('readable', read);
	}

	function onclose(err) {
		debug('onclose had error %o', err);
	}

	function onend() {
		debug('onend');
	}

	function onerror(err) {
		cleanup();
		fn(err);
	}

	function ondata(b) {
		buffers.push(b);
		buffersLength += b.length;
		var buffered = Buffer.concat(buffers, buffersLength);
		var str = buffered.toString('ascii');

		if (!~str.indexOf('\r\n\r\n')) {
			// keep buffering
			debug('have not received end of HTTP headers yet...');
			read();
			return;
		}

		var firstLine = str.substring(0, str.indexOf('\r\n'));
		var statusCode = +firstLine.split(' ')[1];
		debug('got proxy server response: %o', firstLine);

		if (200 == statusCode) {
			// 200 Connected status code!
			var sock = socket;

			// nullify the buffered data since we won't be needing it
			buffers = buffered = null;

			if (opts.secureEndpoint) {
				// since the proxy is connecting to an SSL server, we have
				// to upgrade this socket connection to an SSL connection
				debug(
					'upgrading proxy-connected socket to TLS connection: %o',
					opts.host
				);
				opts.socket = socket;
				opts.servername = opts.servername || opts.host;
				opts.host = null;
				opts.hostname = null;
				opts.port = null;
				sock = tls.connect(opts);
			}

			cleanup();
			req.once('socket', resume);
			fn(null, sock);
		} else {
			// some other status code that's not 200... need to re-play the HTTP header
			// "data" events onto the socket once the HTTP machinery is attached so
			// that the node core `http` can parse and handle the error status code
			cleanup();

			// the original socket is closed, and a new closed socket is
			// returned instead, so that the proxy doesn't get the HTTP request
			// written to it (which may contain `Authorization` headers or other
			// sensitive data).
			//
			// See: https://hackerone.com/reports/541502
			socket.destroy();
			socket = new net.Socket();
			socket.readable = true;


			// save a reference to the concat'd Buffer for the `onsocket` callback
			buffers = buffered;

			// need to wait for the "socket" event to re-play the "data" events
			req.once('socket', onsocket);

			fn(null, socket);
		}
	}

	function onsocket(socket) {
		debug('replaying proxy buffer for failed request');
		assert(socket.listenerCount('data') > 0);

		// replay the "buffers" Buffer onto the `socket`, since at this point
		// the HTTP module machinery has been hooked up for the user
		socket.push(buffers);

		// nullify the cached Buffer instance
		buffers = null;
	}

	socket.on('error', onerror);
	socket.on('close', onclose);
	socket.on('end', onend);

	read();

	var hostname = opts.host + ':' + opts.port;
	var msg = 'CONNECT ' + hostname + ' HTTP/1.1\r\n';

	var headers = Object.assign({}, proxy.headers);
	if (proxy.auth) {
		headers['Proxy-Authorization'] =
			'Basic ' + Buffer.from(proxy.auth).toString('base64');
	}

	// the Host header should only include the port
	// number when it is a non-standard port
	var host = opts.host;
	if (!isDefaultPort(opts.port, opts.secureEndpoint)) {
		host += ':' + opts.port;
	}
	headers['Host'] = host;

	headers['Connection'] = 'close';
	Object.keys(headers).forEach(function(name) {
		msg += name + ': ' + headers[name] + '\r\n';
	});

	socket.write(msg + '\r\n');
};

/**
 * Resumes a socket.
 *
 * @param {(net.Socket|tls.Socket)} socket The socket to resume
 * @api public
 */

function resume(socket) {
	socket.resume();
}

function isDefaultPort(port, secure) {
	return Boolean((!secure && port === 80) || (secure && port === 443));
}


/***/ }),

/***/ 7476:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = __webpack_require__(4226)(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};



/***/ }),

/***/ 4226:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = __webpack_require__(8632);
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      // Disabled?
      if (!debug.enabled) {
        return;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;



/***/ }),

/***/ 6166:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */
if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
  module.exports = __webpack_require__(7476);
} else {
  module.exports = __webpack_require__(2720);
}



/***/ }),

/***/ 2720:
/***/ ((module, exports, __webpack_require__) => {

"use strict";


/**
 * Module dependencies.
 */
var tty = __webpack_require__(3867);

var util = __webpack_require__(1669);
/**
 * This is the Node.js implementation of `debug()`.
 */


exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
  // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
  // eslint-disable-next-line import/no-extraneous-dependencies
  var supportsColor = __webpack_require__(7581);

  if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
    exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
  }
} catch (error) {} // Swallow - we only care if `supports-color` is available; it doesn't have to be.

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */


exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // Camel-case
  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
    return k.toUpperCase();
  }); // Coerce string value into JS value

  var val = process.env[key];

  if (/^(yes|on|true|enabled)$/i.test(val)) {
    val = true;
  } else if (/^(no|off|false|disabled)$/i.test(val)) {
    val = false;
  } else if (val === 'null') {
    val = null;
  } else {
    val = Number(val);
  }

  obj[prop] = val;
  return obj;
}, {});
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  var name = this.namespace,
      useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var colorCode = "\x1B[3" + (c < 8 ? c : '8;5;' + c);
    var prefix = "  ".concat(colorCode, ";1m").concat(name, " \x1B[0m");
    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + "\x1B[0m");
  } else {
    args[0] = getDate() + name + ' ' + args[0];
  }
}

function getDate() {
  if (exports.inspectOpts.hideDate) {
    return '';
  }

  return new Date().toISOString() + ' ';
}
/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */


function log() {
  return process.stderr.write(util.format.apply(util, arguments) + '\n');
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  if (namespaces) {
    process.env.DEBUG = namespaces;
  } else {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  return process.env.DEBUG;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */


function init(debug) {
  debug.inspectOpts = {};
  var keys = Object.keys(exports.inspectOpts);

  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

module.exports = __webpack_require__(4226)(exports);
var formatters = module.exports.formatters;
/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n')
    .map(function (str) { return str.trim(); })
    .join(' ');
};
/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */


formatters.O = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};



/***/ }),

/***/ 8156:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(7534)
var reqs = Object.create(null)
var once = __webpack_require__(8034)

module.exports = wrappy(inflight)

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb)
    return null
  } else {
    reqs[key] = [cb]
    return makeres(key)
  }
}

function makeres (key) {
  return once(function RES () {
    var cbs = reqs[key]
    var len = cbs.length
    var args = slice(arguments)

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args)
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len)
        process.nextTick(function () {
          RES.apply(null, args)
        })
      } else {
        delete reqs[key]
      }
    }
  })
}

function slice (args) {
  var length = args.length
  var array = []

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
}


/***/ }),

/***/ 1947:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
  var util = __webpack_require__(1669);
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__(7442);
}


/***/ }),

/***/ 7442:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 4219:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(5747)
var core
if (process.platform === 'win32' || global.TESTING_WINDOWS) {
  core = __webpack_require__(2514)
} else {
  core = __webpack_require__(7305)
}

module.exports = isexe
isexe.sync = sync

function isexe (path, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  if (!cb) {
    if (typeof Promise !== 'function') {
      throw new TypeError('callback not provided')
    }

    return new Promise(function (resolve, reject) {
      isexe(path, options || {}, function (er, is) {
        if (er) {
          reject(er)
        } else {
          resolve(is)
        }
      })
    })
  }

  core(path, options || {}, function (er, is) {
    // ignore EACCES because that just means we aren't allowed to run it
    if (er) {
      if (er.code === 'EACCES' || options && options.ignoreErrors) {
        er = null
        is = false
      }
    }
    cb(er, is)
  })
}

function sync (path, options) {
  // my kingdom for a filtered catch
  try {
    return core.sync(path, options || {})
  } catch (er) {
    if (options && options.ignoreErrors || er.code === 'EACCES') {
      return false
    } else {
      throw er
    }
  }
}


/***/ }),

/***/ 7305:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = isexe
isexe.sync = sync

var fs = __webpack_require__(5747)

function isexe (path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, options))
  })
}

function sync (path, options) {
  return checkStat(fs.statSync(path), options)
}

function checkStat (stat, options) {
  return stat.isFile() && checkMode(stat, options)
}

function checkMode (stat, options) {
  var mod = stat.mode
  var uid = stat.uid
  var gid = stat.gid

  var myUid = options.uid !== undefined ?
    options.uid : process.getuid && process.getuid()
  var myGid = options.gid !== undefined ?
    options.gid : process.getgid && process.getgid()

  var u = parseInt('100', 8)
  var g = parseInt('010', 8)
  var o = parseInt('001', 8)
  var ug = u | g

  var ret = (mod & o) ||
    (mod & g) && gid === myGid ||
    (mod & u) && uid === myUid ||
    (mod & ug) && myUid === 0

  return ret
}


/***/ }),

/***/ 2514:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = isexe
isexe.sync = sync

var fs = __webpack_require__(5747)

function checkPathExt (path, options) {
  var pathext = options.pathExt !== undefined ?
    options.pathExt : process.env.PATHEXT

  if (!pathext) {
    return true
  }

  pathext = pathext.split(';')
  if (pathext.indexOf('') !== -1) {
    return true
  }
  for (var i = 0; i < pathext.length; i++) {
    var p = pathext[i].toLowerCase()
    if (p && path.substr(-p.length).toLowerCase() === p) {
      return true
    }
  }
  return false
}

function checkStat (stat, path, options) {
  if (!stat.isSymbolicLink() && !stat.isFile()) {
    return false
  }
  return checkPathExt(path, options)
}

function isexe (path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, path, options))
  })
}

function sync (path, options) {
  return checkStat(fs.statSync(path), path, options)
}


/***/ }),

/***/ 5076:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = { sep: '/' }
try {
  path = __webpack_require__(5622)
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __webpack_require__(9158)

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long')
  }

  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ 8632:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ 8034:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(7534)
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ 9991:
/***/ ((module) => {

"use strict";


function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;


/***/ }),

/***/ 277:
/***/ ((module) => {

module.exports = Pend;

function Pend() {
  this.pending = 0;
  this.max = Infinity;
  this.listeners = [];
  this.waiting = [];
  this.error = null;
}

Pend.prototype.go = function(fn) {
  if (this.pending < this.max) {
    pendGo(this, fn);
  } else {
    this.waiting.push(fn);
  }
};

Pend.prototype.wait = function(cb) {
  if (this.pending === 0) {
    cb(this.error);
  } else {
    this.listeners.push(cb);
  }
};

Pend.prototype.hold = function() {
  return pendHold(this);
};

function pendHold(self) {
  self.pending += 1;
  var called = false;
  return onCb;
  function onCb(err) {
    if (called) throw new Error("callback called twice");
    called = true;
    self.error = self.error || err;
    self.pending -= 1;
    if (self.waiting.length > 0 && self.pending < self.max) {
      pendGo(self, self.waiting.shift());
    } else if (self.pending === 0) {
      var listeners = self.listeners;
      self.listeners = [];
      listeners.forEach(cbListener);
    }
  }
  function cbListener(listener) {
    listener(self.error);
  }
}

function pendGo(self, fn) {
  fn(pendHold(self));
}


/***/ }),

/***/ 6540:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Parser functions.
 */

var parserFunctions = __webpack_require__(2307);
Object.keys(parserFunctions).forEach(function (k) { exports[k] = parserFunctions[k]; });

/**
 * Builder functions.
 */

var builderFunctions = __webpack_require__(4473);
Object.keys(builderFunctions).forEach(function (k) { exports[k] = builderFunctions[k]; });


/***/ }),

/***/ 4473:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

var base64 = __webpack_require__(1759);
var xmlbuilder = __webpack_require__(2066);

/**
 * Module exports.
 */

exports.build = build;

/**
 * Accepts a `Date` instance and returns an ISO date string.
 *
 * @param {Date} d - Date instance to serialize
 * @returns {String} ISO date string representation of `d`
 * @api private
 */

function ISODateString(d){
  function pad(n){
    return n < 10 ? '0' + n : n;
  }
  return d.getUTCFullYear()+'-'
    + pad(d.getUTCMonth()+1)+'-'
    + pad(d.getUTCDate())+'T'
    + pad(d.getUTCHours())+':'
    + pad(d.getUTCMinutes())+':'
    + pad(d.getUTCSeconds())+'Z';
}

/**
 * Returns the internal "type" of `obj` via the
 * `Object.prototype.toString()` trick.
 *
 * @param {Mixed} obj - any value
 * @returns {String} the internal "type" name
 * @api private
 */

var toString = Object.prototype.toString;
function type (obj) {
  var m = toString.call(obj).match(/\[object (.*)\]/);
  return m ? m[1] : m;
}

/**
 * Generate an XML plist string from the input object `obj`.
 *
 * @param {Object} obj - the object to convert
 * @param {Object} [opts] - optional options object
 * @returns {String} converted plist XML string
 * @api public
 */

function build (obj, opts) {
  var XMLHDR = {
    version: '1.0',
    encoding: 'UTF-8'
  };

  var XMLDTD = {
    pubid: '-//Apple//DTD PLIST 1.0//EN',
    sysid: 'http://www.apple.com/DTDs/PropertyList-1.0.dtd'
  };

  var doc = xmlbuilder.create('plist');

  doc.dec(XMLHDR.version, XMLHDR.encoding, XMLHDR.standalone);
  doc.dtd(XMLDTD.pubid, XMLDTD.sysid);
  doc.att('version', '1.0');

  walk_obj(obj, doc);

  if (!opts) opts = {};
  // default `pretty` to `true`
  opts.pretty = opts.pretty !== false;
  return doc.end(opts);
}

/**
 * depth first, recursive traversal of a javascript object. when complete,
 * next_child contains a reference to the build XML object.
 *
 * @api private
 */

function walk_obj(next, next_child) {
  var tag_type, i, prop;
  var name = type(next);

  if ('Undefined' == name) {
    return;
  } else if (Array.isArray(next)) {
    next_child = next_child.ele('array');
    for (i = 0; i < next.length; i++) {
      walk_obj(next[i], next_child);
    }

  } else if (Buffer.isBuffer(next)) {
    next_child.ele('data').raw(next.toString('base64'));

  } else if ('Object' == name) {
    next_child = next_child.ele('dict');
    for (prop in next) {
      if (next.hasOwnProperty(prop)) {
        next_child.ele('key').txt(prop);
        walk_obj(next[prop], next_child);
      }
    }

  } else if ('Number' == name) {
    // detect if this is an integer or real
    // TODO: add an ability to force one way or another via a "cast"
    tag_type = (next % 1 === 0) ? 'integer' : 'real';
    next_child.ele(tag_type).txt(next.toString());

  } else if ('Date' == name) {
    next_child.ele('date').txt(ISODateString(new Date(next)));

  } else if ('Boolean' == name) {
    next_child.ele(next ? 'true' : 'false');

  } else if ('String' == name) {
    next_child.ele('string').txt(next);

  } else if ('ArrayBuffer' == name) {
    next_child.ele('data').raw(base64.fromByteArray(next));

  } else if (next && next.buffer && 'ArrayBuffer' == type(next.buffer)) {
    // a typed array
    next_child.ele('data').raw(base64.fromByteArray(new Uint8Array(next.buffer), next_child));

  }
}


/***/ }),

/***/ 2307:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

var DOMParser = __webpack_require__(4466)/* .DOMParser */ .a;

/**
 * Module exports.
 */

exports.parse = parse;

var TEXT_NODE = 3;
var CDATA_NODE = 4;
var COMMENT_NODE = 8;


/**
 * We ignore raw text (usually whitespace), <!-- xml comments -->,
 * and raw CDATA nodes.
 *
 * @param {Element} node
 * @returns {Boolean}
 * @api private
 */

function shouldIgnoreNode (node) {
  return node.nodeType === TEXT_NODE
    || node.nodeType === COMMENT_NODE
    || node.nodeType === CDATA_NODE;
}

/**
 * Check if the node is empty. Some plist file has such node:
 * <key />
 * this node shoud be ignored.
 *
 * @see https://github.com/TooTallNate/plist.js/issues/66
 * @param {Element} node
 * @returns {Boolean}
 * @api private
 */
function isEmptyNode(node){
  if(!node.childNodes || node.childNodes.length === 0) {
    return true;
  } else {
    return false;
  }
}

function invariant(test, message) {
  if (!test) {
    throw new Error(message);
  }
}

/**
 * Parses a Plist XML string. Returns an Object.
 *
 * @param {String} xml - the XML String to decode
 * @returns {Mixed} the decoded value from the Plist XML
 * @api public
 */

function parse (xml) {
  var doc = new DOMParser().parseFromString(xml);
  invariant(
    doc.documentElement.nodeName === 'plist',
    'malformed document. First element should be <plist>'
  );
  var plist = parsePlistXML(doc.documentElement);

  // the root <plist> node gets interpreted as an Array,
  // so pull out the inner data first
  if (plist.length == 1) plist = plist[0];

  return plist;
}

/**
 * Convert an XML based plist document into a JSON representation.
 *
 * @param {Object} xml_node - current XML node in the plist
 * @returns {Mixed} built up JSON object
 * @api private
 */

function parsePlistXML (node) {
  var i, new_obj, key, val, new_arr, res, counter, type;

  if (!node)
    return null;

  if (node.nodeName === 'plist') {
    new_arr = [];
    if (isEmptyNode(node)) {
      return new_arr;
    }
    for (i=0; i < node.childNodes.length; i++) {
      if (!shouldIgnoreNode(node.childNodes[i])) {
        new_arr.push( parsePlistXML(node.childNodes[i]));
      }
    }
    return new_arr;
  } else if (node.nodeName === 'dict') {
    new_obj = {};
    key = null;
    counter = 0;
    if (isEmptyNode(node)) {
      return new_obj;
    }
    for (i=0; i < node.childNodes.length; i++) {
      if (shouldIgnoreNode(node.childNodes[i])) continue;
      if (counter % 2 === 0) {
        invariant(
          node.childNodes[i].nodeName === 'key',
          'Missing key while parsing <dict/>.'
        );
        key = parsePlistXML(node.childNodes[i]);
      } else {
        invariant(
          node.childNodes[i].nodeName !== 'key',
          'Unexpected key "'
            + parsePlistXML(node.childNodes[i])
            + '" while parsing <dict/>.'
        );
        new_obj[key] = parsePlistXML(node.childNodes[i]);
      }
      counter += 1;
    }
    if (counter % 2 === 1) {
      throw new Error('Missing value for "' + key + '" while parsing <dict/>');
    }
    return new_obj;

  } else if (node.nodeName === 'array') {
    new_arr = [];
    if (isEmptyNode(node)) {
      return new_arr;
    }
    for (i=0; i < node.childNodes.length; i++) {
      if (!shouldIgnoreNode(node.childNodes[i])) {
        res = parsePlistXML(node.childNodes[i]);
        if (null != res) new_arr.push(res);
      }
    }
    return new_arr;

  } else if (node.nodeName === '#text') {
    // TODO: what should we do with text types? (CDATA sections)

  } else if (node.nodeName === 'key') {
    if (isEmptyNode(node)) {
      return '';
    }
    return node.childNodes[0].nodeValue;
  } else if (node.nodeName === 'string') {
    res = '';
    if (isEmptyNode(node)) {
      return res;
    }
    for (i=0; i < node.childNodes.length; i++) {
      var type = node.childNodes[i].nodeType;
      if (type === TEXT_NODE || type === CDATA_NODE) {
        res += node.childNodes[i].nodeValue;
      }
    }
    return res;

  } else if (node.nodeName === 'integer') {
    invariant(
      !isEmptyNode(node),
      'Cannot parse "" as integer.'
    );
    return parseInt(node.childNodes[0].nodeValue, 10);

  } else if (node.nodeName === 'real') {
    invariant(
      !isEmptyNode(node),
      'Cannot parse "" as real.'
    );
    res = '';
    for (i=0; i < node.childNodes.length; i++) {
      if (node.childNodes[i].nodeType === TEXT_NODE) {
        res += node.childNodes[i].nodeValue;
      }
    }
    return parseFloat(res);

  } else if (node.nodeName === 'data') {
    res = '';
    if (isEmptyNode(node)) {
      return Buffer.from(res, 'base64');
    }
    for (i=0; i < node.childNodes.length; i++) {
      if (node.childNodes[i].nodeType === TEXT_NODE) {
        res += node.childNodes[i].nodeValue.replace(/\s+/g, '');
      }
    }
    return Buffer.from(res, 'base64');

  } else if (node.nodeName === 'date') {
    invariant(
      !isEmptyNode(node),
      'Cannot parse "" as Date.'
    )
    return new Date(node.childNodes[0].nodeValue);

  } else if (node.nodeName === 'true') {
    return true;

  } else if (node.nodeName === 'false') {
    return false;
  }
}


/***/ }),

/***/ 4466:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;
function DOMParser(options){
	this.options = options ||{locator:{}};
}

DOMParser.prototype.parseFromString = function(source,mimeType){
	var options = this.options;
	var sax =  new XMLReader();
	var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
	var errorHandler = options.errorHandler;
	var locator = options.locator;
	var defaultNSMap = options.xmlns||{};
	var isHTML = /\/x?html?$/.test(mimeType);//mimeType.toLowerCase().indexOf('html') > -1;
  	var entityMap = isHTML?htmlEntity.entityMap:{'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"};
	if(locator){
		domBuilder.setDocumentLocator(locator)
	}

	sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
	sax.domBuilder = options.domBuilder || domBuilder;
	if(isHTML){
		defaultNSMap['']= 'http://www.w3.org/1999/xhtml';
	}
	defaultNSMap.xml = defaultNSMap.xml || 'http://www.w3.org/XML/1998/namespace';
	if(source && typeof source === 'string'){
		sax.parse(source,defaultNSMap,entityMap);
	}else{
		sax.errorHandler.error("invalid doc source");
	}
	return domBuilder.doc;
}
function buildErrorHandler(errorImpl,domBuilder,locator){
	if(!errorImpl){
		if(domBuilder instanceof DOMHandler){
			return domBuilder;
		}
		errorImpl = domBuilder ;
	}
	var errorHandler = {}
	var isCallback = errorImpl instanceof Function;
	locator = locator||{}
	function build(key){
		var fn = errorImpl[key];
		if(!fn && isCallback){
			fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
		}
		errorHandler[key] = fn && function(msg){
			fn('[xmldom '+key+']\t'+msg+_locator(locator));
		}||function(){};
	}
	build('warning');
	build('error');
	build('fatalError');
	return errorHandler;
}

//console.log('#\n\n\n\n\n\n\n####')
/**
 * +ContentHandler+ErrorHandler
 * +LexicalHandler+EntityResolver2
 * -DeclHandler-DTDHandler
 *
 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
 */
function DOMHandler() {
    this.cdata = false;
}
function position(locator,node){
	node.lineNumber = locator.lineNumber;
	node.columnNumber = locator.columnNumber;
}
/**
 * @see org.xml.sax.ContentHandler#startDocument
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
 */
DOMHandler.prototype = {
	startDocument : function() {
    	this.doc = new DOMImplementation().createDocument(null, null, null);
    	if (this.locator) {
        	this.doc.documentURI = this.locator.systemId;
    	}
	},
	startElement:function(namespaceURI, localName, qName, attrs) {
		var doc = this.doc;
	    var el = doc.createElementNS(namespaceURI, qName||localName);
	    var len = attrs.length;
	    appendElement(this, el);
	    this.currentElement = el;

		this.locator && position(this.locator,el)
	    for (var i = 0 ; i < len; i++) {
	        var namespaceURI = attrs.getURI(i);
	        var value = attrs.getValue(i);
	        var qName = attrs.getQName(i);
			var attr = doc.createAttributeNS(namespaceURI, qName);
			this.locator &&position(attrs.getLocator(i),attr);
			attr.value = attr.nodeValue = value;
			el.setAttributeNode(attr)
	    }
	},
	endElement:function(namespaceURI, localName, qName) {
		var current = this.currentElement
		var tagName = current.tagName;
		this.currentElement = current.parentNode;
	},
	startPrefixMapping:function(prefix, uri) {
	},
	endPrefixMapping:function(prefix) {
	},
	processingInstruction:function(target, data) {
	    var ins = this.doc.createProcessingInstruction(target, data);
	    this.locator && position(this.locator,ins)
	    appendElement(this, ins);
	},
	ignorableWhitespace:function(ch, start, length) {
	},
	characters:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
		//console.log(chars)
		if(chars){
			if (this.cdata) {
				var charNode = this.doc.createCDATASection(chars);
			} else {
				var charNode = this.doc.createTextNode(chars);
			}
			if(this.currentElement){
				this.currentElement.appendChild(charNode);
			}else if(/^\s*$/.test(chars)){
				this.doc.appendChild(charNode);
				//process xml
			}
			this.locator && position(this.locator,charNode)
		}
	},
	skippedEntity:function(name) {
	},
	endDocument:function() {
		this.doc.normalize();
	},
	setDocumentLocator:function (locator) {
	    if(this.locator = locator){// && !('lineNumber' in locator)){
	    	locator.lineNumber = 0;
	    }
	},
	//LexicalHandler
	comment:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
	    var comm = this.doc.createComment(chars);
	    this.locator && position(this.locator,comm)
	    appendElement(this, comm);
	},

	startCDATA:function() {
	    //used in characters() methods
	    this.cdata = true;
	},
	endCDATA:function() {
	    this.cdata = false;
	},

	startDTD:function(name, publicId, systemId) {
		var impl = this.doc.implementation;
	    if (impl && impl.createDocumentType) {
	        var dt = impl.createDocumentType(name, publicId, systemId);
	        this.locator && position(this.locator,dt)
	        appendElement(this, dt);
	    }
	},
	/**
	 * @see org.xml.sax.ErrorHandler
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
	 */
	warning:function(error) {
		console.warn('[xmldom warning]\t'+error,_locator(this.locator));
	},
	error:function(error) {
		console.error('[xmldom error]\t'+error,_locator(this.locator));
	},
	fatalError:function(error) {
		throw new ParseError(error, this.locator);
	}
}
function _locator(l){
	if(l){
		return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
	}
}
function _toString(chars,start,length){
	if(typeof chars == 'string'){
		return chars.substr(start,length)
	}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
		if(chars.length >= start+length || start){
			return new java.lang.String(chars,start,length)+'';
		}
		return chars;
	}
}

/*
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
 * used method of org.xml.sax.ext.LexicalHandler:
 *  #comment(chars, start, length)
 *  #startCDATA()
 *  #endCDATA()
 *  #startDTD(name, publicId, systemId)
 *
 *
 * IGNORED method of org.xml.sax.ext.LexicalHandler:
 *  #endDTD()
 *  #startEntity(name)
 *  #endEntity(name)
 *
 *
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
 * IGNORED method of org.xml.sax.ext.DeclHandler
 * 	#attributeDecl(eName, aName, type, mode, value)
 *  #elementDecl(name, model)
 *  #externalEntityDecl(name, publicId, systemId)
 *  #internalEntityDecl(name, value)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
 * IGNORED method of org.xml.sax.EntityResolver2
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
 *  #resolveEntity(publicId, systemId)
 *  #getExternalSubset(name, baseURI)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
 * IGNORED method of org.xml.sax.DTDHandler
 *  #notationDecl(name, publicId, systemId) {};
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
 */
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
	DOMHandler.prototype[key] = function(){return null}
})

/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
function appendElement (hander,node) {
    if (!hander.currentElement) {
        hander.doc.appendChild(node);
    } else {
        hander.currentElement.appendChild(node);
    }
}//appendChild and setAttributeNS are preformance key

//if(typeof require == 'function'){
var htmlEntity = __webpack_require__(8903);
var sax = __webpack_require__(391);
var XMLReader = sax.XMLReader;
var ParseError = sax.ParseError;
var DOMImplementation = /* unused reexport */ __webpack_require__(9772).DOMImplementation;
/* unused reexport */ __webpack_require__(9772) ;
exports.a = DOMParser;
__webpack_unused_export__ = DOMHandler;
//}


/***/ }),

/***/ 9772:
/***/ ((__unused_webpack_module, exports) => {

var __webpack_unused_export__;
function copy(src,dest){
	for(var p in src){
		dest[p] = src[p];
	}
}
/**
^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
 */
function _extends(Class,Super){
	var pt = Class.prototype;
	if(!(pt instanceof Super)){
		function t(){};
		t.prototype = Super.prototype;
		t = new t();
		copy(pt,t);
		Class.prototype = pt = t;
	}
	if(pt.constructor != Class){
		if(typeof Class != 'function'){
			console.error("unknow Class:"+Class)
		}
		pt.constructor = Class
	}
}
var htmlns = 'http://www.w3.org/1999/xhtml' ;
// Node Types
var NodeType = {}
var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

// ExceptionCode
var ExceptionCode = {}
var ExceptionMessage = {};
var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
//level2
var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);

/**
 * DOM Level 2
 * Object DOMException
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 */
function DOMException(code, message) {
	if(message instanceof Error){
		var error = message;
	}else{
		error = this;
		Error.call(this, ExceptionMessage[code]);
		this.message = ExceptionMessage[code];
		if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
	}
	error.code = code;
	if(message) this.message = this.message + ": " + message;
	return error;
};
DOMException.prototype = Error.prototype;
copy(ExceptionCode,DOMException)
/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 */
function NodeList() {
};
NodeList.prototype = {
	/**
	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
	 * @standard level1
	 */
	length:0, 
	/**
	 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
	 * @standard level1
	 * @param index  unsigned long 
	 *   Index into the collection.
	 * @return Node
	 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
	 */
	item: function(index) {
		return this[index] || null;
	},
	toString:function(isHTML,nodeFilter){
		for(var buf = [], i = 0;i<this.length;i++){
			serializeToString(this[i],buf,isHTML,nodeFilter);
		}
		return buf.join('');
	}
};
function LiveNodeList(node,refresh){
	this._node = node;
	this._refresh = refresh
	_updateLiveList(this);
}
function _updateLiveList(list){
	var inc = list._node._inc || list._node.ownerDocument._inc;
	if(list._inc != inc){
		var ls = list._refresh(list._node);
		//console.log(ls.length)
		__set__(list,'length',ls.length);
		copy(ls,list);
		list._inc = inc;
	}
}
LiveNodeList.prototype.item = function(i){
	_updateLiveList(this);
	return this[i];
}

_extends(LiveNodeList,NodeList);
/**
 * 
 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities 
 */
function NamedNodeMap() {
};

function _findNodeIndex(list,node){
	var i = list.length;
	while(i--){
		if(list[i] === node){return i}
	}
}

function _addNamedNode(el,list,newAttr,oldAttr){
	if(oldAttr){
		list[_findNodeIndex(list,oldAttr)] = newAttr;
	}else{
		list[list.length++] = newAttr;
	}
	if(el){
		newAttr.ownerElement = el;
		var doc = el.ownerDocument;
		if(doc){
			oldAttr && _onRemoveAttribute(doc,el,oldAttr);
			_onAddAttribute(doc,el,newAttr);
		}
	}
}
function _removeNamedNode(el,list,attr){
	//console.log('remove attr:'+attr)
	var i = _findNodeIndex(list,attr);
	if(i>=0){
		var lastIndex = list.length-1
		while(i<lastIndex){
			list[i] = list[++i]
		}
		list.length = lastIndex;
		if(el){
			var doc = el.ownerDocument;
			if(doc){
				_onRemoveAttribute(doc,el,attr);
				attr.ownerElement = null;
			}
		}
	}else{
		throw DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))
	}
}
NamedNodeMap.prototype = {
	length:0,
	item:NodeList.prototype.item,
	getNamedItem: function(key) {
//		if(key.indexOf(':')>0 || key == 'xmlns'){
//			return null;
//		}
		//console.log()
		var i = this.length;
		while(i--){
			var attr = this[i];
			//console.log(attr.nodeName,key)
			if(attr.nodeName == key){
				return attr;
			}
		}
	},
	setNamedItem: function(attr) {
		var el = attr.ownerElement;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		var oldAttr = this.getNamedItem(attr.nodeName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},
	/* returns Node */
	setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
		var el = attr.ownerElement, oldAttr;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},

	/* returns Node */
	removeNamedItem: function(key) {
		var attr = this.getNamedItem(key);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
		
		
	},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
	
	//for level2
	removeNamedItemNS:function(namespaceURI,localName){
		var attr = this.getNamedItemNS(namespaceURI,localName);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
	},
	getNamedItemNS: function(namespaceURI, localName) {
		var i = this.length;
		while(i--){
			var node = this[i];
			if(node.localName == localName && node.namespaceURI == namespaceURI){
				return node;
			}
		}
		return null;
	}
};
/**
 * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
 */
function DOMImplementation(/* Object */ features) {
	this._features = {};
	if (features) {
		for (var feature in features) {
			 this._features = features[feature];
		}
	}
};

DOMImplementation.prototype = {
	hasFeature: function(/* string */ feature, /* string */ version) {
		var versions = this._features[feature.toLowerCase()];
		if (versions && (!version || version in versions)) {
			return true;
		} else {
			return false;
		}
	},
	// Introduced in DOM Level 2:
	createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
		var doc = new Document();
		doc.implementation = this;
		doc.childNodes = new NodeList();
		doc.doctype = doctype;
		if(doctype){
			doc.appendChild(doctype);
		}
		if(qualifiedName){
			var root = doc.createElementNS(namespaceURI,qualifiedName);
			doc.appendChild(root);
		}
		return doc;
	},
	// Introduced in DOM Level 2:
	createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
		var node = new DocumentType();
		node.name = qualifiedName;
		node.nodeName = qualifiedName;
		node.publicId = publicId;
		node.systemId = systemId;
		// Introduced in DOM Level 2:
		//readonly attribute DOMString        internalSubset;
		
		//TODO:..
		//  readonly attribute NamedNodeMap     entities;
		//  readonly attribute NamedNodeMap     notations;
		return node;
	}
};


/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 */

function Node() {
};

Node.prototype = {
	firstChild : null,
	lastChild : null,
	previousSibling : null,
	nextSibling : null,
	attributes : null,
	parentNode : null,
	childNodes : null,
	ownerDocument : null,
	nodeValue : null,
	namespaceURI : null,
	prefix : null,
	localName : null,
	// Modified in DOM Level 2:
	insertBefore:function(newChild, refChild){//raises 
		return _insertBefore(this,newChild,refChild);
	},
	replaceChild:function(newChild, oldChild){//raises 
		this.insertBefore(newChild,oldChild);
		if(oldChild){
			this.removeChild(oldChild);
		}
	},
	removeChild:function(oldChild){
		return _removeChild(this,oldChild);
	},
	appendChild:function(newChild){
		return this.insertBefore(newChild,null);
	},
	hasChildNodes:function(){
		return this.firstChild != null;
	},
	cloneNode:function(deep){
		return cloneNode(this.ownerDocument||this,this,deep);
	},
	// Modified in DOM Level 2:
	normalize:function(){
		var child = this.firstChild;
		while(child){
			var next = child.nextSibling;
			if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
				this.removeChild(next);
				child.appendData(next.data);
			}else{
				child.normalize();
				child = next;
			}
		}
	},
  	// Introduced in DOM Level 2:
	isSupported:function(feature, version){
		return this.ownerDocument.implementation.hasFeature(feature,version);
	},
    // Introduced in DOM Level 2:
    hasAttributes:function(){
    	return this.attributes.length>0;
    },
    lookupPrefix:function(namespaceURI){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			for(var n in map){
    				if(map[n] == namespaceURI){
    					return n;
    				}
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI:function(prefix){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			if(prefix in map){
    				return map[prefix] ;
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace:function(namespaceURI){
    	var prefix = this.lookupPrefix(namespaceURI);
    	return prefix == null;
    }
};


function _xmlEncoder(c){
	return c == '<' && '&lt;' ||
         c == '>' && '&gt;' ||
         c == '&' && '&amp;' ||
         c == '"' && '&quot;' ||
         '&#'+c.charCodeAt()+';'
}


copy(NodeType,Node);
copy(NodeType,Node.prototype);

/**
 * @param callback return true for continue,false for break
 * @return boolean true: break visit;
 */
function _visitNode(node,callback){
	if(callback(node)){
		return true;
	}
	if(node = node.firstChild){
		do{
			if(_visitNode(node,callback)){return true}
        }while(node=node.nextSibling)
    }
}



function Document(){
}
function _onAddAttribute(doc,el,newAttr){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
	}
}
function _onRemoveAttribute(doc,el,newAttr,remove){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		delete el._nsMap[newAttr.prefix?newAttr.localName:'']
	}
}
function _onUpdateChild(doc,el,newChild){
	if(doc && doc._inc){
		doc._inc++;
		//update childNodes
		var cs = el.childNodes;
		if(newChild){
			cs[cs.length++] = newChild;
		}else{
			//console.log(1)
			var child = el.firstChild;
			var i = 0;
			while(child){
				cs[i++] = child;
				child =child.nextSibling;
			}
			cs.length = i;
		}
	}
}

/**
 * attributes;
 * children;
 * 
 * writeable properties:
 * nodeValue,Attr:value,CharacterData:data
 * prefix
 */
function _removeChild(parentNode,child){
	var previous = child.previousSibling;
	var next = child.nextSibling;
	if(previous){
		previous.nextSibling = next;
	}else{
		parentNode.firstChild = next
	}
	if(next){
		next.previousSibling = previous;
	}else{
		parentNode.lastChild = previous;
	}
	_onUpdateChild(parentNode.ownerDocument,parentNode);
	return child;
}
/**
 * preformance key(refChild == null)
 */
function _insertBefore(parentNode,newChild,nextChild){
	var cp = newChild.parentNode;
	if(cp){
		cp.removeChild(newChild);//remove and update
	}
	if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
		var newFirst = newChild.firstChild;
		if (newFirst == null) {
			return newChild;
		}
		var newLast = newChild.lastChild;
	}else{
		newFirst = newLast = newChild;
	}
	var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

	newFirst.previousSibling = pre;
	newLast.nextSibling = nextChild;
	
	
	if(pre){
		pre.nextSibling = newFirst;
	}else{
		parentNode.firstChild = newFirst;
	}
	if(nextChild == null){
		parentNode.lastChild = newLast;
	}else{
		nextChild.previousSibling = newLast;
	}
	do{
		newFirst.parentNode = parentNode;
	}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
	_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
	//console.log(parentNode.lastChild.nextSibling == null)
	if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
		newChild.firstChild = newChild.lastChild = null;
	}
	return newChild;
}
function _appendSingleChild(parentNode,newChild){
	var cp = newChild.parentNode;
	if(cp){
		var pre = parentNode.lastChild;
		cp.removeChild(newChild);//remove and update
		var pre = parentNode.lastChild;
	}
	var pre = parentNode.lastChild;
	newChild.parentNode = parentNode;
	newChild.previousSibling = pre;
	newChild.nextSibling = null;
	if(pre){
		pre.nextSibling = newChild;
	}else{
		parentNode.firstChild = newChild;
	}
	parentNode.lastChild = newChild;
	_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
	return newChild;
	//console.log("__aa",parentNode.lastChild.nextSibling == null)
}
Document.prototype = {
	//implementation : null,
	nodeName :  '#document',
	nodeType :  DOCUMENT_NODE,
	doctype :  null,
	documentElement :  null,
	_inc : 1,
	
	insertBefore :  function(newChild, refChild){//raises 
		if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
			var child = newChild.firstChild;
			while(child){
				var next = child.nextSibling;
				this.insertBefore(child,refChild);
				child = next;
			}
			return newChild;
		}
		if(this.documentElement == null && newChild.nodeType == ELEMENT_NODE){
			this.documentElement = newChild;
		}
		
		return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
	},
	removeChild :  function(oldChild){
		if(this.documentElement == oldChild){
			this.documentElement = null;
		}
		return _removeChild(this,oldChild);
	},
	// Introduced in DOM Level 2:
	importNode : function(importedNode,deep){
		return importNode(this,importedNode,deep);
	},
	// Introduced in DOM Level 2:
	getElementById :	function(id){
		var rtv = null;
		_visitNode(this.documentElement,function(node){
			if(node.nodeType == ELEMENT_NODE){
				if(node.getAttribute('id') == id){
					rtv = node;
					return true;
				}
			}
		})
		return rtv;
	},
	
	getElementsByClassName: function(className) {
		var pattern = new RegExp("(^|\\s)" + className + "(\\s|$)");
		return new LiveNodeList(this, function(base) {
			var ls = [];
			_visitNode(base.documentElement, function(node) {
				if(node !== base && node.nodeType == ELEMENT_NODE) {
					if(pattern.test(node.getAttribute('class'))) {
						ls.push(node);
					}
				}
			});
			return ls;
		});
	},
	
	//document factory method:
	createElement :	function(tagName){
		var node = new Element();
		node.ownerDocument = this;
		node.nodeName = tagName;
		node.tagName = tagName;
		node.childNodes = new NodeList();
		var attrs	= node.attributes = new NamedNodeMap();
		attrs._ownerElement = node;
		return node;
	},
	createDocumentFragment :	function(){
		var node = new DocumentFragment();
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		return node;
	},
	createTextNode :	function(data){
		var node = new Text();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createComment :	function(data){
		var node = new Comment();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createCDATASection :	function(data){
		var node = new CDATASection();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createProcessingInstruction :	function(target,data){
		var node = new ProcessingInstruction();
		node.ownerDocument = this;
		node.tagName = node.target = target;
		node.nodeValue= node.data = data;
		return node;
	},
	createAttribute :	function(name){
		var node = new Attr();
		node.ownerDocument	= this;
		node.name = name;
		node.nodeName	= name;
		node.localName = name;
		node.specified = true;
		return node;
	},
	createEntityReference :	function(name){
		var node = new EntityReference();
		node.ownerDocument	= this;
		node.nodeName	= name;
		return node;
	},
	// Introduced in DOM Level 2:
	createElementNS :	function(namespaceURI,qualifiedName){
		var node = new Element();
		var pl = qualifiedName.split(':');
		var attrs	= node.attributes = new NamedNodeMap();
		node.childNodes = new NodeList();
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.tagName = qualifiedName;
		node.namespaceURI = namespaceURI;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		attrs._ownerElement = node;
		return node;
	},
	// Introduced in DOM Level 2:
	createAttributeNS :	function(namespaceURI,qualifiedName){
		var node = new Attr();
		var pl = qualifiedName.split(':');
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.name = qualifiedName;
		node.namespaceURI = namespaceURI;
		node.specified = true;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		return node;
	}
};
_extends(Document,Node);


function Element() {
	this._nsMap = {};
};
Element.prototype = {
	nodeType : ELEMENT_NODE,
	hasAttribute : function(name){
		return this.getAttributeNode(name)!=null;
	},
	getAttribute : function(name){
		var attr = this.getAttributeNode(name);
		return attr && attr.value || '';
	},
	getAttributeNode : function(name){
		return this.attributes.getNamedItem(name);
	},
	setAttribute : function(name, value){
		var attr = this.ownerDocument.createAttribute(name);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	removeAttribute : function(name){
		var attr = this.getAttributeNode(name)
		attr && this.removeAttributeNode(attr);
	},
	
	//four real opeartion method
	appendChild:function(newChild){
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			return this.insertBefore(newChild,null);
		}else{
			return _appendSingleChild(this,newChild);
		}
	},
	setAttributeNode : function(newAttr){
		return this.attributes.setNamedItem(newAttr);
	},
	setAttributeNodeNS : function(newAttr){
		return this.attributes.setNamedItemNS(newAttr);
	},
	removeAttributeNode : function(oldAttr){
		//console.log(this == oldAttr.ownerElement)
		return this.attributes.removeNamedItem(oldAttr.nodeName);
	},
	//get real attribute name,and remove it by removeAttributeNode
	removeAttributeNS : function(namespaceURI, localName){
		var old = this.getAttributeNodeNS(namespaceURI, localName);
		old && this.removeAttributeNode(old);
	},
	
	hasAttributeNS : function(namespaceURI, localName){
		return this.getAttributeNodeNS(namespaceURI, localName)!=null;
	},
	getAttributeNS : function(namespaceURI, localName){
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		return attr && attr.value || '';
	},
	setAttributeNS : function(namespaceURI, qualifiedName, value){
		var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	getAttributeNodeNS : function(namespaceURI, localName){
		return this.attributes.getNamedItemNS(namespaceURI, localName);
	},
	
	getElementsByTagName : function(tagName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
					ls.push(node);
				}
			});
			return ls;
		});
	},
	getElementsByTagNameNS : function(namespaceURI, localName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
					ls.push(node);
				}
			});
			return ls;
			
		});
	}
};
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


_extends(Element,Node);
function Attr() {
};
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr,Node);


function CharacterData() {
};
CharacterData.prototype = {
	data : '',
	substringData : function(offset, count) {
		return this.data.substring(offset, offset+count);
	},
	appendData: function(text) {
		text = this.data+text;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
	insertData: function(offset,text) {
		this.replaceData(offset,0,text);
	
	},
	appendChild:function(newChild){
		throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
	},
	deleteData: function(offset, count) {
		this.replaceData(offset,count,"");
	},
	replaceData: function(offset, count, text) {
		var start = this.data.substring(0,offset);
		var end = this.data.substring(offset+count);
		text = start + text + end;
		this.nodeValue = this.data = text;
		this.length = text.length;
	}
}
_extends(CharacterData,Node);
function Text() {
};
Text.prototype = {
	nodeName : "#text",
	nodeType : TEXT_NODE,
	splitText : function(offset) {
		var text = this.data;
		var newText = text.substring(offset);
		text = text.substring(0, offset);
		this.data = this.nodeValue = text;
		this.length = text.length;
		var newNode = this.ownerDocument.createTextNode(newText);
		if(this.parentNode){
			this.parentNode.insertBefore(newNode, this.nextSibling);
		}
		return newNode;
	}
}
_extends(Text,CharacterData);
function Comment() {
};
Comment.prototype = {
	nodeName : "#comment",
	nodeType : COMMENT_NODE
}
_extends(Comment,CharacterData);

function CDATASection() {
};
CDATASection.prototype = {
	nodeName : "#cdata-section",
	nodeType : CDATA_SECTION_NODE
}
_extends(CDATASection,CharacterData);


function DocumentType() {
};
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType,Node);

function Notation() {
};
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation,Node);

function Entity() {
};
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity,Node);

function EntityReference() {
};
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference,Node);

function DocumentFragment() {
};
DocumentFragment.prototype.nodeName =	"#document-fragment";
DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment,Node);


function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction,Node);
function XMLSerializer(){}
XMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){
	return nodeSerializeToString.call(node,isHtml,nodeFilter);
}
Node.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(isHtml,nodeFilter){
	var buf = [];
	var refNode = this.nodeType == 9 && this.documentElement || this;
	var prefix = refNode.prefix;
	var uri = refNode.namespaceURI;
	
	if(uri && prefix == null){
		//console.log(prefix)
		var prefix = refNode.lookupPrefix(uri);
		if(prefix == null){
			//isHTML = true;
			var visibleNamespaces=[
			{namespace:uri,prefix:null}
			//{namespace:uri,prefix:''}
			]
		}
	}
	serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);
	//console.log('###',this.nodeType,uri,prefix,buf.join(''))
	return buf.join('');
}
function needNamespaceDefine(node,isHTML, visibleNamespaces) {
	var prefix = node.prefix||'';
	var uri = node.namespaceURI;
	if (!prefix && !uri){
		return false;
	}
	if (prefix === "xml" && uri === "http://www.w3.org/XML/1998/namespace" 
		|| uri == 'http://www.w3.org/2000/xmlns/'){
		return false;
	}
	
	var i = visibleNamespaces.length 
	//console.log('@@@@',node.tagName,prefix,uri,visibleNamespaces)
	while (i--) {
		var ns = visibleNamespaces[i];
		// get namespace prefix
		//console.log(node.nodeType,node.tagName,ns.prefix,prefix)
		if (ns.prefix == prefix){
			return ns.namespace != uri;
		}
	}
	//console.log(isHTML,uri,prefix=='')
	//if(isHTML && prefix ==null && uri == 'http://www.w3.org/1999/xhtml'){
	//	return false;
	//}
	//node.flag = '11111'
	//console.error(3,true,node.flag,node.prefix,node.namespaceURI)
	return true;
}
function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){
	if(nodeFilter){
		node = nodeFilter(node);
		if(node){
			if(typeof node == 'string'){
				buf.push(node);
				return;
			}
		}else{
			return;
		}
		//buf.sort.apply(attrs, attributeSorter);
	}
	switch(node.nodeType){
	case ELEMENT_NODE:
		if (!visibleNamespaces) visibleNamespaces = [];
		var startVisibleNamespaces = visibleNamespaces.length;
		var attrs = node.attributes;
		var len = attrs.length;
		var child = node.firstChild;
		var nodeName = node.tagName;
		
		isHTML =  (htmlns === node.namespaceURI) ||isHTML 
		buf.push('<',nodeName);
		
		
		
		for(var i=0;i<len;i++){
			// add namespaces for attributes
			var attr = attrs.item(i);
			if (attr.prefix == 'xmlns') {
				visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
			}else if(attr.nodeName == 'xmlns'){
				visibleNamespaces.push({ prefix: '', namespace: attr.value });
			}
		}
		for(var i=0;i<len;i++){
			var attr = attrs.item(i);
			if (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {
				var prefix = attr.prefix||'';
				var uri = attr.namespaceURI;
				var ns = prefix ? ' xmlns:' + prefix : " xmlns";
				buf.push(ns, '="' , uri , '"');
				visibleNamespaces.push({ prefix: prefix, namespace:uri });
			}
			serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);
		}
		// add namespace for current node		
		if (needNamespaceDefine(node,isHTML, visibleNamespaces)) {
			var prefix = node.prefix||'';
			var uri = node.namespaceURI;
			if (uri) {
				// Avoid empty namespace value like xmlns:ds=""
				// Empty namespace URL will we produce an invalid XML document
				var ns = prefix ? ' xmlns:' + prefix : " xmlns";
				buf.push(ns, '="' , uri , '"');
				visibleNamespaces.push({ prefix: prefix, namespace:uri });
			}
		}
		
		if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
			buf.push('>');
			//if is cdata child node
			if(isHTML && /^script$/i.test(nodeName)){
				while(child){
					if(child.data){
						buf.push(child.data);
					}else{
						serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
					}
					child = child.nextSibling;
				}
			}else
			{
				while(child){
					serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
					child = child.nextSibling;
				}
			}
			buf.push('</',nodeName,'>');
		}else{
			buf.push('/>');
		}
		// remove added visible namespaces
		//visibleNamespaces.length = startVisibleNamespaces;
		return;
	case DOCUMENT_NODE:
	case DOCUMENT_FRAGMENT_NODE:
		var child = node.firstChild;
		while(child){
			serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
			child = child.nextSibling;
		}
		return;
	case ATTRIBUTE_NODE:
		/**
		 * Well-formedness constraint: No < in Attribute Values
		 * The replacement text of any entity referred to directly or indirectly in an attribute value must not contain a <.
		 * @see https://www.w3.org/TR/xml/#CleanAttrVals
		 * @see https://www.w3.org/TR/xml/#NT-AttValue
		 */
		return buf.push(' ', node.name, '="', node.value.replace(/[<&"]/g,_xmlEncoder), '"');
	case TEXT_NODE:
		/**
		 * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,
		 * except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.
		 * If they are needed elsewhere, they must be escaped using either numeric character references or the strings
		 * `&amp;` and `&lt;` respectively.
		 * The right angle bracket (>) may be represented using the string " &gt; ", and must, for compatibility,
		 * be escaped using either `&gt;` or a character reference when it appears in the string `]]>` in content,
		 * when that string is not marking the end of a CDATA section.
		 *
		 * In the content of elements, character data is any string of characters
		 * which does not contain the start-delimiter of any markup
		 * and does not include the CDATA-section-close delimiter, `]]>`.
		 *
		 * @see https://www.w3.org/TR/xml/#NT-CharData
		 */
		return buf.push(node.data
			.replace(/[<&]/g,_xmlEncoder)
			.replace(/]]>/g, ']]&gt;')
		);
	case CDATA_SECTION_NODE:
		return buf.push( '<![CDATA[',node.data,']]>');
	case COMMENT_NODE:
		return buf.push( "<!--",node.data,"-->");
	case DOCUMENT_TYPE_NODE:
		var pubid = node.publicId;
		var sysid = node.systemId;
		buf.push('<!DOCTYPE ',node.name);
		if(pubid){
			buf.push(' PUBLIC ', pubid);
			if (sysid && sysid!='.') {
				buf.push(' ', sysid);
			}
			buf.push('>');
		}else if(sysid && sysid!='.'){
			buf.push(' SYSTEM ', sysid, '>');
		}else{
			var sub = node.internalSubset;
			if(sub){
				buf.push(" [",sub,"]");
			}
			buf.push(">");
		}
		return;
	case PROCESSING_INSTRUCTION_NODE:
		return buf.push( "<?",node.target," ",node.data,"?>");
	case ENTITY_REFERENCE_NODE:
		return buf.push( '&',node.nodeName,';');
	//case ENTITY_NODE:
	//case NOTATION_NODE:
	default:
		buf.push('??',node.nodeName);
	}
}
function importNode(doc,node,deep){
	var node2;
	switch (node.nodeType) {
	case ELEMENT_NODE:
		node2 = node.cloneNode(false);
		node2.ownerDocument = doc;
		//var attrs = node2.attributes;
		//var len = attrs.length;
		//for(var i=0;i<len;i++){
			//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
		//}
	case DOCUMENT_FRAGMENT_NODE:
		break;
	case ATTRIBUTE_NODE:
		deep = true;
		break;
	//case ENTITY_REFERENCE_NODE:
	//case PROCESSING_INSTRUCTION_NODE:
	////case TEXT_NODE:
	//case CDATA_SECTION_NODE:
	//case COMMENT_NODE:
	//	deep = false;
	//	break;
	//case DOCUMENT_NODE:
	//case DOCUMENT_TYPE_NODE:
	//cannot be imported.
	//case ENTITY_NODE:
	//case NOTATION_NODE：
	//can not hit in level3
	//default:throw e;
	}
	if(!node2){
		node2 = node.cloneNode(false);//false
	}
	node2.ownerDocument = doc;
	node2.parentNode = null;
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(importNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}
//
//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
function cloneNode(doc,node,deep){
	var node2 = new node.constructor();
	for(var n in node){
		var v = node[n];
		if(typeof v != 'object' ){
			if(v != node2[n]){
				node2[n] = v;
			}
		}
	}
	if(node.childNodes){
		node2.childNodes = new NodeList();
	}
	node2.ownerDocument = doc;
	switch (node2.nodeType) {
	case ELEMENT_NODE:
		var attrs	= node.attributes;
		var attrs2	= node2.attributes = new NamedNodeMap();
		var len = attrs.length
		attrs2._ownerElement = node2;
		for(var i=0;i<len;i++){
			node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
		}
		break;;
	case ATTRIBUTE_NODE:
		deep = true;
	}
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(cloneNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

function __set__(object,key,value){
	object[key] = value
}
//do dynamic
try{
	if(Object.defineProperty){
		Object.defineProperty(LiveNodeList.prototype,'length',{
			get:function(){
				_updateLiveList(this);
				return this.$$length;
			}
		});
		Object.defineProperty(Node.prototype,'textContent',{
			get:function(){
				return getTextContent(this);
			},
			set:function(data){
				switch(this.nodeType){
				case ELEMENT_NODE:
				case DOCUMENT_FRAGMENT_NODE:
					while(this.firstChild){
						this.removeChild(this.firstChild);
					}
					if(data || String(data)){
						this.appendChild(this.ownerDocument.createTextNode(data));
					}
					break;
				default:
					//TODO:
					this.data = data;
					this.value = data;
					this.nodeValue = data;
				}
			}
		})
		
		function getTextContent(node){
			switch(node.nodeType){
			case ELEMENT_NODE:
			case DOCUMENT_FRAGMENT_NODE:
				var buf = [];
				node = node.firstChild;
				while(node){
					if(node.nodeType!==7 && node.nodeType !==8){
						buf.push(getTextContent(node));
					}
					node = node.nextSibling;
				}
				return buf.join('');
			default:
				return node.nodeValue;
			}
		}
		__set__ = function(object,key,value){
			//console.log(value)
			object['$$'+key] = value
		}
	}
}catch(e){//ie8
}

//if(typeof require == 'function'){
	__webpack_unused_export__ = Node;
	__webpack_unused_export__ = DOMException;
	exports.DOMImplementation = DOMImplementation;
	__webpack_unused_export__ = XMLSerializer;
//}


/***/ }),

/***/ 8903:
/***/ ((__unused_webpack_module, exports) => {

exports.entityMap = {
       lt: '<',
       gt: '>',
       amp: '&',
       quot: '"',
       apos: "'",
       Agrave: "À",
       Aacute: "Á",
       Acirc: "Â",
       Atilde: "Ã",
       Auml: "Ä",
       Aring: "Å",
       AElig: "Æ",
       Ccedil: "Ç",
       Egrave: "È",
       Eacute: "É",
       Ecirc: "Ê",
       Euml: "Ë",
       Igrave: "Ì",
       Iacute: "Í",
       Icirc: "Î",
       Iuml: "Ï",
       ETH: "Ð",
       Ntilde: "Ñ",
       Ograve: "Ò",
       Oacute: "Ó",
       Ocirc: "Ô",
       Otilde: "Õ",
       Ouml: "Ö",
       Oslash: "Ø",
       Ugrave: "Ù",
       Uacute: "Ú",
       Ucirc: "Û",
       Uuml: "Ü",
       Yacute: "Ý",
       THORN: "Þ",
       szlig: "ß",
       agrave: "à",
       aacute: "á",
       acirc: "â",
       atilde: "ã",
       auml: "ä",
       aring: "å",
       aelig: "æ",
       ccedil: "ç",
       egrave: "è",
       eacute: "é",
       ecirc: "ê",
       euml: "ë",
       igrave: "ì",
       iacute: "í",
       icirc: "î",
       iuml: "ï",
       eth: "ð",
       ntilde: "ñ",
       ograve: "ò",
       oacute: "ó",
       ocirc: "ô",
       otilde: "õ",
       ouml: "ö",
       oslash: "ø",
       ugrave: "ù",
       uacute: "ú",
       ucirc: "û",
       uuml: "ü",
       yacute: "ý",
       thorn: "þ",
       yuml: "ÿ",
       nbsp: "\u00a0",
       iexcl: "¡",
       cent: "¢",
       pound: "£",
       curren: "¤",
       yen: "¥",
       brvbar: "¦",
       sect: "§",
       uml: "¨",
       copy: "©",
       ordf: "ª",
       laquo: "«",
       not: "¬",
       shy: "­­",
       reg: "®",
       macr: "¯",
       deg: "°",
       plusmn: "±",
       sup2: "²",
       sup3: "³",
       acute: "´",
       micro: "µ",
       para: "¶",
       middot: "·",
       cedil: "¸",
       sup1: "¹",
       ordm: "º",
       raquo: "»",
       frac14: "¼",
       frac12: "½",
       frac34: "¾",
       iquest: "¿",
       times: "×",
       divide: "÷",
       forall: "∀",
       part: "∂",
       exist: "∃",
       empty: "∅",
       nabla: "∇",
       isin: "∈",
       notin: "∉",
       ni: "∋",
       prod: "∏",
       sum: "∑",
       minus: "−",
       lowast: "∗",
       radic: "√",
       prop: "∝",
       infin: "∞",
       ang: "∠",
       and: "∧",
       or: "∨",
       cap: "∩",
       cup: "∪",
       'int': "∫",
       there4: "∴",
       sim: "∼",
       cong: "≅",
       asymp: "≈",
       ne: "≠",
       equiv: "≡",
       le: "≤",
       ge: "≥",
       sub: "⊂",
       sup: "⊃",
       nsub: "⊄",
       sube: "⊆",
       supe: "⊇",
       oplus: "⊕",
       otimes: "⊗",
       perp: "⊥",
       sdot: "⋅",
       Alpha: "Α",
       Beta: "Β",
       Gamma: "Γ",
       Delta: "Δ",
       Epsilon: "Ε",
       Zeta: "Ζ",
       Eta: "Η",
       Theta: "Θ",
       Iota: "Ι",
       Kappa: "Κ",
       Lambda: "Λ",
       Mu: "Μ",
       Nu: "Ν",
       Xi: "Ξ",
       Omicron: "Ο",
       Pi: "Π",
       Rho: "Ρ",
       Sigma: "Σ",
       Tau: "Τ",
       Upsilon: "Υ",
       Phi: "Φ",
       Chi: "Χ",
       Psi: "Ψ",
       Omega: "Ω",
       alpha: "α",
       beta: "β",
       gamma: "γ",
       delta: "δ",
       epsilon: "ε",
       zeta: "ζ",
       eta: "η",
       theta: "θ",
       iota: "ι",
       kappa: "κ",
       lambda: "λ",
       mu: "μ",
       nu: "ν",
       xi: "ξ",
       omicron: "ο",
       pi: "π",
       rho: "ρ",
       sigmaf: "ς",
       sigma: "σ",
       tau: "τ",
       upsilon: "υ",
       phi: "φ",
       chi: "χ",
       psi: "ψ",
       omega: "ω",
       thetasym: "ϑ",
       upsih: "ϒ",
       piv: "ϖ",
       OElig: "Œ",
       oelig: "œ",
       Scaron: "Š",
       scaron: "š",
       Yuml: "Ÿ",
       fnof: "ƒ",
       circ: "ˆ",
       tilde: "˜",
       ensp: " ",
       emsp: " ",
       thinsp: " ",
       zwnj: "‌",
       zwj: "‍",
       lrm: "‎",
       rlm: "‏",
       ndash: "–",
       mdash: "—",
       lsquo: "‘",
       rsquo: "’",
       sbquo: "‚",
       ldquo: "“",
       rdquo: "”",
       bdquo: "„",
       dagger: "†",
       Dagger: "‡",
       bull: "•",
       hellip: "…",
       permil: "‰",
       prime: "′",
       Prime: "″",
       lsaquo: "‹",
       rsaquo: "›",
       oline: "‾",
       euro: "€",
       trade: "™",
       larr: "←",
       uarr: "↑",
       rarr: "→",
       darr: "↓",
       harr: "↔",
       crarr: "↵",
       lceil: "⌈",
       rceil: "⌉",
       lfloor: "⌊",
       rfloor: "⌋",
       loz: "◊",
       spades: "♠",
       clubs: "♣",
       hearts: "♥",
       diams: "♦"
};


/***/ }),

/***/ 391:
/***/ ((__unused_webpack_module, exports) => {

//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//[5]   	Name	   ::=   	NameStartChar (NameChar)*
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
var S_TAG = 0;//tag name offerring
var S_ATTR = 1;//attr name offerring 
var S_ATTR_SPACE=2;//attr name end and space offer
var S_EQ = 3;//=space?
var S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)
var S_ATTR_END = 5;//attr value end and no space(quot end)
var S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)
var S_TAG_CLOSE = 7;//closed el<el />

/**
 * Creates an error that will not be caught by XMLReader aka the SAX parser.
 *
 * @param {string} message
 * @param {any?} locator Optional, can provide details about the location in the source
 * @constructor
 */
function ParseError(message, locator) {
	this.message = message
	this.locator = locator
	if(Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
}
ParseError.prototype = new Error();
ParseError.prototype.name = ParseError.name

function XMLReader(){
	
}

XMLReader.prototype = {
	parse:function(source,defaultNSMap,entityMap){
		var domBuilder = this.domBuilder;
		domBuilder.startDocument();
		_copy(defaultNSMap ,defaultNSMap = {})
		parse(source,defaultNSMap,entityMap,
				domBuilder,this.errorHandler);
		domBuilder.endDocument();
	}
}
function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
	function fixedFromCharCode(code) {
		// String.prototype.fromCharCode does not supports
		// > 2 bytes unicode chars directly
		if (code > 0xffff) {
			code -= 0x10000;
			var surrogate1 = 0xd800 + (code >> 10)
				, surrogate2 = 0xdc00 + (code & 0x3ff);

			return String.fromCharCode(surrogate1, surrogate2);
		} else {
			return String.fromCharCode(code);
		}
	}
	function entityReplacer(a){
		var k = a.slice(1,-1);
		if(k in entityMap){
			return entityMap[k]; 
		}else if(k.charAt(0) === '#'){
			return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
		}else{
			errorHandler.error('entity not found:'+a);
			return a;
		}
	}
	function appendText(end){//has some bugs
		if(end>start){
			var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
			locator&&position(start);
			domBuilder.characters(xt,0,end-start);
			start = end
		}
	}
	function position(p,m){
		while(p>=lineEnd && (m = linePattern.exec(source))){
			lineStart = m.index;
			lineEnd = lineStart + m[0].length;
			locator.lineNumber++;
			//console.log('line++:',locator,startPos,endPos)
		}
		locator.columnNumber = p-lineStart+1;
	}
	var lineStart = 0;
	var lineEnd = 0;
	var linePattern = /.*(?:\r\n?|\n)|.*$/g
	var locator = domBuilder.locator;
	
	var parseStack = [{currentNSMap:defaultNSMapCopy}]
	var closeMap = {};
	var start = 0;
	while(true){
		try{
			var tagStart = source.indexOf('<',start);
			if(tagStart<0){
				if(!source.substr(start).match(/^\s*$/)){
					var doc = domBuilder.doc;
	    			var text = doc.createTextNode(source.substr(start));
	    			doc.appendChild(text);
	    			domBuilder.currentElement = text;
				}
				return;
			}
			if(tagStart>start){
				appendText(tagStart);
			}
			switch(source.charAt(tagStart+1)){
			case '/':
				var end = source.indexOf('>',tagStart+3);
				var tagName = source.substring(tagStart+2,end);
				var config = parseStack.pop();
				if(end<0){
					
	        		tagName = source.substring(tagStart+2).replace(/[\s<].*/,'');
	        		errorHandler.error("end tag name: "+tagName+' is not complete:'+config.tagName);
	        		end = tagStart+1+tagName.length;
	        	}else if(tagName.match(/\s</)){
	        		tagName = tagName.replace(/[\s<].*/,'');
	        		errorHandler.error("end tag name: "+tagName+' maybe not complete');
	        		end = tagStart+1+tagName.length;
				}
				var localNSMap = config.localNSMap;
				var endMatch = config.tagName == tagName;
				var endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase()
		        if(endIgnoreCaseMach){
		        	domBuilder.endElement(config.uri,config.localName,tagName);
					if(localNSMap){
						for(var prefix in localNSMap){
							domBuilder.endPrefixMapping(prefix) ;
						}
					}
					if(!endMatch){
		            	errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName ); // No known test case
					}
		        }else{
		        	parseStack.push(config)
		        }
				
				end++;
				break;
				// end elment
			case '?':// <?...?>
				locator&&position(tagStart);
				end = parseInstruction(source,tagStart,domBuilder);
				break;
			case '!':// <!doctype,<![CDATA,<!--
				locator&&position(tagStart);
				end = parseDCC(source,tagStart,domBuilder,errorHandler);
				break;
			default:
				locator&&position(tagStart);
				var el = new ElementAttributes();
				var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
				//elStartEnd
				var end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);
				var len = el.length;
				
				
				if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
					el.closed = true;
					if(!entityMap.nbsp){
						errorHandler.warning('unclosed xml attribute');
					}
				}
				if(locator && len){
					var locator2 = copyLocator(locator,{});
					//try{//attribute position fixed
					for(var i = 0;i<len;i++){
						var a = el[i];
						position(a.offset);
						a.locator = copyLocator(locator,{});
					}
					domBuilder.locator = locator2
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
					domBuilder.locator = locator;
				}else{
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
				}
				
				
				
				if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){
					end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
				}else{
					end++;
				}
			}
		}catch(e){
			if (e instanceof ParseError) {
				throw e;
			}
			errorHandler.error('element parse error: '+e)
			end = -1;
		}
		if(end>start){
			start = end;
		}else{
			//TODO: 这里有可能sax回退，有位置错误风险
			appendText(Math.max(tagStart,start)+1);
		}
	}
}
function copyLocator(f,t){
	t.lineNumber = f.lineNumber;
	t.columnNumber = f.columnNumber;
	return t;
}

/**
 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){

	/**
	 * @param {string} qname
	 * @param {string} value
	 * @param {number} startIndex
	 */
	function addAttribute(qname, value, startIndex) {
		if (qname in el.attributeNames) errorHandler.fatalError('Attribute ' + qname + ' redefined')
		el.addValue(qname, value, startIndex)
	}
	var attrName;
	var value;
	var p = ++start;
	var s = S_TAG;//status
	while(true){
		var c = source.charAt(p);
		switch(c){
		case '=':
			if(s === S_ATTR){//attrName
				attrName = source.slice(start,p);
				s = S_EQ;
			}else if(s === S_ATTR_SPACE){
				s = S_EQ;
			}else{
				//fatalError: equal must after attrName or space after attrName
				throw new Error('attribute equal must after attrName'); // No known test case
			}
			break;
		case '\'':
		case '"':
			if(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE
				){//equal
				if(s === S_ATTR){
					errorHandler.warning('attribute value must after "="')
					attrName = source.slice(start,p)
				}
				start = p+1;
				p = source.indexOf(c,start)
				if(p>0){
					value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					addAttribute(attrName, value, start-1);
					s = S_ATTR_END;
				}else{
					//fatalError: no end quot match
					throw new Error('attribute value no end \''+c+'\' match');
				}
			}else if(s == S_ATTR_NOQUOT_VALUE){
				value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
				//console.log(attrName,value,start,p)
				addAttribute(attrName, value, start);
				//console.dir(el)
				errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
				start = p+1;
				s = S_ATTR_END
			}else{
				//fatalError: no equal before
				throw new Error('attribute value must after "="'); // No known test case
			}
			break;
		case '/':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				s =S_TAG_CLOSE;
				el.closed = true;
			case S_ATTR_NOQUOT_VALUE:
			case S_ATTR:
			case S_ATTR_SPACE:
				break;
			//case S_EQ:
			default:
				throw new Error("attribute invalid close char('/')") // No known test case
			}
			break;
		case ''://end document
			errorHandler.error('unexpected end of input');
			if(s == S_TAG){
				el.setTagName(source.slice(start,p));
			}
			return p;
		case '>':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				break;//normal
			case S_ATTR_NOQUOT_VALUE://Compatible state
			case S_ATTR:
				value = source.slice(start,p);
				if(value.slice(-1) === '/'){
					el.closed  = true;
					value = value.slice(0,-1)
				}
			case S_ATTR_SPACE:
				if(s === S_ATTR_SPACE){
					value = attrName;
				}
				if(s == S_ATTR_NOQUOT_VALUE){
					errorHandler.warning('attribute "'+value+'" missed quot(")!');
					addAttribute(attrName, value.replace(/&#?\w+;/g,entityReplacer), start)
				}else{
					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !value.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
					}
					addAttribute(value, value, start)
				}
				break;
			case S_EQ:
				throw new Error('attribute value missed!!');
			}
//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
			return p;
		/*xml space '\x20' | #x9 | #xD | #xA; */
		case '\u0080':
			c = ' ';
		default:
			if(c<= ' '){//space
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));//tagName
					s = S_TAG_SPACE;
					break;
				case S_ATTR:
					attrName = source.slice(start,p)
					s = S_ATTR_SPACE;
					break;
				case S_ATTR_NOQUOT_VALUE:
					var value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					addAttribute(attrName, value, start)
				case S_ATTR_END:
					s = S_TAG_SPACE;
					break;
				//case S_TAG_SPACE:
				//case S_EQ:
				//case S_ATTR_SPACE:
				//	void();break;
				//case S_TAG_CLOSE:
					//ignore warning
				}
			}else{//not space
//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
				switch(s){
				//case S_TAG:void();break;
				//case S_ATTR:void();break;
				//case S_ATTR_NOQUOT_VALUE:void();break;
				case S_ATTR_SPACE:
					var tagName =  el.tagName;
					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !attrName.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!')
					}
					addAttribute(attrName, attrName, start);
					start = p;
					s = S_ATTR;
					break;
				case S_ATTR_END:
					errorHandler.warning('attribute space is required"'+attrName+'"!!')
				case S_TAG_SPACE:
					s = S_ATTR;
					start = p;
					break;
				case S_EQ:
					s = S_ATTR_NOQUOT_VALUE;
					start = p;
					break;
				case S_TAG_CLOSE:
					throw new Error("elements closed character '/' and '>' must be connected to");
				}
			}
		}//end outer switch
		//console.log('p++',p)
		p++;
	}
}
/**
 * @return true if has new namespace define
 */
function appendElement(el,domBuilder,currentNSMap){
	var tagName = el.tagName;
	var localNSMap = null;
	//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
	var i = el.length;
	while(i--){
		var a = el[i];
		var qName = a.qName;
		var value = a.value;
		var nsp = qName.indexOf(':');
		if(nsp>0){
			var prefix = a.prefix = qName.slice(0,nsp);
			var localName = qName.slice(nsp+1);
			var nsPrefix = prefix === 'xmlns' && localName
		}else{
			localName = qName;
			prefix = null
			nsPrefix = qName === 'xmlns' && ''
		}
		//can not set prefix,because prefix !== ''
		a.localName = localName ;
		//prefix == null for no ns prefix attribute 
		if(nsPrefix !== false){//hack!!
			if(localNSMap == null){
				localNSMap = {}
				//console.log(currentNSMap,0)
				_copy(currentNSMap,currentNSMap={})
				//console.log(currentNSMap,1)
			}
			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
			a.uri = 'http://www.w3.org/2000/xmlns/'
			domBuilder.startPrefixMapping(nsPrefix, value) 
		}
	}
	var i = el.length;
	while(i--){
		a = el[i];
		var prefix = a.prefix;
		if(prefix){//no prefix attribute has no namespace
			if(prefix === 'xml'){
				a.uri = 'http://www.w3.org/XML/1998/namespace';
			}if(prefix !== 'xmlns'){
				a.uri = currentNSMap[prefix || '']
				
				//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
			}
		}
	}
	var nsp = tagName.indexOf(':');
	if(nsp>0){
		prefix = el.prefix = tagName.slice(0,nsp);
		localName = el.localName = tagName.slice(nsp+1);
	}else{
		prefix = null;//important!!
		localName = el.localName = tagName;
	}
	//no prefix element has default namespace
	var ns = el.uri = currentNSMap[prefix || ''];
	domBuilder.startElement(ns,localName,tagName,el);
	//endPrefixMapping and startPrefixMapping have not any help for dom builder
	//localNSMap = null
	if(el.closed){
		domBuilder.endElement(ns,localName,tagName);
		if(localNSMap){
			for(prefix in localNSMap){
				domBuilder.endPrefixMapping(prefix) 
			}
		}
	}else{
		el.currentNSMap = currentNSMap;
		el.localNSMap = localNSMap;
		//parseStack.push(el);
		return true;
	}
}
function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
	if(/^(?:script|textarea)$/i.test(tagName)){
		var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
		var text = source.substring(elStartEnd+1,elEndStart);
		if(/[&<]/.test(text)){
			if(/^script$/i.test(tagName)){
				//if(!/\]\]>/.test(text)){
					//lexHandler.startCDATA();
					domBuilder.characters(text,0,text.length);
					//lexHandler.endCDATA();
					return elEndStart;
				//}
			}//}else{//text area
				text = text.replace(/&#?\w+;/g,entityReplacer);
				domBuilder.characters(text,0,text.length);
				return elEndStart;
			//}
			
		}
	}
	return elStartEnd+1;
}
function fixSelfClosed(source,elStartEnd,tagName,closeMap){
	//if(tagName in closeMap){
	var pos = closeMap[tagName];
	if(pos == null){
		//console.log(tagName)
		pos =  source.lastIndexOf('</'+tagName+'>')
		if(pos<elStartEnd){//忘记闭合
			pos = source.lastIndexOf('</'+tagName)
		}
		closeMap[tagName] =pos
	}
	return pos<elStartEnd;
	//} 
}
function _copy(source,target){
	for(var n in source){target[n] = source[n]}
}
function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
	var next= source.charAt(start+2)
	switch(next){
	case '-':
		if(source.charAt(start + 3) === '-'){
			var end = source.indexOf('-->',start+4);
			//append comment source.substring(4,end)//<!--
			if(end>start){
				domBuilder.comment(source,start+4,end-start-4);
				return end+3;
			}else{
				errorHandler.error("Unclosed comment");
				return -1;
			}
		}else{
			//error
			return -1;
		}
	default:
		if(source.substr(start+3,6) == 'CDATA['){
			var end = source.indexOf(']]>',start+9);
			domBuilder.startCDATA();
			domBuilder.characters(source,start+9,end-start-9);
			domBuilder.endCDATA() 
			return end+3;
		}
		//<!DOCTYPE
		//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
		var matchs = split(source,start);
		var len = matchs.length;
		if(len>1 && /!doctype/i.test(matchs[0][0])){
			var name = matchs[1][0];
			var pubid = false;
			var sysid = false;
			if(len>3){
				if(/^public$/i.test(matchs[2][0])){
					pubid = matchs[3][0];
					sysid = len>4 && matchs[4][0];
				}else if(/^system$/i.test(matchs[2][0])){
					sysid = matchs[3][0];
				}
			}
			var lastMatch = matchs[len-1]
			domBuilder.startDTD(name, pubid, sysid);
			domBuilder.endDTD();
			
			return lastMatch.index+lastMatch[0].length
		}
	}
	return -1;
}



function parseInstruction(source,start,domBuilder){
	var end = source.indexOf('?>',start);
	if(end){
		var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
		if(match){
			var len = match[0].length;
			domBuilder.processingInstruction(match[1], match[2]) ;
			return end+2;
		}else{//error
			return -1;
		}
	}
	return -1;
}

function ElementAttributes(){
	this.attributeNames = {}
}
ElementAttributes.prototype = {
	setTagName:function(tagName){
		if(!tagNamePattern.test(tagName)){
			throw new Error('invalid tagName:'+tagName)
		}
		this.tagName = tagName
	},
	addValue:function(qName, value, offset) {
		if(!tagNamePattern.test(qName)){
			throw new Error('invalid attribute:'+qName)
		}
		this.attributeNames[qName] = this.length;
		this[this.length++] = {qName:qName,value:value,offset:offset}
	},
	length:0,
	getLocalName:function(i){return this[i].localName},
	getLocator:function(i){return this[i].locator},
	getQName:function(i){return this[i].qName},
	getURI:function(i){return this[i].uri},
	getValue:function(i){return this[i].value}
//	,getIndex:function(uri, localName)){
//		if(localName){
//			
//		}else{
//			var qName = uri
//		}
//	},
//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
//	getType:function(uri,localName){}
//	getType:function(i){},
}



function split(source,start){
	var match;
	var buf = [];
	var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
	reg.lastIndex = start;
	reg.exec(source);//skip <
	while(match = reg.exec(source)){
		buf.push(match);
		if(match[1])return buf;
	}
}

exports.XMLReader = XMLReader;
exports.ParseError = ParseError;


/***/ }),

/***/ 8318:
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var assign, isArray, isEmpty, isFunction, isObject, isPlainObject,
    slice = [].slice,
    hasProp = {}.hasOwnProperty;

  assign = function() {
    var i, key, len, source, sources, target;
    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (isFunction(Object.assign)) {
      Object.assign.apply(null, arguments);
    } else {
      for (i = 0, len = sources.length; i < len; i++) {
        source = sources[i];
        if (source != null) {
          for (key in source) {
            if (!hasProp.call(source, key)) continue;
            target[key] = source[key];
          }
        }
      }
    }
    return target;
  };

  isFunction = function(val) {
    return !!val && Object.prototype.toString.call(val) === '[object Function]';
  };

  isObject = function(val) {
    var ref;
    return !!val && ((ref = typeof val) === 'function' || ref === 'object');
  };

  isArray = function(val) {
    if (isFunction(Array.isArray)) {
      return Array.isArray(val);
    } else {
      return Object.prototype.toString.call(val) === '[object Array]';
    }
  };

  isEmpty = function(val) {
    var key;
    if (isArray(val)) {
      return !val.length;
    } else {
      for (key in val) {
        if (!hasProp.call(val, key)) continue;
        return false;
      }
      return true;
    }
  };

  isPlainObject = function(val) {
    var ctor, proto;
    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));
  };

  module.exports.assign = assign;

  module.exports.isFunction = isFunction;

  module.exports.isObject = isObject;

  module.exports.isArray = isArray;

  module.exports.isEmpty = isEmpty;

  module.exports.isPlainObject = isPlainObject;

}).call(this);


/***/ }),

/***/ 8311:
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLAttribute;

  module.exports = XMLAttribute = (function() {
    function XMLAttribute(parent, name, value) {
      this.options = parent.options;
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing attribute name of element " + parent.name);
      }
      if (value == null) {
        throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
      }
      this.name = this.stringify.attName(name);
      this.value = this.stringify.attValue(value);
    }

    XMLAttribute.prototype.clone = function() {
      return Object.create(this);
    };

    XMLAttribute.prototype.toString = function(options) {
      return this.options.writer.set(options).attribute(this);
    };

    return XMLAttribute;

  })();

}).call(this);


/***/ }),

/***/ 5851:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCData, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(94);

  module.exports = XMLCData = (function(superClass) {
    extend(XMLCData, superClass);

    function XMLCData(parent, text) {
      XMLCData.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing CDATA text");
      }
      this.text = this.stringify.cdata(text);
    }

    XMLCData.prototype.clone = function() {
      return Object.create(this);
    };

    XMLCData.prototype.toString = function(options) {
      return this.options.writer.set(options).cdata(this);
    };

    return XMLCData;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 1989:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLComment, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(94);

  module.exports = XMLComment = (function(superClass) {
    extend(XMLComment, superClass);

    function XMLComment(parent, text) {
      XMLComment.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing comment text");
      }
      this.text = this.stringify.comment(text);
    }

    XMLComment.prototype.clone = function() {
      return Object.create(this);
    };

    XMLComment.prototype.toString = function(options) {
      return this.options.writer.set(options).comment(this);
    };

    return XMLComment;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 1586:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDAttList, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(94);

  module.exports = XMLDTDAttList = (function(superClass) {
    extend(XMLDTDAttList, superClass);

    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      XMLDTDAttList.__super__.constructor.call(this, parent);
      if (elementName == null) {
        throw new Error("Missing DTD element name");
      }
      if (attributeName == null) {
        throw new Error("Missing DTD attribute name");
      }
      if (!attributeType) {
        throw new Error("Missing DTD attribute type");
      }
      if (!defaultValueType) {
        throw new Error("Missing DTD attribute default");
      }
      if (defaultValueType.indexOf('#') !== 0) {
        defaultValueType = '#' + defaultValueType;
      }
      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
      }
      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
        throw new Error("Default value only applies to #FIXED or #DEFAULT");
      }
      this.elementName = this.stringify.eleName(elementName);
      this.attributeName = this.stringify.attName(attributeName);
      this.attributeType = this.stringify.dtdAttType(attributeType);
      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
      this.defaultValueType = defaultValueType;
    }

    XMLDTDAttList.prototype.toString = function(options) {
      return this.options.writer.set(options).dtdAttList(this);
    };

    return XMLDTDAttList;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 1800:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDElement, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(94);

  module.exports = XMLDTDElement = (function(superClass) {
    extend(XMLDTDElement, superClass);

    function XMLDTDElement(parent, name, value) {
      XMLDTDElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing DTD element name");
      }
      if (!value) {
        value = '(#PCDATA)';
      }
      if (Array.isArray(value)) {
        value = '(' + value.join(',') + ')';
      }
      this.name = this.stringify.eleName(name);
      this.value = this.stringify.dtdElementValue(value);
    }

    XMLDTDElement.prototype.toString = function(options) {
      return this.options.writer.set(options).dtdElement(this);
    };

    return XMLDTDElement;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 3252:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDEntity, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = __webpack_require__(8318).isObject;

  XMLNode = __webpack_require__(94);

  module.exports = XMLDTDEntity = (function(superClass) {
    extend(XMLDTDEntity, superClass);

    function XMLDTDEntity(parent, pe, name, value) {
      XMLDTDEntity.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing entity name");
      }
      if (value == null) {
        throw new Error("Missing entity value");
      }
      this.pe = !!pe;
      this.name = this.stringify.eleName(name);
      if (!isObject(value)) {
        this.value = this.stringify.dtdEntityValue(value);
      } else {
        if (!value.pubID && !value.sysID) {
          throw new Error("Public and/or system identifiers are required for an external entity");
        }
        if (value.pubID && !value.sysID) {
          throw new Error("System identifier is required for a public external entity");
        }
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
        if (value.nData != null) {
          this.nData = this.stringify.dtdNData(value.nData);
        }
        if (this.pe && this.nData) {
          throw new Error("Notation declaration is not allowed in a parameter entity");
        }
      }
    }

    XMLDTDEntity.prototype.toString = function(options) {
      return this.options.writer.set(options).dtdEntity(this);
    };

    return XMLDTDEntity;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 5360:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDNotation, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(94);

  module.exports = XMLDTDNotation = (function(superClass) {
    extend(XMLDTDNotation, superClass);

    function XMLDTDNotation(parent, name, value) {
      XMLDTDNotation.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing notation name");
      }
      if (!value.pubID && !value.sysID) {
        throw new Error("Public or system identifiers are required for an external entity");
      }
      this.name = this.stringify.eleName(name);
      if (value.pubID != null) {
        this.pubID = this.stringify.dtdPubID(value.pubID);
      }
      if (value.sysID != null) {
        this.sysID = this.stringify.dtdSysID(value.sysID);
      }
    }

    XMLDTDNotation.prototype.toString = function(options) {
      return this.options.writer.set(options).dtdNotation(this);
    };

    return XMLDTDNotation;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 7365:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDeclaration, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = __webpack_require__(8318).isObject;

  XMLNode = __webpack_require__(94);

  module.exports = XMLDeclaration = (function(superClass) {
    extend(XMLDeclaration, superClass);

    function XMLDeclaration(parent, version, encoding, standalone) {
      var ref;
      XMLDeclaration.__super__.constructor.call(this, parent);
      if (isObject(version)) {
        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
      }
      if (!version) {
        version = '1.0';
      }
      this.version = this.stringify.xmlVersion(version);
      if (encoding != null) {
        this.encoding = this.stringify.xmlEncoding(encoding);
      }
      if (standalone != null) {
        this.standalone = this.stringify.xmlStandalone(standalone);
      }
    }

    XMLDeclaration.prototype.toString = function(options) {
      return this.options.writer.set(options).declaration(this);
    };

    return XMLDeclaration;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 1479:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = __webpack_require__(8318).isObject;

  XMLNode = __webpack_require__(94);

  XMLDTDAttList = __webpack_require__(1586);

  XMLDTDEntity = __webpack_require__(3252);

  XMLDTDElement = __webpack_require__(1800);

  XMLDTDNotation = __webpack_require__(5360);

  module.exports = XMLDocType = (function(superClass) {
    extend(XMLDocType, superClass);

    function XMLDocType(parent, pubID, sysID) {
      var ref, ref1;
      XMLDocType.__super__.constructor.call(this, parent);
      this.documentObject = parent;
      if (isObject(pubID)) {
        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
      }
      if (sysID == null) {
        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
      }
      if (pubID != null) {
        this.pubID = this.stringify.dtdPubID(pubID);
      }
      if (sysID != null) {
        this.sysID = this.stringify.dtdSysID(sysID);
      }
    }

    XMLDocType.prototype.element = function(name, value) {
      var child;
      child = new XMLDTDElement(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var child;
      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.entity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, false, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.pEntity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, true, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.notation = function(name, value) {
      var child;
      child = new XMLDTDNotation(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.toString = function(options) {
      return this.options.writer.set(options).docType(this);
    };

    XMLDocType.prototype.ele = function(name, value) {
      return this.element(name, value);
    };

    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
    };

    XMLDocType.prototype.ent = function(name, value) {
      return this.entity(name, value);
    };

    XMLDocType.prototype.pent = function(name, value) {
      return this.pEntity(name, value);
    };

    XMLDocType.prototype.not = function(name, value) {
      return this.notation(name, value);
    };

    XMLDocType.prototype.up = function() {
      return this.root() || this.documentObject;
    };

    return XMLDocType;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 5255:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isPlainObject = __webpack_require__(8318).isPlainObject;

  XMLNode = __webpack_require__(94);

  XMLStringifier = __webpack_require__(926);

  XMLStringWriter = __webpack_require__(7155);

  module.exports = XMLDocument = (function(superClass) {
    extend(XMLDocument, superClass);

    function XMLDocument(options) {
      XMLDocument.__super__.constructor.call(this, null);
      options || (options = {});
      if (!options.writer) {
        options.writer = new XMLStringWriter();
      }
      this.options = options;
      this.stringify = new XMLStringifier(options);
      this.isDocument = true;
    }

    XMLDocument.prototype.end = function(writer) {
      var writerOptions;
      if (!writer) {
        writer = this.options.writer;
      } else if (isPlainObject(writer)) {
        writerOptions = writer;
        writer = this.options.writer.set(writerOptions);
      }
      return writer.document(this);
    };

    XMLDocument.prototype.toString = function(options) {
      return this.options.writer.set(options).document(this);
    };

    return XMLDocument;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 9587:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, isFunction, isObject, isPlainObject, ref,
    hasProp = {}.hasOwnProperty;

  ref = __webpack_require__(8318), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject;

  XMLElement = __webpack_require__(2433);

  XMLCData = __webpack_require__(5851);

  XMLComment = __webpack_require__(1989);

  XMLRaw = __webpack_require__(1785);

  XMLText = __webpack_require__(1879);

  XMLProcessingInstruction = __webpack_require__(5713);

  XMLDeclaration = __webpack_require__(7365);

  XMLDocType = __webpack_require__(1479);

  XMLDTDAttList = __webpack_require__(1586);

  XMLDTDEntity = __webpack_require__(3252);

  XMLDTDElement = __webpack_require__(1800);

  XMLDTDNotation = __webpack_require__(5360);

  XMLAttribute = __webpack_require__(8311);

  XMLStringifier = __webpack_require__(926);

  XMLStringWriter = __webpack_require__(7155);

  module.exports = XMLDocumentCB = (function() {
    function XMLDocumentCB(options, onData, onEnd) {
      var writerOptions;
      options || (options = {});
      if (!options.writer) {
        options.writer = new XMLStringWriter(options);
      } else if (isPlainObject(options.writer)) {
        writerOptions = options.writer;
        options.writer = new XMLStringWriter(writerOptions);
      }
      this.options = options;
      this.writer = options.writer;
      this.stringify = new XMLStringifier(options);
      this.onDataCallback = onData || function() {};
      this.onEndCallback = onEnd || function() {};
      this.currentNode = null;
      this.currentLevel = -1;
      this.openTags = {};
      this.documentStarted = false;
      this.documentCompleted = false;
      this.root = null;
    }

    XMLDocumentCB.prototype.node = function(name, attributes, text) {
      var ref1;
      if (name == null) {
        throw new Error("Missing node name");
      }
      if (this.root && this.currentLevel === -1) {
        throw new Error("Document can only have one root node");
      }
      this.openCurrent();
      name = name.valueOf();
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      this.currentNode = new XMLElement(this, name, attributes);
      this.currentNode.children = false;
      this.currentLevel++;
      this.openTags[this.currentLevel] = this.currentNode;
      if (text != null) {
        this.text(text);
      }
      return this;
    };

    XMLDocumentCB.prototype.element = function(name, attributes, text) {
      if (this.currentNode && this.currentNode instanceof XMLDocType) {
        return this.dtdElement.apply(this, arguments);
      } else {
        return this.node(name, attributes, text);
      }
    };

    XMLDocumentCB.prototype.attribute = function(name, value) {
      var attName, attValue;
      if (!this.currentNode || this.currentNode.children) {
        throw new Error("att() can only be used immediately after an ele() call in callback mode");
      }
      if (name != null) {
        name = name.valueOf();
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (!this.options.skipNullAttributes || (value != null)) {
          this.currentNode.attributes[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLDocumentCB.prototype.text = function(value) {
      var node;
      this.openCurrent();
      node = new XMLText(this, value);
      this.onData(this.writer.text(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.cdata = function(value) {
      var node;
      this.openCurrent();
      node = new XMLCData(this, value);
      this.onData(this.writer.cdata(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.comment = function(value) {
      var node;
      this.openCurrent();
      node = new XMLComment(this, value);
      this.onData(this.writer.comment(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.raw = function(value) {
      var node;
      this.openCurrent();
      node = new XMLRaw(this, value);
      this.onData(this.writer.raw(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.instruction = function(target, value) {
      var i, insTarget, insValue, len, node;
      this.openCurrent();
      if (target != null) {
        target = target.valueOf();
      }
      if (value != null) {
        value = value.valueOf();
      }
      if (Array.isArray(target)) {
        for (i = 0, len = target.length; i < len; i++) {
          insTarget = target[i];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        node = new XMLProcessingInstruction(this, target, value);
        this.onData(this.writer.processingInstruction(node, this.currentLevel + 1));
      }
      return this;
    };

    XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
      var node;
      this.openCurrent();
      if (this.documentStarted) {
        throw new Error("declaration() must be the first node");
      }
      node = new XMLDeclaration(this, version, encoding, standalone);
      this.onData(this.writer.declaration(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
      this.openCurrent();
      if (root == null) {
        throw new Error("Missing root node name");
      }
      if (this.root) {
        throw new Error("dtd() must come before the root node");
      }
      this.currentNode = new XMLDocType(this, pubID, sysID);
      this.currentNode.rootNodeName = root;
      this.currentNode.children = false;
      this.currentLevel++;
      this.openTags[this.currentLevel] = this.currentNode;
      return this;
    };

    XMLDocumentCB.prototype.dtdElement = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDElement(this, name, value);
      this.onData(this.writer.dtdElement(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var node;
      this.openCurrent();
      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.onData(this.writer.dtdAttList(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.entity = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDEntity(this, false, name, value);
      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.pEntity = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDEntity(this, true, name, value);
      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.notation = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDNotation(this, name, value);
      this.onData(this.writer.dtdNotation(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.up = function() {
      if (this.currentLevel < 0) {
        throw new Error("The document node has no parent");
      }
      if (this.currentNode) {
        if (this.currentNode.children) {
          this.closeNode(this.currentNode);
        } else {
          this.openNode(this.currentNode);
        }
        this.currentNode = null;
      } else {
        this.closeNode(this.openTags[this.currentLevel]);
      }
      delete this.openTags[this.currentLevel];
      this.currentLevel--;
      return this;
    };

    XMLDocumentCB.prototype.end = function() {
      while (this.currentLevel >= 0) {
        this.up();
      }
      return this.onEnd();
    };

    XMLDocumentCB.prototype.openCurrent = function() {
      if (this.currentNode) {
        this.currentNode.children = true;
        return this.openNode(this.currentNode);
      }
    };

    XMLDocumentCB.prototype.openNode = function(node) {
      if (!node.isOpen) {
        if (!this.root && this.currentLevel === 0 && node instanceof XMLElement) {
          this.root = node;
        }
        this.onData(this.writer.openNode(node, this.currentLevel));
        return node.isOpen = true;
      }
    };

    XMLDocumentCB.prototype.closeNode = function(node) {
      if (!node.isClosed) {
        this.onData(this.writer.closeNode(node, this.currentLevel));
        return node.isClosed = true;
      }
    };

    XMLDocumentCB.prototype.onData = function(chunk) {
      this.documentStarted = true;
      return this.onDataCallback(chunk);
    };

    XMLDocumentCB.prototype.onEnd = function() {
      this.documentCompleted = true;
      return this.onEndCallback();
    };

    XMLDocumentCB.prototype.ele = function() {
      return this.element.apply(this, arguments);
    };

    XMLDocumentCB.prototype.nod = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLDocumentCB.prototype.txt = function(value) {
      return this.text(value);
    };

    XMLDocumentCB.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLDocumentCB.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLDocumentCB.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
      return this.doctype(root, pubID, sysID);
    };

    XMLDocumentCB.prototype.e = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLDocumentCB.prototype.n = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLDocumentCB.prototype.t = function(value) {
      return this.text(value);
    };

    XMLDocumentCB.prototype.d = function(value) {
      return this.cdata(value);
    };

    XMLDocumentCB.prototype.c = function(value) {
      return this.comment(value);
    };

    XMLDocumentCB.prototype.r = function(value) {
      return this.raw(value);
    };

    XMLDocumentCB.prototype.i = function(target, value) {
      return this.instruction(target, value);
    };

    XMLDocumentCB.prototype.att = function() {
      if (this.currentNode && this.currentNode instanceof XMLDocType) {
        return this.attList.apply(this, arguments);
      } else {
        return this.attribute.apply(this, arguments);
      }
    };

    XMLDocumentCB.prototype.a = function() {
      if (this.currentNode && this.currentNode instanceof XMLDocType) {
        return this.attList.apply(this, arguments);
      } else {
        return this.attribute.apply(this, arguments);
      }
    };

    XMLDocumentCB.prototype.ent = function(name, value) {
      return this.entity(name, value);
    };

    XMLDocumentCB.prototype.pent = function(name, value) {
      return this.pEntity(name, value);
    };

    XMLDocumentCB.prototype.not = function(name, value) {
      return this.notation(name, value);
    };

    return XMLDocumentCB;

  })();

}).call(this);


/***/ }),

/***/ 2433:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLAttribute, XMLElement, XMLNode, isFunction, isObject, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = __webpack_require__(8318), isObject = ref.isObject, isFunction = ref.isFunction;

  XMLNode = __webpack_require__(94);

  XMLAttribute = __webpack_require__(8311);

  module.exports = XMLElement = (function(superClass) {
    extend(XMLElement, superClass);

    function XMLElement(parent, name, attributes) {
      XMLElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing element name");
      }
      this.name = this.stringify.eleName(name);
      this.attributes = {};
      if (attributes != null) {
        this.attribute(attributes);
      }
      if (parent.isDocument) {
        this.isRoot = true;
        this.documentObject = parent;
        parent.rootObject = this;
      }
    }

    XMLElement.prototype.clone = function() {
      var att, attName, clonedSelf, ref1;
      clonedSelf = Object.create(this);
      if (clonedSelf.isRoot) {
        clonedSelf.documentObject = null;
      }
      clonedSelf.attributes = {};
      ref1 = this.attributes;
      for (attName in ref1) {
        if (!hasProp.call(ref1, attName)) continue;
        att = ref1[attName];
        clonedSelf.attributes[attName] = att.clone();
      }
      clonedSelf.children = [];
      this.children.forEach(function(child) {
        var clonedChild;
        clonedChild = child.clone();
        clonedChild.parent = clonedSelf;
        return clonedSelf.children.push(clonedChild);
      });
      return clonedSelf;
    };

    XMLElement.prototype.attribute = function(name, value) {
      var attName, attValue;
      if (name != null) {
        name = name.valueOf();
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (!this.options.skipNullAttributes || (value != null)) {
          this.attributes[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLElement.prototype.removeAttribute = function(name) {
      var attName, i, len;
      if (name == null) {
        throw new Error("Missing attribute name");
      }
      name = name.valueOf();
      if (Array.isArray(name)) {
        for (i = 0, len = name.length; i < len; i++) {
          attName = name[i];
          delete this.attributes[attName];
        }
      } else {
        delete this.attributes[name];
      }
      return this;
    };

    XMLElement.prototype.toString = function(options) {
      return this.options.writer.set(options).element(this);
    };

    XMLElement.prototype.att = function(name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.a = function(name, value) {
      return this.attribute(name, value);
    };

    return XMLElement;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 94:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLProcessingInstruction, XMLRaw, XMLText, isEmpty, isFunction, isObject, ref,
    hasProp = {}.hasOwnProperty;

  ref = __webpack_require__(8318), isObject = ref.isObject, isFunction = ref.isFunction, isEmpty = ref.isEmpty;

  XMLElement = null;

  XMLCData = null;

  XMLComment = null;

  XMLDeclaration = null;

  XMLDocType = null;

  XMLRaw = null;

  XMLText = null;

  XMLProcessingInstruction = null;

  module.exports = XMLNode = (function() {
    function XMLNode(parent) {
      this.parent = parent;
      if (this.parent) {
        this.options = this.parent.options;
        this.stringify = this.parent.stringify;
      }
      this.children = [];
      if (!XMLElement) {
        XMLElement = __webpack_require__(2433);
        XMLCData = __webpack_require__(5851);
        XMLComment = __webpack_require__(1989);
        XMLDeclaration = __webpack_require__(7365);
        XMLDocType = __webpack_require__(1479);
        XMLRaw = __webpack_require__(1785);
        XMLText = __webpack_require__(1879);
        XMLProcessingInstruction = __webpack_require__(5713);
      }
    }

    XMLNode.prototype.element = function(name, attributes, text) {
      var childNode, item, j, k, key, lastChild, len, len1, ref1, val;
      lastChild = null;
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      if (name != null) {
        name = name.valueOf();
      }
      if (Array.isArray(name)) {
        for (j = 0, len = name.length; j < len; j++) {
          item = name[j];
          lastChild = this.element(item);
        }
      } else if (isFunction(name)) {
        lastChild = this.element(name.apply());
      } else if (isObject(name)) {
        for (key in name) {
          if (!hasProp.call(name, key)) continue;
          val = name[key];
          if (isFunction(val)) {
            val = val.apply();
          }
          if ((isObject(val)) && (isEmpty(val))) {
            val = null;
          }
          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
          } else if (!this.options.separateArrayItems && Array.isArray(val)) {
            for (k = 0, len1 = val.length; k < len1; k++) {
              item = val[k];
              childNode = {};
              childNode[key] = item;
              lastChild = this.element(childNode);
            }
          } else if (isObject(val)) {
            lastChild = this.element(key);
            lastChild.element(val);
          } else {
            lastChild = this.element(key, val);
          }
        }
      } else {
        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
          lastChild = this.text(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
          lastChild = this.cdata(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
          lastChild = this.comment(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
          lastChild = this.raw(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
          lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
        } else {
          lastChild = this.node(name, attributes, text);
        }
      }
      if (lastChild == null) {
        throw new Error("Could not create any elements with: " + name);
      }
      return lastChild;
    };

    XMLNode.prototype.insertBefore = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.insertAfter = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.remove = function() {
      var i, ref1;
      if (this.isRoot) {
        throw new Error("Cannot remove the root element");
      }
      i = this.parent.children.indexOf(this);
      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;
      return this.parent;
    };

    XMLNode.prototype.node = function(name, attributes, text) {
      var child, ref1;
      if (name != null) {
        name = name.valueOf();
      }
      attributes || (attributes = {});
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      child = new XMLElement(this, name, attributes);
      if (text != null) {
        child.text(text);
      }
      this.children.push(child);
      return child;
    };

    XMLNode.prototype.text = function(value) {
      var child;
      child = new XMLText(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.cdata = function(value) {
      var child;
      child = new XMLCData(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.comment = function(value) {
      var child;
      child = new XMLComment(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.commentBefore = function(value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.comment(value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.commentAfter = function(value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.comment(value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.raw = function(value) {
      var child;
      child = new XMLRaw(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.instruction = function(target, value) {
      var insTarget, insValue, instruction, j, len;
      if (target != null) {
        target = target.valueOf();
      }
      if (value != null) {
        value = value.valueOf();
      }
      if (Array.isArray(target)) {
        for (j = 0, len = target.length; j < len; j++) {
          insTarget = target[j];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        instruction = new XMLProcessingInstruction(this, target, value);
        this.children.push(instruction);
      }
      return this;
    };

    XMLNode.prototype.instructionBefore = function(target, value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.instruction(target, value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.instructionAfter = function(target, value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.instruction(target, value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.declaration = function(version, encoding, standalone) {
      var doc, xmldec;
      doc = this.document();
      xmldec = new XMLDeclaration(doc, version, encoding, standalone);
      if (doc.children[0] instanceof XMLDeclaration) {
        doc.children[0] = xmldec;
      } else {
        doc.children.unshift(xmldec);
      }
      return doc.root() || doc;
    };

    XMLNode.prototype.doctype = function(pubID, sysID) {
      var child, doc, doctype, i, j, k, len, len1, ref1, ref2;
      doc = this.document();
      doctype = new XMLDocType(doc, pubID, sysID);
      ref1 = doc.children;
      for (i = j = 0, len = ref1.length; j < len; i = ++j) {
        child = ref1[i];
        if (child instanceof XMLDocType) {
          doc.children[i] = doctype;
          return doctype;
        }
      }
      ref2 = doc.children;
      for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {
        child = ref2[i];
        if (child.isRoot) {
          doc.children.splice(i, 0, doctype);
          return doctype;
        }
      }
      doc.children.push(doctype);
      return doctype;
    };

    XMLNode.prototype.up = function() {
      if (this.isRoot) {
        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
      }
      return this.parent;
    };

    XMLNode.prototype.root = function() {
      var node;
      node = this;
      while (node) {
        if (node.isDocument) {
          return node.rootObject;
        } else if (node.isRoot) {
          return node;
        } else {
          node = node.parent;
        }
      }
    };

    XMLNode.prototype.document = function() {
      var node;
      node = this;
      while (node) {
        if (node.isDocument) {
          return node;
        } else {
          node = node.parent;
        }
      }
    };

    XMLNode.prototype.end = function(options) {
      return this.document().end(options);
    };

    XMLNode.prototype.prev = function() {
      var i;
      i = this.parent.children.indexOf(this);
      if (i < 1) {
        throw new Error("Already at the first node");
      }
      return this.parent.children[i - 1];
    };

    XMLNode.prototype.next = function() {
      var i;
      i = this.parent.children.indexOf(this);
      if (i === -1 || i === this.parent.children.length - 1) {
        throw new Error("Already at the last node");
      }
      return this.parent.children[i + 1];
    };

    XMLNode.prototype.importDocument = function(doc) {
      var clonedRoot;
      clonedRoot = doc.root().clone();
      clonedRoot.parent = this;
      clonedRoot.isRoot = false;
      this.children.push(clonedRoot);
      return this;
    };

    XMLNode.prototype.ele = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.nod = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.txt = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLNode.prototype.doc = function() {
      return this.document();
    };

    XMLNode.prototype.dec = function(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLNode.prototype.dtd = function(pubID, sysID) {
      return this.doctype(pubID, sysID);
    };

    XMLNode.prototype.e = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.n = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.t = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.d = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.c = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.r = function(value) {
      return this.raw(value);
    };

    XMLNode.prototype.i = function(target, value) {
      return this.instruction(target, value);
    };

    XMLNode.prototype.u = function() {
      return this.up();
    };

    XMLNode.prototype.importXMLBuilder = function(doc) {
      return this.importDocument(doc);
    };

    return XMLNode;

  })();

}).call(this);


/***/ }),

/***/ 5713:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLNode, XMLProcessingInstruction,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(94);

  module.exports = XMLProcessingInstruction = (function(superClass) {
    extend(XMLProcessingInstruction, superClass);

    function XMLProcessingInstruction(parent, target, value) {
      XMLProcessingInstruction.__super__.constructor.call(this, parent);
      if (target == null) {
        throw new Error("Missing instruction target");
      }
      this.target = this.stringify.insTarget(target);
      if (value) {
        this.value = this.stringify.insValue(value);
      }
    }

    XMLProcessingInstruction.prototype.clone = function() {
      return Object.create(this);
    };

    XMLProcessingInstruction.prototype.toString = function(options) {
      return this.options.writer.set(options).processingInstruction(this);
    };

    return XMLProcessingInstruction;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 1785:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLNode, XMLRaw,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(94);

  module.exports = XMLRaw = (function(superClass) {
    extend(XMLRaw, superClass);

    function XMLRaw(parent, text) {
      XMLRaw.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing raw text");
      }
      this.value = this.stringify.raw(text);
    }

    XMLRaw.prototype.clone = function() {
      return Object.create(this);
    };

    XMLRaw.prototype.toString = function(options) {
      return this.options.writer.set(options).raw(this);
    };

    return XMLRaw;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 9427:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStreamWriter, XMLText, XMLWriterBase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLDeclaration = __webpack_require__(7365);

  XMLDocType = __webpack_require__(1479);

  XMLCData = __webpack_require__(5851);

  XMLComment = __webpack_require__(1989);

  XMLElement = __webpack_require__(2433);

  XMLRaw = __webpack_require__(1785);

  XMLText = __webpack_require__(1879);

  XMLProcessingInstruction = __webpack_require__(5713);

  XMLDTDAttList = __webpack_require__(1586);

  XMLDTDElement = __webpack_require__(1800);

  XMLDTDEntity = __webpack_require__(3252);

  XMLDTDNotation = __webpack_require__(5360);

  XMLWriterBase = __webpack_require__(3935);

  module.exports = XMLStreamWriter = (function(superClass) {
    extend(XMLStreamWriter, superClass);

    function XMLStreamWriter(stream, options) {
      XMLStreamWriter.__super__.constructor.call(this, options);
      this.stream = stream;
    }

    XMLStreamWriter.prototype.document = function(doc) {
      var child, i, j, len, len1, ref, ref1, results;
      ref = doc.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        child.isLastRootNode = false;
      }
      doc.children[doc.children.length - 1].isLastRootNode = true;
      ref1 = doc.children;
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        child = ref1[j];
        switch (false) {
          case !(child instanceof XMLDeclaration):
            results.push(this.declaration(child));
            break;
          case !(child instanceof XMLDocType):
            results.push(this.docType(child));
            break;
          case !(child instanceof XMLComment):
            results.push(this.comment(child));
            break;
          case !(child instanceof XMLProcessingInstruction):
            results.push(this.processingInstruction(child));
            break;
          default:
            results.push(this.element(child));
        }
      }
      return results;
    };

    XMLStreamWriter.prototype.attribute = function(att) {
      return this.stream.write(' ' + att.name + '="' + att.value + '"');
    };

    XMLStreamWriter.prototype.cdata = function(node, level) {
      return this.stream.write(this.space(level) + '<![CDATA[' + node.text + ']]>' + this.endline(node));
    };

    XMLStreamWriter.prototype.comment = function(node, level) {
      return this.stream.write(this.space(level) + '<!-- ' + node.text + ' -->' + this.endline(node));
    };

    XMLStreamWriter.prototype.declaration = function(node, level) {
      this.stream.write(this.space(level));
      this.stream.write('<?xml version="' + node.version + '"');
      if (node.encoding != null) {
        this.stream.write(' encoding="' + node.encoding + '"');
      }
      if (node.standalone != null) {
        this.stream.write(' standalone="' + node.standalone + '"');
      }
      this.stream.write(this.spacebeforeslash + '?>');
      return this.stream.write(this.endline(node));
    };

    XMLStreamWriter.prototype.docType = function(node, level) {
      var child, i, len, ref;
      level || (level = 0);
      this.stream.write(this.space(level));
      this.stream.write('<!DOCTYPE ' + node.root().name);
      if (node.pubID && node.sysID) {
        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
      } else if (node.sysID) {
        this.stream.write(' SYSTEM "' + node.sysID + '"');
      }
      if (node.children.length > 0) {
        this.stream.write(' [');
        this.stream.write(this.endline(node));
        ref = node.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          switch (false) {
            case !(child instanceof XMLDTDAttList):
              this.dtdAttList(child, level + 1);
              break;
            case !(child instanceof XMLDTDElement):
              this.dtdElement(child, level + 1);
              break;
            case !(child instanceof XMLDTDEntity):
              this.dtdEntity(child, level + 1);
              break;
            case !(child instanceof XMLDTDNotation):
              this.dtdNotation(child, level + 1);
              break;
            case !(child instanceof XMLCData):
              this.cdata(child, level + 1);
              break;
            case !(child instanceof XMLComment):
              this.comment(child, level + 1);
              break;
            case !(child instanceof XMLProcessingInstruction):
              this.processingInstruction(child, level + 1);
              break;
            default:
              throw new Error("Unknown DTD node type: " + child.constructor.name);
          }
        }
        this.stream.write(']');
      }
      this.stream.write(this.spacebeforeslash + '>');
      return this.stream.write(this.endline(node));
    };

    XMLStreamWriter.prototype.element = function(node, level) {
      var att, child, i, len, name, ref, ref1, space;
      level || (level = 0);
      space = this.space(level);
      this.stream.write(space + '<' + node.name);
      ref = node.attributes;
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        att = ref[name];
        this.attribute(att);
      }
      if (node.children.length === 0 || node.children.every(function(e) {
        return e.value === '';
      })) {
        if (this.allowEmpty) {
          this.stream.write('></' + node.name + '>');
        } else {
          this.stream.write(this.spacebeforeslash + '/>');
        }
      } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {
        this.stream.write('>');
        this.stream.write(node.children[0].value);
        this.stream.write('</' + node.name + '>');
      } else {
        this.stream.write('>' + this.newline);
        ref1 = node.children;
        for (i = 0, len = ref1.length; i < len; i++) {
          child = ref1[i];
          switch (false) {
            case !(child instanceof XMLCData):
              this.cdata(child, level + 1);
              break;
            case !(child instanceof XMLComment):
              this.comment(child, level + 1);
              break;
            case !(child instanceof XMLElement):
              this.element(child, level + 1);
              break;
            case !(child instanceof XMLRaw):
              this.raw(child, level + 1);
              break;
            case !(child instanceof XMLText):
              this.text(child, level + 1);
              break;
            case !(child instanceof XMLProcessingInstruction):
              this.processingInstruction(child, level + 1);
              break;
            default:
              throw new Error("Unknown XML node type: " + child.constructor.name);
          }
        }
        this.stream.write(space + '</' + node.name + '>');
      }
      return this.stream.write(this.endline(node));
    };

    XMLStreamWriter.prototype.processingInstruction = function(node, level) {
      this.stream.write(this.space(level) + '<?' + node.target);
      if (node.value) {
        this.stream.write(' ' + node.value);
      }
      return this.stream.write(this.spacebeforeslash + '?>' + this.endline(node));
    };

    XMLStreamWriter.prototype.raw = function(node, level) {
      return this.stream.write(this.space(level) + node.value + this.endline(node));
    };

    XMLStreamWriter.prototype.text = function(node, level) {
      return this.stream.write(this.space(level) + node.value + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdAttList = function(node, level) {
      this.stream.write(this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType);
      if (node.defaultValueType !== '#DEFAULT') {
        this.stream.write(' ' + node.defaultValueType);
      }
      if (node.defaultValue) {
        this.stream.write(' "' + node.defaultValue + '"');
      }
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdElement = function(node, level) {
      this.stream.write(this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value);
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdEntity = function(node, level) {
      this.stream.write(this.space(level) + '<!ENTITY');
      if (node.pe) {
        this.stream.write(' %');
      }
      this.stream.write(' ' + node.name);
      if (node.value) {
        this.stream.write(' "' + node.value + '"');
      } else {
        if (node.pubID && node.sysID) {
          this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
        } else if (node.sysID) {
          this.stream.write(' SYSTEM "' + node.sysID + '"');
        }
        if (node.nData) {
          this.stream.write(' NDATA ' + node.nData);
        }
      }
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdNotation = function(node, level) {
      this.stream.write(this.space(level) + '<!NOTATION ' + node.name);
      if (node.pubID && node.sysID) {
        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
      } else if (node.pubID) {
        this.stream.write(' PUBLIC "' + node.pubID + '"');
      } else if (node.sysID) {
        this.stream.write(' SYSTEM "' + node.sysID + '"');
      }
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.endline = function(node) {
      if (!node.isLastRootNode) {
        return this.newline;
      } else {
        return '';
      }
    };

    return XMLStreamWriter;

  })(XMLWriterBase);

}).call(this);


/***/ }),

/***/ 7155:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLText, XMLWriterBase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLDeclaration = __webpack_require__(7365);

  XMLDocType = __webpack_require__(1479);

  XMLCData = __webpack_require__(5851);

  XMLComment = __webpack_require__(1989);

  XMLElement = __webpack_require__(2433);

  XMLRaw = __webpack_require__(1785);

  XMLText = __webpack_require__(1879);

  XMLProcessingInstruction = __webpack_require__(5713);

  XMLDTDAttList = __webpack_require__(1586);

  XMLDTDElement = __webpack_require__(1800);

  XMLDTDEntity = __webpack_require__(3252);

  XMLDTDNotation = __webpack_require__(5360);

  XMLWriterBase = __webpack_require__(3935);

  module.exports = XMLStringWriter = (function(superClass) {
    extend(XMLStringWriter, superClass);

    function XMLStringWriter(options) {
      XMLStringWriter.__super__.constructor.call(this, options);
    }

    XMLStringWriter.prototype.document = function(doc) {
      var child, i, len, r, ref;
      this.textispresent = false;
      r = '';
      ref = doc.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        r += (function() {
          switch (false) {
            case !(child instanceof XMLDeclaration):
              return this.declaration(child);
            case !(child instanceof XMLDocType):
              return this.docType(child);
            case !(child instanceof XMLComment):
              return this.comment(child);
            case !(child instanceof XMLProcessingInstruction):
              return this.processingInstruction(child);
            default:
              return this.element(child, 0);
          }
        }).call(this);
      }
      if (this.pretty && r.slice(-this.newline.length) === this.newline) {
        r = r.slice(0, -this.newline.length);
      }
      return r;
    };

    XMLStringWriter.prototype.attribute = function(att) {
      return ' ' + att.name + '="' + att.value + '"';
    };

    XMLStringWriter.prototype.cdata = function(node, level) {
      return this.space(level) + '<![CDATA[' + node.text + ']]>' + this.newline;
    };

    XMLStringWriter.prototype.comment = function(node, level) {
      return this.space(level) + '<!-- ' + node.text + ' -->' + this.newline;
    };

    XMLStringWriter.prototype.declaration = function(node, level) {
      var r;
      r = this.space(level);
      r += '<?xml version="' + node.version + '"';
      if (node.encoding != null) {
        r += ' encoding="' + node.encoding + '"';
      }
      if (node.standalone != null) {
        r += ' standalone="' + node.standalone + '"';
      }
      r += this.spacebeforeslash + '?>';
      r += this.newline;
      return r;
    };

    XMLStringWriter.prototype.docType = function(node, level) {
      var child, i, len, r, ref;
      level || (level = 0);
      r = this.space(level);
      r += '<!DOCTYPE ' + node.root().name;
      if (node.pubID && node.sysID) {
        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
      } else if (node.sysID) {
        r += ' SYSTEM "' + node.sysID + '"';
      }
      if (node.children.length > 0) {
        r += ' [';
        r += this.newline;
        ref = node.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          r += (function() {
            switch (false) {
              case !(child instanceof XMLDTDAttList):
                return this.dtdAttList(child, level + 1);
              case !(child instanceof XMLDTDElement):
                return this.dtdElement(child, level + 1);
              case !(child instanceof XMLDTDEntity):
                return this.dtdEntity(child, level + 1);
              case !(child instanceof XMLDTDNotation):
                return this.dtdNotation(child, level + 1);
              case !(child instanceof XMLCData):
                return this.cdata(child, level + 1);
              case !(child instanceof XMLComment):
                return this.comment(child, level + 1);
              case !(child instanceof XMLProcessingInstruction):
                return this.processingInstruction(child, level + 1);
              default:
                throw new Error("Unknown DTD node type: " + child.constructor.name);
            }
          }).call(this);
        }
        r += ']';
      }
      r += this.spacebeforeslash + '>';
      r += this.newline;
      return r;
    };

    XMLStringWriter.prototype.element = function(node, level) {
      var att, child, i, j, len, len1, name, r, ref, ref1, ref2, space, textispresentwasset;
      level || (level = 0);
      textispresentwasset = false;
      if (this.textispresent) {
        this.newline = '';
        this.pretty = false;
      } else {
        this.newline = this.newlinedefault;
        this.pretty = this.prettydefault;
      }
      space = this.space(level);
      r = '';
      r += space + '<' + node.name;
      ref = node.attributes;
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        att = ref[name];
        r += this.attribute(att);
      }
      if (node.children.length === 0 || node.children.every(function(e) {
        return e.value === '';
      })) {
        if (this.allowEmpty) {
          r += '></' + node.name + '>' + this.newline;
        } else {
          r += this.spacebeforeslash + '/>' + this.newline;
        }
      } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {
        r += '>';
        r += node.children[0].value;
        r += '</' + node.name + '>' + this.newline;
      } else {
        if (this.dontprettytextnodes) {
          ref1 = node.children;
          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];
            if (child.value != null) {
              this.textispresent++;
              textispresentwasset = true;
              break;
            }
          }
        }
        if (this.textispresent) {
          this.newline = '';
          this.pretty = false;
          space = this.space(level);
        }
        r += '>' + this.newline;
        ref2 = node.children;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          child = ref2[j];
          r += (function() {
            switch (false) {
              case !(child instanceof XMLCData):
                return this.cdata(child, level + 1);
              case !(child instanceof XMLComment):
                return this.comment(child, level + 1);
              case !(child instanceof XMLElement):
                return this.element(child, level + 1);
              case !(child instanceof XMLRaw):
                return this.raw(child, level + 1);
              case !(child instanceof XMLText):
                return this.text(child, level + 1);
              case !(child instanceof XMLProcessingInstruction):
                return this.processingInstruction(child, level + 1);
              default:
                throw new Error("Unknown XML node type: " + child.constructor.name);
            }
          }).call(this);
        }
        if (textispresentwasset) {
          this.textispresent--;
        }
        if (!this.textispresent) {
          this.newline = this.newlinedefault;
          this.pretty = this.prettydefault;
        }
        r += space + '</' + node.name + '>' + this.newline;
      }
      return r;
    };

    XMLStringWriter.prototype.processingInstruction = function(node, level) {
      var r;
      r = this.space(level) + '<?' + node.target;
      if (node.value) {
        r += ' ' + node.value;
      }
      r += this.spacebeforeslash + '?>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.raw = function(node, level) {
      return this.space(level) + node.value + this.newline;
    };

    XMLStringWriter.prototype.text = function(node, level) {
      return this.space(level) + node.value + this.newline;
    };

    XMLStringWriter.prototype.dtdAttList = function(node, level) {
      var r;
      r = this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
      if (node.defaultValueType !== '#DEFAULT') {
        r += ' ' + node.defaultValueType;
      }
      if (node.defaultValue) {
        r += ' "' + node.defaultValue + '"';
      }
      r += this.spacebeforeslash + '>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.dtdElement = function(node, level) {
      return this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value + this.spacebeforeslash + '>' + this.newline;
    };

    XMLStringWriter.prototype.dtdEntity = function(node, level) {
      var r;
      r = this.space(level) + '<!ENTITY';
      if (node.pe) {
        r += ' %';
      }
      r += ' ' + node.name;
      if (node.value) {
        r += ' "' + node.value + '"';
      } else {
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        if (node.nData) {
          r += ' NDATA ' + node.nData;
        }
      }
      r += this.spacebeforeslash + '>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.dtdNotation = function(node, level) {
      var r;
      r = this.space(level) + '<!NOTATION ' + node.name;
      if (node.pubID && node.sysID) {
        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
      } else if (node.pubID) {
        r += ' PUBLIC "' + node.pubID + '"';
      } else if (node.sysID) {
        r += ' SYSTEM "' + node.sysID + '"';
      }
      r += this.spacebeforeslash + '>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.openNode = function(node, level) {
      var att, name, r, ref;
      level || (level = 0);
      if (node instanceof XMLElement) {
        r = this.space(level) + '<' + node.name;
        ref = node.attributes;
        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          att = ref[name];
          r += this.attribute(att);
        }
        r += (node.children ? '>' : '/>') + this.newline;
        return r;
      } else {
        r = this.space(level) + '<!DOCTYPE ' + node.rootNodeName;
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        r += (node.children ? ' [' : '>') + this.newline;
        return r;
      }
    };

    XMLStringWriter.prototype.closeNode = function(node, level) {
      level || (level = 0);
      switch (false) {
        case !(node instanceof XMLElement):
          return this.space(level) + '</' + node.name + '>' + this.newline;
        case !(node instanceof XMLDocType):
          return this.space(level) + ']>' + this.newline;
      }
    };

    return XMLStringWriter;

  })(XMLWriterBase);

}).call(this);


/***/ }),

/***/ 926:
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLStringifier,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  module.exports = XMLStringifier = (function() {
    function XMLStringifier(options) {
      this.assertLegalChar = bind(this.assertLegalChar, this);
      var key, ref, value;
      options || (options = {});
      this.noDoubleEncoding = options.noDoubleEncoding;
      ref = options.stringify || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this[key] = value;
      }
    }

    XMLStringifier.prototype.eleName = function(val) {
      val = '' + val || '';
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.eleText = function(val) {
      val = '' + val || '';
      return this.assertLegalChar(this.elEscape(val));
    };

    XMLStringifier.prototype.cdata = function(val) {
      val = '' + val || '';
      val = val.replace(']]>', ']]]]><![CDATA[>');
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.comment = function(val) {
      val = '' + val || '';
      if (val.match(/--/)) {
        throw new Error("Comment text cannot contain double-hypen: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.raw = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.attName = function(val) {
      return val = '' + val || '';
    };

    XMLStringifier.prototype.attValue = function(val) {
      val = '' + val || '';
      return this.attEscape(val);
    };

    XMLStringifier.prototype.insTarget = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.insValue = function(val) {
      val = '' + val || '';
      if (val.match(/\?>/)) {
        throw new Error("Invalid processing instruction value: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlVersion = function(val) {
      val = '' + val || '';
      if (!val.match(/1\.[0-9]+/)) {
        throw new Error("Invalid version number: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlEncoding = function(val) {
      val = '' + val || '';
      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
        throw new Error("Invalid encoding: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlStandalone = function(val) {
      if (val) {
        return "yes";
      } else {
        return "no";
      }
    };

    XMLStringifier.prototype.dtdPubID = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdSysID = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdElementValue = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttType = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttDefault = function(val) {
      if (val != null) {
        return '' + val || '';
      } else {
        return val;
      }
    };

    XMLStringifier.prototype.dtdEntityValue = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdNData = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.convertAttKey = '@';

    XMLStringifier.prototype.convertPIKey = '?';

    XMLStringifier.prototype.convertTextKey = '#text';

    XMLStringifier.prototype.convertCDataKey = '#cdata';

    XMLStringifier.prototype.convertCommentKey = '#comment';

    XMLStringifier.prototype.convertRawKey = '#raw';

    XMLStringifier.prototype.assertLegalChar = function(str) {
      var res;
      res = str.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/);
      if (res) {
        throw new Error("Invalid character in string: " + str + " at index " + res.index);
      }
      return str;
    };

    XMLStringifier.prototype.elEscape = function(str) {
      var ampregex;
      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
    };

    XMLStringifier.prototype.attEscape = function(str) {
      var ampregex;
      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
    };

    return XMLStringifier;

  })();

}).call(this);


/***/ }),

/***/ 1879:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLNode, XMLText,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(94);

  module.exports = XMLText = (function(superClass) {
    extend(XMLText, superClass);

    function XMLText(parent, text) {
      XMLText.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing element text");
      }
      this.value = this.stringify.eleText(text);
    }

    XMLText.prototype.clone = function() {
      return Object.create(this);
    };

    XMLText.prototype.toString = function(options) {
      return this.options.writer.set(options).text(this);
    };

    return XMLText;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 3935:
/***/ (function(module) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLWriterBase,
    hasProp = {}.hasOwnProperty;

  module.exports = XMLWriterBase = (function() {
    function XMLWriterBase(options) {
      var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;
      options || (options = {});
      this.pretty = options.pretty || false;
      this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;
      if (this.pretty) {
        this.indent = (ref1 = options.indent) != null ? ref1 : '  ';
        this.newline = (ref2 = options.newline) != null ? ref2 : '\n';
        this.offset = (ref3 = options.offset) != null ? ref3 : 0;
        this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;
      } else {
        this.indent = '';
        this.newline = '';
        this.offset = 0;
        this.dontprettytextnodes = 0;
      }
      this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : '';
      if (this.spacebeforeslash === true) {
        this.spacebeforeslash = ' ';
      }
      this.newlinedefault = this.newline;
      this.prettydefault = this.pretty;
      ref6 = options.writer || {};
      for (key in ref6) {
        if (!hasProp.call(ref6, key)) continue;
        value = ref6[key];
        this[key] = value;
      }
    }

    XMLWriterBase.prototype.set = function(options) {
      var key, ref, value;
      options || (options = {});
      if ("pretty" in options) {
        this.pretty = options.pretty;
      }
      if ("allowEmpty" in options) {
        this.allowEmpty = options.allowEmpty;
      }
      if (this.pretty) {
        this.indent = "indent" in options ? options.indent : '  ';
        this.newline = "newline" in options ? options.newline : '\n';
        this.offset = "offset" in options ? options.offset : 0;
        this.dontprettytextnodes = "dontprettytextnodes" in options ? options.dontprettytextnodes : 0;
      } else {
        this.indent = '';
        this.newline = '';
        this.offset = 0;
        this.dontprettytextnodes = 0;
      }
      this.spacebeforeslash = "spacebeforeslash" in options ? options.spacebeforeslash : '';
      if (this.spacebeforeslash === true) {
        this.spacebeforeslash = ' ';
      }
      this.newlinedefault = this.newline;
      this.prettydefault = this.pretty;
      ref = options.writer || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this[key] = value;
      }
      return this;
    };

    XMLWriterBase.prototype.space = function(level) {
      var indent;
      if (this.pretty) {
        indent = (level || 0) + this.offset + 1;
        if (indent > 0) {
          return new Array(indent).join(this.indent);
        } else {
          return '';
        }
      } else {
        return '';
      }
    };

    return XMLWriterBase;

  })();

}).call(this);


/***/ }),

/***/ 2066:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;

  ref = __webpack_require__(8318), assign = ref.assign, isFunction = ref.isFunction;

  XMLDocument = __webpack_require__(5255);

  XMLDocumentCB = __webpack_require__(9587);

  XMLStringWriter = __webpack_require__(7155);

  XMLStreamWriter = __webpack_require__(9427);

  module.exports.create = function(name, xmldec, doctype, options) {
    var doc, root;
    if (name == null) {
      throw new Error("Root element needs a name");
    }
    options = assign({}, xmldec, doctype, options);
    doc = new XMLDocument(options);
    root = doc.element(name);
    if (!options.headless) {
      doc.declaration(options);
      if ((options.pubID != null) || (options.sysID != null)) {
        doc.doctype(options);
      }
    }
    return root;
  };

  module.exports.begin = function(options, onData, onEnd) {
    var ref1;
    if (isFunction(options)) {
      ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
      options = {};
    }
    if (onData) {
      return new XMLDocumentCB(options, onData, onEnd);
    } else {
      return new XMLDocument(options);
    }
  };

  module.exports.stringWriter = function(options) {
    return new XMLStringWriter(options);
  };

  module.exports.streamWriter = function(stream, options) {
    return new XMLStreamWriter(stream, options);
  };

}).call(this);


/***/ }),

/***/ 5637:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

if (process.env.npm_package_name === 'pseudomap' &&
    process.env.npm_lifecycle_script === 'test')
  process.env.TEST_PSEUDOMAP = 'true'

if (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {
  module.exports = Map
} else {
  module.exports = __webpack_require__(5411)
}


/***/ }),

/***/ 5411:
/***/ ((module) => {

var hasOwnProperty = Object.prototype.hasOwnProperty

module.exports = PseudoMap

function PseudoMap (set) {
  if (!(this instanceof PseudoMap)) // whyyyyyyy
    throw new TypeError("Constructor PseudoMap requires 'new'")

  this.clear()

  if (set) {
    if ((set instanceof PseudoMap) ||
        (typeof Map === 'function' && set instanceof Map))
      set.forEach(function (value, key) {
        this.set(key, value)
      }, this)
    else if (Array.isArray(set))
      set.forEach(function (kv) {
        this.set(kv[0], kv[1])
      }, this)
    else
      throw new TypeError('invalid argument')
  }
}

PseudoMap.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  Object.keys(this._data).forEach(function (k) {
    if (k !== 'size')
      fn.call(thisp, this._data[k].value, this._data[k].key)
  }, this)
}

PseudoMap.prototype.has = function (k) {
  return !!find(this._data, k)
}

PseudoMap.prototype.get = function (k) {
  var res = find(this._data, k)
  return res && res.value
}

PseudoMap.prototype.set = function (k, v) {
  set(this._data, k, v)
}

PseudoMap.prototype.delete = function (k) {
  var res = find(this._data, k)
  if (res) {
    delete this._data[res._index]
    this._data.size--
  }
}

PseudoMap.prototype.clear = function () {
  var data = Object.create(null)
  data.size = 0

  Object.defineProperty(this, '_data', {
    value: data,
    enumerable: false,
    configurable: true,
    writable: false
  })
}

Object.defineProperty(PseudoMap.prototype, 'size', {
  get: function () {
    return this._data.size
  },
  set: function (n) {},
  enumerable: true,
  configurable: true
})

PseudoMap.prototype.values =
PseudoMap.prototype.keys =
PseudoMap.prototype.entries = function () {
  throw new Error('iterators are not implemented in this version')
}

// Either identical, or both NaN
function same (a, b) {
  return a === b || a !== a && b !== b
}

function Entry (k, v, i) {
  this.key = k
  this.value = v
  this._index = i
}

function find (data, k) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k))
      return data[key]
  }
}

function set (data, k, v) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k)) {
      data[key].value = v
      return
    }
  }
  data.size++
  data[key] = new Entry(k, v, key)
}


/***/ }),

/***/ 652:
/***/ ((module) => {

"use strict";
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */



/**
 * Results cache
 */

var res = '';
var cache;

/**
 * Expose `repeat`
 */

module.exports = repeat;

/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */

function repeat(str, num) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  // cover common, quick use cases
  if (num === 1) return str;
  if (num === 2) return str + str;

  var max = str.length * num;
  if (cache !== str || typeof cache === 'undefined') {
    cache = str;
    res = '';
  } else if (res.length >= max) {
    return res.substr(0, max);
  }

  while (max > res.length && num > 1) {
    if (num & 1) {
      res += str;
    }

    num >>= 1;
    str += str;
  }

  res += str;
  res = res.substr(0, max);
  return res;
}


/***/ }),

/***/ 3844:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const assert = __webpack_require__(2357)
const path = __webpack_require__(5622)
const fs = __webpack_require__(5747)
let glob = undefined
try {
  glob = __webpack_require__(6825)
} catch (_err) {
  // treat glob as optional.
}

const defaultGlobOpts = {
  nosort: true,
  silent: true
}

// for EMFILE handling
let timeout = 0

const isWindows = (process.platform === "win32")

const defaults = options => {
  const methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(m => {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
  options.emfileWait = options.emfileWait || 1000
  if (options.glob === false) {
    options.disableGlob = true
  }
  if (options.disableGlob !== true && glob === undefined) {
    throw Error('glob dependency not found, set `options.disableGlob = true` if intentional')
  }
  options.disableGlob = options.disableGlob || false
  options.glob = options.glob || defaultGlobOpts
}

const rimraf = (p, options, cb) => {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert.equal(typeof cb, 'function', 'rimraf: callback function required')
  assert(options, 'rimraf: invalid options argument provided')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  defaults(options)

  let busyTries = 0
  let errState = null
  let n = 0

  const next = (er) => {
    errState = errState || er
    if (--n === 0)
      cb(errState)
  }

  const afterGlob = (er, results) => {
    if (er)
      return cb(er)

    n = results.length
    if (n === 0)
      return cb()

    results.forEach(p => {
      const CB = (er) => {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
              busyTries < options.maxBusyTries) {
            busyTries ++
            // try again, with the same exact callback as this one.
            return setTimeout(() => rimraf_(p, options, CB), busyTries * 100)
          }

          // this one won't happen if graceful-fs is used.
          if (er.code === "EMFILE" && timeout < options.emfileWait) {
            return setTimeout(() => rimraf_(p, options, CB), timeout ++)
          }

          // already gone
          if (er.code === "ENOENT") er = null
        }

        timeout = 0
        next(er)
      }
      rimraf_(p, options, CB)
    })
  }

  if (options.disableGlob || !glob.hasMagic(p))
    return afterGlob(null, [p])

  options.lstat(p, (er, stat) => {
    if (!er)
      return afterGlob(null, [p])

    glob(p, options.glob, afterGlob)
  })

}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
const rimraf_ = (p, options, cb) => {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === "ENOENT")
      return cb(null)

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === "EPERM" && isWindows)
      fixWinEPERM(p, options, er, cb)

    if (st && st.isDirectory())
      return rmdir(p, options, er, cb)

    options.unlink(p, er => {
      if (er) {
        if (er.code === "ENOENT")
          return cb(null)
        if (er.code === "EPERM")
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        if (er.code === "EISDIR")
          return rmdir(p, options, er, cb)
      }
      return cb(er)
    })
  })
}

const fixWinEPERM = (p, options, er, cb) => {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.chmod(p, 0o666, er2 => {
    if (er2)
      cb(er2.code === "ENOENT" ? null : er)
    else
      options.stat(p, (er3, stats) => {
        if (er3)
          cb(er3.code === "ENOENT" ? null : er)
        else if (stats.isDirectory())
          rmdir(p, options, er, cb)
        else
          options.unlink(p, cb)
      })
  })
}

const fixWinEPERMSync = (p, options, er) => {
  assert(p)
  assert(options)

  try {
    options.chmodSync(p, 0o666)
  } catch (er2) {
    if (er2.code === "ENOENT")
      return
    else
      throw er
  }

  let stats
  try {
    stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === "ENOENT")
      return
    else
      throw er
  }

  if (stats.isDirectory())
    rmdirSync(p, options, er)
  else
    options.unlinkSync(p)
}

const rmdir = (p, options, originalEr, cb) => {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
      rmkids(p, options, cb)
    else if (er && er.code === "ENOTDIR")
      cb(originalEr)
    else
      cb(er)
  })
}

const rmkids = (p, options, cb) => {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, (er, files) => {
    if (er)
      return cb(er)
    let n = files.length
    if (n === 0)
      return options.rmdir(p, cb)
    let errState
    files.forEach(f => {
      rimraf(path.join(p, f), options, er => {
        if (errState)
          return
        if (er)
          return cb(errState = er)
        if (--n === 0)
          options.rmdir(p, cb)
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
const rimrafSync = (p, options) => {
  options = options || {}
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  let results

  if (options.disableGlob || !glob.hasMagic(p)) {
    results = [p]
  } else {
    try {
      options.lstatSync(p)
      results = [p]
    } catch (er) {
      results = glob.sync(p, options.glob)
    }
  }

  if (!results.length)
    return

  for (let i = 0; i < results.length; i++) {
    const p = results[i]

    let st
    try {
      st = options.lstatSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return

      // Windows can EPERM on stat.  Life is suffering.
      if (er.code === "EPERM" && isWindows)
        fixWinEPERMSync(p, options, er)
    }

    try {
      // sunos lets the root user unlink directories, which is... weird.
      if (st && st.isDirectory())
        rmdirSync(p, options, null)
      else
        options.unlinkSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return
      if (er.code === "EPERM")
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
      if (er.code !== "EISDIR")
        throw er

      rmdirSync(p, options, er)
    }
  }
}

const rmdirSync = (p, options, originalEr) => {
  assert(p)
  assert(options)

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "ENOTDIR")
      throw originalEr
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      rmkidsSync(p, options)
  }
}

const rmkidsSync = (p, options) => {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))

  // We only end up here once we got ENOTEMPTY at least once, and
  // at this point, we are guaranteed to have removed all the kids.
  // So, we know that it won't be ENOENT or ENOTDIR or anything else.
  // try really hard to delete stuff on windows, because it has a
  // PROFOUNDLY annoying habit of not closing handles promptly when
  // files are deleted, resulting in spurious ENOTEMPTY errors.
  const retries = isWindows ? 100 : 1
  let i = 0
  do {
    let threw = true
    try {
      const ret = options.rmdirSync(p, options)
      threw = false
      return ret
    } finally {
      if (++i < retries && threw)
        continue
    }
  } while (true)
}

module.exports = rimraf
rimraf.sync = rimrafSync


/***/ }),

/***/ 2751:
/***/ ((module, exports) => {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}


/***/ }),

/***/ 2462:
/***/ ((module) => {

module.exports = sigmund
function sigmund (subject, maxSessions) {
    maxSessions = maxSessions || 10;
    var notes = [];
    var analysis = '';
    var RE = RegExp;

    function psychoAnalyze (subject, session) {
        if (session > maxSessions) return;

        if (typeof subject === 'function' ||
            typeof subject === 'undefined') {
            return;
        }

        if (typeof subject !== 'object' || !subject ||
            (subject instanceof RE)) {
            analysis += subject;
            return;
        }

        if (notes.indexOf(subject) !== -1 || session === maxSessions) return;

        notes.push(subject);
        analysis += '{';
        Object.keys(subject).forEach(function (issue, _, __) {
            // pseudo-private values.  skip those.
            if (issue.charAt(0) === '_') return;
            var to = typeof subject[issue];
            if (to === 'function' || to === 'undefined') return;
            analysis += issue;
            psychoAnalyze(subject[issue], session + 1);
        });
    }
    psychoAnalyze(subject, 0);
    return analysis;
}

// vim: set softtabstop=4 shiftwidth=4:


/***/ }),

/***/ 7581:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(2087);
const tty = __webpack_require__(3867);
const hasFlag = __webpack_require__(6275);

const {env} = process;

let flagForceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	flagForceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	flagForceColor = 1;
}

function envForceColor() {
	if ('FORCE_COLOR' in env) {
		if (env.FORCE_COLOR === 'true') {
			return 1;
		}

		if (env.FORCE_COLOR === 'false') {
			return 0;
		}

		return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, {streamIsTTY, sniffFlags = true} = {}) {
	const noFlagForceColor = envForceColor();
	if (noFlagForceColor !== undefined) {
		flagForceColor = noFlagForceColor;
	}

	const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;

	if (forceColor === 0) {
		return 0;
	}

	if (sniffFlags) {
		if (hasFlag('color=16m') ||
			hasFlag('color=full') ||
			hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE', 'DRONE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream, options = {}) {
	const level = supportsColor(stream, {
		streamIsTTY: stream && stream.isTTY,
		...options
	});

	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: getSupportLevel({isTTY: tty.isatty(1)}),
	stderr: getSupportLevel({isTTY: tty.isatty(2)})
};


/***/ }),

/***/ 4248:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ExperimentationService_1 = __webpack_require__(9009);
exports.ExperimentationService = ExperimentationService_1.ExperimentationService;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9009:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const TasApiFeatureProvider_1 = __webpack_require__(1392);
const AxiosHttpClient_1 = __webpack_require__(4762);
const ExperimentationServiceAutoPolling_1 = __webpack_require__(3043);
/**
 * Experimentation service to provide functionality of A/B experiments:
 * - reading flights;
 * - caching current set of flights;
 * - get answer on if flights are enabled.
 */
class ExperimentationService extends ExperimentationServiceAutoPolling_1.ExperimentationServiceAutoPolling {
    constructor(options) {
        super(options.telemetry, options.filterProviders || [], // Defaulted to empty array.
        options.refetchInterval != null
            ? options.refetchInterval
            : // If no fetch interval is provided, refetch functionality is turned off.
                0, options.featuresTelemetryPropertyName, options.assignmentContextTelemetryPropertyName, options.telemetryEventName, options.storageKey, options.keyValueStorage);
        this.options = options;
        this.invokeInit();
    }
    init() {
        // set feature providers to be an empty array.
        this.featureProviders = [];
        // Add WebApi feature provider.
        this.addFeatureProvider(new TasApiFeatureProvider_1.TasApiFeatureProvider(new AxiosHttpClient_1.AxiosHttpClient(this.options.endpoint), this.telemetry, this.filterProviders));
        // This will start polling the TAS.
        super.init();
    }
}
exports.ExperimentationService = ExperimentationService;
ExperimentationService.REFRESH_RATE_IN_MINUTES = 30;
//# sourceMappingURL=ExperimentationService.js.map

/***/ }),

/***/ 3043:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const ExperimentationServiceBase_1 = __webpack_require__(9859);
const PollingService_1 = __webpack_require__(3283);
/**
 * Implementation of Feature provider that provides a polling feature, where the source can be re-fetched every x time given.
 */
class ExperimentationServiceAutoPolling extends ExperimentationServiceBase_1.ExperimentationServiceBase {
    constructor(telemetry, filterProviders, refreshRateMs, featuresTelemetryPropertyName, assignmentContextTelemetryPropertyName, telemetryEventName, storageKey, storage) {
        super(telemetry, featuresTelemetryPropertyName, assignmentContextTelemetryPropertyName, telemetryEventName, storageKey, storage);
        this.telemetry = telemetry;
        this.filterProviders = filterProviders;
        this.refreshRateMs = refreshRateMs;
        this.featuresTelemetryPropertyName = featuresTelemetryPropertyName;
        this.assignmentContextTelemetryPropertyName = assignmentContextTelemetryPropertyName;
        this.telemetryEventName = telemetryEventName;
        this.storageKey = storageKey;
        this.storage = storage;
        // Excluding 0 since it allows to turn off the auto polling.
        if (refreshRateMs < 1000 && refreshRateMs !== 0) {
            throw new Error('The minimum refresh rate for polling is 1000 ms (1 second). If you wish to deactivate this auto-polling use value of 0.');
        }
        if (refreshRateMs > 0) {
            this.pollingService = new PollingService_1.PollingService(refreshRateMs);
            this.pollingService.OnPollTick(async () => {
                await super.getFeaturesAsync();
            });
        }
    }
    init() {
        if (this.pollingService) {
            this.pollingService.StartPolling(true);
        }
        else {
            super.getFeaturesAsync();
        }
    }
    /**
     * Wrapper that will reset the polling intervals whenever the feature data is fetched manually.
     */
    async getFeaturesAsync(overrideInMemoryFeatures = false) {
        if (!this.pollingService) {
            return await super.getFeaturesAsync(overrideInMemoryFeatures);
        }
        else {
            this.pollingService.StopPolling();
            let result = await super.getFeaturesAsync(overrideInMemoryFeatures);
            this.pollingService.StartPolling();
            return result;
        }
    }
}
exports.ExperimentationServiceAutoPolling = ExperimentationServiceAutoPolling;
//# sourceMappingURL=ExperimentationServiceAutoPolling.js.map

/***/ }),

/***/ 9859:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const MemoryKeyValueStorage_1 = __webpack_require__(350);
/**
 * Experimentation service to provide functionality of A/B experiments:
 * - reading flights;
 * - caching current set of flights;
 * - get answer on if flights are enabled.
 */
class ExperimentationServiceBase {
    constructor(telemetry, featuresTelemetryPropertyName, assignmentContextTelemetryPropertyName, telemetryEventName, storageKey, storage) {
        this.telemetry = telemetry;
        this.featuresTelemetryPropertyName = featuresTelemetryPropertyName;
        this.assignmentContextTelemetryPropertyName = assignmentContextTelemetryPropertyName;
        this.telemetryEventName = telemetryEventName;
        this.storageKey = storageKey;
        this.storage = storage;
        this.featuresConsumed = false;
        this.cachedTelemetryEvents = [];
        this._features = {
            features: [],
            assignmentContext: '',
            configs: []
        };
        if (!this.storageKey) {
            this.storageKey = 'ABExp.Features';
        }
        if (!this.storage) {
            storage = new MemoryKeyValueStorage_1.MemoryKeyValueStorage();
        }
        this.loadCachePromise = this.loadCachedFeatureData();
        this.initializePromise = this.loadCachePromise;
        this.initialFetch = new Promise((resolve, reject) => {
            this.resolveInitialFetchPromise = resolve;
        });
    }
    get features() {
        return this._features;
    }
    set features(value) {
        this._features = value;
        /**
         * If an implementation of telemetry exists, we set the shared property.
         */
        if (this.telemetry) {
            this.telemetry.setSharedProperty(this.featuresTelemetryPropertyName, this.features.features.join(';'));
            this.telemetry.setSharedProperty(this.assignmentContextTelemetryPropertyName, this.features.assignmentContext);
        }
    }
    /**
     * Gets all the features from the provider sources (not cache).
     * It returns these features and will also update the providers to have the latest features cached.
     */
    async getFeaturesAsync(overrideInMemoryFeatures = false) {
        /**
         * If there's already a fetching promise, there's no need to call it again.
         * We return that as result.
         */
        if (this.fetchPromise != null) {
            try {
                await this.fetchPromise;
            }
            catch (_a) {
                // Fetching features threw. Can happen if not connected to the internet, e.g
            }
            return this.features;
        }
        if (!this.featureProviders || this.featureProviders.length === 0) {
            return Promise.resolve({
                features: [],
                assignmentContext: '',
                configs: []
            });
        }
        /**
         * Fetch all from providers.
         */
        this.fetchPromise = Promise.all(this.featureProviders.map(async (provider) => {
            return await provider.getFeatures();
        }));
        try {
            const featureResults = await this.fetchPromise;
            this.updateFeatures(featureResults, overrideInMemoryFeatures);
        }
        catch (_b) {
            // Fetching features threw. Can happen if not connected to the internet, e.g.
        }
        this.fetchPromise = undefined;
        if (this.resolveInitialFetchPromise) {
            this.resolveInitialFetchPromise();
            this.resolveInitialFetchPromise = undefined;
        }
        /**
         * At this point all features have been re-fetched and cache has been updated.
         * We return the cached features.
         */
        return this.features;
    }
    /**
     *
     * @param featureResults The feature results obtained from all the feature providers.
     */
    updateFeatures(featureResults, overrideInMemoryFeatures = false) {
        /**
         * if features comes as a null value, that is taken as if there aren't any features active,
         * so an empty array is defaulted.
         */
        let features = {
            features: [],
            assignmentContext: '',
            configs: []
        };
        for (let result of featureResults) {
            for (let feature of result.features) {
                if (!features.features.includes(feature)) {
                    features.features.push(feature);
                }
            }
            for (let config of result.configs) {
                const existingConfig = features.configs.find(c => c.Id === config.Id);
                if (existingConfig) {
                    existingConfig.Parameters = Object.assign(Object.assign({}, existingConfig.Parameters), config.Parameters);
                }
                else {
                    features.configs.push(config);
                }
            }
            features.assignmentContext += result.assignmentContext;
        }
        /**
         * Set the obtained feature values to the global features variable. This stores them in memory.
         */
        if (overrideInMemoryFeatures || !this.featuresConsumed) {
            this.features = features;
        }
        /**
         * If we have storage, we cache the latest results into the storage.
         */
        if (this.storage) {
            this.storage.setValue(this.storageKey, features);
        }
    }
    async loadCachedFeatureData() {
        let cachedFeatureData;
        if (this.storage) {
            cachedFeatureData = await this.storage.getValue(this.storageKey);
            // When updating from an older version of tas-client, configs may be undefined 
            if (cachedFeatureData !== undefined && cachedFeatureData.configs === undefined) {
                cachedFeatureData.configs = [];
            }
        }
        if (this.features.features.length === 0) {
            this.features = cachedFeatureData || { features: [], assignmentContext: '', configs: [] };
        }
    }
    /**
     * Returns a value indicating whether the given flight is enabled.
     * It uses the in-memory cache.
     * @param flight The flight to check.
     */
    isFlightEnabled(flight) {
        this.featuresConsumed = true;
        this.PostEventToTelemetry(flight);
        return this.features.features.includes(flight);
    }
    /**
     * Returns a value indicating whether the given flight is enabled.
     * It uses the values currently on cache.
     * @param flight The flight to check.
     */
    async isCachedFlightEnabled(flight) {
        await this.loadCachePromise;
        this.featuresConsumed = true;
        this.PostEventToTelemetry(flight);
        return this.features.features.includes(flight);
    }
    /**
     * Returns a value indicating whether the given flight is enabled.
     * It re-fetches values from the server.
     * @param flight the flight to check.
     */
    async isFlightEnabledAsync(flight) {
        const features = await this.getFeaturesAsync(true);
        this.featuresConsumed = true;
        this.PostEventToTelemetry(flight);
        return features.features.includes(flight);
    }
    /**
     * Returns the value of the treatment variable, or undefined if not found.
     * It uses the values currently in memory, so the experimentation service
     * must be initialized before calling.
     * @param config name of the config to check.
     * @param name name of the treatment variable.
     */
    getTreatmentVariable(configId, name) {
        var _a;
        this.featuresConsumed = true;
        this.PostEventToTelemetry(`${configId}.${name}`);
        const config = this.features.configs.find(c => c.Id === configId);
        return (_a = config) === null || _a === void 0 ? void 0 : _a.Parameters[name];
    }
    /**
     * Returns the value of the treatment variable, or undefined if not found.
     * It re-fetches values from the server. If checkCache is set to true and the value exists
     * in the cache, the Treatment Assignment Service is not called.
     * @param config name of the config to check.
     * @param name name of the treatment variable.
     * @param checkCache check the cache for the variable before calling the TAS.
     */
    async getTreatmentVariableAsync(configId, name, checkCache) {
        if (checkCache) {
            const _featuresConsumed = this.featuresConsumed;
            const cachedValue = this.getTreatmentVariable(configId, name);
            if (cachedValue === undefined) {
                this.featuresConsumed = _featuresConsumed;
            }
            else {
                return cachedValue;
            }
        }
        await this.getFeaturesAsync(true);
        return this.getTreatmentVariable(configId, name);
    }
    PostEventToTelemetry(flight) {
        /**
         * If this event has already been posted, we omit from posting it again.
         */
        if (this.cachedTelemetryEvents.includes(flight)) {
            return;
        }
        this.telemetry.postEvent(this.telemetryEventName, new Map([['ABExp.queriedFeature', flight]]));
        /**
         * We cache the flight so we don't post it again.
         */
        this.cachedTelemetryEvents.push(flight);
    }
    invokeInit() {
        this.init();
    }
    addFeatureProvider(...providers) {
        if (providers == null || this.featureProviders == null) {
            return;
        }
        for (let provider of providers) {
            this.featureProviders.push(provider);
        }
    }
}
exports.ExperimentationServiceBase = ExperimentationServiceBase;
//# sourceMappingURL=ExperimentationServiceBase.js.map

/***/ }),

/***/ 433:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Abstract class for Feature Provider Implementation.
 */
class BaseFeatureProvider {
    /**
     * @param telemetry The telemetry implementation.
     */
    constructor(telemetry) {
        this.telemetry = telemetry;
        this.isFetching = false;
    }
    /**
     * Method that wraps the fetch method in order to re-use the fetch promise if needed.
     * @param headers The headers to be used on the fetch method.
     */
    async getFeatures() {
        if (this.isFetching && this.fetchPromise) {
            return this.fetchPromise;
        }
        this.fetchPromise = this.fetch();
        let features = await this.fetchPromise;
        this.isFetching = false;
        this.fetchPromise = undefined;
        return features;
    }
}
exports.BaseFeatureProvider = BaseFeatureProvider;
//# sourceMappingURL=BaseFeatureProvider.js.map

/***/ }),

/***/ 2958:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const BaseFeatureProvider_1 = __webpack_require__(433);
/**
 * Feature provider implementation that handles filters.
 */
class FilteredFeatureProvider extends BaseFeatureProvider_1.BaseFeatureProvider {
    constructor(telemetry, filterProviders) {
        super(telemetry);
        this.telemetry = telemetry;
        this.filterProviders = filterProviders;
        this.cachedTelemetryEvents = [];
    }
    getFilters() {
        // We get the filters that will be sent as headers.
        let filters = new Map();
        for (let filter of this.filterProviders) {
            let filterHeaders = filter.getFilters();
            for (let key of filterHeaders.keys()) {
                // Headers can be overridden by custom filters.
                // That's why a check isn't done to see if the header already exists, the value is just set.
                let filterValue = filterHeaders.get(key);
                filters.set(key, filterValue);
            }
        }
        return filters;
    }
    PostEventToTelemetry(headers) {
        /**
         * If these headers have already been posted, we skip from posting them again..
         */
        if (this.cachedTelemetryEvents.includes(headers)) {
            return;
        }
        const jsonHeaders = JSON.stringify(headers);
        this.telemetry.postEvent('report-headers', new Map([['ABExp.headers', jsonHeaders]]));
        /**
         * We cache the flight so we don't post it again.
         */
        this.cachedTelemetryEvents.push(headers);
    }
}
exports.FilteredFeatureProvider = FilteredFeatureProvider;
//# sourceMappingURL=FilteredFeatureProvider.js.map

/***/ }),

/***/ 1392:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const FilteredFeatureProvider_1 = __webpack_require__(2958);
/**
 * Feature provider implementation that calls the TAS web service to get the most recent active features.
 */
class TasApiFeatureProvider extends FilteredFeatureProvider_1.FilteredFeatureProvider {
    constructor(httpClient, telemetry, filterProviders) {
        super(telemetry, filterProviders);
        this.httpClient = httpClient;
        this.telemetry = telemetry;
        this.filterProviders = filterProviders;
    }
    /**
     * Method that handles fetching of latest data (in this case, flights) from the provider.
     */
    async fetch() {
        // We get the filters that will be sent as headers.
        let filters = this.getFilters();
        let headers = {};
        // Filters are handled using Map<string,any> therefore we need to
        // convert these filters into something axios can take as headers.
        for (let key of filters.keys()) {
            const filterValue = filters.get(key);
            headers[key] = filterValue;
        }
        //axios webservice call.
        let response = await this.httpClient.get({ headers: headers });
        // If we have at least one filter, we post it to telemetry event.
        if (filters.keys.length > 0) {
            this.PostEventToTelemetry(headers);
        }
        // Read the response data from the server.
        let responseData = response.data;
        let configs = responseData.Configs;
        let features = [];
        for (let c of configs) {
            if (!c.Parameters) {
                continue;
            }
            for (let key of Object.keys(c.Parameters)) {
                const featureName = key + (c.Parameters[key] ? '' : 'cf');
                if (!features.includes(featureName)) {
                    features.push(featureName);
                }
            }
        }
        return {
            features,
            assignmentContext: responseData.AssignmentContext,
            configs
        };
    }
}
exports.TasApiFeatureProvider = TasApiFeatureProvider;
//# sourceMappingURL=TasApiFeatureProvider.js.map

/***/ }),

/***/ 4762:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const axios_1 = __webpack_require__(1240);
class AxiosHttpClient {
    constructor(endpoint) {
        this.endpoint = endpoint;
    }
    get(config) {
        return axios_1.default.get(this.endpoint, Object.assign(Object.assign({}, config), { proxy: false }));
    }
}
exports.AxiosHttpClient = AxiosHttpClient;
//# sourceMappingURL=AxiosHttpClient.js.map

/***/ }),

/***/ 350:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class MemoryKeyValueStorage {
    constructor() {
        this.storage = new Map();
    }
    async getValue(key, defaultValue) {
        if (this.storage.has(key)) {
            return await Promise.resolve(this.storage.get(key));
        }
        return await Promise.resolve(defaultValue || undefined);
    }
    setValue(key, value) {
        this.storage.set(key, value);
    }
}
exports.MemoryKeyValueStorage = MemoryKeyValueStorage;
//# sourceMappingURL=MemoryKeyValueStorage.js.map

/***/ }),

/***/ 3283:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class PollingService {
    constructor(fetchInterval) {
        this.fetchInterval = fetchInterval;
    }
    StopPolling() {
        clearInterval(this.intervalHandle);
        this.intervalHandle = undefined;
    }
    OnPollTick(callback) {
        this.onTick = callback;
    }
    StartPolling(pollImmediately = false) {
        if (this.intervalHandle) {
            this.StopPolling();
        }
        // If there's no callback, there's no point to start polling.
        if (this.onTick == null) {
            return;
        }
        if (pollImmediately) {
            this.onTick().then(() => { return; }).catch(() => { return; });
        }
        /**
         * Set the interval to start running.
         */
        this.intervalHandle = setInterval(async () => {
            await this.onTick();
        }, this.fetchInterval);
        if (this.intervalHandle.unref) { // unref is only available in Node, not the web
            this.intervalHandle.unref(); // unref is used to avoid keeping node.js alive only because of these timeouts.
        }
    }
}
exports.PollingService = PollingService;
//# sourceMappingURL=PollingService.js.map

/***/ }),

/***/ 7010:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Tmp
 *
 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
 *
 * MIT Licensed
 */

/*
 * Module dependencies.
 */
const fs = __webpack_require__(5747);
const os = __webpack_require__(2087);
const path = __webpack_require__(5622);
const crypto = __webpack_require__(6417);
const _c = { fs: fs.constants, os: os.constants };
const rimraf = __webpack_require__(3844);

/*
 * The working inner variables.
 */
const
  // the random characters to choose from
  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',

  TEMPLATE_PATTERN = /XXXXXX/,

  DEFAULT_TRIES = 3,

  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),

  // constants are off on the windows platform and will not match the actual errno codes
  IS_WIN32 = os.platform() === 'win32',
  EBADF = _c.EBADF || _c.os.errno.EBADF,
  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,

  DIR_MODE = 0o700 /* 448 */,
  FILE_MODE = 0o600 /* 384 */,

  EXIT = 'exit',

  // this will hold the objects need to be removed on exit
  _removeObjects = [],

  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback
  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs),
  FN_RIMRAF_SYNC = rimraf.sync;

let
  _gracefulCleanup = false;

/**
 * Gets a temporary file name.
 *
 * @param {(Options|tmpNameCallback)} options options or callback
 * @param {?tmpNameCallback} callback the callback function
 */
function tmpName(options, callback) {
  const
    args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  try {
    _assertAndSanitizeOptions(opts);
  } catch (err) {
    return cb(err);
  }

  let tries = opts.tries;
  (function _getUniqueName() {
    try {
      const name = _generateTmpName(opts);

      // check whether the path exists then retry if needed
      fs.stat(name, function (err) {
        /* istanbul ignore else */
        if (!err) {
          /* istanbul ignore else */
          if (tries-- > 0) return _getUniqueName();

          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));
        }

        cb(null, name);
      });
    } catch (err) {
      cb(err);
    }
  }());
}

/**
 * Synchronous version of tmpName.
 *
 * @param {Object} options
 * @returns {string} the generated random name
 * @throws {Error} if the options are invalid or could not generate a filename
 */
function tmpNameSync(options) {
  const
    args = _parseArguments(options),
    opts = args[0];

  _assertAndSanitizeOptions(opts);

  let tries = opts.tries;
  do {
    const name = _generateTmpName(opts);
    try {
      fs.statSync(name);
    } catch (e) {
      return name;
    }
  } while (tries-- > 0);

  throw new Error('Could not get a unique tmp filename, max tries reached');
}

/**
 * Creates and opens a temporary file.
 *
 * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined
 * @param {?fileCallback} callback
 */
function file(options, callback) {
  const
    args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  // gets a temporary filename
  tmpName(opts, function _tmpNameCreated(err, name) {
    /* istanbul ignore else */
    if (err) return cb(err);

    // create and open the file
    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {
      /* istanbu ignore else */
      if (err) return cb(err);

      if (opts.discardDescriptor) {
        return fs.close(fd, function _discardCallback(possibleErr) {
          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only
          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));
        });
      } else {
        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care
        // about the descriptor
        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
      }
    });
  });
}

/**
 * Synchronous version of file.
 *
 * @param {Options} options
 * @returns {FileSyncObject} object consists of name, fd and removeCallback
 * @throws {Error} if cannot create a file
 */
function fileSync(options) {
  const
    args = _parseArguments(options),
    opts = args[0];

  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
  const name = tmpNameSync(opts);
  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
  /* istanbul ignore else */
  if (opts.discardDescriptor) {
    fs.closeSync(fd);
    fd = undefined;
  }

  return {
    name: name,
    fd: fd,
    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
  };
}

/**
 * Creates a temporary directory.
 *
 * @param {(Options|dirCallback)} options the options or the callback function
 * @param {?dirCallback} callback
 */
function dir(options, callback) {
  const
    args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  // gets a temporary filename
  tmpName(opts, function _tmpNameCreated(err, name) {
    /* istanbul ignore else */
    if (err) return cb(err);

    // create the directory
    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {
      /* istanbul ignore else */
      if (err) return cb(err);

      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
    });
  });
}

/**
 * Synchronous version of dir.
 *
 * @param {Options} options
 * @returns {DirSyncObject} object consists of name and removeCallback
 * @throws {Error} if it cannot create a directory
 */
function dirSync(options) {
  const
    args = _parseArguments(options),
    opts = args[0];

  const name = tmpNameSync(opts);
  fs.mkdirSync(name, opts.mode || DIR_MODE);

  return {
    name: name,
    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
  };
}

/**
 * Removes files asynchronously.
 *
 * @param {Object} fdPath
 * @param {Function} next
 * @private
 */
function _removeFileAsync(fdPath, next) {
  const _handler = function (err) {
    if (err && !_isENOENT(err)) {
      // reraise any unanticipated error
      return next(err);
    }
    next();
  };

  if (0 <= fdPath[0])
    fs.close(fdPath[0], function () {
      fs.unlink(fdPath[1], _handler);
    });
  else fs.unlink(fdPath[1], _handler);
}

/**
 * Removes files synchronously.
 *
 * @param {Object} fdPath
 * @private
 */
function _removeFileSync(fdPath) {
  let rethrownException = null;
  try {
    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);
  } catch (e) {
    // reraise any unanticipated error
    if (!_isEBADF(e) && !_isENOENT(e)) throw e;
  } finally {
    try {
      fs.unlinkSync(fdPath[1]);
    }
    catch (e) {
      // reraise any unanticipated error
      if (!_isENOENT(e)) rethrownException = e;
    }
  }
  if (rethrownException !== null) {
    throw rethrownException;
  }
}

/**
 * Prepares the callback for removal of the temporary file.
 *
 * Returns either a sync callback or a async callback depending on whether
 * fileSync or file was called, which is expressed by the sync parameter.
 *
 * @param {string} name the path of the file
 * @param {number} fd file descriptor
 * @param {Object} opts
 * @param {boolean} sync
 * @returns {fileCallback | fileCallbackSync}
 * @private
 */
function _prepareTmpFileRemoveCallback(name, fd, opts, sync) {
  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);
  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);

  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

  return sync ? removeCallbackSync : removeCallback;
}

/**
 * Prepares the callback for removal of the temporary directory.
 *
 * Returns either a sync callback or a async callback depending on whether
 * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.
 *
 * @param {string} name
 * @param {Object} opts
 * @param {boolean} sync
 * @returns {Function} the callback
 * @private
 */
function _prepareTmpDirRemoveCallback(name, opts, sync) {
  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);
  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);
  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);
  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

  return sync ? removeCallbackSync : removeCallback;
}

/**
 * Creates a guarded function wrapping the removeFunction call.
 *
 * The cleanup callback is save to be called multiple times.
 * Subsequent invocations will be ignored.
 *
 * @param {Function} removeFunction
 * @param {string} fileOrDirName
 * @param {boolean} sync
 * @param {cleanupCallbackSync?} cleanupCallbackSync
 * @returns {cleanupCallback | cleanupCallbackSync}
 * @private
 */
function _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {
  let called = false;

  // if sync is true, the next parameter will be ignored
  return function _cleanupCallback(next) {

    /* istanbul ignore else */
    if (!called) {
      // remove cleanupCallback from cache
      const toRemove = cleanupCallbackSync || _cleanupCallback;
      const index = _removeObjects.indexOf(toRemove);
      /* istanbul ignore else */
      if (index >= 0) _removeObjects.splice(index, 1);

      called = true;
      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
        return removeFunction(fileOrDirName);
      } else {
        return removeFunction(fileOrDirName, next || function() {});
      }
    }
  };
}

/**
 * The garbage collector.
 *
 * @private
 */
function _garbageCollector() {
  /* istanbul ignore else */
  if (!_gracefulCleanup) return;

  // the function being called removes itself from _removeObjects,
  // loop until _removeObjects is empty
  while (_removeObjects.length) {
    try {
      _removeObjects[0]();
    } catch (e) {
      // already removed?
    }
  }
}

/**
 * Random name generator based on crypto.
 * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript
 *
 * @param {number} howMany
 * @returns {string} the generated random name
 * @private
 */
function _randomChars(howMany) {
  let
    value = [],
    rnd = null;

  // make sure that we do not fail because we ran out of entropy
  try {
    rnd = crypto.randomBytes(howMany);
  } catch (e) {
    rnd = crypto.pseudoRandomBytes(howMany);
  }

  for (var i = 0; i < howMany; i++) {
    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
  }

  return value.join('');
}

/**
 * Helper which determines whether a string s is blank, that is undefined, or empty or null.
 *
 * @private
 * @param {string} s
 * @returns {Boolean} true whether the string s is blank, false otherwise
 */
function _isBlank(s) {
  return s === null || _isUndefined(s) || !s.trim();
}

/**
 * Checks whether the `obj` parameter is defined or not.
 *
 * @param {Object} obj
 * @returns {boolean} true if the object is undefined
 * @private
 */
function _isUndefined(obj) {
  return typeof obj === 'undefined';
}

/**
 * Parses the function arguments.
 *
 * This function helps to have optional arguments.
 *
 * @param {(Options|null|undefined|Function)} options
 * @param {?Function} callback
 * @returns {Array} parsed arguments
 * @private
 */
function _parseArguments(options, callback) {
  /* istanbul ignore else */
  if (typeof options === 'function') {
    return [{}, options];
  }

  /* istanbul ignore else */
  if (_isUndefined(options)) {
    return [{}, callback];
  }

  // copy options so we do not leak the changes we make internally
  const actualOptions = {};
  for (const key of Object.getOwnPropertyNames(options)) {
    actualOptions[key] = options[key];
  }

  return [actualOptions, callback];
}

/**
 * Generates a new temporary name.
 *
 * @param {Object} opts
 * @returns {string} the new random name according to opts
 * @private
 */
function _generateTmpName(opts) {

  const tmpDir = opts.tmpdir;

  /* istanbul ignore else */
  if (!_isUndefined(opts.name))
    return path.join(tmpDir, opts.dir, opts.name);

  /* istanbul ignore else */
  if (!_isUndefined(opts.template))
    return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));

  // prefix and postfix
  const name = [
    opts.prefix ? opts.prefix : 'tmp',
    '-',
    process.pid,
    '-',
    _randomChars(12),
    opts.postfix ? '-' + opts.postfix : ''
  ].join('');

  return path.join(tmpDir, opts.dir, name);
}

/**
 * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing
 * options.
 *
 * @param {Options} options
 * @private
 */
function _assertAndSanitizeOptions(options) {

  options.tmpdir = _getTmpDir(options);

  const tmpDir = options.tmpdir;

  /* istanbul ignore else */
  if (!_isUndefined(options.name))
    _assertIsRelative(options.name, 'name', tmpDir);
  /* istanbul ignore else */
  if (!_isUndefined(options.dir))
    _assertIsRelative(options.dir, 'dir', tmpDir);
  /* istanbul ignore else */
  if (!_isUndefined(options.template)) {
    _assertIsRelative(options.template, 'template', tmpDir);
    if (!options.template.match(TEMPLATE_PATTERN))
      throw new Error(`Invalid template, found "${options.template}".`);
  }
  /* istanbul ignore else */
  if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0)
    throw new Error(`Invalid tries, found "${options.tries}".`);

  // if a name was specified we will try once
  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
  options.keep = !!options.keep;
  options.detachDescriptor = !!options.detachDescriptor;
  options.discardDescriptor = !!options.discardDescriptor;
  options.unsafeCleanup = !!options.unsafeCleanup;

  // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to
  options.dir = _isUndefined(options.dir) ? '' : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));
  options.template = _isUndefined(options.template) ? undefined : path.relative(tmpDir, _resolvePath(options.template, tmpDir));
  // sanitize further if template is relative to options.dir
  options.template = _isBlank(options.template) ? undefined : path.relative(options.dir, options.template);

  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to
  options.name = _isUndefined(options.name) ? undefined : _sanitizeName(options.name);
  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;
  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;
}

/**
 * Resolve the specified path name in respect to tmpDir.
 *
 * The specified name might include relative path components, e.g. ../
 * so we need to resolve in order to be sure that is is located inside tmpDir
 *
 * @param name
 * @param tmpDir
 * @returns {string}
 * @private
 */
function _resolvePath(name, tmpDir) {
  const sanitizedName = _sanitizeName(name);
  if (sanitizedName.startsWith(tmpDir)) {
    return path.resolve(sanitizedName);
  } else {
    return path.resolve(path.join(tmpDir, sanitizedName));
  }
}

/**
 * Sanitize the specified path name by removing all quote characters.
 *
 * @param name
 * @returns {string}
 * @private
 */
function _sanitizeName(name) {
  if (_isBlank(name)) {
    return name;
  }
  return name.replace(/["']/g, '');
}

/**
 * Asserts whether specified name is relative to the specified tmpDir.
 *
 * @param {string} name
 * @param {string} option
 * @param {string} tmpDir
 * @throws {Error}
 * @private
 */
function _assertIsRelative(name, option, tmpDir) {
  if (option === 'name') {
    // assert that name is not absolute and does not contain a path
    if (path.isAbsolute(name))
      throw new Error(`${option} option must not contain an absolute path, found "${name}".`);
    // must not fail on valid .<name> or ..<name> or similar such constructs
    let basename = path.basename(name);
    if (basename === '..' || basename === '.' || basename !== name)
      throw new Error(`${option} option must not contain a path, found "${name}".`);
  }
  else { // if (option === 'dir' || option === 'template') {
    // assert that dir or template are relative to tmpDir
    if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {
      throw new Error(`${option} option must be relative to "${tmpDir}", found "${name}".`);
    }
    let resolvedPath = _resolvePath(name, tmpDir);
    if (!resolvedPath.startsWith(tmpDir))
      throw new Error(`${option} option must be relative to "${tmpDir}", found "${resolvedPath}".`);
  }
}

/**
 * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.
 *
 * @private
 */
function _isEBADF(error) {
  return _isExpectedError(error, -EBADF, 'EBADF');
}

/**
 * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.
 *
 * @private
 */
function _isENOENT(error) {
  return _isExpectedError(error, -ENOENT, 'ENOENT');
}

/**
 * Helper to determine whether the expected error code matches the actual code and errno,
 * which will differ between the supported node versions.
 *
 * - Node >= 7.0:
 *   error.code {string}
 *   error.errno {number} any numerical value will be negated
 *
 * CAVEAT
 *
 * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT
 * is no different here.
 *
 * @param {SystemError} error
 * @param {number} errno
 * @param {string} code
 * @private
 */
function _isExpectedError(error, errno, code) {
  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;
}

/**
 * Sets the graceful cleanup.
 *
 * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the
 * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary
 * object removals.
 */
function setGracefulCleanup() {
  _gracefulCleanup = true;
}

/**
 * Returns the currently configured tmp dir from os.tmpdir().
 *
 * @private
 * @param {?Options} options
 * @returns {string} the currently configured tmp dir
 */
function _getTmpDir(options) {
  return path.resolve(_sanitizeName(options && options.tmpdir || os.tmpdir()));
}

// Install process exit listener
process.addListener(EXIT, _garbageCollector);

/**
 * Configuration options.
 *
 * @typedef {Object} Options
 * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected
 * @property {?number} tries the number of tries before give up the name generation
 * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files
 * @property {?string} template the "mkstemp" like filename template
 * @property {?string} name fixed name relative to tmpdir or the specified dir option
 * @property {?string} dir tmp directory relative to the root tmp directory in use
 * @property {?string} prefix prefix for the generated name
 * @property {?string} postfix postfix for the generated name
 * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir
 * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty
 * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection
 * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection
 */

/**
 * @typedef {Object} FileSyncObject
 * @property {string} name the name of the file
 * @property {string} fd the file descriptor or -1 if the fd has been discarded
 * @property {fileCallback} removeCallback the callback function to remove the file
 */

/**
 * @typedef {Object} DirSyncObject
 * @property {string} name the name of the directory
 * @property {fileCallback} removeCallback the callback function to remove the directory
 */

/**
 * @callback tmpNameCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 */

/**
 * @callback fileCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {number} fd the file descriptor or -1 if the fd had been discarded
 * @param {cleanupCallback} fn the cleanup callback function
 */

/**
 * @callback fileCallbackSync
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {number} fd the file descriptor or -1 if the fd had been discarded
 * @param {cleanupCallbackSync} fn the cleanup callback function
 */

/**
 * @callback dirCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {cleanupCallback} fn the cleanup callback function
 */

/**
 * @callback dirCallbackSync
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {cleanupCallbackSync} fn the cleanup callback function
 */

/**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallback
 * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed
 */

/**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallbackSync
 */

/**
 * Callback function for function composition.
 * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}
 *
 * @callback simpleCallback
 */

// exporting all the needed methods

// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will
// allow users to reconfigure the temporary directory
Object.defineProperty(module.exports, "tmpdir", ({
  enumerable: true,
  configurable: false,
  get: function () {
    return _getTmpDir();
  }
}));

module.exports.dir = dir;
module.exports.dirSync = dirSync;

module.exports.file = file;
module.exports.fileSync = fileSync;

module.exports.tmpName = tmpName;
module.exports.tmpNameSync = tmpNameSync;

module.exports.setGracefulCleanup = setGracefulCleanup;


/***/ }),

/***/ 6893:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParsedEnvironmentFile = void 0;
const fs = __webpack_require__(5747);
const nls = __webpack_require__(3463);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\Debugger\\ParsedEnvironmentFile.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\Debugger\\ParsedEnvironmentFile.ts'));
class ParsedEnvironmentFile {
    constructor(env, warning) {
        this.Env = env;
        this.Warning = warning;
    }
    static CreateFromFile(envFile, initialEnv) {
        const content = fs.readFileSync(envFile, "utf8");
        return this.CreateFromContent(content, envFile, initialEnv);
    }
    static CreateFromContent(content, envFile, initialEnv) {
        if (content.charAt(0) === '\uFEFF') {
            content = content.substr(1);
        }
        const parseErrors = [];
        const env = new Map();
        if (initialEnv) {
            initialEnv.forEach((e) => {
                env.set(e.name, e.value);
            });
        }
        content.split("\n").forEach(line => {
            var _a;
            const r = line.match(/^\s*([\w\.\-]+)\s*=\s*(.*)?\s*$/);
            if (r) {
                const key = r[1];
                let value = (_a = r[2]) !== null && _a !== void 0 ? _a : "";
                if ((value.length > 0) && (value.charAt(0) === '"') && (value.charAt(value.length - 1) === '"')) {
                    value = value.replace(/\\n/gm, "\n");
                }
                value = value.replace(/(^['"]|['"]$)/g, "");
                env.set(key, value);
            }
            else {
                const comments = new RegExp(/^\s*(#|$)/);
                if (!comments.test(line)) {
                    parseErrors.push(line);
                }
            }
        });
        let warning;
        if (parseErrors.length !== 0) {
            warning = localize(0, null, "envFile", envFile);
            parseErrors.forEach(function (value, idx, array) {
                warning += "\"" + value + "\"" + ((idx !== array.length - 1) ? ", " : ".");
            });
        }
        const arrayEnv = [];
        for (const key of env.keys()) {
            arrayEnv.push({ name: key, value: env.get(key) });
        }
        return new ParsedEnvironmentFile(arrayEnv, warning);
    }
}
exports.ParsedEnvironmentFile = ParsedEnvironmentFile;


/***/ }),

/***/ 2931:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.showQuickPick = void 0;
const util = __webpack_require__(5331);
const vscode = __webpack_require__(7549);
const nls = __webpack_require__(3463);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\Debugger\\attachQuickPick.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\Debugger\\attachQuickPick.ts'));
class RefreshButton {
    get iconPath() {
        const refreshImagePathDark = util.getExtensionFilePath("assets/Refresh_inverse.svg");
        const refreshImagePathLight = util.getExtensionFilePath("assets/Refresh.svg");
        return {
            dark: vscode.Uri.file(refreshImagePathDark),
            light: vscode.Uri.file(refreshImagePathLight)
        };
    }
    get tooltip() {
        return localize(0, null);
    }
}
function showQuickPick(getAttachItems) {
    return __awaiter(this, void 0, void 0, function* () {
        const processEntries = yield getAttachItems();
        return new Promise((resolve, reject) => {
            const quickPick = vscode.window.createQuickPick();
            quickPick.title = localize(1, null);
            quickPick.canSelectMany = false;
            quickPick.matchOnDescription = true;
            quickPick.matchOnDetail = true;
            quickPick.placeholder = localize(2, null);
            quickPick.buttons = [new RefreshButton()];
            quickPick.items = processEntries;
            const disposables = [];
            quickPick.onDidTriggerButton(() => __awaiter(this, void 0, void 0, function* () { quickPick.items = yield getAttachItems(); }), undefined, disposables);
            quickPick.onDidAccept(() => {
                if (quickPick.selectedItems.length !== 1) {
                    reject(new Error(localize(3, null)));
                }
                const selectedId = quickPick.selectedItems[0].id;
                disposables.forEach(item => item.dispose());
                quickPick.dispose();
                resolve(selectedId);
            }, undefined, disposables);
            quickPick.onDidHide(() => {
                disposables.forEach(item => item.dispose());
                quickPick.dispose();
                reject(new Error(localize(4, null)));
            }, undefined, disposables);
            quickPick.show();
        });
    });
}
exports.showQuickPick = showQuickPick;


/***/ }),

/***/ 1191:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RemoteAttachPicker = exports.AttachPicker = void 0;
const nativeAttach_1 = __webpack_require__(1476);
const attachQuickPick_1 = __webpack_require__(2931);
const settings_1 = __webpack_require__(296);
const debugUtils = __webpack_require__(1371);
const os = __webpack_require__(2087);
const path = __webpack_require__(5622);
const util = __webpack_require__(5331);
const vscode = __webpack_require__(7549);
const nls = __webpack_require__(3463);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\Debugger\\attachToProcess.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\Debugger\\attachToProcess.ts'));
class AttachPicker {
    constructor(attachItemsProvider) {
        this.attachItemsProvider = attachItemsProvider;
    }
    ShowAttachEntries() {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, attachQuickPick_1.showQuickPick)(() => this.attachItemsProvider.getAttachItems());
        });
    }
}
exports.AttachPicker = AttachPicker;
class RemoteAttachPicker {
    constructor() {
        this._channel = vscode.window.createOutputChannel('remote-attach');
    }
    ShowAttachEntries(config) {
        return __awaiter(this, void 0, void 0, function* () {
            this._channel.clear();
            const pipeTransport = config ? config.pipeTransport : undefined;
            if (!pipeTransport) {
                throw new Error(localize(0, null, "pipeTransport"));
            }
            let pipeProgram;
            if (os.platform() === 'win32' &&
                pipeTransport.pipeProgram &&
                !(yield util.checkFileExists(pipeTransport.pipeProgram))) {
                const pipeProgramStr = pipeTransport.pipeProgram.toLowerCase().trim();
                const expectedArch = debugUtils.ArchType[process.arch];
                if (!(yield util.checkFileExists(config.pipeTransport.pipeProgram))) {
                    pipeProgram = debugUtils.ArchitectureReplacer.checkAndReplaceWSLPipeProgram(pipeProgramStr, expectedArch);
                }
                if (!pipeProgram && config.pipeTransport.pipeCwd) {
                    const pipeCwdStr = config.pipeTransport.pipeCwd.toLowerCase().trim();
                    const newPipeProgramStr = path.join(pipeCwdStr, pipeProgramStr);
                    if (!(yield util.checkFileExists(newPipeProgramStr))) {
                        pipeProgram = debugUtils.ArchitectureReplacer.checkAndReplaceWSLPipeProgram(newPipeProgramStr, expectedArch);
                    }
                }
            }
            if (!pipeProgram) {
                pipeProgram = pipeTransport.pipeProgram;
            }
            const pipeArgs = pipeTransport.pipeArgs;
            const argList = RemoteAttachPicker.createArgumentList(pipeArgs);
            const pipeCmd = `"${pipeProgram}" ${argList}`;
            const processes = yield this.getRemoteOSAndProcesses(pipeCmd);
            const attachPickOptions = {
                matchOnDetail: true,
                matchOnDescription: true,
                placeHolder: localize(1, null)
            };
            const item = yield vscode.window.showQuickPick(processes, attachPickOptions);
            if (item) {
                return item.id;
            }
            else {
                throw new Error(localize(2, null));
            }
        });
    }
    getRemoteProcessCommand() {
        let innerQuote = `'`;
        let outerQuote = `"`;
        let parameterBegin = `$(`;
        let parameterEnd = `)`;
        let escapedQuote = `\\\"`;
        const settings = new settings_1.CppSettings();
        if (settings.useBacktickCommandSubstitution) {
            parameterBegin = `\``;
            parameterEnd = `\``;
            escapedQuote = `\"`;
        }
        if (os.platform() !== "win32") {
            innerQuote = `"`;
            outerQuote = `'`;
        }
        return `${outerQuote}sh -c ${innerQuote}uname && if [ ${parameterBegin}uname${parameterEnd} = ${escapedQuote}Linux${escapedQuote} ] ; ` +
            `then ${nativeAttach_1.PsProcessParser.psLinuxCommand} ; elif [ ${parameterBegin}uname${parameterEnd} = ${escapedQuote}Darwin${escapedQuote} ] ; ` +
            `then ${nativeAttach_1.PsProcessParser.psDarwinCommand}; fi${innerQuote}${outerQuote}`;
    }
    getRemoteOSAndProcesses(pipeCmd) {
        return __awaiter(this, void 0, void 0, function* () {
            const execCommand = `${pipeCmd} ${this.getRemoteProcessCommand()}`;
            const output = yield util.execChildProcess(execCommand, undefined, this._channel);
            const lines = output.split(/\r?\n/);
            if (lines.length === 0) {
                throw new Error(localize(3, null));
            }
            else {
                const remoteOS = lines[0].replace(/[\r\n]+/g, '');
                if (remoteOS !== "Linux" && remoteOS !== "Darwin") {
                    throw new Error(`Operating system "${remoteOS}" not supported.`);
                }
                if (lines.length === 1) {
                    throw new Error(localize(4, null));
                }
                else {
                    const processes = lines.slice(1);
                    return nativeAttach_1.PsProcessParser.ParseProcessFromPsArray(processes)
                        .sort((a, b) => {
                        if (a.name === undefined) {
                            if (b.name === undefined) {
                                return 0;
                            }
                            return 1;
                        }
                        if (b.name === undefined) {
                            return -1;
                        }
                        const aLower = a.name.toLowerCase();
                        const bLower = b.name.toLowerCase();
                        if (aLower === bLower) {
                            return 0;
                        }
                        return aLower < bLower ? -1 : 1;
                    })
                        .map(p => p.toAttachItem());
                }
            }
        });
    }
    static createArgumentList(args) {
        let argsString = "";
        for (const arg of args) {
            if (argsString) {
                argsString += " ";
            }
            argsString += `"${arg}"`;
        }
        return argsString;
    }
}
exports.RemoteAttachPicker = RemoteAttachPicker;


/***/ }),

/***/ 9042:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationSnippetProvider = exports.ConfigurationAssetProviderFactory = exports.CppDbgConfigurationProvider = exports.CppVsDbgConfigurationProvider = exports.QuickPickConfigurationProvider = void 0;
const debugUtils = __webpack_require__(1371);
const os = __webpack_require__(2087);
const path = __webpack_require__(5622);
const vscode = __webpack_require__(7549);
const util = __webpack_require__(5331);
const fs = __webpack_require__(5747);
const Telemetry = __webpack_require__(1818);
const extension_1 = __webpack_require__(2763);
const extension_2 = __webpack_require__(2973);
const logger = __webpack_require__(5610);
const nls = __webpack_require__(3463);
const configurations_1 = __webpack_require__(134);
const comment_json_1 = __webpack_require__(634);
const platform_1 = __webpack_require__(3383);
const ParsedEnvironmentFile_1 = __webpack_require__(6893);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\Debugger\\configurationProvider.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\Debugger\\configurationProvider.ts'));
function isDebugLaunchStr(str) {
    return str.startsWith("(gdb) ") || str.startsWith("(lldb) ") || str.startsWith("(Windows) ");
}
class QuickPickConfigurationProvider {
    constructor(provider) {
        this.underlyingProvider = provider;
    }
    provideDebugConfigurations(folder, token) {
        return __awaiter(this, void 0, void 0, function* () {
            let configs = this.underlyingProvider.provideDebugConfigurations ? yield this.underlyingProvider.provideDebugConfigurations(folder, token) : undefined;
            if (!configs) {
                configs = [];
            }
            const defaultConfig = configs.find(config => isDebugLaunchStr(config.name) && config.request === "launch");
            if (!defaultConfig) {
                throw new Error("Default config not found in provideDebugConfigurations()");
            }
            const editor = vscode.window.activeTextEditor;
            if (!editor || !util.fileIsCOrCppSource(editor.document.fileName) || configs.length <= 1) {
                return [defaultConfig];
            }
            const items = configs.map(config => {
                const noDetailConfig = Object.assign({}, config);
                noDetailConfig.detail = undefined;
                const menuItem = { label: config.name, configuration: noDetailConfig, description: config.detail };
                if (isDebugLaunchStr(menuItem.label)) {
                    menuItem.label = localize(0, null);
                }
                return menuItem;
            });
            const selection = yield vscode.window.showQuickPick(items, { placeHolder: localize(1, null) });
            if (!selection) {
                throw Error(localize(2, null));
            }
            if (selection.label.startsWith("cl.exe")) {
                if (!process.env.DevEnvDir) {
                    vscode.window.showErrorMessage(localize(3, null, "cl.exe"));
                    return [selection.configuration];
                }
            }
            if (selection.label.indexOf((0, extension_1.buildAndDebugActiveFileStr)()) !== -1 && selection.configuration.preLaunchTask) {
                try {
                    yield extension_2.cppBuildTaskProvider.ensureBuildTaskExists(selection.configuration.preLaunchTask);
                    if (selection.configuration.miDebuggerPath) {
                        if (!(yield util.checkFileExists(selection.configuration.miDebuggerPath))) {
                            vscode.window.showErrorMessage(localize(4, null, selection.configuration.miDebuggerPath));
                            throw new Error();
                        }
                    }
                    yield vscode.debug.startDebugging(folder, selection.configuration);
                    Telemetry.logDebuggerEvent("buildAndDebug", { "success": "true" });
                }
                catch (e) {
                    Telemetry.logDebuggerEvent("buildAndDebug", { "success": "false" });
                }
            }
            return [selection.configuration];
        });
    }
    resolveDebugConfiguration(folder, config, token) {
        return this.underlyingProvider.resolveDebugConfiguration ? this.underlyingProvider.resolveDebugConfiguration(folder, config, token) : undefined;
    }
    resolveDebugConfigurationWithSubstitutedVariables(folder, config, token) {
        return this.underlyingProvider.resolveDebugConfigurationWithSubstitutedVariables ? this.underlyingProvider.resolveDebugConfigurationWithSubstitutedVariables(folder, config, token) : undefined;
    }
}
exports.QuickPickConfigurationProvider = QuickPickConfigurationProvider;
class CppConfigurationProvider {
    constructor(provider, type) {
        this.provider = provider;
        this.type = type;
    }
    provideDebugConfigurations(folder, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const defaultConfig = this.provider.getInitialConfigurations(this.type).find((config) => isDebugLaunchStr(config.name) && config.request === "launch");
            console.assert(defaultConfig, "Could not find default debug configuration.");
            const platformInfo = yield platform_1.PlatformInformation.GetPlatformInformation();
            const platform = platformInfo.platform;
            const buildTasksJson = yield extension_2.cppBuildTaskProvider.getJsonTasks();
            const buildTasksDetected = yield extension_2.cppBuildTaskProvider.getTasks(true);
            const buildTasksDetectedRename = buildTasksDetected.map(taskDetected => {
                for (const taskJson of buildTasksJson) {
                    if (taskDetected.definition.label === taskJson.definition.label) {
                        taskDetected.name = extension_2.cppBuildTaskProvider.provideUniqueTaskLabel(taskJson.definition.label, buildTasksJson);
                        taskDetected.definition.label = taskDetected.name;
                        break;
                    }
                }
                return taskDetected;
            });
            let buildTasks = [];
            buildTasks = buildTasks.concat(buildTasksJson, buildTasksDetectedRename);
            if (buildTasks.length === 0) {
                return Promise.resolve(this.provider.getInitialConfigurations(this.type));
            }
            if (buildTasks.length === 0) {
                return Promise.resolve(this.provider.getInitialConfigurations(this.type));
            }
            buildTasks = buildTasks.filter((task) => {
                const command = task.definition.command;
                if (!command) {
                    return false;
                }
                if (defaultConfig.name.startsWith("(Windows) ")) {
                    if (command.startsWith("cl.exe")) {
                        return true;
                    }
                }
                else {
                    if (!command.startsWith("cl.exe")) {
                        return true;
                    }
                }
                return false;
            });
            const configs = yield Promise.all(buildTasks.map((task) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                const definition = task.definition;
                const compilerPath = definition.command;
                const compilerName = path.basename(compilerPath);
                const newConfig = Object.assign({}, defaultConfig);
                newConfig.name = compilerName + (0, extension_1.buildAndDebugActiveFileStr)();
                newConfig.preLaunchTask = task.name;
                if (newConfig.type === "cppdbg") {
                    newConfig.externalConsole = false;
                }
                else {
                    newConfig.console = "externalTerminal";
                }
                const exeName = path.join("${fileDirname}", "${fileBasenameNoExtension}");
                const isWindows = platform === 'win32';
                newConfig.program = isWindows ? exeName + ".exe" : exeName;
                newConfig.detail = task.detail ? task.detail : definition.command;
                const isCl = compilerName === "cl.exe";
                newConfig.cwd = isWindows && !isCl && !((_a = process.env.PATH) === null || _a === void 0 ? void 0 : _a.includes(path.dirname(compilerPath))) ? path.dirname(compilerPath) : "${fileDirname}";
                return new Promise(resolve => {
                    if (platform === "darwin") {
                        return resolve(newConfig);
                    }
                    else {
                        let debuggerName;
                        if (compilerName.startsWith("clang")) {
                            newConfig.MIMode = "lldb";
                            debuggerName = "lldb-mi";
                            if ((compilerName !== "clang-cl.exe") && (compilerName !== "clang-cpp.exe")) {
                                const suffixIndex = compilerName.indexOf("-");
                                if (suffixIndex !== -1) {
                                    const suffix = compilerName.substr(suffixIndex);
                                    debuggerName += suffix;
                                }
                            }
                            newConfig.type = "cppdbg";
                        }
                        else if (compilerName === "cl.exe") {
                            newConfig.miDebuggerPath = undefined;
                            newConfig.type = "cppvsdbg";
                            return resolve(newConfig);
                        }
                        else {
                            debuggerName = "gdb";
                        }
                        if (isWindows) {
                            debuggerName = debuggerName.endsWith(".exe") ? debuggerName : (debuggerName + ".exe");
                        }
                        const compilerDirname = path.dirname(compilerPath);
                        const debuggerPath = path.join(compilerDirname, debuggerName);
                        if (isWindows) {
                            newConfig.miDebuggerPath = debuggerPath;
                            return resolve(newConfig);
                        }
                        else {
                            fs.stat(debuggerPath, (err, stats) => {
                                if (!err && stats && stats.isFile) {
                                    newConfig.miDebuggerPath = debuggerPath;
                                }
                                else {
                                    newConfig.miDebuggerPath = path.join("/usr", "bin", debuggerName);
                                }
                                return resolve(newConfig);
                            });
                        }
                    }
                });
            })));
            configs.push(defaultConfig);
            return configs;
        });
    }
    resolveDebugConfiguration(folder, config, token) {
        if (!config || !config.type) {
            return null;
        }
        if (config.type === 'cppvsdbg') {
            if (config.hasOwnProperty("externalConsole")) {
                logger.getOutputChannelLogger().showWarningMessage(localize(5, null, "externalConsole", "console"));
                if (config.externalConsole && !config.console) {
                    config.console = "externalTerminal";
                }
                delete config.externalConsole;
            }
            if (os.platform() !== 'win32') {
                logger.getOutputChannelLogger().showWarningMessage(localize(6, null, "cppvsdbg", "cppdbg"));
                return undefined;
            }
        }
        return config;
    }
    resolveDebugConfigurationWithSubstitutedVariables(folder, config, token) {
        var _a, _b, _c, _d, _e;
        if (!config || !config.type) {
            return null;
        }
        if (config.type === 'cppvsdbg') {
            if (!config.enableDebugHeap) {
                const disableDebugHeapEnvSetting = { "name": "_NO_DEBUG_HEAP", "value": "1" };
                if (config.environment && util.isArray(config.environment)) {
                    config.environment.push(disableDebugHeapEnvSetting);
                }
                else {
                    config.environment = [disableDebugHeapEnvSetting];
                }
            }
        }
        this.resolveEnvFile(config, folder);
        this.resolveSourceFileMapVariables(config);
        if (os.platform() === 'win32' &&
            config.pipeTransport &&
            config.pipeTransport.pipeProgram) {
            let replacedPipeProgram;
            const pipeProgramStr = config.pipeTransport.pipeProgram.toLowerCase().trim();
            replacedPipeProgram = debugUtils.ArchitectureReplacer.checkAndReplaceWSLPipeProgram(pipeProgramStr, debugUtils.ArchType.ia32);
            if (!replacedPipeProgram && !path.isAbsolute(pipeProgramStr) && config.pipeTransport.pipeCwd) {
                const pipeCwdStr = config.pipeTransport.pipeCwd.toLowerCase().trim();
                const newPipeProgramStr = path.join(pipeCwdStr, pipeProgramStr);
                replacedPipeProgram = debugUtils.ArchitectureReplacer.checkAndReplaceWSLPipeProgram(newPipeProgramStr, debugUtils.ArchType.ia32);
            }
            if (replacedPipeProgram) {
                config.pipeTransport.pipeProgram = replacedPipeProgram;
            }
        }
        const macOSMIMode = (_b = (_a = config.osx) === null || _a === void 0 ? void 0 : _a.MIMode) !== null && _b !== void 0 ? _b : config.MIMode;
        const macOSMIDebuggerPath = (_d = (_c = config.osx) === null || _c === void 0 ? void 0 : _c.miDebuggerPath) !== null && _d !== void 0 ? _d : config.miDebuggerPath;
        const lldb_mi_10_x_path = path.join(util.extensionPath, "debugAdapters", "lldb-mi", "bin", "lldb-mi");
        if (os.platform() === 'darwin' &&
            fs.existsSync(lldb_mi_10_x_path) &&
            (!macOSMIMode || macOSMIMode === 'lldb') &&
            !macOSMIDebuggerPath) {
            const frameworkPath = this.getLLDBFrameworkPath();
            if (!frameworkPath) {
                const moreInfoButton = localize(7, null);
                const LLDBFrameworkMissingMessage = localize(8, null);
                vscode.window.showErrorMessage(LLDBFrameworkMissingMessage, moreInfoButton)
                    .then(value => {
                    if (value === moreInfoButton) {
                        const helpURL = "https://aka.ms/vscode-cpptools/LLDBFrameworkNotFound";
                        vscode.env.openExternal(vscode.Uri.parse(helpURL));
                    }
                });
                return undefined;
            }
        }
        if ((_e = config.logging) === null || _e === void 0 ? void 0 : _e.engineLogging) {
            const outputChannel = logger.getOutputChannelLogger();
            outputChannel.appendLine(localize(9, null));
            outputChannel.appendLine(JSON.stringify(config, undefined, 2));
        }
        return config;
    }
    getLLDBFrameworkPath() {
        const LLDBFramework = "LLDB.framework";
        const searchPaths = [
            "/Library/Developer/CommandLineTools/Library/PrivateFrameworks",
            "/Applications/Xcode.app/Contents/SharedFrameworks"
        ];
        for (const searchPath of searchPaths) {
            if (fs.existsSync(path.join(searchPath, LLDBFramework))) {
                return searchPath;
            }
        }
        const outputChannel = logger.getOutputChannelLogger();
        outputChannel.appendLine(localize(10, null, LLDBFramework));
        outputChannel.appendLine(localize(11, null));
        searchPaths.forEach(searchPath => {
            outputChannel.appendLine(`\t${searchPath}`);
        });
        const xcodeCLIInstallCmd = "xcode-select --install";
        outputChannel.appendLine(localize(12, null, xcodeCLIInstallCmd));
        logger.showOutputChannel();
        return undefined;
    }
    resolveEnvFile(config, folder) {
        if (config.envFile) {
            let envFilePath = util.resolveVariables(config.envFile, undefined);
            try {
                if (folder && folder.uri && folder.uri.fsPath) {
                    envFilePath = envFilePath.replace(/(\${workspaceFolder}|\${workspaceRoot})/g, folder.uri.fsPath);
                }
                const parsedFile = ParsedEnvironmentFile_1.ParsedEnvironmentFile.CreateFromFile(envFilePath, config["environment"]);
                if (parsedFile.Warning) {
                    CppConfigurationProvider.showFileWarningAsync(parsedFile.Warning, config.envFile);
                }
                config.environment = parsedFile.Env;
                delete config.envFile;
            }
            catch (errJS) {
                const e = errJS;
                throw new Error(localize(13, null, "envFile", e.message));
            }
        }
    }
    resolveSourceFileMapVariables(config) {
        const messages = [];
        if (config.sourceFileMap) {
            for (const sourceFileMapSource of Object.keys(config.sourceFileMap)) {
                let message = "";
                const sourceFileMapTarget = config.sourceFileMap[sourceFileMapSource];
                let source = sourceFileMapSource;
                let target = sourceFileMapTarget;
                const newSourceFileMapSource = util.resolveVariables(sourceFileMapSource, undefined);
                if (sourceFileMapSource !== newSourceFileMapSource) {
                    message = "\t" + localize(14, null, "sourcePath", sourceFileMapSource, newSourceFileMapSource);
                    delete config.sourceFileMap[sourceFileMapSource];
                    source = newSourceFileMapSource;
                }
                if (util.isString(sourceFileMapTarget)) {
                    const newSourceFileMapTarget = util.resolveVariables(sourceFileMapTarget, undefined);
                    if (sourceFileMapTarget !== newSourceFileMapTarget) {
                        message += (message ? ' ' : '\t');
                        message += localize(15, null, "targetPath", sourceFileMapTarget, newSourceFileMapTarget);
                        target = newSourceFileMapTarget;
                    }
                }
                else if (util.isObject(sourceFileMapTarget)) {
                    const newSourceFileMapTarget = sourceFileMapTarget;
                    newSourceFileMapTarget["editorPath"] = util.resolveVariables(sourceFileMapTarget["editorPath"], undefined);
                    if (sourceFileMapTarget !== newSourceFileMapTarget) {
                        message += (message ? ' ' : '\t');
                        message += localize(16, null, "editorPath", sourceFileMapTarget, newSourceFileMapTarget["editorPath"]);
                        target = newSourceFileMapTarget;
                    }
                }
                if (message) {
                    config.sourceFileMap[source] = target;
                    messages.push(message);
                }
            }
            if (messages.length > 0) {
                logger.getOutputChannel().appendLine(localize(17, null, "sourceFileMap"));
                messages.forEach((message) => {
                    logger.getOutputChannel().appendLine(message);
                });
                logger.showOutputChannel();
            }
        }
    }
    static showFileWarningAsync(message, fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            const openItem = { title: localize(18, null, "envFile") };
            const result = yield vscode.window.showWarningMessage(message, openItem);
            if (result && result.title === openItem.title) {
                const doc = yield vscode.workspace.openTextDocument(fileName);
                if (doc) {
                    vscode.window.showTextDocument(doc);
                }
            }
        });
    }
}
class CppVsDbgConfigurationProvider extends CppConfigurationProvider {
    constructor(provider) {
        super(provider, configurations_1.DebuggerType.cppvsdbg);
    }
}
exports.CppVsDbgConfigurationProvider = CppVsDbgConfigurationProvider;
class CppDbgConfigurationProvider extends CppConfigurationProvider {
    constructor(provider) {
        super(provider, configurations_1.DebuggerType.cppdbg);
    }
}
exports.CppDbgConfigurationProvider = CppDbgConfigurationProvider;
class ConfigurationAssetProviderFactory {
    static getConfigurationProvider() {
        switch (os.platform()) {
            case 'win32':
                return new WindowsConfigurationProvider();
            case 'darwin':
                return new OSXConfigurationProvider();
            case 'linux':
                return new LinuxConfigurationProvider();
            default:
                throw new Error(localize(19, null));
        }
    }
}
exports.ConfigurationAssetProviderFactory = ConfigurationAssetProviderFactory;
class DefaultConfigurationProvider {
    constructor() {
        this.configurations = [];
    }
    getInitialConfigurations(debuggerType) {
        const configurationSnippet = [];
        this.configurations.forEach(configuration => {
            configurationSnippet.push(configuration.GetLaunchConfiguration());
        });
        const initialConfigurations = configurationSnippet.filter(snippet => snippet.debuggerType === debuggerType && snippet.isInitialConfiguration)
            .map(snippet => JSON.parse(snippet.bodyText));
        return initialConfigurations;
    }
    getConfigurationSnippets() {
        const completionItems = [];
        this.configurations.forEach(configuration => {
            completionItems.push(convertConfigurationSnippetToCompetionItem(configuration.GetLaunchConfiguration()));
            completionItems.push(convertConfigurationSnippetToCompetionItem(configuration.GetAttachConfiguration()));
        });
        return completionItems;
    }
}
class WindowsConfigurationProvider extends DefaultConfigurationProvider {
    constructor() {
        super();
        this.executable = "a.exe";
        this.pipeProgram = "<" + localize(20, null, "plink.exe").replace(/\"/g, "\\\"") + ">";
        this.MIMode = 'gdb';
        this.setupCommandsBlock = `"setupCommands": [
    {
        "description": "${localize(21, null, "gdb").replace(/\"/g, "\\\"")}",
        "text": "-enable-pretty-printing",
        "ignoreFailures": true
    },
    {
        "description":  "${localize(22, null, "Intel").replace(/\"/g, "\\\"")}",
        "text": "-gdb-set disassembly-flavor intel",
        "ignoreFailures": true
    }
]`;
        this.configurations = [
            new configurations_1.MIConfigurations(this.MIMode, this.executable, this.pipeProgram, this.setupCommandsBlock),
            new configurations_1.PipeTransportConfigurations(this.MIMode, this.executable, this.pipeProgram, this.setupCommandsBlock),
            new configurations_1.WindowsConfigurations(this.MIMode, this.executable, this.pipeProgram, this.setupCommandsBlock),
            new configurations_1.WSLConfigurations(this.MIMode, this.executable, this.pipeProgram, this.setupCommandsBlock)
        ];
    }
}
class OSXConfigurationProvider extends DefaultConfigurationProvider {
    constructor() {
        super();
        this.MIMode = 'lldb';
        this.executable = "a.out";
        this.pipeProgram = "/usr/bin/ssh";
        this.configurations = [
            new configurations_1.MIConfigurations(this.MIMode, this.executable, this.pipeProgram)
        ];
    }
}
class LinuxConfigurationProvider extends DefaultConfigurationProvider {
    constructor() {
        super();
        this.MIMode = 'gdb';
        this.setupCommandsBlock = `"setupCommands": [
    {
        "description": "${localize(23, null, "gdb").replace(/\"/g, "\\\"")}",
        "text": "-enable-pretty-printing",
        "ignoreFailures": true
    },
    {
        "description":  "${localize(24, null, "Intel").replace(/\"/g, "\\\"")}",
        "text": "-gdb-set disassembly-flavor intel",
        "ignoreFailures": true
    }
]`;
        this.executable = "a.out";
        this.pipeProgram = "/usr/bin/ssh";
        this.configurations = [
            new configurations_1.MIConfigurations(this.MIMode, this.executable, this.pipeProgram, this.setupCommandsBlock),
            new configurations_1.PipeTransportConfigurations(this.MIMode, this.executable, this.pipeProgram, this.setupCommandsBlock)
        ];
    }
}
function convertConfigurationSnippetToCompetionItem(snippet) {
    const item = new vscode.CompletionItem(snippet.label, vscode.CompletionItemKind.Snippet);
    item.insertText = snippet.bodyText;
    return item;
}
class ConfigurationSnippetProvider {
    constructor(provider) {
        this.provider = provider;
        this.snippets = this.provider.getConfigurationSnippets();
    }
    resolveCompletionItem(item, token) {
        return Promise.resolve(item);
    }
    provideCompletionItems(document, position, token, context) {
        let items = this.snippets;
        const launch = (0, comment_json_1.parse)(document.getText());
        if (launch.configurations.length !== 0) {
            items = [];
            this.snippets.forEach((item) => items.push(Object.assign({}, item)));
            items.map((item) => {
                item.insertText = item.insertText + ',';
            });
        }
        return Promise.resolve(new vscode.CompletionList(items, true));
    }
}
exports.ConfigurationSnippetProvider = ConfigurationSnippetProvider;


/***/ }),

/***/ 134:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WSLConfigurations = exports.WindowsConfigurations = exports.PipeTransportConfigurations = exports.MIConfigurations = exports.indentJsonString = exports.DebuggerType = void 0;
const os = __webpack_require__(2087);
const nls = __webpack_require__(3463);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\Debugger\\configurations.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\Debugger\\configurations.ts'));
var DebuggerType;
(function (DebuggerType) {
    DebuggerType[DebuggerType["cppvsdbg"] = 0] = "cppvsdbg";
    DebuggerType[DebuggerType["cppdbg"] = 1] = "cppdbg";
})(DebuggerType = exports.DebuggerType || (exports.DebuggerType = {}));
function indentJsonString(json, numTabs = 1) {
    return json.split('\n').map(line => '\t'.repeat(numTabs) + line).join('\n').trim();
}
exports.indentJsonString = indentJsonString;
function formatString(format, args) {
    args.forEach((arg, index) => {
        format = format.replace("{" + index + "}", arg);
    });
    return format;
}
function createLaunchString(name, type, executable) {
    return `"name": "${name}",
"type": "${type}",
"request": "launch",
"program": "${localize(0, null, "$\{workspaceFolder\}" + "/" + executable).replace(/\"/g, "\\\"")}",
"args": [],
"stopAtEntry": false,
"cwd": "$\{fileDirname\}",
"environment": [],
${type === "cppdbg" ? `"externalConsole": false` : `"console": "externalTerminal"`}
`;
}
function createAttachString(name, type, executable) {
    return formatString(`
"name": "${name}",
"type": "${type}",
"request": "attach",{0}
"processId": "$\{command:pickProcess\}"
`, [type === "cppdbg" ? `${os.EOL}"program": "${localize(1, null, "$\{workspaceFolder\}" + "/" + executable).replace(/\"/g, "\\\"")}",` : ""]);
}
function createRemoteAttachString(name, type, executable) {
    return `
"name": "${name}",
"type": "${type}",
"request": "attach",
"program": "${localize(2, null, "$\{workspaceFolder\}" + "/" + executable).replace(/\"/g, "\\\"")}",
"processId": "$\{command:pickRemoteProcess\}"
`;
}
function createPipeTransportString(pipeProgram, debuggerProgram, pipeArgs = []) {
    return `
"pipeTransport": {
\t"debuggerPath": "/usr/bin/${debuggerProgram}",
\t"pipeProgram": "${pipeProgram}",
\t"pipeArgs": ${JSON.stringify(pipeArgs)},
\t"pipeCwd": ""
}`;
}
class Configuration {
    constructor(MIMode, executable, pipeProgram, additionalProperties = "") {
        this.snippetPrefix = "C/C++: ";
        this.miDebugger = "cppdbg";
        this.windowsDebugger = "cppvsdbg";
        this.MIMode = MIMode;
        this.executable = executable;
        this.pipeProgram = pipeProgram;
        this.additionalProperties = additionalProperties;
    }
}
class MIConfigurations extends Configuration {
    GetLaunchConfiguration() {
        const name = `(${this.MIMode}) ${localize(3, null).replace(/\"/g, "\\\"")}`;
        const body = formatString(`{
\t${indentJsonString(createLaunchString(name, this.miDebugger, this.executable))},
\t"MIMode": "${this.MIMode}"{0}{1}
}`, [this.miDebugger === "cppdbg" && os.platform() === "win32" ? `,${os.EOL}\t"miDebuggerPath": "/path/to/gdb"` : "",
            this.additionalProperties ? `,${os.EOL}\t${indentJsonString(this.additionalProperties)}` : ""]);
        return {
            "label": this.snippetPrefix + name,
            "description": localize(4, null, this.MIMode).replace(/\"/g, "\\\""),
            "bodyText": body.trim(),
            "isInitialConfiguration": true,
            "debuggerType": DebuggerType.cppdbg
        };
    }
    GetAttachConfiguration() {
        const name = `(${this.MIMode}) ${localize(5, null).replace(/\"/g, "\\\"")}`;
        const body = formatString(`{
\t${indentJsonString(createAttachString(name, this.miDebugger, this.executable))},
\t"MIMode": "${this.MIMode}"{0}{1}
}`, [this.miDebugger === "cppdbg" && os.platform() === "win32" ? `,${os.EOL}\t"miDebuggerPath": "/path/to/gdb"` : "",
            this.additionalProperties ? `,${os.EOL}\t${indentJsonString(this.additionalProperties)}` : ""]);
        return {
            "label": this.snippetPrefix + name,
            "description": localize(6, null, this.MIMode).replace(/\"/g, "\\\""),
            "bodyText": body.trim(),
            "debuggerType": DebuggerType.cppdbg
        };
    }
}
exports.MIConfigurations = MIConfigurations;
class PipeTransportConfigurations extends Configuration {
    GetLaunchConfiguration() {
        const name = `(${this.MIMode}) ${localize(7, null).replace(/\"/g, "\\\"")}`;
        const body = formatString(`
{
\t${indentJsonString(createLaunchString(name, this.miDebugger, this.executable))},
\t${indentJsonString(createPipeTransportString(this.pipeProgram, this.MIMode))},
\t"MIMode": "${this.MIMode}"{0}
}`, [this.additionalProperties ? `,${os.EOL}\t${indentJsonString(this.additionalProperties)}` : ""]);
        return {
            "label": this.snippetPrefix + name,
            "description": localize(8, null, this.MIMode).replace(/\"/g, "\\\""),
            "bodyText": body.trim(),
            "debuggerType": DebuggerType.cppdbg
        };
    }
    GetAttachConfiguration() {
        const name = `(${this.MIMode}) ${localize(9, null).replace(/\"/g, "\\\"")}`;
        const body = formatString(`
{
\t${indentJsonString(createRemoteAttachString(name, this.miDebugger, this.executable))},
\t${indentJsonString(createPipeTransportString(this.pipeProgram, this.MIMode))},
\t"MIMode": "${this.MIMode}"{0}
}`, [this.additionalProperties ? `,${os.EOL}\t${indentJsonString(this.additionalProperties)}` : ""]);
        return {
            "label": this.snippetPrefix + name,
            "description": localize(10, null, this.MIMode).replace(/\"/g, "\\\""),
            "bodyText": body.trim(),
            "debuggerType": DebuggerType.cppdbg
        };
    }
}
exports.PipeTransportConfigurations = PipeTransportConfigurations;
class WindowsConfigurations extends Configuration {
    GetLaunchConfiguration() {
        const name = `(Windows) ${localize(11, null).replace(/\"/g, "\\\"")}`;
        const body = `
{
\t${indentJsonString(createLaunchString(name, this.windowsDebugger, this.executable))}
}`;
        return {
            "label": this.snippetPrefix + name,
            "description": localize(12, null).replace(/\"/g, "\\\""),
            "bodyText": body.trim(),
            "isInitialConfiguration": true,
            "debuggerType": DebuggerType.cppvsdbg
        };
    }
    GetAttachConfiguration() {
        const name = `(Windows) ${localize(13, null).replace(/\"/g, "\\\"")}`;
        const body = `
{
\t${indentJsonString(createAttachString(name, this.windowsDebugger, this.executable))}
}`;
        return {
            "label": this.snippetPrefix + name,
            "description": localize(14, null).replace(/\"/g, "\\\""),
            "bodyText": body.trim(),
            "debuggerType": DebuggerType.cppvsdbg
        };
    }
}
exports.WindowsConfigurations = WindowsConfigurations;
class WSLConfigurations extends Configuration {
    constructor() {
        super(...arguments);
        this.bashPipeProgram = process.arch === 'ia32' ? "${env:windir}\\\\sysnative\\\\bash.exe" : "${env:windir}\\\\system32\\\\bash.exe";
    }
    GetLaunchConfiguration() {
        const name = `(${this.MIMode}) ${localize(15, null).replace(/\"/g, "\\\"")}`;
        const body = formatString(`
{
\t${indentJsonString(createLaunchString(name, this.miDebugger, this.executable))},
\t${indentJsonString(createPipeTransportString(this.bashPipeProgram, this.MIMode, ["-c"]))}{0}
}`, [this.additionalProperties ? `,${os.EOL}\t${indentJsonString(this.additionalProperties)}` : ""]);
        return {
            "label": this.snippetPrefix + name,
            "description": localize(16, null, this.MIMode).replace(/\"/g, "\\\""),
            "bodyText": body.trim(),
            "debuggerType": DebuggerType.cppdbg
        };
    }
    GetAttachConfiguration() {
        const name = `(${this.MIMode}) ${localize(17, null).replace(/\"/g, "\\\"")}`;
        const body = formatString(`
{
\t${indentJsonString(createRemoteAttachString(name, this.miDebugger, this.executable))},
\t${indentJsonString(createPipeTransportString(this.bashPipeProgram, this.MIMode, ["-c"]))}{0}
}`, [this.additionalProperties ? `,${os.EOL}\t${indentJsonString(this.additionalProperties)}` : ""]);
        return {
            "label": this.snippetPrefix + name,
            "description": localize(18, null, this.MIMode).replace(/\"/g, "\\\""),
            "bodyText": body.trim(),
            "debuggerType": DebuggerType.cppdbg
        };
    }
}
exports.WSLConfigurations = WSLConfigurations;


/***/ }),

/***/ 4568:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CppvsdbgDebugAdapterDescriptorFactory = exports.CppdbgDebugAdapterDescriptorFactory = void 0;
const vscode = __webpack_require__(7549);
const path = __webpack_require__(5622);
const os = __webpack_require__(2087);
const nls = __webpack_require__(3463);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\Debugger\\debugAdapterDescriptorFactory.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\Debugger\\debugAdapterDescriptorFactory.ts'));
class AbstractDebugAdapterDescriptorFactory {
    constructor(context) {
        this.context = context;
    }
}
class CppdbgDebugAdapterDescriptorFactory extends AbstractDebugAdapterDescriptorFactory {
    constructor(context) {
        super(context);
    }
    createDebugAdapterDescriptor(session, executable) {
        return __awaiter(this, void 0, void 0, function* () {
            const adapter = "./debugAdapters/bin/OpenDebugAD7" + (os.platform() === 'win32' ? ".exe" : "");
            const command = path.join(this.context.extensionPath, adapter);
            return new vscode.DebugAdapterExecutable(command, []);
        });
    }
}
exports.CppdbgDebugAdapterDescriptorFactory = CppdbgDebugAdapterDescriptorFactory;
CppdbgDebugAdapterDescriptorFactory.DEBUG_TYPE = "cppdbg";
class CppvsdbgDebugAdapterDescriptorFactory extends AbstractDebugAdapterDescriptorFactory {
    constructor(context) {
        super(context);
    }
    createDebugAdapterDescriptor(session, executable) {
        return __awaiter(this, void 0, void 0, function* () {
            if (os.platform() !== 'win32') {
                vscode.window.showErrorMessage(localize(0, null, "cppvsdbg"));
                return null;
            }
            else {
                return new vscode.DebugAdapterExecutable(path.join(this.context.extensionPath, './debugAdapters/vsdbg/bin/vsdbg.exe'), ['--interpreter=vscode', '--extConfigDir=%USERPROFILE%\\.cppvsdbg\\extensions']);
            }
        });
    }
}
exports.CppvsdbgDebugAdapterDescriptorFactory = CppvsdbgDebugAdapterDescriptorFactory;
CppvsdbgDebugAdapterDescriptorFactory.DEBUG_TYPE = "cppvsdbg";


/***/ }),

/***/ 2763:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dispose = exports.initialize = exports.buildAndDebugActiveFileStr = void 0;
const vscode = __webpack_require__(7549);
const os = __webpack_require__(2087);
const attachToProcess_1 = __webpack_require__(1191);
const nativeAttach_1 = __webpack_require__(1476);
const configurationProvider_1 = __webpack_require__(9042);
const debugAdapterDescriptorFactory_1 = __webpack_require__(4568);
const util = __webpack_require__(5331);
const Telemetry = __webpack_require__(1818);
const nls = __webpack_require__(3463);
const extension_1 = __webpack_require__(2973);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\Debugger\\extension.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\Debugger\\extension.ts'));
const disposables = [];
function buildAndDebugActiveFileStr() {
    return ` - ${localize(0, null)}`;
}
exports.buildAndDebugActiveFileStr = buildAndDebugActiveFileStr;
function initialize(context) {
    const attachItemsProvider = nativeAttach_1.NativeAttachItemsProviderFactory.Get();
    const attacher = new attachToProcess_1.AttachPicker(attachItemsProvider);
    disposables.push(vscode.commands.registerCommand('extension.pickNativeProcess', () => attacher.ShowAttachEntries()));
    const remoteAttacher = new attachToProcess_1.RemoteAttachPicker();
    disposables.push(vscode.commands.registerCommand('extension.pickRemoteNativeProcess', (any) => remoteAttacher.ShowAttachEntries(any)));
    const configurationProvider = configurationProvider_1.ConfigurationAssetProviderFactory.getConfigurationProvider();
    let vsdbgProvider = null;
    if (os.platform() === 'win32') {
        vsdbgProvider = new configurationProvider_1.CppVsDbgConfigurationProvider(configurationProvider);
        disposables.push(vscode.debug.registerDebugConfigurationProvider('cppvsdbg', new configurationProvider_1.QuickPickConfigurationProvider(vsdbgProvider)));
    }
    const provider = new configurationProvider_1.CppDbgConfigurationProvider(configurationProvider);
    disposables.push(vscode.debug.registerDebugConfigurationProvider('cppdbg', new configurationProvider_1.QuickPickConfigurationProvider(provider)));
    disposables.push(vscode.commands.registerTextEditorCommand("C_Cpp.BuildAndDebugActiveFile", (textEditor, edit, ...args) => __awaiter(this, void 0, void 0, function* () {
        const folder = vscode.workspace.getWorkspaceFolder(textEditor.document.uri);
        if (!folder) {
            vscode.window.showErrorMessage(localize(1, null));
            return Promise.resolve();
        }
        if (!util.fileIsCOrCppSource(textEditor.document.uri.fsPath)) {
            vscode.window.showErrorMessage(localize(2, null));
            return Promise.resolve();
        }
        const configs = (yield provider.provideDebugConfigurations(folder)).filter(config => config.name.indexOf(buildAndDebugActiveFileStr()) !== -1);
        if (vsdbgProvider) {
            const vsdbgConfigs = (yield vsdbgProvider.provideDebugConfigurations(folder)).filter(config => config.name.indexOf(buildAndDebugActiveFileStr()) !== -1);
            if (vsdbgConfigs) {
                configs.push(...vsdbgConfigs);
            }
        }
        const items = configs.map(config => ({ label: config.name, configuration: config, description: config.detail }));
        const selection = yield vscode.window.showQuickPick(items, {
            placeHolder: (items.length === 0 ? localize(3, null) : localize(4, null))
        });
        if (!selection) {
            return;
        }
        if (selection.label.startsWith("cl.exe")) {
            if (!process.env.DevEnvDir || process.env.DevEnvDir.length === 0) {
                vscode.window.showErrorMessage(localize(5, null, "cl.exe"));
                return;
            }
        }
        if (selection.configuration.preLaunchTask) {
            if (folder) {
                try {
                    yield extension_1.cppBuildTaskProvider.ensureBuildTaskExists(selection.configuration.preLaunchTask);
                    Telemetry.logDebuggerEvent("buildAndDebug", { "success": "false" });
                }
                catch (errJS) {
                    const e = errJS;
                    if (e && e.message === util.failedToParseJson) {
                        vscode.window.showErrorMessage(util.failedToParseJson);
                    }
                    return;
                }
            }
            else {
                return;
            }
        }
        try {
            yield extension_1.cppBuildTaskProvider.ensureDebugConfigExists(selection.configuration.name);
            try {
                yield vscode.debug.startDebugging(folder, selection.configuration.name);
                Telemetry.logDebuggerEvent("buildAndDebug", { "success": "true" });
            }
            catch (e) {
                Telemetry.logDebuggerEvent("buildAndDebug", { "success": "false" });
            }
        }
        catch (e) {
            try {
                yield vscode.debug.startDebugging(folder, selection.configuration);
                Telemetry.logDebuggerEvent("buildAndDebug", { "success": "true" });
            }
            catch (e) {
                Telemetry.logDebuggerEvent("buildAndDebug", { "success": "false" });
            }
        }
    })));
    configurationProvider.getConfigurationSnippets();
    const launchJsonDocumentSelector = [{
            scheme: 'file',
            language: 'jsonc',
            pattern: '**/launch.json'
        }];
    disposables.push(vscode.languages.registerCompletionItemProvider(launchJsonDocumentSelector, new configurationProvider_1.ConfigurationSnippetProvider(configurationProvider)));
    disposables.push(vscode.debug.registerDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory_1.CppvsdbgDebugAdapterDescriptorFactory.DEBUG_TYPE, new debugAdapterDescriptorFactory_1.CppvsdbgDebugAdapterDescriptorFactory(context)));
    disposables.push(vscode.debug.registerDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory_1.CppdbgDebugAdapterDescriptorFactory.DEBUG_TYPE, new debugAdapterDescriptorFactory_1.CppdbgDebugAdapterDescriptorFactory(context)));
    vscode.Disposable.from(...disposables);
}
exports.initialize = initialize;
function dispose() {
    disposables.forEach(d => d.dispose());
}
exports.dispose = dispose;


/***/ }),

/***/ 1476:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CimProcessParser = exports.CimAttachItemsProvider = exports.WmicProcessParser = exports.WmicAttachItemsProvider = exports.PsProcessParser = exports.PsAttachItemsProvider = exports.NativeAttachItemsProviderFactory = exports.Process = void 0;
const child_process = __webpack_require__(3129);
const os = __webpack_require__(2087);
const nls = __webpack_require__(3463);
const common_1 = __webpack_require__(5331);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\Debugger\\nativeAttach.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\Debugger\\nativeAttach.ts'));
class Process {
    constructor(name, pid, commandLine) {
        this.name = name;
        this.pid = pid;
        this.commandLine = commandLine;
    }
    toAttachItem() {
        return {
            label: this.name,
            description: this.pid,
            detail: this.commandLine,
            id: this.pid
        };
    }
}
exports.Process = Process;
class NativeAttachItemsProviderFactory {
    static Get() {
        if (os.platform() === 'win32') {
            const pwsh = (0, common_1.findPowerShell)();
            return pwsh ? new CimAttachItemsProvider(pwsh) : new WmicAttachItemsProvider();
        }
        else {
            return new PsAttachItemsProvider();
        }
    }
}
exports.NativeAttachItemsProviderFactory = NativeAttachItemsProviderFactory;
class NativeAttachItemsProvider {
    getAttachItems() {
        return __awaiter(this, void 0, void 0, function* () {
            const processEntries = yield this.getInternalProcessEntries();
            processEntries.sort((a, b) => {
                if (a.name === undefined) {
                    if (b.name === undefined) {
                        return 0;
                    }
                    return 1;
                }
                if (b.name === undefined) {
                    return -1;
                }
                const aLower = a.name.toLowerCase();
                const bLower = b.name.toLowerCase();
                if (aLower === bLower) {
                    return 0;
                }
                return aLower < bLower ? -1 : 1;
            });
            const attachItems = processEntries.map(p => p.toAttachItem());
            return attachItems;
        });
    }
}
class PsAttachItemsProvider extends NativeAttachItemsProvider {
    getInternalProcessEntries() {
        return __awaiter(this, void 0, void 0, function* () {
            let processCmd = '';
            switch (os.platform()) {
                case 'darwin':
                    processCmd = PsProcessParser.psDarwinCommand;
                    break;
                case 'linux':
                    processCmd = PsProcessParser.psLinuxCommand;
                    break;
                default:
                    throw new Error(localize(0, null, os.platform()));
            }
            const processes = yield execChildProcess(processCmd, undefined);
            return PsProcessParser.ParseProcessFromPs(processes);
        });
    }
}
exports.PsAttachItemsProvider = PsAttachItemsProvider;
class PsProcessParser {
    static get secondColumnCharacters() { return 50; }
    static get commColumnTitle() { return Array(PsProcessParser.secondColumnCharacters).join("a"); }
    static get psLinuxCommand() { return `ps axww -o pid=,comm=${PsProcessParser.commColumnTitle},args=`; }
    static get psDarwinCommand() { return `ps axww -o pid=,comm=${PsProcessParser.commColumnTitle},args= -c`; }
    static ParseProcessFromPs(processes) {
        const lines = processes.split(os.EOL);
        return PsProcessParser.ParseProcessFromPsArray(lines);
    }
    static ParseProcessFromPsArray(processArray) {
        const processEntries = [];
        for (let i = 1; i < processArray.length; i++) {
            const line = processArray[i];
            if (!line) {
                continue;
            }
            const processEntry = PsProcessParser.parseLineFromPs(line);
            if (processEntry) {
                processEntries.push(processEntry);
            }
        }
        return processEntries;
    }
    static parseLineFromPs(line) {
        const psEntry = new RegExp(`^\\s*([0-9]+)\\s+(.{${PsProcessParser.secondColumnCharacters - 1}})\\s+(.*)$`);
        const matches = psEntry.exec(line);
        if (matches && matches.length === 4) {
            const pid = matches[1].trim();
            const executable = matches[2].trim();
            const cmdline = matches[3].trim();
            return new Process(executable, pid, cmdline);
        }
    }
}
exports.PsProcessParser = PsProcessParser;
function execChildProcess(process, workingDirectory) {
    return new Promise((resolve, reject) => {
        child_process.exec(process, { cwd: workingDirectory, maxBuffer: 500 * 1024 }, (error, stdout, stderr) => {
            if (error) {
                reject(error);
                return;
            }
            if (stderr && stderr.length > 0) {
                if (stderr.indexOf('screen size is bogus') >= 0) {
                }
                else {
                    reject(new Error(stderr));
                    return;
                }
            }
            resolve(stdout);
        });
    });
}
class WmicAttachItemsProvider extends NativeAttachItemsProvider {
    getInternalProcessEntries() {
        return __awaiter(this, void 0, void 0, function* () {
            const wmicCommand = 'wmic process get Name,ProcessId,CommandLine /FORMAT:list';
            const processes = yield execChildProcess(wmicCommand, undefined);
            return WmicProcessParser.ParseProcessFromWmic(processes);
        });
    }
}
exports.WmicAttachItemsProvider = WmicAttachItemsProvider;
class WmicProcessParser {
    static get wmicNameTitle() { return 'Name'; }
    static get wmicCommandLineTitle() { return 'CommandLine'; }
    static get wmicPidTitle() { return 'ProcessId'; }
    static ParseProcessFromWmic(processes) {
        const lines = processes.split(os.EOL);
        let currentProcess = new Process("current process", undefined, undefined);
        const processEntries = [];
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (!line) {
                continue;
            }
            WmicProcessParser.parseLineFromWmic(line, currentProcess);
            if (line.lastIndexOf(WmicProcessParser.wmicPidTitle, 0) === 0) {
                processEntries.push(currentProcess);
                currentProcess = new Process("current process", undefined, undefined);
            }
        }
        return processEntries;
    }
    static parseLineFromWmic(line, process) {
        const splitter = line.indexOf('=');
        if (splitter >= 0) {
            const key = line.slice(0, line.indexOf('=')).trim();
            let value = line.slice(line.indexOf('=') + 1).trim();
            if (key === WmicProcessParser.wmicNameTitle) {
                process.name = value;
            }
            else if (key === WmicProcessParser.wmicPidTitle) {
                process.pid = value;
            }
            else if (key === WmicProcessParser.wmicCommandLineTitle) {
                const extendedLengthPath = '\\??\\';
                if (value.lastIndexOf(extendedLengthPath, 0) === 0) {
                    value = value.slice(extendedLengthPath.length);
                }
                process.commandLine = value;
            }
        }
    }
}
exports.WmicProcessParser = WmicProcessParser;
class CimAttachItemsProvider extends NativeAttachItemsProvider {
    constructor(pwsh) {
        super();
        this.pwsh = pwsh;
    }
    getInternalProcessEntries() {
        return __awaiter(this, void 0, void 0, function* () {
            const pwshCommand = `${this.pwsh} -NoProfile -Command`;
            const cimCommand = 'Get-CimInstance Win32_Process | Select-Object Name,ProcessId,CommandLine | ConvertTo-JSON';
            const processes = yield execChildProcess(`${pwshCommand} "${cimCommand}"`, undefined);
            return CimProcessParser.ParseProcessFromCim(processes);
        });
    }
}
exports.CimAttachItemsProvider = CimAttachItemsProvider;
class CimProcessParser {
    static get extendedLengthPathPrefix() { return '\\\\?\\'; }
    static get ntObjectManagerPathPrefix() { return '\\??\\'; }
    static ParseProcessFromCim(processes) {
        const processInfos = JSON.parse(processes);
        return processInfos.map(info => {
            let cmdline = info.CommandLine || undefined;
            if (cmdline === null || cmdline === void 0 ? void 0 : cmdline.startsWith(this.extendedLengthPathPrefix)) {
                cmdline = cmdline.slice(this.extendedLengthPathPrefix.length);
            }
            if (cmdline === null || cmdline === void 0 ? void 0 : cmdline.startsWith(this.ntObjectManagerPathPrefix)) {
                cmdline = cmdline.slice(this.ntObjectManagerPathPrefix.length);
            }
            return new Process(info.Name, `${info.ProcessId}`, cmdline);
        });
    }
}
exports.CimProcessParser = CimProcessParser;


/***/ }),

/***/ 1371:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArchitectureReplacer = exports.ArchType = void 0;
var ArchType;
(function (ArchType) {
    ArchType[ArchType["ia32"] = 0] = "ia32";
    ArchType[ArchType["x64"] = 1] = "x64";
})(ArchType = exports.ArchType || (exports.ArchType = {}));
class ArchitectureReplacer {
    static checkAndReplaceWSLPipeProgram(pipeProgramStr, expectedArch) {
        let replacedPipeProgram;
        const winDir = process.env.WINDIR ? process.env.WINDIR.toLowerCase() : undefined;
        const winDirAltDirSep = process.env.WINDIR ? process.env.WINDIR.replace('\\', '/').toLowerCase() : undefined;
        const winDirEnv = "${env:windir}";
        if (winDir && winDirAltDirSep && (pipeProgramStr.indexOf(winDir) === 0 || pipeProgramStr.indexOf(winDirAltDirSep) === 0 || pipeProgramStr.indexOf(winDirEnv) === 0)) {
            if (expectedArch === ArchType.x64) {
                const pathSep = ArchitectureReplacer.checkForFolderInPath(pipeProgramStr, "sysnative");
                if (pathSep) {
                    replacedPipeProgram = pipeProgramStr.replace(`${pathSep}sysnative${pathSep}`, `${pathSep}system32${pathSep}`);
                }
            }
            else if (expectedArch === ArchType.ia32) {
                const pathSep = ArchitectureReplacer.checkForFolderInPath(pipeProgramStr, "system32");
                if (pathSep) {
                    replacedPipeProgram = pipeProgramStr.replace(`${pathSep}system32${pathSep}`, `${pathSep}sysnative${pathSep}`);
                }
            }
        }
        return replacedPipeProgram;
    }
    static checkForFolderInPath(path, folder) {
        if (path.indexOf(`/${folder}/`) >= 0) {
            return '/';
        }
        else if (path.indexOf(`\\${folder}\\`) >= 0) {
            return '\\';
        }
        return "";
    }
}
exports.ArchitectureReplacer = ArchitectureReplacer;


/***/ }),

/***/ 6790:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentFormattingEditProvider = void 0;
const vscode = __webpack_require__(7549);
const client_1 = __webpack_require__(9325);
const settings_1 = __webpack_require__(296);
class DocumentFormattingEditProvider {
    constructor(client) {
        this.client = client;
    }
    provideDocumentFormattingEdits(document, options, token) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.awaitUntilLanguageClientReady();
            const filePath = document.uri.fsPath;
            const settings = new settings_1.CppSettings(this.client.RootUri);
            const useVcFormat = settings.useVcFormat(document);
            const configCallBack = (editorConfigSettings) => __awaiter(this, void 0, void 0, function* () {
                const params = {
                    editorConfigSettings: Object.assign({}, editorConfigSettings),
                    useVcFormat: useVcFormat,
                    uri: document.uri.toString(),
                    insertSpaces: options.insertSpaces,
                    tabSize: options.tabSize,
                    character: "",
                    range: {
                        start: {
                            character: 0,
                            line: 0
                        },
                        end: {
                            character: 0,
                            line: 0
                        }
                    }
                };
                const textEdits = yield this.client.languageClient.sendRequest(client_1.FormatDocumentRequest, params);
                const results = [];
                textEdits.forEach((textEdit) => {
                    results.push({
                        range: new vscode.Range(textEdit.range.start.line, textEdit.range.start.character, textEdit.range.end.line, textEdit.range.end.character),
                        newText: textEdit.newText
                    });
                });
                if (document.lineCount > 0 && editorConfigSettings !== undefined && editorConfigSettings.insert_final_newline) {
                    const lastLine = document.lineAt(document.lineCount - 1);
                    if (!lastLine.isEmptyOrWhitespace) {
                        const endPosition = lastLine.range.end;
                        let lastEdit;
                        results.forEach(edit => {
                            if (edit.range.end.isAfterOrEqual(endPosition) && (!lastEdit || edit.range.start.isAfterOrEqual(lastEdit.range.start)) && edit.newText !== "") {
                                lastEdit = edit;
                            }
                        });
                        if (lastEdit === undefined) {
                            results.push({
                                range: new vscode.Range(endPosition, endPosition),
                                newText: "\n"
                            });
                        }
                        else {
                            if (!lastEdit.newText.endsWith("\n")) {
                                lastEdit.newText += "\n";
                            }
                        }
                    }
                }
                return results;
            });
            if (!useVcFormat) {
                return configCallBack(undefined);
            }
            else {
                const editorConfigSettings = (0, settings_1.getEditorConfigSettings)(filePath);
                return configCallBack(editorConfigSettings);
            }
        });
    }
}
exports.DocumentFormattingEditProvider = DocumentFormattingEditProvider;


/***/ }),

/***/ 1438:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentRangeFormattingEditProvider = void 0;
const vscode = __webpack_require__(7549);
const client_1 = __webpack_require__(9325);
const settings_1 = __webpack_require__(296);
class DocumentRangeFormattingEditProvider {
    constructor(client) {
        this.client = client;
    }
    provideDocumentRangeFormattingEdits(document, range, options, token) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.awaitUntilLanguageClientReady();
            const filePath = document.uri.fsPath;
            const settings = new settings_1.CppSettings(this.client.RootUri);
            const useVcFormat = settings.useVcFormat(document);
            const configCallBack = (editorConfigSettings) => __awaiter(this, void 0, void 0, function* () {
                const params = {
                    editorConfigSettings: Object.assign({}, editorConfigSettings),
                    useVcFormat: useVcFormat,
                    uri: document.uri.toString(),
                    insertSpaces: options.insertSpaces,
                    tabSize: options.tabSize,
                    character: "",
                    range: {
                        start: {
                            character: range.start.character,
                            line: range.start.line
                        },
                        end: {
                            character: range.end.character,
                            line: range.end.line
                        }
                    }
                };
                const textEdits = yield this.client.languageClient.sendRequest(client_1.FormatRangeRequest, params);
                const result = [];
                textEdits.forEach((textEdit) => {
                    result.push({
                        range: new vscode.Range(textEdit.range.start.line, textEdit.range.start.character, textEdit.range.end.line, textEdit.range.end.character),
                        newText: textEdit.newText
                    });
                });
                return result;
            });
            if (!useVcFormat) {
                return configCallBack(undefined);
            }
            else {
                const editorConfigSettings = (0, settings_1.getEditorConfigSettings)(filePath);
                return configCallBack(editorConfigSettings);
            }
        });
    }
    ;
}
exports.DocumentRangeFormattingEditProvider = DocumentRangeFormattingEditProvider;


/***/ }),

/***/ 4763:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentSymbolProvider = void 0;
const vscode = __webpack_require__(7549);
const client_1 = __webpack_require__(9325);
const util = __webpack_require__(5331);
const extension_1 = __webpack_require__(2973);
class DocumentSymbolProvider {
    constructor(client) {
        this.client = client;
    }
    getChildrenSymbols(symbols) {
        const documentSymbols = [];
        if (symbols) {
            symbols.forEach((symbol) => {
                let detail = util.getLocalizedString(symbol.detail);
                if (symbol.scope === client_1.SymbolScope.Private) {
                    if (detail.length === 0) {
                        detail = "private";
                    }
                    else {
                        detail = util.getLocalizedSymbolScope("private", detail);
                    }
                }
                else if (symbol.scope === client_1.SymbolScope.Protected) {
                    if (detail.length === 0) {
                        detail = "protected";
                    }
                    else {
                        detail = util.getLocalizedSymbolScope("protected", detail);
                    }
                }
                if (detail.length === 0) {
                    let offset_paren = symbol.name.indexOf("(");
                    if (offset_paren < 0) {
                        offset_paren = symbol.name.length;
                    }
                    const offset_scope = symbol.name.lastIndexOf("::", offset_paren - 2);
                    if (offset_scope > 0) {
                        detail = symbol.name.substr(0, offset_scope);
                        symbol.name = symbol.name.substr(offset_scope + 2);
                    }
                }
                let r = new vscode.Range(symbol.range.start.line, symbol.range.start.character, symbol.range.end.line, symbol.range.end.character);
                const sr = new vscode.Range(symbol.selectionRange.start.line, symbol.selectionRange.start.character, symbol.selectionRange.end.line, symbol.selectionRange.end.character);
                if (!r.contains(sr)) {
                    r = sr;
                }
                const vscodeSymbol = new vscode.DocumentSymbol(symbol.name, detail, symbol.kind, r, sr);
                vscodeSymbol.children = this.getChildrenSymbols(symbol.children);
                documentSymbols.push(vscodeSymbol);
            });
        }
        return documentSymbols;
    }
    provideDocumentSymbols(document) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client.TrackedDocuments.has(document)) {
                (0, extension_1.processDelayedDidOpen)(document);
            }
            return this.client.requestWhenReady(() => __awaiter(this, void 0, void 0, function* () {
                const params = {
                    uri: document.uri.toString()
                };
                const symbols = yield this.client.languageClient.sendRequest(client_1.GetDocumentSymbolRequest, params);
                const resultSymbols = this.getChildrenSymbols(symbols);
                return resultSymbols;
            }));
        });
    }
}
exports.DocumentSymbolProvider = DocumentSymbolProvider;


/***/ }),

/***/ 676:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FindAllReferencesProvider = void 0;
const vscode = __webpack_require__(7549);
const client_1 = __webpack_require__(9325);
const vscode_languageclient_1 = __webpack_require__(3094);
const refs = __webpack_require__(2664);
class FindAllReferencesProvider {
    constructor(client) {
        this.client = client;
    }
    provideReferences(document, position, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const callback = () => __awaiter(this, void 0, void 0, function* () {
                    const params = {
                        position: vscode_languageclient_1.Position.create(position.line, position.character),
                        textDocument: this.client.languageClient.code2ProtocolConverter.asTextDocumentIdentifier(document)
                    };
                    client_1.DefaultClient.referencesParams = params;
                    yield this.client.awaitUntilLanguageClientReady();
                    if (params !== client_1.DefaultClient.referencesParams) {
                        const locations = [];
                        resolve(locations);
                        return;
                    }
                    client_1.DefaultClient.referencesRequestPending = true;
                    const resultCallback = (result, doResolve) => {
                        client_1.DefaultClient.referencesRequestPending = false;
                        const locations = [];
                        if (result) {
                            result.referenceInfos.forEach((referenceInfo) => {
                                if (referenceInfo.type === refs.ReferenceType.Confirmed) {
                                    const uri = vscode.Uri.file(referenceInfo.file);
                                    const range = new vscode.Range(referenceInfo.position.line, referenceInfo.position.character, referenceInfo.position.line, referenceInfo.position.character + result.text.length);
                                    locations.push(new vscode.Location(uri, range));
                                }
                            });
                        }
                        if (doResolve) {
                            resolve(locations);
                        }
                        if (client_1.DefaultClient.referencesPendingCancellations.length > 0) {
                            while (client_1.DefaultClient.referencesPendingCancellations.length > 1) {
                                const pendingCancel = client_1.DefaultClient.referencesPendingCancellations[0];
                                client_1.DefaultClient.referencesPendingCancellations.pop();
                                pendingCancel.reject();
                            }
                            const pendingCancel = client_1.DefaultClient.referencesPendingCancellations[0];
                            client_1.DefaultClient.referencesPendingCancellations.pop();
                            pendingCancel.callback();
                        }
                    };
                    if (!client_1.workspaceReferences.referencesRefreshPending) {
                        client_1.workspaceReferences.setResultsCallback(resultCallback);
                        client_1.workspaceReferences.startFindAllReferences(params);
                    }
                    else {
                        client_1.workspaceReferences.referencesRefreshPending = false;
                        if (client_1.workspaceReferences.lastResults) {
                            const lastResults = client_1.workspaceReferences.lastResults;
                            client_1.workspaceReferences.lastResults = null;
                            resultCallback(lastResults, true);
                        }
                        else {
                            client_1.workspaceReferences.referencesRequestPending = true;
                            client_1.workspaceReferences.setResultsCallback(resultCallback);
                            this.client.languageClient.sendNotification(client_1.RequestReferencesNotification, false);
                        }
                    }
                    token.onCancellationRequested(e => {
                        if (params === client_1.DefaultClient.referencesParams) {
                            this.client.cancelReferences();
                        }
                    });
                });
                if (client_1.DefaultClient.referencesRequestPending || (client_1.workspaceReferences.symbolSearchInProgress && !client_1.workspaceReferences.referencesRefreshPending)) {
                    const cancelling = client_1.DefaultClient.referencesPendingCancellations.length > 0;
                    client_1.DefaultClient.referencesPendingCancellations.push({
                        reject: () => {
                            const locations = [];
                            resolve(locations);
                        }, callback
                    });
                    if (!cancelling) {
                        client_1.DefaultClient.renamePending = false;
                        client_1.workspaceReferences.referencesCanceled = true;
                        if (!client_1.DefaultClient.referencesRequestPending) {
                            client_1.workspaceReferences.referencesCanceledWhilePreviewing = true;
                        }
                        this.client.languageClient.sendNotification(client_1.CancelReferencesNotification);
                    }
                }
                else {
                    callback();
                }
            });
        });
    }
}
exports.FindAllReferencesProvider = FindAllReferencesProvider;


/***/ }),

/***/ 2042:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeProvider = void 0;
const vscode = __webpack_require__(7549);
const client_1 = __webpack_require__(9325);
class FoldingRangeProvider {
    constructor(client) {
        this.onDidChangeFoldingRangesEvent = new vscode.EventEmitter();
        this.client = client;
        this.onDidChangeFoldingRanges = this.onDidChangeFoldingRangesEvent.event;
    }
    provideFoldingRanges(document, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = ++client_1.DefaultClient.abortRequestId;
            const params = {
                id: id,
                uri: document.uri.toString()
            };
            yield this.client.awaitUntilLanguageClientReady();
            token.onCancellationRequested(e => this.client.abortRequest(id));
            const ranges = yield this.client.languageClient.sendRequest(client_1.GetFoldingRangesRequest, params);
            if (ranges.canceled) {
                return undefined;
            }
            const result = [];
            ranges.ranges.forEach((r) => {
                const foldingRange = {
                    start: r.range.startLine,
                    end: r.range.endLine
                };
                switch (r.kind) {
                    case client_1.FoldingRangeKind.Comment:
                        foldingRange.kind = vscode.FoldingRangeKind.Comment;
                        break;
                    case client_1.FoldingRangeKind.Imports:
                        foldingRange.kind = vscode.FoldingRangeKind.Imports;
                        break;
                    case client_1.FoldingRangeKind.Region:
                        foldingRange.kind = vscode.FoldingRangeKind.Region;
                        break;
                    default:
                        break;
                }
                result.push(foldingRange);
            });
            return result;
        });
    }
    refresh() {
        this.onDidChangeFoldingRangesEvent.fire();
    }
}
exports.FoldingRangeProvider = FoldingRangeProvider;


/***/ }),

/***/ 1684:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OnTypeFormattingEditProvider = void 0;
const vscode = __webpack_require__(7549);
const client_1 = __webpack_require__(9325);
const settings_1 = __webpack_require__(296);
class OnTypeFormattingEditProvider {
    constructor(client) {
        this.client = client;
    }
    provideOnTypeFormattingEdits(document, position, ch, options, token) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.awaitUntilLanguageClientReady();
            const filePath = document.uri.fsPath;
            const settings = new settings_1.CppSettings(this.client.RootUri);
            const useVcFormat = settings.useVcFormat(document);
            const configCallBack = (editorConfigSettings) => __awaiter(this, void 0, void 0, function* () {
                const params = {
                    editorConfigSettings: Object.assign({}, editorConfigSettings),
                    useVcFormat: useVcFormat,
                    uri: document.uri.toString(),
                    insertSpaces: options.insertSpaces,
                    tabSize: options.tabSize,
                    character: ch,
                    range: {
                        start: {
                            character: position.character,
                            line: position.line
                        },
                        end: {
                            character: 0,
                            line: 0
                        }
                    }
                };
                const textEdits = yield this.client.languageClient.sendRequest(client_1.FormatOnTypeRequest, params);
                const result = [];
                textEdits.forEach((textEdit) => {
                    result.push({
                        range: new vscode.Range(textEdit.range.start.line, textEdit.range.start.character, textEdit.range.end.line, textEdit.range.end.character),
                        newText: textEdit.newText
                    });
                });
                return result;
            });
            if (!useVcFormat) {
                if (ch !== ';') {
                    const result = [];
                    return result;
                }
                else {
                    return configCallBack(undefined);
                }
            }
            else {
                const editorConfigSettings = (0, settings_1.getEditorConfigSettings)(filePath);
                return configCallBack(editorConfigSettings);
            }
        });
    }
}
exports.OnTypeFormattingEditProvider = OnTypeFormattingEditProvider;


/***/ }),

/***/ 2568:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenameProvider = void 0;
const vscode = __webpack_require__(7549);
const client_1 = __webpack_require__(9325);
const refs = __webpack_require__(2664);
const settings_1 = __webpack_require__(296);
const vscode_languageclient_1 = __webpack_require__(3094);
const nls = __webpack_require__(3463);
const util = __webpack_require__(5331);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\Providers\\renameProvider.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\Providers\\renameProvider.ts'));
class RenameProvider {
    constructor(client) {
        this.client = client;
    }
    provideRenameEdits(document, position, newName, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const settings = new settings_1.CppSettings();
            if (settings.renameRequiresIdentifier && !util.isValidIdentifier(newName)) {
                vscode.window.showErrorMessage(localize(0, null));
                const workspaceEdit = new vscode.WorkspaceEdit();
                return workspaceEdit;
            }
            client_1.DefaultClient.renamePending = true;
            ++client_1.DefaultClient.renameRequestsPending;
            return new Promise((resolve, reject) => {
                const callback = () => __awaiter(this, void 0, void 0, function* () {
                    const params = {
                        newName: newName,
                        position: vscode_languageclient_1.Position.create(position.line, position.character),
                        textDocument: this.client.languageClient.code2ProtocolConverter.asTextDocumentIdentifier(document)
                    };
                    client_1.DefaultClient.referencesParams = params;
                    yield this.client.awaitUntilLanguageClientReady();
                    if (params !== client_1.DefaultClient.referencesParams) {
                        if (--client_1.DefaultClient.renameRequestsPending === 0) {
                            client_1.DefaultClient.renamePending = false;
                        }
                        const workspaceEdit = new vscode.WorkspaceEdit();
                        resolve(workspaceEdit);
                        return;
                    }
                    client_1.DefaultClient.referencesRequestPending = true;
                    client_1.workspaceReferences.setResultsCallback((referencesResult, doResolve) => {
                        client_1.DefaultClient.referencesRequestPending = false;
                        --client_1.DefaultClient.renameRequestsPending;
                        const workspaceEdit = new vscode.WorkspaceEdit();
                        const cancelling = client_1.DefaultClient.referencesPendingCancellations.length > 0;
                        if (cancelling) {
                            while (client_1.DefaultClient.referencesPendingCancellations.length > 1) {
                                const pendingCancel = client_1.DefaultClient.referencesPendingCancellations[0];
                                client_1.DefaultClient.referencesPendingCancellations.pop();
                                pendingCancel.reject();
                            }
                            const pendingCancel = client_1.DefaultClient.referencesPendingCancellations[0];
                            client_1.DefaultClient.referencesPendingCancellations.pop();
                            pendingCancel.callback();
                        }
                        else {
                            if (client_1.DefaultClient.renameRequestsPending === 0) {
                                client_1.DefaultClient.renamePending = false;
                            }
                            if (referencesResult) {
                                for (const reference of referencesResult.referenceInfos) {
                                    const uri = vscode.Uri.file(reference.file);
                                    const range = new vscode.Range(reference.position.line, reference.position.character, reference.position.line, reference.position.character + referencesResult.text.length);
                                    const metadata = {
                                        needsConfirmation: reference.type !== refs.ReferenceType.Confirmed,
                                        label: refs.getReferenceTagString(reference.type, false, true),
                                        iconPath: refs.getReferenceItemIconPath(reference.type, false)
                                    };
                                    workspaceEdit.replace(uri, range, newName, metadata);
                                }
                            }
                        }
                        if (referencesResult && (referencesResult.referenceInfos === null || referencesResult.referenceInfos.length === 0)) {
                            vscode.window.showErrorMessage(localize(1, null));
                        }
                        resolve(workspaceEdit);
                    });
                    client_1.workspaceReferences.startRename(params);
                });
                if (client_1.DefaultClient.referencesRequestPending || client_1.workspaceReferences.symbolSearchInProgress) {
                    const cancelling = client_1.DefaultClient.referencesPendingCancellations.length > 0;
                    client_1.DefaultClient.referencesPendingCancellations.push({
                        reject: () => {
                            --client_1.DefaultClient.renameRequestsPending;
                            const workspaceEdit = new vscode.WorkspaceEdit();
                            resolve(workspaceEdit);
                        }, callback
                    });
                    if (!cancelling) {
                        client_1.workspaceReferences.referencesCanceled = true;
                        if (!client_1.DefaultClient.referencesRequestPending) {
                            client_1.workspaceReferences.referencesCanceledWhilePreviewing = true;
                        }
                        this.client.languageClient.sendNotification(client_1.CancelReferencesNotification);
                    }
                }
                else {
                    callback();
                }
            });
        });
    }
}
exports.RenameProvider = RenameProvider;


/***/ }),

/***/ 6595:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensProvider = void 0;
const vscode = __webpack_require__(7549);
const client_1 = __webpack_require__(9325);
class SemanticTokensProvider {
    constructor(client) {
        this.onDidChangeSemanticTokensEvent = new vscode.EventEmitter();
        this.tokenCaches = new Map();
        this.client = client;
        this.onDidChangeSemanticTokens = this.onDidChangeSemanticTokensEvent.event;
    }
    provideDocumentSemanticTokens(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.awaitUntilLanguageClientReady();
            const uriString = document.uri.toString();
            const cache = this.tokenCaches.get(uriString);
            if (cache && cache[0] === document.version) {
                return cache[1];
            }
            else {
                token.onCancellationRequested(_e => this.client.abortRequest(id));
                const id = ++client_1.DefaultClient.abortRequestId;
                const params = {
                    id: id,
                    uri: uriString
                };
                const tokensResult = yield this.client.languageClient.sendRequest(client_1.GetSemanticTokensRequest, params);
                if (tokensResult.canceled) {
                    throw new vscode.CancellationError();
                }
                else {
                    if (tokensResult.fileVersion !== client_1.openFileVersions.get(uriString)) {
                        throw new vscode.CancellationError();
                    }
                    else {
                        const builder = new vscode.SemanticTokensBuilder(this.client.semanticTokensLegend);
                        tokensResult.tokens.forEach((token) => {
                            builder.push(token.line, token.character, token.length, token.type, token.modifiers);
                        });
                        const tokens = builder.build();
                        this.tokenCaches.set(uriString, [tokensResult.fileVersion, tokens]);
                        return tokens;
                    }
                }
            }
        });
    }
    invalidateFile(uri) {
        this.tokenCaches.delete(uri);
        this.onDidChangeSemanticTokensEvent.fire();
    }
}
exports.SemanticTokensProvider = SemanticTokensProvider;


/***/ }),

/***/ 4015:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceSymbolProvider = void 0;
const vscode = __webpack_require__(7549);
const client_1 = __webpack_require__(9325);
const util = __webpack_require__(5331);
class WorkspaceSymbolProvider {
    constructor(client) {
        this.client = client;
    }
    provideWorkspaceSymbols(query, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = {
                query: query
            };
            const symbols = yield this.client.languageClient.sendRequest(client_1.GetSymbolInfoRequest, params);
            const resultSymbols = [];
            symbols.forEach((symbol) => {
                let suffix = util.getLocalizedString(symbol.suffix);
                let name = symbol.name;
                if (suffix.length) {
                    if (symbol.scope === client_1.SymbolScope.Private) {
                        suffix = util.getLocalizedSymbolScope("private", suffix);
                    }
                    else if (symbol.scope === client_1.SymbolScope.Protected) {
                        suffix = util.getLocalizedSymbolScope("protected", suffix);
                    }
                    name = name + ' (' + suffix + ')';
                }
                else {
                    if (symbol.scope === client_1.SymbolScope.Private) {
                        name = name + " (private)";
                    }
                    else if (symbol.scope === client_1.SymbolScope.Protected) {
                        name = name + " (protected)";
                    }
                }
                const range = new vscode.Range(symbol.location.range.start.line, symbol.location.range.start.character, symbol.location.range.end.line, symbol.location.range.end.character);
                const uri = vscode.Uri.parse(symbol.location.uri.toString());
                const vscodeSymbol = new vscode.SymbolInformation(name, symbol.kind, symbol.containerName, new vscode.Location(uri, range));
                resultSymbols.push(vscodeSymbol);
            });
            return resultSymbols;
        });
    }
}
exports.WorkspaceSymbolProvider = WorkspaceSymbolProvider;


/***/ }),

/***/ 9325:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultClient = exports.createNullClient = exports.createClient = exports.CancelReferencesNotification = exports.RequestReferencesNotification = exports.FormatOnTypeRequest = exports.FormatRangeRequest = exports.FormatDocumentRequest = exports.GetSemanticTokensRequest = exports.GetFoldingRangesRequest = exports.GetSymbolInfoRequest = exports.GetDocumentSymbolRequest = exports.FoldingRangeKind = exports.SymbolScope = exports.disposeWorkspaceData = exports.cachedEditorConfigLookups = exports.cachedEditorConfigSettings = exports.openFileVersions = exports.workspaceReferences = void 0;
const path = __webpack_require__(5622);
const vscode = __webpack_require__(7549);
const onTypeFormattingEditProvider_1 = __webpack_require__(1684);
const foldingRangeProvider_1 = __webpack_require__(2042);
const semanticTokensProvider_1 = __webpack_require__(6595);
const documentFormattingEditProvider_1 = __webpack_require__(6790);
const documentRangeFormattingEditProvider_1 = __webpack_require__(1438);
const documentSymbolProvider_1 = __webpack_require__(4763);
const workspaceSymbolProvider_1 = __webpack_require__(4015);
const renameProvider_1 = __webpack_require__(2568);
const findAllReferencesProvider_1 = __webpack_require__(676);
const vscode_languageclient_1 = __webpack_require__(3094);
const vscode_cpptools_1 = __webpack_require__(3286);
const testApi_1 = __webpack_require__(7373);
const util = __webpack_require__(5331);
const configs = __webpack_require__(6932);
const settings_1 = __webpack_require__(296);
const telemetry = __webpack_require__(1818);
const persistentState_1 = __webpack_require__(1102);
const ui_1 = __webpack_require__(6713);
const protocolFilter_1 = __webpack_require__(9696);
const dataBinding_1 = __webpack_require__(1748);
const minimatch = __webpack_require__(5076);
const logger = __webpack_require__(5610);
const extension_1 = __webpack_require__(2973);
const settingsTracker_1 = __webpack_require__(5313);
const testHook_1 = __webpack_require__(5648);
const customProviders_1 = __webpack_require__(4977);
const fs = __webpack_require__(5747);
const os = __webpack_require__(2087);
const refs = __webpack_require__(2664);
const nls = __webpack_require__(3463);
const nativeStrings_1 = __webpack_require__(5391);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\client.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\client.ts'));
let ui;
let timeStamp = 0;
const configProviderTimeout = 2000;
let languageClient;
let languageClientCrashedNeedsRestart = false;
const languageClientCrashTimes = [];
let clientCollection;
let pendingTask;
let compilerDefaults;
let diagnosticsChannel;
let outputChannel;
let debugChannel;
let warningChannel;
let diagnosticsCollectionIntelliSense;
let diagnosticsCollectionCodeAnalysis;
let workspaceDisposables = [];
exports.openFileVersions = new Map();
exports.cachedEditorConfigSettings = new Map();
exports.cachedEditorConfigLookups = new Map();
function disposeWorkspaceData() {
    workspaceDisposables.forEach((d) => d.dispose());
    workspaceDisposables = [];
}
exports.disposeWorkspaceData = disposeWorkspaceData;
function logTelemetry(notificationBody) {
    telemetry.logLanguageServerEvent(notificationBody.event, notificationBody.properties, notificationBody.metrics);
}
function setupOutputHandlers() {
    console.assert(languageClient !== undefined, "This method must not be called until this.languageClient is set in \"onReady\"");
    languageClient.onNotification(DebugProtocolNotification, (output) => {
        if (!debugChannel) {
            debugChannel = vscode.window.createOutputChannel(`${localize(0, null)}`);
            workspaceDisposables.push(debugChannel);
        }
        debugChannel.appendLine("");
        debugChannel.appendLine("************************************************************************************************************************");
        debugChannel.append(`${output}`);
    });
    languageClient.onNotification(DebugLogNotification, logLocalized);
}
function log(output) {
    if (!outputChannel) {
        outputChannel = logger.getOutputChannel();
        workspaceDisposables.push(outputChannel);
    }
    outputChannel.appendLine(`${output}`);
}
function logLocalized(params) {
    const output = util.getLocalizedString(params);
    log(output);
}
function showMessageWindow(params) {
    const message = util.getLocalizedString(params.localizeStringParams);
    switch (params.type) {
        case 1:
            vscode.window.showErrorMessage(message);
            break;
        case 2:
            vscode.window.showWarningMessage(message);
            break;
        case 3:
            vscode.window.showInformationMessage(message);
            break;
        default:
            console.assert("Unrecognized type for showMessageWindow");
            break;
    }
}
function showWarning(params) {
    const message = util.getLocalizedString(params.localizeStringParams);
    let showChannel = false;
    if (!warningChannel) {
        warningChannel = vscode.window.createOutputChannel(`${localize(1, null)}`);
        workspaceDisposables.push(warningChannel);
        showChannel = true;
    }
    warningChannel.appendLine(`[${new Date().toLocaleString()}] ${message}`);
    if (showChannel) {
        warningChannel.show(true);
    }
}
function publishDiagnostics(params) {
    if (!diagnosticsCollectionIntelliSense) {
        diagnosticsCollectionIntelliSense = vscode.languages.createDiagnosticCollection("C/C++");
    }
    const diagnosticsIntelliSense = [];
    params.diagnostics.forEach((d) => {
        const message = util.getLocalizedString(d.localizeStringParams);
        const r = new vscode.Range(d.range.start.line, d.range.start.character, d.range.end.line, d.range.end.character);
        const diagnostic = new vscode.Diagnostic(r, message, d.severity);
        diagnostic.code = d.code;
        diagnostic.source = "C/C++";
        if (d.relatedInformation) {
            diagnostic.relatedInformation = [];
            for (const info of d.relatedInformation) {
                const infoRange = new vscode.Range(info.location.range.start.line, info.location.range.start.character, info.location.range.end.line, info.location.range.end.character);
                diagnostic.relatedInformation.push(new vscode.DiagnosticRelatedInformation(new vscode.Location(vscode.Uri.parse(info.location.uri), infoRange), info.message));
            }
        }
        diagnosticsIntelliSense.push(diagnostic);
    });
    const realUri = vscode.Uri.parse(params.uri);
    diagnosticsCollectionIntelliSense.set(realUri, diagnosticsIntelliSense);
    clientCollection.timeTelemetryCollector.setUpdateRangeTime(realUri);
}
function publishCodeAnalysisDiagnostics(params) {
    if (!diagnosticsCollectionCodeAnalysis) {
        diagnosticsCollectionCodeAnalysis = vscode.languages.createDiagnosticCollection("clang-tidy");
    }
    const diagnosticsCodeAnalysis = [];
    params.diagnostics.forEach((d) => {
        const message = util.getLocalizedString(d.localizeStringParams);
        const r = new vscode.Range(d.range.start.line, d.range.start.character, d.range.end.line, d.range.end.character);
        const diagnostic = new vscode.Diagnostic(r, message, d.severity);
        if (typeof d.code === "string" && d.code.length !== 0 && !d.code.startsWith("clang-diagnostic-")) {
            const codes = d.code.split(',');
            let codeIndex = codes.length - 1;
            if (codes[codeIndex] === "cert-dcl51-cpp") {
                codeIndex = 0;
            }
            diagnostic.code = { value: d.code,
                target: vscode.Uri.parse(`https://releases.llvm.org/13.0.0/tools/clang/tools/extra/docs/clang-tidy/checks/${codes[codeIndex]}.html`) };
        }
        else {
            diagnostic.code = d.code;
        }
        diagnostic.source = "C/C++";
        if (d.relatedInformation) {
            diagnostic.relatedInformation = [];
            for (const info of d.relatedInformation) {
                const infoRange = new vscode.Range(info.location.range.start.line, info.location.range.start.character, info.location.range.end.line, info.location.range.end.character);
                diagnostic.relatedInformation.push(new vscode.DiagnosticRelatedInformation(new vscode.Location(vscode.Uri.parse(info.location.uri), infoRange), info.message));
            }
        }
        diagnosticsCodeAnalysis.push(diagnostic);
    });
    const realUri = vscode.Uri.parse(params.uri);
    diagnosticsCollectionCodeAnalysis.set(realUri, diagnosticsCodeAnalysis);
}
var SymbolScope;
(function (SymbolScope) {
    SymbolScope[SymbolScope["Public"] = 0] = "Public";
    SymbolScope[SymbolScope["Protected"] = 1] = "Protected";
    SymbolScope[SymbolScope["Private"] = 2] = "Private";
})(SymbolScope = exports.SymbolScope || (exports.SymbolScope = {}));
var FoldingRangeKind;
(function (FoldingRangeKind) {
    FoldingRangeKind[FoldingRangeKind["None"] = 0] = "None";
    FoldingRangeKind[FoldingRangeKind["Comment"] = 1] = "Comment";
    FoldingRangeKind[FoldingRangeKind["Imports"] = 2] = "Imports";
    FoldingRangeKind[FoldingRangeKind["Region"] = 3] = "Region";
})(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes[SemanticTokenTypes["macro"] = 0] = "macro";
    SemanticTokenTypes[SemanticTokenTypes["enumMember"] = 1] = "enumMember";
    SemanticTokenTypes[SemanticTokenTypes["variable"] = 2] = "variable";
    SemanticTokenTypes[SemanticTokenTypes["parameter"] = 3] = "parameter";
    SemanticTokenTypes[SemanticTokenTypes["type"] = 4] = "type";
    SemanticTokenTypes[SemanticTokenTypes["referenceType"] = 5] = "referenceType";
    SemanticTokenTypes[SemanticTokenTypes["valueType"] = 6] = "valueType";
    SemanticTokenTypes[SemanticTokenTypes["function"] = 7] = "function";
    SemanticTokenTypes[SemanticTokenTypes["method"] = 8] = "method";
    SemanticTokenTypes[SemanticTokenTypes["property"] = 9] = "property";
    SemanticTokenTypes[SemanticTokenTypes["cliProperty"] = 10] = "cliProperty";
    SemanticTokenTypes[SemanticTokenTypes["event"] = 11] = "event";
    SemanticTokenTypes[SemanticTokenTypes["genericType"] = 12] = "genericType";
    SemanticTokenTypes[SemanticTokenTypes["templateFunction"] = 13] = "templateFunction";
    SemanticTokenTypes[SemanticTokenTypes["templateType"] = 14] = "templateType";
    SemanticTokenTypes[SemanticTokenTypes["namespace"] = 15] = "namespace";
    SemanticTokenTypes[SemanticTokenTypes["label"] = 16] = "label";
    SemanticTokenTypes[SemanticTokenTypes["customLiteral"] = 17] = "customLiteral";
    SemanticTokenTypes[SemanticTokenTypes["numberLiteral"] = 18] = "numberLiteral";
    SemanticTokenTypes[SemanticTokenTypes["stringLiteral"] = 19] = "stringLiteral";
    SemanticTokenTypes[SemanticTokenTypes["operatorOverload"] = 20] = "operatorOverload";
    SemanticTokenTypes[SemanticTokenTypes["memberOperatorOverload"] = 21] = "memberOperatorOverload";
    SemanticTokenTypes[SemanticTokenTypes["newOperator"] = 22] = "newOperator";
})(SemanticTokenTypes || (SemanticTokenTypes = {}));
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers[SemanticTokenModifiers["static"] = 1] = "static";
    SemanticTokenModifiers[SemanticTokenModifiers["global"] = 2] = "global";
    SemanticTokenModifiers[SemanticTokenModifiers["local"] = 4] = "local";
})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
;
var CodeAnalysisScope;
(function (CodeAnalysisScope) {
    CodeAnalysisScope[CodeAnalysisScope["ActiveFile"] = 0] = "ActiveFile";
    CodeAnalysisScope[CodeAnalysisScope["OpenFiles"] = 1] = "OpenFiles";
    CodeAnalysisScope[CodeAnalysisScope["AllFiles"] = 2] = "AllFiles";
    CodeAnalysisScope[CodeAnalysisScope["ClearSquiggles"] = 3] = "ClearSquiggles";
})(CodeAnalysisScope || (CodeAnalysisScope = {}));
;
;
const QueryCompilerDefaultsRequest = new vscode_languageclient_1.RequestType('cpptools/queryCompilerDefaults');
const QueryTranslationUnitSourceRequest = new vscode_languageclient_1.RequestType('cpptools/queryTranslationUnitSource');
const SwitchHeaderSourceRequest = new vscode_languageclient_1.RequestType('cpptools/didSwitchHeaderSource');
const GetDiagnosticsRequest = new vscode_languageclient_1.RequestType('cpptools/getDiagnostics');
const GetCodeActionsRequest = new vscode_languageclient_1.RequestType('cpptools/getCodeActions');
exports.GetDocumentSymbolRequest = new vscode_languageclient_1.RequestType('cpptools/getDocumentSymbols');
exports.GetSymbolInfoRequest = new vscode_languageclient_1.RequestType('cpptools/getWorkspaceSymbols');
exports.GetFoldingRangesRequest = new vscode_languageclient_1.RequestType('cpptools/getFoldingRanges');
exports.GetSemanticTokensRequest = new vscode_languageclient_1.RequestType('cpptools/getSemanticTokens');
exports.FormatDocumentRequest = new vscode_languageclient_1.RequestType('cpptools/formatDocument');
exports.FormatRangeRequest = new vscode_languageclient_1.RequestType('cpptools/formatRange');
exports.FormatOnTypeRequest = new vscode_languageclient_1.RequestType('cpptools/formatOnType');
const GoToDirectiveInGroupRequest = new vscode_languageclient_1.RequestType('cpptools/goToDirectiveInGroup');
const DidOpenNotification = new vscode_languageclient_1.NotificationType('textDocument/didOpen');
const FileCreatedNotification = new vscode_languageclient_1.NotificationType('cpptools/fileCreated');
const FileChangedNotification = new vscode_languageclient_1.NotificationType('cpptools/fileChanged');
const FileDeletedNotification = new vscode_languageclient_1.NotificationType('cpptools/fileDeleted');
const ResetDatabaseNotification = new vscode_languageclient_1.NotificationType('cpptools/resetDatabase');
const PauseParsingNotification = new vscode_languageclient_1.NotificationType('cpptools/pauseParsing');
const ResumeParsingNotification = new vscode_languageclient_1.NotificationType('cpptools/resumeParsing');
const PauseCodeAnalysisNotification = new vscode_languageclient_1.NotificationType('cpptools/pauseCodeAnalysis');
const ResumeCodeAnalysisNotification = new vscode_languageclient_1.NotificationType('cpptools/resumeCodeAnalysis');
const CancelCodeAnalysisNotification = new vscode_languageclient_1.NotificationType('cpptools/cancelCodeAnalysis');
const ActiveDocumentChangeNotification = new vscode_languageclient_1.NotificationType('cpptools/activeDocumentChange');
const RestartIntelliSenseForFileNotification = new vscode_languageclient_1.NotificationType('cpptools/restartIntelliSenseForFile');
const TextEditorSelectionChangeNotification = new vscode_languageclient_1.NotificationType('cpptools/textEditorSelectionChange');
const ChangeCppPropertiesNotification = new vscode_languageclient_1.NotificationType('cpptools/didChangeCppProperties');
const ChangeCompileCommandsNotification = new vscode_languageclient_1.NotificationType('cpptools/didChangeCompileCommands');
const ChangeSelectedSettingNotification = new vscode_languageclient_1.NotificationType('cpptools/didChangeSelectedSetting');
const IntervalTimerNotification = new vscode_languageclient_1.NotificationType('cpptools/onIntervalTimer');
const CustomConfigurationNotification = new vscode_languageclient_1.NotificationType('cpptools/didChangeCustomConfiguration');
const CustomBrowseConfigurationNotification = new vscode_languageclient_1.NotificationType('cpptools/didChangeCustomBrowseConfiguration');
const ClearCustomConfigurationsNotification = new vscode_languageclient_1.NotificationType('cpptools/clearCustomConfigurations');
const ClearCustomBrowseConfigurationNotification = new vscode_languageclient_1.NotificationType('cpptools/clearCustomBrowseConfiguration');
const RescanFolderNotification = new vscode_languageclient_1.NotificationType('cpptools/rescanFolder');
exports.RequestReferencesNotification = new vscode_languageclient_1.NotificationType('cpptools/requestReferences');
exports.CancelReferencesNotification = new vscode_languageclient_1.NotificationType('cpptools/cancelReferences');
const FinishedRequestCustomConfig = new vscode_languageclient_1.NotificationType('cpptools/finishedRequestCustomConfig');
const FindAllReferencesNotification = new vscode_languageclient_1.NotificationType('cpptools/findAllReferences');
const RenameNotification = new vscode_languageclient_1.NotificationType('cpptools/rename');
const DidChangeSettingsNotification = new vscode_languageclient_1.NotificationType('cpptools/didChangeSettings');
const AbortRequestNotification = new vscode_languageclient_1.NotificationType('cpptools/abortRequest');
const CodeAnalysisNotification = new vscode_languageclient_1.NotificationType('cpptools/runCodeAnalysis');
const ReloadWindowNotification = new vscode_languageclient_1.NotificationType('cpptools/reloadWindow');
const LogTelemetryNotification = new vscode_languageclient_1.NotificationType('cpptools/logTelemetry');
const ReportTagParseStatusNotification = new vscode_languageclient_1.NotificationType('cpptools/reportTagParseStatus');
const ReportStatusNotification = new vscode_languageclient_1.NotificationType('cpptools/reportStatus');
const DebugProtocolNotification = new vscode_languageclient_1.NotificationType('cpptools/debugProtocol');
const DebugLogNotification = new vscode_languageclient_1.NotificationType('cpptools/debugLog');
const InactiveRegionNotification = new vscode_languageclient_1.NotificationType('cpptools/inactiveRegions');
const CompileCommandsPathsNotification = new vscode_languageclient_1.NotificationType('cpptools/compileCommandsPaths');
const ReferencesNotification = new vscode_languageclient_1.NotificationType('cpptools/references');
const ReportReferencesProgressNotification = new vscode_languageclient_1.NotificationType('cpptools/reportReferencesProgress');
const RequestCustomConfig = new vscode_languageclient_1.NotificationType('cpptools/requestCustomConfig');
const PublishDiagnosticsNotification = new vscode_languageclient_1.NotificationType('cpptools/publishDiagnostics');
const PublishCodeAnalysisDiagnosticsNotification = new vscode_languageclient_1.NotificationType('cpptools/publishCodeAnalysisDiagnostics');
const ShowMessageWindowNotification = new vscode_languageclient_1.NotificationType('cpptools/showMessageWindow');
const ShowWarningNotification = new vscode_languageclient_1.NotificationType('cpptools/showWarning');
const ReportTextDocumentLanguage = new vscode_languageclient_1.NotificationType('cpptools/reportTextDocumentLanguage');
const SemanticTokensChanged = new vscode_languageclient_1.NotificationType('cpptools/semanticTokensChanged');
const IntelliSenseSetupNotification = new vscode_languageclient_1.NotificationType('cpptools/IntelliSenseSetup');
const SetTemporaryTextDocumentLanguageNotification = new vscode_languageclient_1.NotificationType('cpptools/setTemporaryTextDocumentLanguage');
const ReportCodeAnalysisProcessedNotification = new vscode_languageclient_1.NotificationType('cpptools/reportCodeAnalysisProcessed');
const ReportCodeAnalysisTotalNotification = new vscode_languageclient_1.NotificationType('cpptools/reportCodeAnalysisTotal');
let failureMessageShown = false;
class ClientModel {
    constructor() {
        this.isParsingWorkspace = new dataBinding_1.DataBinding(false);
        this.isParsingWorkspacePausable = new dataBinding_1.DataBinding(false);
        this.isParsingWorkspacePaused = new dataBinding_1.DataBinding(false);
        this.isParsingFiles = new dataBinding_1.DataBinding(false);
        this.isUpdatingIntelliSense = new dataBinding_1.DataBinding(false);
        this.isRunningCodeAnalysis = new dataBinding_1.DataBinding(false);
        this.isCodeAnalysisPaused = new dataBinding_1.DataBinding(false);
        this.codeAnalysisProcessed = new dataBinding_1.DataBinding(0);
        this.codeAnalysisTotal = new dataBinding_1.DataBinding(0);
        this.referencesCommandMode = new dataBinding_1.DataBinding(refs.ReferencesCommandMode.None);
        this.parsingWorkspaceStatus = new dataBinding_1.DataBinding("");
        this.activeConfigName = new dataBinding_1.DataBinding("");
    }
    activate() {
        this.isParsingWorkspace.activate();
        this.isParsingWorkspacePausable.activate();
        this.isParsingWorkspacePaused.activate();
        this.isParsingFiles.activate();
        this.isUpdatingIntelliSense.activate();
        this.isRunningCodeAnalysis.activate();
        this.isCodeAnalysisPaused.activate();
        this.codeAnalysisProcessed.activate();
        this.codeAnalysisTotal.activate();
        this.referencesCommandMode.activate();
        this.parsingWorkspaceStatus.activate();
        this.activeConfigName.activate();
    }
    deactivate() {
        this.isParsingWorkspace.deactivate();
        this.isParsingWorkspacePausable.deactivate();
        this.isParsingWorkspacePaused.deactivate();
        this.isParsingFiles.deactivate();
        this.isUpdatingIntelliSense.deactivate();
        this.isRunningCodeAnalysis.deactivate();
        this.isCodeAnalysisPaused.deactivate();
        this.codeAnalysisProcessed.deactivate();
        this.codeAnalysisTotal.deactivate();
        this.referencesCommandMode.deactivate();
        this.parsingWorkspaceStatus.deactivate();
        this.activeConfigName.deactivate();
    }
    dispose() {
        this.isParsingWorkspace.dispose();
        this.isParsingWorkspacePausable.dispose();
        this.isParsingWorkspacePaused.dispose();
        this.isParsingFiles.dispose();
        this.isUpdatingIntelliSense.dispose();
        this.isRunningCodeAnalysis.dispose();
        this.isCodeAnalysisPaused.dispose();
        this.codeAnalysisProcessed.dispose();
        this.codeAnalysisTotal.dispose();
        this.referencesCommandMode.dispose();
        this.parsingWorkspaceStatus.dispose();
        this.activeConfigName.dispose();
    }
}
function createClient(allClients, workspaceFolder) {
    return new DefaultClient(allClients, workspaceFolder);
}
exports.createClient = createClient;
function createNullClient() {
    return new NullClient();
}
exports.createNullClient = createNullClient;
class DefaultClient {
    constructor(allClients, workspaceFolder) {
        var _a;
        this.disposables = [];
        this.trackedDocuments = new Set();
        this.isSupported = true;
        this.inactiveRegionsDecorations = new Map();
        this.documentSelector = [
            { scheme: 'file', language: 'c' },
            { scheme: 'file', language: 'cpp' },
            { scheme: 'file', language: 'cuda-cpp' }
        ];
        this.model = new ClientModel();
        this.registeredProviders = [];
        this.doneInitialCustomBrowseConfigurationCheck = false;
        this.browseConfigurationLogging = "";
        this.configurationLogging = new Map();
        this.rootFolder = workspaceFolder;
        this.rootRealPath = this.RootPath ? (fs.existsSync(this.RootPath) ? fs.realpathSync(this.RootPath) : this.RootPath) : "";
        let storagePath;
        if (util.extensionContext) {
            const path = (_a = util.extensionContext.storageUri) === null || _a === void 0 ? void 0 : _a.fsPath;
            if (path) {
                storagePath = path;
            }
        }
        if (!storagePath) {
            storagePath = this.RootPath ? path.join(this.RootPath, "/.vscode") : "";
        }
        if (workspaceFolder && vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 1) {
            storagePath = path.join(storagePath, util.getUniqueWorkspaceStorageName(workspaceFolder));
        }
        this.storagePath = storagePath;
        const rootUri = this.RootUri;
        this.settingsTracker = (0, settingsTracker_1.getTracker)(rootUri);
        try {
            let firstClient = false;
            if (!languageClient || languageClientCrashedNeedsRestart) {
                if (languageClientCrashedNeedsRestart) {
                    languageClientCrashedNeedsRestart = false;
                }
                languageClient = this.createLanguageClient(allClients);
                clientCollection = allClients;
                languageClient.registerProposedFeatures();
                languageClient.start();
                util.setProgress(util.getProgressExecutableStarted());
                firstClient = true;
            }
            ui = (0, ui_1.getUI)();
            ui.bind(this);
            this.queueBlockingTask(() => __awaiter(this, void 0, void 0, function* () {
                yield languageClient.onReady();
                try {
                    const workspaceFolder = this.rootFolder;
                    this.innerConfiguration = new configs.CppProperties(rootUri, workspaceFolder);
                    this.innerConfiguration.ConfigurationsChanged((e) => this.onConfigurationsChanged(e));
                    this.innerConfiguration.SelectionChanged((e) => this.onSelectedConfigurationChanged(e));
                    this.innerConfiguration.CompileCommandsChanged((e) => this.onCompileCommandsChanged(e));
                    this.disposables.push(this.innerConfiguration);
                    this.innerLanguageClient = languageClient;
                    telemetry.logLanguageServerEvent("NonDefaultInitialCppSettings", this.settingsTracker.getUserModifiedSettings());
                    failureMessageShown = false;
                    class CodeActionProvider {
                        constructor(client) {
                            this.client = client;
                        }
                        provideCodeActions(document, range, context, token) {
                            return __awaiter(this, void 0, void 0, function* () {
                                return this.client.requestWhenReady(() => __awaiter(this, void 0, void 0, function* () {
                                    let r;
                                    if (range instanceof vscode.Selection) {
                                        if (range.active.isBefore(range.anchor)) {
                                            r = vscode_languageclient_1.Range.create(vscode_languageclient_1.Position.create(range.active.line, range.active.character), vscode_languageclient_1.Position.create(range.anchor.line, range.anchor.character));
                                        }
                                        else {
                                            r = vscode_languageclient_1.Range.create(vscode_languageclient_1.Position.create(range.anchor.line, range.anchor.character), vscode_languageclient_1.Position.create(range.active.line, range.active.character));
                                        }
                                    }
                                    else {
                                        r = vscode_languageclient_1.Range.create(vscode_languageclient_1.Position.create(range.start.line, range.start.character), vscode_languageclient_1.Position.create(range.end.line, range.end.character));
                                    }
                                    const params = {
                                        range: r,
                                        uri: document.uri.toString()
                                    };
                                    const commands = yield this.client.languageClient.sendRequest(GetCodeActionsRequest, params);
                                    const resultCodeActions = [];
                                    commands.forEach((command) => {
                                        const title = util.getLocalizedString(command.localizeStringParams);
                                        let edit;
                                        if (command.edit) {
                                            edit = new vscode.WorkspaceEdit();
                                            edit.replace(document.uri, new vscode.Range(new vscode.Position(command.edit.range.start.line, command.edit.range.start.character), new vscode.Position(command.edit.range.end.line, command.edit.range.end.character)), command.edit.newText);
                                        }
                                        const vscodeCodeAction = {
                                            title: title,
                                            command: command.command === "edit" ? undefined : {
                                                title: title,
                                                command: command.command,
                                                arguments: command.arguments
                                            },
                                            edit: edit,
                                            kind: edit === undefined ? vscode.CodeActionKind.QuickFix : vscode.CodeActionKind.RefactorInline
                                        };
                                        resultCodeActions.push(vscodeCodeAction);
                                    });
                                    return resultCodeActions;
                                }));
                            });
                        }
                    }
                    const tokenTypesLegend = [];
                    for (const e in SemanticTokenTypes) {
                        if (isNaN(Number(e))) {
                            tokenTypesLegend.push(e);
                        }
                    }
                    const tokenModifiersLegend = [];
                    for (const e in SemanticTokenModifiers) {
                        if (isNaN(Number(e))) {
                            tokenModifiersLegend.push(e);
                        }
                    }
                    this.semanticTokensLegend = new vscode.SemanticTokensLegend(tokenTypesLegend, tokenModifiersLegend);
                    if (firstClient) {
                        exports.workspaceReferences = new refs.ReferencesManager(this);
                        const inputCompilerDefaults = yield languageClient.sendRequest(QueryCompilerDefaultsRequest, {});
                        compilerDefaults = inputCompilerDefaults;
                        this.configuration.CompilerDefaults = compilerDefaults;
                        (0, extension_1.registerCommands)();
                        this.registerFileWatcher();
                        this.disposables.push(vscode.languages.registerRenameProvider(this.documentSelector, new renameProvider_1.RenameProvider(this)));
                        this.disposables.push(vscode.languages.registerReferenceProvider(this.documentSelector, new findAllReferencesProvider_1.FindAllReferencesProvider(this)));
                        this.disposables.push(vscode.languages.registerWorkspaceSymbolProvider(new workspaceSymbolProvider_1.WorkspaceSymbolProvider(this)));
                        this.disposables.push(vscode.languages.registerDocumentSymbolProvider(this.documentSelector, new documentSymbolProvider_1.DocumentSymbolProvider(this), undefined));
                        this.disposables.push(vscode.languages.registerCodeActionsProvider(this.documentSelector, new CodeActionProvider(this), undefined));
                        const settings = new settings_1.CppSettings();
                        if (settings.formattingEngine !== "Disabled") {
                            this.documentFormattingProviderDisposable = vscode.languages.registerDocumentFormattingEditProvider(this.documentSelector, new documentFormattingEditProvider_1.DocumentFormattingEditProvider(this));
                            this.formattingRangeProviderDisposable = vscode.languages.registerDocumentRangeFormattingEditProvider(this.documentSelector, new documentRangeFormattingEditProvider_1.DocumentRangeFormattingEditProvider(this));
                            this.onTypeFormattingProviderDisposable = vscode.languages.registerOnTypeFormattingEditProvider(this.documentSelector, new onTypeFormattingEditProvider_1.OnTypeFormattingEditProvider(this), ";", "}", "\n");
                        }
                        if (settings.codeFolding) {
                            this.codeFoldingProvider = new foldingRangeProvider_1.FoldingRangeProvider(this);
                            this.codeFoldingProviderDisposable = vscode.languages.registerFoldingRangeProvider(this.documentSelector, this.codeFoldingProvider);
                        }
                        if (settings.enhancedColorization && this.semanticTokensLegend) {
                            this.semanticTokensProvider = new semanticTokensProvider_1.SemanticTokensProvider(this);
                            this.semanticTokensProviderDisposable = vscode.languages.registerDocumentSemanticTokensProvider(this.documentSelector, this.semanticTokensProvider, this.semanticTokensLegend);
                        }
                        this.registerNotifications();
                    }
                    else {
                        this.configuration.CompilerDefaults = compilerDefaults;
                    }
                }
                catch (err) {
                    this.isSupported = false;
                    if (!failureMessageShown) {
                        failureMessageShown = true;
                        vscode.window.showErrorMessage(localize(2, null, String(err)));
                    }
                }
            }));
        }
        catch (errJS) {
            const err = errJS;
            this.isSupported = false;
            if (!failureMessageShown) {
                failureMessageShown = true;
                let additionalInfo;
                if (err.code === "EPERM") {
                    additionalInfo = localize(3, null, getLanguageServerFileName());
                }
                else {
                    additionalInfo = String(err);
                }
                vscode.window.showErrorMessage(localize(4, null, additionalInfo));
            }
        }
    }
    get ParsingWorkspaceChanged() { return this.model.isParsingWorkspace.ValueChanged; }
    get ParsingWorkspacePausableChanged() { return this.model.isParsingWorkspacePausable.ValueChanged; }
    get ParsingWorkspacePausedChanged() { return this.model.isParsingWorkspacePaused.ValueChanged; }
    get ParsingFilesChanged() { return this.model.isParsingFiles.ValueChanged; }
    get IntelliSenseParsingChanged() { return this.model.isUpdatingIntelliSense.ValueChanged; }
    get RunningCodeAnalysisChanged() { return this.model.isRunningCodeAnalysis.ValueChanged; }
    get CodeAnalysisPausedChanged() { return this.model.isCodeAnalysisPaused.ValueChanged; }
    get CodeAnalysisProcessedChanged() { return this.model.codeAnalysisProcessed.ValueChanged; }
    get CodeAnalysisTotalChanged() { return this.model.codeAnalysisTotal.ValueChanged; }
    get ReferencesCommandModeChanged() { return this.model.referencesCommandMode.ValueChanged; }
    get TagParserStatusChanged() { return this.model.parsingWorkspaceStatus.ValueChanged; }
    get ActiveConfigChanged() { return this.model.activeConfigName.ValueChanged; }
    get RootPath() {
        return (this.rootFolder) ? this.rootFolder.uri.fsPath : "";
    }
    get RootRealPath() {
        return this.rootRealPath;
    }
    get RootUri() {
        return (this.rootFolder) ? this.rootFolder.uri : undefined;
    }
    get RootFolder() {
        return this.rootFolder;
    }
    get Name() {
        return this.getName(this.rootFolder);
    }
    get TrackedDocuments() {
        return this.trackedDocuments;
    }
    get IsTagParsing() {
        return this.model.isParsingWorkspace.Value || this.model.isParsingFiles.Value;
    }
    get ReferencesCommandMode() {
        return this.model.referencesCommandMode.Value;
    }
    get languageClient() {
        if (!this.innerLanguageClient) {
            throw new Error("Attempting to use languageClient before initialized");
        }
        return this.innerLanguageClient;
    }
    get configuration() {
        if (!this.innerConfiguration) {
            throw new Error("Attempting to use configuration before initialized");
        }
        return this.innerConfiguration;
    }
    get AdditionalEnvironment() {
        return {
            workspaceFolderBasename: this.Name,
            workspaceStorage: this.storagePath,
            execPath: process.execPath,
            pathSeparator: (os.platform() === 'win32') ? "\\" : "/"
        };
    }
    getName(workspaceFolder) {
        return workspaceFolder ? workspaceFolder.name : "untitled";
    }
    sendFindAllReferencesNotification(params) {
        this.languageClient.sendNotification(FindAllReferencesNotification, params);
    }
    sendRenameNofication(params) {
        this.languageClient.sendNotification(RenameNotification, params);
    }
    createLanguageClient(allClients) {
        const serverModule = getLanguageServerFileName();
        const exeExists = fs.existsSync(serverModule);
        if (!exeExists) {
            telemetry.logLanguageServerEvent("missingLanguageServerBinary");
            throw String('Missing binary at ' + serverModule);
        }
        const serverName = this.getName(this.rootFolder);
        const serverOptions = {
            run: { command: serverModule },
            debug: { command: serverModule, args: [serverName] }
        };
        const settings_clangFormatPath = [];
        const settings_clangFormatStyle = [];
        const settings_clangFormatFallbackStyle = [];
        const settings_clangFormatSortIncludes = [];
        const settings_codeAnalysisExclude = [];
        const settings_codeAnalysisRunAutomatically = [];
        const settings_clangTidyEnabled = [];
        const settings_clangTidyPath = [];
        const settings_clangTidyConfig = [];
        const settings_clangTidyFallbackConfig = [];
        const settings_clangTidyFixWarnings = [];
        const settings_clangTidyFixErrors = [];
        const settings_clangTidyFixNotes = [];
        const settings_clangTidyHeaderFilter = [];
        const settings_clangTidyArgs = [];
        const settings_clangTidyChecksEnabled = [];
        const settings_clangTidyChecksDisabled = [];
        const settings_filesEncoding = [];
        const settings_cppFilesExclude = [];
        const settings_filesExclude = [];
        const settings_filesAutoSaveAfterDelay = [];
        const settings_searchExclude = [];
        const settings_editorAutoClosingBrackets = [];
        const settings_intelliSenseEngine = [];
        const settings_intelliSenseEngineFallback = [];
        const settings_errorSquiggles = [];
        const settings_dimInactiveRegions = [];
        const settings_enhancedColorization = [];
        const settings_suggestSnippets = [];
        const settings_exclusionPolicy = [];
        const settings_preferredPathSeparator = [];
        const settings_defaultSystemIncludePath = [];
        const settings_intelliSenseCachePath = [];
        const settings_intelliSenseCacheSize = [];
        const settings_intelliSenseMemoryLimit = [];
        const settings_autocomplete = [];
        const settings_autocompleteAddParentheses = [];
        const workspaceSettings = new settings_1.CppSettings();
        const workspaceOtherSettings = new settings_1.OtherSettings();
        const settings_indentBraces = [];
        const settings_indentMultiLine = [];
        const settings_indentWithinParentheses = [];
        const settings_indentPreserveWithinParentheses = [];
        const settings_indentCaseLabels = [];
        const settings_indentCaseContents = [];
        const settings_indentCaseContentsWhenBlock = [];
        const settings_indentLambdaBracesWhenParameter = [];
        const settings_indentGotoLabels = [];
        const settings_indentPreprocessor = [];
        const settings_indentAccessSpecifiers = [];
        const settings_indentNamespaceContents = [];
        const settings_indentPreserveComments = [];
        const settings_newLineBeforeOpenBraceNamespace = [];
        const settings_newLineBeforeOpenBraceType = [];
        const settings_newLineBeforeOpenBraceFunction = [];
        const settings_newLineBeforeOpenBraceBlock = [];
        const settings_newLineBeforeOpenBraceLambda = [];
        const settings_newLineScopeBracesOnSeparateLines = [];
        const settings_newLineCloseBraceSameLineEmptyType = [];
        const settings_newLineCloseBraceSameLineEmptyFunction = [];
        const settings_newLineBeforeCatch = [];
        const settings_newLineBeforeElse = [];
        const settings_newLineBeforeWhileInDoWhile = [];
        const settings_spaceBeforeFunctionOpenParenthesis = [];
        const settings_spaceWithinParameterListParentheses = [];
        const settings_spaceBetweenEmptyParameterListParentheses = [];
        const settings_spaceAfterKeywordsInControlFlowStatements = [];
        const settings_spaceWithinControlFlowStatementParentheses = [];
        const settings_spaceBeforeLambdaOpenParenthesis = [];
        const settings_spaceWithinCastParentheses = [];
        const settings_spaceSpaceAfterCastCloseParenthesis = [];
        const settings_spaceWithinExpressionParentheses = [];
        const settings_spaceBeforeBlockOpenBrace = [];
        const settings_spaceBetweenEmptyBraces = [];
        const settings_spaceBeforeInitializerListOpenBrace = [];
        const settings_spaceWithinInitializerListBraces = [];
        const settings_spacePreserveInInitializerList = [];
        const settings_spaceBeforeOpenSquareBracket = [];
        const settings_spaceWithinSquareBrackets = [];
        const settings_spaceBeforeEmptySquareBrackets = [];
        const settings_spaceBetweenEmptySquareBrackets = [];
        const settings_spaceGroupSquareBrackets = [];
        const settings_spaceWithinLambdaBrackets = [];
        const settings_spaceBetweenEmptyLambdaBrackets = [];
        const settings_spaceBeforeComma = [];
        const settings_spaceAfterComma = [];
        const settings_spaceRemoveAroundMemberOperators = [];
        const settings_spaceBeforeInheritanceColon = [];
        const settings_spaceBeforeConstructorColon = [];
        const settings_spaceRemoveBeforeSemicolon = [];
        const settings_spaceInsertAfterSemicolon = [];
        const settings_spaceRemoveAroundUnaryOperator = [];
        const settings_spaceAroundBinaryOperator = [];
        const settings_spaceAroundAssignmentOperator = [];
        const settings_spacePointerReferenceAlignment = [];
        const settings_spaceAroundTernaryOperator = [];
        const settings_wrapPreserveBlocks = [];
        {
            const settings = [];
            const otherSettings = [];
            if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
                for (const workspaceFolder of vscode.workspace.workspaceFolders) {
                    settings.push(new settings_1.CppSettings(workspaceFolder.uri));
                    otherSettings.push(new settings_1.OtherSettings(workspaceFolder.uri));
                }
            }
            else {
                settings.push(workspaceSettings);
                otherSettings.push(workspaceOtherSettings);
            }
            for (const setting of settings) {
                settings_clangFormatPath.push(util.resolveVariables(setting.clangFormatPath, this.AdditionalEnvironment));
                settings_codeAnalysisExclude.push(setting.codeAnalysisExclude);
                settings_codeAnalysisRunAutomatically.push(setting.codeAnalysisRunAutomatically);
                settings_clangTidyEnabled.push(setting.clangTidyEnabled);
                settings_clangTidyPath.push(util.resolveVariables(setting.clangTidyPath, this.AdditionalEnvironment));
                settings_clangTidyConfig.push(setting.clangTidyConfig);
                settings_clangTidyFallbackConfig.push(setting.clangTidyFallbackConfig);
                settings_clangTidyFixWarnings.push(setting.clangTidyFixWarnings);
                settings_clangTidyFixErrors.push(setting.clangTidyFixErrors);
                settings_clangTidyFixNotes.push(setting.clangTidyFixNotes);
                settings_clangTidyHeaderFilter.push(setting.clangTidyHeaderFilter);
                settings_clangTidyArgs.push(setting.clangTidyArgs);
                settings_clangTidyChecksEnabled.push(setting.clangTidyChecksEnabled);
                settings_clangTidyChecksDisabled.push(setting.clangTidyChecksDisabled);
                settings_indentBraces.push(setting.vcFormatIndentBraces);
                settings_indentWithinParentheses.push(setting.vcFormatIndentWithinParentheses);
                settings_indentPreserveWithinParentheses.push(setting.vcFormatIndentPreserveWithinParentheses);
                settings_indentMultiLine.push(setting.vcFormatIndentMultiLineRelativeTo);
                settings_indentCaseLabels.push(setting.vcFormatIndentCaseLabels);
                settings_indentCaseContents.push(setting.vcFormatIndentCaseContents);
                settings_indentCaseContentsWhenBlock.push(setting.vcFormatIndentCaseContentsWhenBlock);
                settings_indentLambdaBracesWhenParameter.push(setting.vcFormatIndentLambdaBracesWhenParameter);
                settings_indentGotoLabels.push(setting.vcFormatIndentGotoLables);
                settings_indentPreprocessor.push(setting.vcFormatIndentPreprocessor);
                settings_indentAccessSpecifiers.push(setting.vcFormatIndentAccessSpecifiers);
                settings_indentNamespaceContents.push(setting.vcFormatIndentNamespaceContents);
                settings_indentPreserveComments.push(setting.vcFormatIndentPreserveComments);
                settings_newLineBeforeOpenBraceNamespace.push(setting.vcFormatNewlineBeforeOpenBraceNamespace);
                settings_newLineBeforeOpenBraceType.push(setting.vcFormatNewlineBeforeOpenBraceType);
                settings_newLineBeforeOpenBraceFunction.push(setting.vcFormatNewlineBeforeOpenBraceFunction);
                settings_newLineBeforeOpenBraceBlock.push(setting.vcFormatNewlineBeforeOpenBraceBlock);
                settings_newLineScopeBracesOnSeparateLines.push(setting.vcFormatNewlineScopeBracesOnSeparateLines);
                settings_newLineBeforeOpenBraceLambda.push(setting.vcFormatNewlineBeforeOpenBraceLambda);
                settings_newLineCloseBraceSameLineEmptyType.push(setting.vcFormatNewlineCloseBraceSameLineEmptyType);
                settings_newLineCloseBraceSameLineEmptyFunction.push(setting.vcFormatNewlineCloseBraceSameLineEmptyFunction);
                settings_newLineBeforeCatch.push(setting.vcFormatNewlineBeforeCatch);
                settings_newLineBeforeElse.push(setting.vcFormatNewlineBeforeElse);
                settings_newLineBeforeWhileInDoWhile.push(setting.vcFormatNewlineBeforeWhileInDoWhile);
                settings_spaceBeforeFunctionOpenParenthesis.push(setting.vcFormatSpaceBeforeFunctionOpenParenthesis);
                settings_spaceWithinParameterListParentheses.push(setting.vcFormatSpaceWithinParameterListParentheses);
                settings_spaceBetweenEmptyParameterListParentheses.push(setting.vcFormatSpaceBetweenEmptyParameterListParentheses);
                settings_spaceAfterKeywordsInControlFlowStatements.push(setting.vcFormatSpaceAfterKeywordsInControlFlowStatements);
                settings_spaceWithinControlFlowStatementParentheses.push(setting.vcFormatSpaceWithinControlFlowStatementParentheses);
                settings_spaceBeforeLambdaOpenParenthesis.push(setting.vcFormatSpaceBeforeLambdaOpenParenthesis);
                settings_spaceWithinCastParentheses.push(setting.vcFormatSpaceWithinCastParentheses);
                settings_spaceSpaceAfterCastCloseParenthesis.push(setting.vcFormatSpaceAfterCastCloseParenthesis);
                settings_spaceWithinExpressionParentheses.push(setting.vcFormatSpaceWithinExpressionParentheses);
                settings_spaceBeforeBlockOpenBrace.push(setting.vcFormatSpaceBeforeBlockOpenBrace);
                settings_spaceBetweenEmptyBraces.push(setting.vcFormatSpaceBetweenEmptyBraces);
                settings_spaceBeforeInitializerListOpenBrace.push(setting.vcFormatSpaceBeforeInitializerListOpenBrace);
                settings_spaceWithinInitializerListBraces.push(setting.vcFormatSpaceWithinInitializerListBraces);
                settings_spacePreserveInInitializerList.push(setting.vcFormatSpacePreserveInInitializerList);
                settings_spaceBeforeOpenSquareBracket.push(setting.vcFormatSpaceBeforeOpenSquareBracket);
                settings_spaceWithinSquareBrackets.push(setting.vcFormatSpaceWithinSquareBrackets);
                settings_spaceBeforeEmptySquareBrackets.push(setting.vcFormatSpaceBeforeEmptySquareBrackets);
                settings_spaceBetweenEmptySquareBrackets.push(setting.vcFormatSpaceBetweenEmptySquareBrackets);
                settings_spaceGroupSquareBrackets.push(setting.vcFormatSpaceGroupSquareBrackets);
                settings_spaceWithinLambdaBrackets.push(setting.vcFormatSpaceWithinLambdaBrackets);
                settings_spaceBetweenEmptyLambdaBrackets.push(setting.vcFormatSpaceBetweenEmptyLambdaBrackets);
                settings_spaceBeforeComma.push(setting.vcFormatSpaceBeforeComma);
                settings_spaceAfterComma.push(setting.vcFormatSpaceAfterComma);
                settings_spaceRemoveAroundMemberOperators.push(setting.vcFormatSpaceRemoveAroundMemberOperators);
                settings_spaceBeforeInheritanceColon.push(setting.vcFormatSpaceBeforeInheritanceColon);
                settings_spaceBeforeConstructorColon.push(setting.vcFormatSpaceBeforeConstructorColon);
                settings_spaceRemoveBeforeSemicolon.push(setting.vcFormatSpaceRemoveBeforeSemicolon);
                settings_spaceInsertAfterSemicolon.push(setting.vcFormatSpaceInsertAfterSemicolon);
                settings_spaceRemoveAroundUnaryOperator.push(setting.vcFormatSpaceRemoveAroundUnaryOperator);
                settings_spaceAroundBinaryOperator.push(setting.vcFormatSpaceAroundBinaryOperator);
                settings_spaceAroundAssignmentOperator.push(setting.vcFormatSpaceAroundAssignmentOperator);
                settings_spacePointerReferenceAlignment.push(setting.vcFormatSpacePointerReferenceAlignment);
                settings_spaceAroundTernaryOperator.push(setting.vcFormatSpaceAroundTernaryOperator);
                settings_wrapPreserveBlocks.push(setting.vcFormatWrapPreserveBlocks);
                settings_clangFormatStyle.push(setting.clangFormatStyle);
                settings_clangFormatFallbackStyle.push(setting.clangFormatFallbackStyle);
                settings_clangFormatSortIncludes.push(setting.clangFormatSortIncludes);
                settings_intelliSenseEngine.push(setting.intelliSenseEngine);
                settings_intelliSenseEngineFallback.push(setting.intelliSenseEngineFallback);
                settings_errorSquiggles.push(setting.errorSquiggles);
                settings_dimInactiveRegions.push(setting.dimInactiveRegions);
                settings_enhancedColorization.push(workspaceSettings.enhancedColorization ? "Enabled" : "Disabled");
                settings_suggestSnippets.push(setting.suggestSnippets);
                settings_exclusionPolicy.push(setting.exclusionPolicy);
                settings_preferredPathSeparator.push(setting.preferredPathSeparator);
                settings_defaultSystemIncludePath.push(setting.defaultSystemIncludePath);
                settings_intelliSenseCachePath.push(util.resolveCachePath(setting.intelliSenseCachePath, this.AdditionalEnvironment));
                settings_intelliSenseCacheSize.push(setting.intelliSenseCacheSize);
                settings_intelliSenseMemoryLimit.push(setting.intelliSenseMemoryLimit);
                settings_autocomplete.push(setting.autocomplete);
                settings_autocompleteAddParentheses.push(setting.autocompleteAddParentheses);
                settings_cppFilesExclude.push(setting.filesExclude);
            }
            for (const otherSetting of otherSettings) {
                settings_filesEncoding.push(otherSetting.filesEncoding);
                settings_filesExclude.push(otherSetting.filesExclude);
                settings_filesAutoSaveAfterDelay.push(otherSetting.filesAutoSaveAfterDelay);
                settings_searchExclude.push(otherSetting.searchExclude);
                settings_editorAutoClosingBrackets.push(otherSetting.editorAutoClosingBrackets);
            }
        }
        let intelliSenseCacheDisabled = false;
        if (os.platform() === "darwin") {
            const releaseParts = os.release().split(".");
            if (releaseParts.length >= 1) {
                intelliSenseCacheDisabled = parseInt(releaseParts[0]) < 17;
            }
        }
        const localizedStrings = [];
        for (let i = 0; i < nativeStrings_1.localizedStringCount; i++) {
            localizedStrings.push((0, nativeStrings_1.lookupString)(i));
        }
        const clientOptions = {
            documentSelector: [
                { scheme: 'file', language: 'c' },
                { scheme: 'file', language: 'cpp' },
                { scheme: 'file', language: 'cuda-cpp' }
            ],
            initializationOptions: {
                freeMemory: os.freemem() / 1048576,
                maxConcurrentThreads: workspaceSettings.maxConcurrentThreads,
                maxCachedProcesses: workspaceSettings.maxCachedProcesses,
                maxMemory: workspaceSettings.maxMemory,
                intelliSense: {
                    maxCachedProcesses: workspaceSettings.intelliSenseMaxCachedProcesses,
                    maxMemory: workspaceSettings.intelliSenseMaxMemory
                },
                references: {
                    maxConcurrentThreads: workspaceSettings.referencesMaxConcurrentThreads,
                    maxCachedProcesses: workspaceSettings.referencesMaxCachedProcesses,
                    maxMemory: workspaceSettings.referencesMaxMemory
                },
                codeAnalysis: {
                    maxConcurrentThreads: workspaceSettings.codeAnalysisMaxConcurrentThreads,
                    maxMemory: workspaceSettings.codeAnalysisMaxMemory,
                    updateDelay: workspaceSettings.codeAnalysisUpdateDelay,
                    exclude: settings_codeAnalysisExclude,
                    runAutomatically: settings_codeAnalysisRunAutomatically,
                    clangTidy: {
                        enabled: settings_clangTidyEnabled,
                        path: settings_clangTidyPath,
                        config: settings_clangTidyConfig,
                        fallbackConfig: settings_clangTidyFallbackConfig,
                        fix: {
                            warnings: settings_clangTidyFixWarnings,
                            errors: settings_clangTidyFixErrors,
                            notes: settings_clangTidyFixNotes
                        },
                        headerFilter: settings_clangTidyHeaderFilter,
                        args: settings_clangTidyArgs,
                        checks: {
                            enabled: settings_clangTidyChecksEnabled,
                            disabled: settings_clangTidyChecksDisabled
                        }
                    }
                },
                clang_format_path: settings_clangFormatPath,
                clang_format_style: settings_clangFormatStyle,
                vcFormat: {
                    indent: {
                        braces: settings_indentBraces,
                        multiLineRelativeTo: settings_indentMultiLine,
                        withinParentheses: settings_indentWithinParentheses,
                        preserveWithinParentheses: settings_indentPreserveWithinParentheses,
                        caseLabels: settings_indentCaseLabels,
                        caseContents: settings_indentCaseContents,
                        caseContentsWhenBlock: settings_indentCaseContentsWhenBlock,
                        lambdaBracesWhenParameter: settings_indentLambdaBracesWhenParameter,
                        gotoLabels: settings_indentGotoLabels,
                        preprocessor: settings_indentPreprocessor,
                        accesSpecifiers: settings_indentAccessSpecifiers,
                        namespaceContents: settings_indentNamespaceContents,
                        preserveComments: settings_indentPreserveComments
                    },
                    newLine: {
                        beforeOpenBrace: {
                            namespace: settings_newLineBeforeOpenBraceNamespace,
                            type: settings_newLineBeforeOpenBraceType,
                            function: settings_newLineBeforeOpenBraceFunction,
                            block: settings_newLineBeforeOpenBraceBlock,
                            lambda: settings_newLineBeforeOpenBraceLambda
                        },
                        scopeBracesOnSeparateLines: settings_newLineScopeBracesOnSeparateLines,
                        closeBraceSameLine: {
                            emptyType: settings_newLineCloseBraceSameLineEmptyType,
                            emptyFunction: settings_newLineCloseBraceSameLineEmptyFunction
                        },
                        beforeCatch: settings_newLineBeforeCatch,
                        beforeElse: settings_newLineBeforeElse,
                        beforeWhileInDoWhile: settings_newLineBeforeWhileInDoWhile
                    },
                    space: {
                        beforeFunctionOpenParenthesis: settings_spaceBeforeFunctionOpenParenthesis,
                        withinParameterListParentheses: settings_spaceWithinParameterListParentheses,
                        betweenEmptyParameterListParentheses: settings_spaceBetweenEmptyParameterListParentheses,
                        afterKeywordsInControlFlowStatements: settings_spaceAfterKeywordsInControlFlowStatements,
                        withinControlFlowStatementParentheses: settings_spaceWithinControlFlowStatementParentheses,
                        beforeLambdaOpenParenthesis: settings_spaceBeforeLambdaOpenParenthesis,
                        withinCastParentheses: settings_spaceWithinCastParentheses,
                        afterCastCloseParenthesis: settings_spaceSpaceAfterCastCloseParenthesis,
                        withinExpressionParentheses: settings_spaceWithinExpressionParentheses,
                        beforeBlockOpenBrace: settings_spaceBeforeBlockOpenBrace,
                        betweenEmptyBraces: settings_spaceBetweenEmptyBraces,
                        beforeInitializerListOpenBrace: settings_spaceBeforeInitializerListOpenBrace,
                        withinInitializerListBraces: settings_spaceWithinInitializerListBraces,
                        preserveInInitializerList: settings_spacePreserveInInitializerList,
                        beforeOpenSquareBracket: settings_spaceBeforeOpenSquareBracket,
                        withinSquareBrackets: settings_spaceWithinSquareBrackets,
                        beforeEmptySquareBrackets: settings_spaceBeforeEmptySquareBrackets,
                        betweenEmptySquareBrackets: settings_spaceBetweenEmptySquareBrackets,
                        groupSquareBrackets: settings_spaceGroupSquareBrackets,
                        withinLambdaBrackets: settings_spaceWithinLambdaBrackets,
                        betweenEmptyLambdaBrackets: settings_spaceBetweenEmptyLambdaBrackets,
                        beforeComma: settings_spaceBeforeComma,
                        afterComma: settings_spaceAfterComma,
                        removeAroundMemberOperators: settings_spaceRemoveAroundMemberOperators,
                        beforeInheritanceColon: settings_spaceBeforeInheritanceColon,
                        beforeConstructorColon: settings_spaceBeforeConstructorColon,
                        removeBeforeSemicolon: settings_spaceRemoveBeforeSemicolon,
                        insertAfterSemicolon: settings_spaceInsertAfterSemicolon,
                        removeAroundUnaryOperator: settings_spaceRemoveAroundUnaryOperator,
                        aroundBinaryOperator: settings_spaceAroundBinaryOperator,
                        aroundAssignmentOperator: settings_spaceAroundAssignmentOperator,
                        pointerReferenceAlignment: settings_spacePointerReferenceAlignment,
                        aroundTernaryOperator: settings_spaceAroundTernaryOperator
                    },
                    wrap: {
                        preserveBlocks: settings_wrapPreserveBlocks
                    }
                },
                clang_format_fallbackStyle: settings_clangFormatFallbackStyle,
                clang_format_sortIncludes: settings_clangFormatSortIncludes,
                extension_path: util.extensionPath,
                files: {
                    encoding: settings_filesEncoding,
                    autoSaveAfterDelay: settings_filesAutoSaveAfterDelay
                },
                editor: {
                    autoClosingBrackets: settings_editorAutoClosingBrackets
                },
                workspace_fallback_encoding: workspaceOtherSettings.filesEncoding,
                cpp_exclude_files: settings_cppFilesExclude,
                exclude_files: settings_filesExclude,
                exclude_search: settings_searchExclude,
                associations: workspaceOtherSettings.filesAssociations,
                storage_path: this.storagePath,
                intelliSenseEngine: settings_intelliSenseEngine,
                intelliSenseEngineFallback: settings_intelliSenseEngineFallback,
                intelliSenseCacheDisabled: intelliSenseCacheDisabled,
                intelliSenseCachePath: settings_intelliSenseCachePath,
                intelliSenseCacheSize: settings_intelliSenseCacheSize,
                intelliSenseMemoryLimit: settings_intelliSenseMemoryLimit,
                intelliSenseUpdateDelay: workspaceSettings.intelliSenseUpdateDelay,
                autocomplete: settings_autocomplete,
                autocompleteAddParentheses: settings_autocompleteAddParentheses,
                errorSquiggles: settings_errorSquiggles,
                dimInactiveRegions: settings_dimInactiveRegions,
                enhancedColorization: settings_enhancedColorization,
                suggestSnippets: settings_suggestSnippets,
                simplifyStructuredComments: workspaceSettings.simplifyStructuredComments,
                loggingLevel: workspaceSettings.loggingLevel,
                workspaceParsingPriority: workspaceSettings.workspaceParsingPriority,
                workspaceSymbols: workspaceSettings.workspaceSymbols,
                exclusionPolicy: settings_exclusionPolicy,
                preferredPathSeparator: settings_preferredPathSeparator,
                default: {
                    systemIncludePath: settings_defaultSystemIncludePath
                },
                vcpkg_root: util.getVcpkgRoot(),
                experimentalFeatures: workspaceSettings.experimentalFeatures,
                edgeMessagesDirectory: path.join(util.getExtensionFilePath("bin"), "messages", util.getLocaleId()),
                localizedStrings: localizedStrings,
                packageVersion: util.packageJson.version
            },
            middleware: (0, protocolFilter_1.createProtocolFilter)(allClients),
            errorHandler: {
                error: () => vscode_languageclient_1.ErrorAction.Continue,
                closed: () => {
                    languageClientCrashTimes.push(Date.now());
                    languageClientCrashedNeedsRestart = true;
                    telemetry.logLanguageServerEvent("languageClientCrash");
                    if (languageClientCrashTimes.length < 5) {
                        allClients.forEach(client => { allClients.replace(client, true); });
                    }
                    else {
                        const elapsed = languageClientCrashTimes[languageClientCrashTimes.length - 1] - languageClientCrashTimes[0];
                        if (elapsed <= 3 * 60 * 1000) {
                            vscode.window.showErrorMessage(localize(5, null));
                            allClients.forEach(client => { allClients.replace(client, false); });
                        }
                        else {
                            languageClientCrashTimes.shift();
                            allClients.forEach(client => { allClients.replace(client, true); });
                        }
                    }
                    return vscode_languageclient_1.CloseAction.DoNotRestart;
                }
            }
        };
        this.loggingLevel = clientOptions.initializationOptions.loggingLevel;
        return new vscode_languageclient_1.LanguageClient(`cpptools`, serverOptions, clientOptions);
    }
    sendAllSettings() {
        const cppSettingsScoped = {};
        {
            const cppSettingsResourceScoped = vscode.workspace.getConfiguration("C_Cpp", this.RootUri);
            const cppSettingsNonScoped = vscode.workspace.getConfiguration("C_Cpp");
            for (const key in cppSettingsResourceScoped) {
                const curSetting = util.packageJson.contributes.configuration.properties["C_Cpp." + key];
                if (curSetting === undefined) {
                    continue;
                }
                const settings = (curSetting.scope === "resource" || curSetting.scope === "machine-overridable") ? cppSettingsResourceScoped : cppSettingsNonScoped;
                cppSettingsScoped[key] = settings.get(key);
            }
            cppSettingsScoped["default"] = { systemIncludePath: cppSettingsResourceScoped.get("default.systemIncludePath") };
        }
        const otherSettingsFolder = new settings_1.OtherSettings(this.RootUri);
        const otherSettingsWorkspace = new settings_1.OtherSettings();
        const clangTidyConfig = vscode.workspace.getConfiguration("C_Cpp.codeAnalysis.clangTidy", this.RootUri);
        const settings = {
            C_Cpp: Object.assign(Object.assign({}, cppSettingsScoped), { clang_format_path: util.resolveVariables(cppSettingsScoped.clang_format_path, this.AdditionalEnvironment), intelliSenseCachePath: util.resolveCachePath(cppSettingsScoped.intelliSenseCachePath, this.AdditionalEnvironment), codeAnalysis: Object.assign(Object.assign({}, vscode.workspace.getConfiguration("C_Cpp.codeAnalysis", this.RootUri)), { clangTidy: Object.assign(Object.assign({}, clangTidyConfig), { path: util.resolveVariables(clangTidyConfig.path, this.AdditionalEnvironment), fix: Object.assign({}, vscode.workspace.getConfiguration("C_Cpp.codeAnalysis.clangTidy.fix", this.RootUri)), checks: Object.assign({}, vscode.workspace.getConfiguration("C_Cpp.codeAnalysis.clangTidy.checks", this.RootUri)) }) }), files: {
                    exclude: vscode.workspace.getConfiguration("C_Cpp.files.exclude", this.RootUri)
                }, intelliSense: Object.assign({}, vscode.workspace.getConfiguration("C_Cpp.intelliSense", this.RootUri)), references: Object.assign({}, vscode.workspace.getConfiguration("C_Cpp.references", this.RootUri)), vcFormat: Object.assign(Object.assign({}, vscode.workspace.getConfiguration("C_Cpp.vcFormat", this.RootUri)), { indent: vscode.workspace.getConfiguration("C_Cpp.vcFormat.indent", this.RootUri), newLine: Object.assign(Object.assign({}, vscode.workspace.getConfiguration("C_Cpp.vcFormat.newLine", this.RootUri)), { beforeOpenBrace: vscode.workspace.getConfiguration("C_Cpp.vcFormat.newLine.beforeOpenBrace", this.RootUri), closeBraceSameLine: vscode.workspace.getConfiguration("C_Cpp.vcFormat.newLine.closeBraceSameLine", this.RootUri) }), space: vscode.workspace.getConfiguration("C_Cpp.vcFormat.space", this.RootUri), wrap: vscode.workspace.getConfiguration("C_Cpp.vcFormat.wrap", this.RootUri) }) }),
            editor: {
                autoClosingBrackets: otherSettingsFolder.editorAutoClosingBrackets
            },
            files: {
                encoding: otherSettingsFolder.filesEncoding,
                exclude: vscode.workspace.getConfiguration("files.exclude", this.RootUri),
                associations: new settings_1.OtherSettings().filesAssociations,
                autoSaveAfterDelay: otherSettingsFolder.filesAutoSaveAfterDelay
            },
            workspace_fallback_encoding: otherSettingsWorkspace.filesEncoding,
            search: {
                exclude: vscode.workspace.getConfiguration("search.exclude", this.RootUri)
            }
        };
        this.sendDidChangeSettings(settings);
    }
    sendDidChangeSettings(settings) {
        this.notifyWhenLanguageClientReady(() => {
            this.languageClient.sendNotification(DidChangeSettingsNotification, { settings, workspaceFolderUri: this.RootPath });
        });
    }
    onDidChangeSettings(event, isFirstClient) {
        this.sendAllSettings();
        const changedSettings = this.settingsTracker.getChangedSettings();
        this.notifyWhenLanguageClientReady(() => {
            if (Object.keys(changedSettings).length > 0) {
                if (isFirstClient) {
                    if (changedSettings["commentContinuationPatterns"]) {
                        (0, extension_1.updateLanguageConfigurations)();
                    }
                    if (changedSettings["loggingLevel"]) {
                        const oldLoggingLevelLogged = !!this.loggingLevel && this.loggingLevel !== "None" && this.loggingLevel !== "Error";
                        const newLoggingLevel = changedSettings["loggingLevel"];
                        this.loggingLevel = newLoggingLevel;
                        const newLoggingLevelLogged = !!newLoggingLevel && newLoggingLevel !== "None" && newLoggingLevel !== "Error";
                        if (oldLoggingLevelLogged || newLoggingLevelLogged) {
                            const out = logger.getOutputChannelLogger();
                            out.appendLine(localize(6, null, "loggingLevel", changedSettings["loggingLevel"]));
                        }
                    }
                    const settings = new settings_1.CppSettings();
                    if (changedSettings["formatting"]) {
                        const folderSettings = new settings_1.CppSettings(this.RootUri);
                        if (folderSettings.formattingEngine !== "Disabled") {
                            if (!this.documentFormattingProviderDisposable) {
                                this.documentFormattingProviderDisposable = vscode.languages.registerDocumentFormattingEditProvider(this.documentSelector, new documentFormattingEditProvider_1.DocumentFormattingEditProvider(this));
                            }
                            if (!this.formattingRangeProviderDisposable) {
                                this.formattingRangeProviderDisposable = vscode.languages.registerDocumentRangeFormattingEditProvider(this.documentSelector, new documentRangeFormattingEditProvider_1.DocumentRangeFormattingEditProvider(this));
                            }
                            if (!this.onTypeFormattingProviderDisposable) {
                                this.onTypeFormattingProviderDisposable = vscode.languages.registerOnTypeFormattingEditProvider(this.documentSelector, new onTypeFormattingEditProvider_1.OnTypeFormattingEditProvider(this), ";", "}", "\n");
                            }
                        }
                        else {
                            if (this.documentFormattingProviderDisposable) {
                                this.documentFormattingProviderDisposable.dispose();
                                this.documentFormattingProviderDisposable = undefined;
                            }
                            if (this.formattingRangeProviderDisposable) {
                                this.formattingRangeProviderDisposable.dispose();
                                this.formattingRangeProviderDisposable = undefined;
                            }
                            if (this.onTypeFormattingProviderDisposable) {
                                this.onTypeFormattingProviderDisposable.dispose();
                                this.onTypeFormattingProviderDisposable = undefined;
                            }
                        }
                    }
                    if (changedSettings["codeFolding"]) {
                        if (settings.codeFolding) {
                            this.codeFoldingProvider = new foldingRangeProvider_1.FoldingRangeProvider(this);
                            this.codeFoldingProviderDisposable = vscode.languages.registerFoldingRangeProvider(this.documentSelector, this.codeFoldingProvider);
                        }
                        else if (this.codeFoldingProviderDisposable) {
                            this.codeFoldingProviderDisposable.dispose();
                            this.codeFoldingProviderDisposable = undefined;
                            this.codeFoldingProvider = undefined;
                        }
                    }
                    if (changedSettings["enhancedColorization"]) {
                        if (settings.enhancedColorization && this.semanticTokensLegend) {
                            this.semanticTokensProvider = new semanticTokensProvider_1.SemanticTokensProvider(this);
                            this.semanticTokensProviderDisposable = vscode.languages.registerDocumentSemanticTokensProvider(this.documentSelector, this.semanticTokensProvider, this.semanticTokensLegend);
                        }
                        else if (this.semanticTokensProviderDisposable) {
                            this.semanticTokensProviderDisposable.dispose();
                            this.semanticTokensProviderDisposable = undefined;
                            this.semanticTokensProvider = undefined;
                        }
                    }
                    if (changedSettings["addNodeAddonIncludePaths"] && settings.addNodeAddonIncludePaths && this.configuration.nodeAddonIncludesFound() === 0) {
                        util.promptForReloadWindowDueToSettingsChange();
                    }
                }
                this.configuration.onDidChangeSettings();
                telemetry.logLanguageServerEvent("CppSettingsChange", changedSettings, undefined);
            }
        });
        return changedSettings;
    }
    onDidChangeVisibleTextEditor(editor) {
        const settings = new settings_1.CppSettings(this.RootUri);
        if (settings.dimInactiveRegions) {
            const valuePair = this.inactiveRegionsDecorations.get(editor.document.uri.toString());
            if (valuePair) {
                editor.setDecorations(valuePair.decoration, valuePair.ranges);
            }
        }
    }
    onDidChangeTextDocument(textDocumentChangeEvent) {
        if (textDocumentChangeEvent.document.uri.scheme === "file") {
            if (textDocumentChangeEvent.document.languageId === "c"
                || textDocumentChangeEvent.document.languageId === "cpp"
                || textDocumentChangeEvent.document.languageId === "cuda-cpp") {
                if (DefaultClient.renamePending) {
                    this.cancelReferences();
                }
                const oldVersion = exports.openFileVersions.get(textDocumentChangeEvent.document.uri.toString());
                const newVersion = textDocumentChangeEvent.document.version;
                if (oldVersion === undefined || newVersion > oldVersion) {
                    exports.openFileVersions.set(textDocumentChangeEvent.document.uri.toString(), newVersion);
                }
            }
        }
    }
    onDidOpenTextDocument(document) {
        if (document.uri.scheme === "file") {
            const uri = document.uri.toString();
            exports.openFileVersions.set(uri, document.version);
        }
    }
    onDidCloseTextDocument(document) {
        const uri = document.uri.toString();
        if (this.semanticTokensProvider) {
            this.semanticTokensProvider.invalidateFile(uri);
        }
        exports.openFileVersions.delete(uri);
    }
    onRegisterCustomConfigurationProvider(provider) {
        const onRegistered = () => {
            if (provider.version >= vscode_cpptools_1.Version.v2) {
                this.pauseParsing();
            }
        };
        return this.notifyWhenLanguageClientReady(() => {
            if (this.registeredProviders.includes(provider)) {
                return;
            }
            this.registeredProviders.push(provider);
            const rootFolder = this.RootFolder;
            if (!rootFolder) {
                return;
            }
            this.configuration.handleConfigurationChange();
            const selectedProvider = this.configuration.CurrentConfigurationProvider;
            if (!selectedProvider) {
                const ask = new persistentState_1.PersistentFolderState("Client.registerProvider", true, rootFolder);
                if (!fs.existsSync(`${this.RootPath}/.vscode/c_cpp_properties.json`) && !fs.existsSync(`${this.RootPath}/.vscode/settings.json`)) {
                    ask.Value = true;
                }
                if (ask.Value) {
                    ui.showConfigureCustomProviderMessage(() => __awaiter(this, void 0, void 0, function* () {
                        const message = (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 1)
                            ? localize(7, null, provider.name, this.Name)
                            : localize(8, null, provider.name);
                        const allow = localize(9, null);
                        const dontAllow = localize(10, null);
                        const askLater = localize(11, null);
                        return vscode.window.showInformationMessage(message, allow, dontAllow, askLater).then((result) => __awaiter(this, void 0, void 0, function* () {
                            switch (result) {
                                case allow: {
                                    yield this.configuration.updateCustomConfigurationProvider(provider.extensionId);
                                    onRegistered();
                                    ask.Value = false;
                                    telemetry.logLanguageServerEvent("customConfigurationProvider", { "providerId": provider.extensionId });
                                    return true;
                                }
                                case dontAllow: {
                                    ask.Value = false;
                                    break;
                                }
                                default: {
                                    break;
                                }
                            }
                            return false;
                        }));
                    }), () => ask.Value = false);
                }
            }
            else if ((0, customProviders_1.isSameProviderExtensionId)(selectedProvider, provider.extensionId)) {
                onRegistered();
                telemetry.logLanguageServerEvent("customConfigurationProvider", { "providerId": provider.extensionId });
            }
            else if (selectedProvider === provider.name) {
                onRegistered();
                this.configuration.updateCustomConfigurationProvider(provider.extensionId);
            }
        });
    }
    updateCustomConfigurations(requestingProvider) {
        return this.notifyWhenLanguageClientReady(() => {
            if (!this.configurationProvider) {
                this.clearCustomConfigurations();
                return;
            }
            const currentProvider = (0, customProviders_1.getCustomConfigProviders)().get(this.configurationProvider);
            if (!currentProvider) {
                this.clearCustomConfigurations();
                return;
            }
            if (requestingProvider && requestingProvider.extensionId !== currentProvider.extensionId) {
                return;
            }
            this.clearCustomConfigurations();
            if (diagnosticsCollectionCodeAnalysis) {
                diagnosticsCollectionCodeAnalysis.clear();
            }
            this.trackedDocuments.forEach(document => {
                this.provideCustomConfiguration(document.uri, undefined);
            });
        });
    }
    updateCustomBrowseConfiguration(requestingProvider) {
        return this.notifyWhenLanguageClientReady(() => {
            if (!this.configurationProvider) {
                return;
            }
            console.log("updateCustomBrowseConfiguration");
            const currentProvider = (0, customProviders_1.getCustomConfigProviders)().get(this.configurationProvider);
            if (!currentProvider || (requestingProvider && requestingProvider.extensionId !== currentProvider.extensionId)) {
                return;
            }
            const tokenSource = new vscode.CancellationTokenSource();
            const task = () => __awaiter(this, void 0, void 0, function* () {
                if (this.RootUri && (yield currentProvider.canProvideBrowseConfigurationsPerFolder(tokenSource.token))) {
                    return (currentProvider.provideFolderBrowseConfiguration(this.RootUri, tokenSource.token));
                }
                if (yield currentProvider.canProvideBrowseConfiguration(tokenSource.token)) {
                    return currentProvider.provideBrowseConfiguration(tokenSource.token);
                }
                if (currentProvider.version >= vscode_cpptools_1.Version.v2) {
                    console.warn("failed to provide browse configuration");
                }
                return null;
            });
            let hasCompleted = false;
            task().then((config) => __awaiter(this, void 0, void 0, function* () {
                if (!config) {
                    return;
                }
                if (currentProvider.version < vscode_cpptools_1.Version.v3) {
                    for (const c of config.browsePath) {
                        if (vscode.workspace.getWorkspaceFolder(vscode.Uri.file(c)) === this.RootFolder) {
                            this.sendCustomBrowseConfiguration(config, currentProvider.extensionId);
                            break;
                        }
                    }
                }
                else {
                    this.sendCustomBrowseConfiguration(config, currentProvider.extensionId);
                }
                if (!hasCompleted) {
                    hasCompleted = true;
                    if (currentProvider.version >= vscode_cpptools_1.Version.v2) {
                        this.resumeParsing();
                    }
                }
            }), () => {
                if (!hasCompleted) {
                    hasCompleted = true;
                    if (currentProvider.version >= vscode_cpptools_1.Version.v2) {
                        this.resumeParsing();
                    }
                }
            });
            global.setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                if (!hasCompleted) {
                    hasCompleted = true;
                    this.sendCustomBrowseConfiguration(null, undefined, true);
                    if (currentProvider.version >= vscode_cpptools_1.Version.v2) {
                        console.warn("Configuration Provider timed out in {0}ms.", configProviderTimeout);
                        this.resumeParsing();
                    }
                }
            }), configProviderTimeout);
        });
    }
    toggleReferenceResultsView() {
        exports.workspaceReferences.toggleGroupView();
    }
    logDiagnostics() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.requestWhenReady(() => this.languageClient.sendRequest(GetDiagnosticsRequest, null));
            if (!diagnosticsChannel) {
                diagnosticsChannel = vscode.window.createOutputChannel(localize(12, null));
                workspaceDisposables.push(diagnosticsChannel);
            }
            else {
                diagnosticsChannel.clear();
            }
            const header = `-------- Diagnostics - ${new Date().toLocaleString()}\n`;
            const version = `Version: ${util.packageJson.version}\n`;
            let configJson = "";
            if (this.configuration.CurrentConfiguration) {
                configJson = `Current Configuration:\n${JSON.stringify(this.configuration.CurrentConfiguration, null, 4)}\n`;
            }
            let configurationLoggingStr = "";
            const tuSearchStart = response.diagnostics.indexOf("Translation Unit Mappings:");
            if (tuSearchStart >= 0) {
                const tuSearchEnd = response.diagnostics.indexOf("Translation Unit Configurations:");
                if (tuSearchEnd >= 0 && tuSearchEnd > tuSearchStart) {
                    let tuSearchString = response.diagnostics.substr(tuSearchStart, tuSearchEnd - tuSearchStart);
                    let tuSearchIndex = tuSearchString.indexOf("[");
                    while (tuSearchIndex >= 0) {
                        const tuMatch = tuSearchString.match(/\[\s(.*)\s\]/);
                        if (tuMatch && tuMatch.length > 1) {
                            const tuPath = vscode.Uri.file(tuMatch[1]).toString();
                            if (this.configurationLogging.has(tuPath)) {
                                if (configurationLoggingStr.length === 0) {
                                    configurationLoggingStr += "Custom configurations:\n";
                                }
                                configurationLoggingStr += `[ ${tuMatch[1]} ]\n${this.configurationLogging.get(tuPath)}\n`;
                            }
                        }
                        tuSearchString = tuSearchString.substr(tuSearchIndex + 1);
                        tuSearchIndex = tuSearchString.indexOf("[");
                    }
                }
            }
            diagnosticsChannel.appendLine(`${header}${version}${configJson}${this.browseConfigurationLogging}${configurationLoggingStr}${response.diagnostics}`);
            diagnosticsChannel.show(false);
        });
    }
    rescanFolder() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.notifyWhenLanguageClientReady(() => this.languageClient.sendNotification(RescanFolderNotification));
        });
    }
    provideCustomConfiguration(docUri, requestFile) {
        return __awaiter(this, void 0, void 0, function* () {
            const onFinished = () => {
                if (requestFile) {
                    this.languageClient.sendNotification(FinishedRequestCustomConfig, requestFile);
                }
            };
            const providerId = this.configurationProvider;
            if (!providerId) {
                onFinished();
                return;
            }
            const provider = (0, customProviders_1.getCustomConfigProviders)().get(providerId);
            if (!provider) {
                onFinished();
                return;
            }
            if (!provider.isReady) {
                onFinished();
                throw new Error(`${this.configurationProvider} is not ready`);
            }
            return this.queueBlockingTask(() => __awaiter(this, void 0, void 0, function* () {
                var _a;
                const tokenSource = new vscode.CancellationTokenSource();
                console.log("provideCustomConfiguration");
                const providerName = provider.name;
                const params = {
                    uri: docUri.toString(),
                    workspaceFolderUri: this.RootPath
                };
                const response = yield this.languageClient.sendRequest(QueryTranslationUnitSourceRequest, params);
                if (!response.candidates || response.candidates.length === 0) {
                    onFinished();
                    return;
                }
                const provideConfigurationAsync = () => __awaiter(this, void 0, void 0, function* () {
                    if (provider) {
                        for (let i = 0; i < response.candidates.length; ++i) {
                            try {
                                const candidate = response.candidates[i];
                                const tuUri = vscode.Uri.parse(candidate);
                                if (yield provider.canProvideConfiguration(tuUri, tokenSource.token)) {
                                    const configs = yield provider.provideConfigurations([tuUri], tokenSource.token);
                                    if (configs && configs.length > 0 && configs[0]) {
                                        const fileConfiguration = this.configuration.CurrentConfiguration;
                                        if (fileConfiguration === null || fileConfiguration === void 0 ? void 0 : fileConfiguration.mergeConfigurations) {
                                            configs.forEach(config => {
                                                if (fileConfiguration.includePath) {
                                                    fileConfiguration.includePath.forEach(p => {
                                                        if (!config.configuration.includePath.includes(p)) {
                                                            config.configuration.includePath.push(p);
                                                        }
                                                    });
                                                }
                                                if (fileConfiguration.defines) {
                                                    fileConfiguration.defines.forEach(d => {
                                                        if (!config.configuration.defines.includes(d)) {
                                                            config.configuration.defines.push(d);
                                                        }
                                                    });
                                                }
                                                if (!config.configuration.forcedInclude) {
                                                    config.configuration.forcedInclude = [];
                                                }
                                                if (fileConfiguration.forcedInclude) {
                                                    fileConfiguration.forcedInclude.forEach(i => {
                                                        if (config.configuration.forcedInclude) {
                                                            if (!config.configuration.forcedInclude.includes(i)) {
                                                                config.configuration.forcedInclude.push(i);
                                                            }
                                                        }
                                                    });
                                                }
                                            });
                                        }
                                        return configs;
                                    }
                                }
                                if (tokenSource.token.isCancellationRequested) {
                                    return null;
                                }
                            }
                            catch (err) {
                                console.warn("Caught exception request configuration");
                            }
                        }
                    }
                });
                const configs = yield this.callTaskWithTimeout(provideConfigurationAsync, configProviderTimeout, tokenSource);
                try {
                    if (configs && configs.length > 0) {
                        this.sendCustomConfigurations(configs, provider.version);
                    }
                    onFinished();
                }
                catch (err) {
                    if (requestFile) {
                        onFinished();
                        return;
                    }
                    const settings = new settings_1.CppSettings(this.RootUri);
                    if (settings.configurationWarnings === "Enabled" && !this.isExternalHeader(docUri) && !vscode.debug.activeDebugSession) {
                        const dismiss = localize(13, null);
                        const disable = localize(14, null);
                        const configName = (_a = this.configuration.CurrentConfiguration) === null || _a === void 0 ? void 0 : _a.name;
                        if (!configName) {
                            return;
                        }
                        let message = localize(15, null, providerName, docUri.fsPath, configName);
                        if (err) {
                            message += ` (${err})`;
                        }
                        vscode.window.showInformationMessage(message, dismiss, disable).then(response => {
                            switch (response) {
                                case disable: {
                                    settings.toggleSetting("configurationWarnings", "Enabled", "Disabled");
                                    break;
                                }
                            }
                        });
                    }
                }
            }));
        });
    }
    handleRequestCustomConfig(requestFile) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.provideCustomConfiguration(vscode.Uri.file(requestFile), requestFile);
        });
    }
    isExternalHeader(uri) {
        const rootUri = this.RootUri;
        return !rootUri || (util.isHeader(uri) && !uri.toString().startsWith(rootUri.toString()));
    }
    getCurrentConfigName() {
        return this.queueTask(() => { var _a; return Promise.resolve((_a = this.configuration.CurrentConfiguration) === null || _a === void 0 ? void 0 : _a.name); });
    }
    getCurrentConfigCustomVariable(variableName) {
        return this.queueTask(() => { var _a, _b; return Promise.resolve(((_b = (_a = this.configuration.CurrentConfiguration) === null || _a === void 0 ? void 0 : _a.customConfigurationVariables) === null || _b === void 0 ? void 0 : _b[variableName]) || ''); });
    }
    setCurrentConfigName(configurationName) {
        return this.queueTask(() => new Promise((resolve, reject) => {
            const configurations = this.configuration.Configurations || [];
            const configurationIndex = configurations.findIndex((config) => config.name === configurationName);
            if (configurationIndex !== -1) {
                this.configuration.select(configurationIndex);
                resolve();
            }
            else {
                reject(new Error(localize(16, null, configurationName)));
            }
        }));
    }
    getCurrentCompilerPathAndArgs() {
        return this.queueTask(() => {
            var _a, _b;
            return Promise.resolve(util.extractCompilerPathAndArgs((_a = this.configuration.CurrentConfiguration) === null || _a === void 0 ? void 0 : _a.compilerPath, (_b = this.configuration.CurrentConfiguration) === null || _b === void 0 ? void 0 : _b.compilerArgs));
        });
    }
    getVcpkgInstalled() {
        return this.queueTask(() => Promise.resolve(this.configuration.VcpkgInstalled));
    }
    getVcpkgEnabled() {
        const cppSettings = new settings_1.CppSettings(this.RootUri);
        return Promise.resolve(cppSettings.vcpkgEnabled === true);
    }
    getKnownCompilers() {
        return this.queueTask(() => Promise.resolve(this.configuration.KnownCompiler));
    }
    takeOwnership(document) {
        const params = {
            textDocument: {
                uri: document.uri.toString(),
                languageId: document.languageId,
                version: document.version,
                text: document.getText()
            }
        };
        this.updateActiveDocumentTextOptions();
        this.notifyWhenLanguageClientReady(() => this.languageClient.sendNotification(DidOpenNotification, params));
        this.trackedDocuments.add(document);
    }
    queueTask(task) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isSupported) {
                const nextTask = () => __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield task();
                    }
                    catch (err) {
                        console.error(err);
                        throw err;
                    }
                });
                if (pendingTask && !pendingTask.Done) {
                    try {
                        yield pendingTask.getPromise();
                    }
                    catch (e) { }
                }
                else {
                    pendingTask = undefined;
                }
                return nextTask();
            }
            else {
                throw new Error(localize(17, null));
            }
        });
    }
    queueBlockingTask(task) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isSupported) {
                pendingTask = new util.BlockingTask(task, pendingTask);
                return pendingTask.getPromise();
            }
            else {
                throw new Error(localize(18, null));
            }
        });
    }
    callTaskWithTimeout(task, ms, cancelToken) {
        let timer;
        const timeout = () => new Promise((resolve, reject) => {
            timer = global.setTimeout(() => {
                clearTimeout(timer);
                if (cancelToken) {
                    cancelToken.cancel();
                }
                reject(localize(19, null, ms));
            }, ms);
        });
        return Promise.race([task(), timeout()]).then((result) => {
            clearTimeout(timer);
            return result;
        }, (error) => {
            clearTimeout(timer);
            throw error;
        });
    }
    requestWhenReady(request) {
        return this.queueTask(request);
    }
    notifyWhenLanguageClientReady(notify) {
        const task = () => new Promise(resolve => {
            resolve(notify());
        });
        return this.queueTask(task);
    }
    awaitUntilLanguageClientReady() {
        const task = () => new Promise(resolve => {
            resolve();
        });
        return this.queueTask(task);
    }
    registerNotifications() {
        console.assert(this.languageClient !== undefined, "This method must not be called until this.languageClient is set in \"onReady\"");
        this.languageClient.onNotification(ReloadWindowNotification, () => util.promptForReloadWindowDueToSettingsChange());
        this.languageClient.onNotification(LogTelemetryNotification, logTelemetry);
        this.languageClient.onNotification(ReportStatusNotification, (e) => this.updateStatus(e));
        this.languageClient.onNotification(ReportTagParseStatusNotification, (e) => this.updateTagParseStatus(e));
        this.languageClient.onNotification(InactiveRegionNotification, (e) => this.updateInactiveRegions(e));
        this.languageClient.onNotification(CompileCommandsPathsNotification, (e) => this.promptCompileCommands(e));
        this.languageClient.onNotification(ReferencesNotification, (e) => this.processReferencesResult(e.referencesResult));
        this.languageClient.onNotification(ReportReferencesProgressNotification, (e) => this.handleReferencesProgress(e));
        this.languageClient.onNotification(RequestCustomConfig, (requestFile) => {
            const client = clientCollection.getClientFor(vscode.Uri.file(requestFile));
            client.handleRequestCustomConfig(requestFile);
        });
        this.languageClient.onNotification(PublishDiagnosticsNotification, publishDiagnostics);
        this.languageClient.onNotification(PublishCodeAnalysisDiagnosticsNotification, publishCodeAnalysisDiagnostics);
        this.languageClient.onNotification(ShowMessageWindowNotification, showMessageWindow);
        this.languageClient.onNotification(ShowWarningNotification, showWarning);
        this.languageClient.onNotification(ReportTextDocumentLanguage, (e) => this.setTextDocumentLanguage(e));
        this.languageClient.onNotification(SemanticTokensChanged, (e) => { var _a; return (_a = this.semanticTokensProvider) === null || _a === void 0 ? void 0 : _a.invalidateFile(e); });
        this.languageClient.onNotification(IntelliSenseSetupNotification, (e) => this.logIntellisenseSetupTime(e));
        this.languageClient.onNotification(SetTemporaryTextDocumentLanguageNotification, (e) => this.setTemporaryTextDocumentLanguage(e));
        this.languageClient.onNotification(ReportCodeAnalysisProcessedNotification, (e) => this.updateCodeAnalysisProcessed(e));
        this.languageClient.onNotification(ReportCodeAnalysisTotalNotification, (e) => this.updateCodeAnalysisTotal(e));
        setupOutputHandlers();
    }
    setTextDocumentLanguage(languageStr) {
        const cppSettings = new settings_1.CppSettings();
        if (cppSettings.autoAddFileAssociations) {
            const is_c = languageStr.startsWith("c;");
            const is_cuda = languageStr.startsWith("cu;");
            languageStr = languageStr.substr(is_c ? 2 : (is_cuda ? 3 : 1));
            this.addFileAssociations(languageStr, is_c ? "c" : (is_cuda ? "cuda-cpp" : "cpp"));
        }
    }
    setTemporaryTextDocumentLanguage(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const languageId = params.isC ? "c" : (params.isCuda ? "cuda-cpp" : "cpp");
            const document = yield vscode.workspace.openTextDocument(params.path);
            if (!!document && document.languageId !== languageId) {
                vscode.languages.setTextDocumentLanguage(document, languageId);
            }
        });
    }
    registerFileWatcher() {
        console.assert(this.languageClient !== undefined, "This method must not be called until this.languageClient is set in \"onReady\"");
        if (this.rootFolder) {
            this.rootPathFileWatcher = vscode.workspace.createFileSystemWatcher("**/*", false, false, false);
            this.rootPathFileWatcher.onDidCreate((uri) => __awaiter(this, void 0, void 0, function* () {
                if (uri.scheme !== 'file') {
                    return;
                }
                const fileName = path.basename(uri.fsPath).toLowerCase();
                if (fileName === ".editorconfig") {
                    exports.cachedEditorConfigSettings.clear();
                    exports.cachedEditorConfigLookups.clear();
                    yield this.updateActiveDocumentTextOptions();
                }
                if (fileName === ".clang-format" || fileName === "_clang-format") {
                    exports.cachedEditorConfigLookups.clear();
                }
                this.languageClient.sendNotification(FileCreatedNotification, { uri: uri.toString() });
            }));
            this.associations_for_did_change = new Set(["cu", "cuh", "c", "i", "cpp", "cc", "cxx", "c++", "cp", "hpp", "hh", "hxx", "h++", "hp", "h", "ii", "ino", "inl", "ipp", "tcc", "idl"]);
            const assocs = new settings_1.OtherSettings().filesAssociations;
            for (const assoc in assocs) {
                const dotIndex = assoc.lastIndexOf('.');
                if (dotIndex !== -1) {
                    const ext = assoc.substr(dotIndex + 1);
                    this.associations_for_did_change.add(ext);
                }
            }
            this.rootPathFileWatcher.onDidChange((uri) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if (uri.scheme !== 'file') {
                    return;
                }
                const dotIndex = uri.fsPath.lastIndexOf('.');
                const fileName = path.basename(uri.fsPath).toLowerCase();
                if (fileName === ".editorconfig") {
                    exports.cachedEditorConfigSettings.clear();
                    exports.cachedEditorConfigLookups.clear();
                    yield this.updateActiveDocumentTextOptions();
                }
                if (dotIndex !== -1) {
                    const ext = uri.fsPath.substr(dotIndex + 1);
                    if ((_a = this.associations_for_did_change) === null || _a === void 0 ? void 0 : _a.has(ext)) {
                        const mtime = fs.statSync(uri.fsPath).mtime;
                        const duration = Date.now() - mtime.getTime();
                        if (duration < 10000) {
                            this.languageClient.sendNotification(FileChangedNotification, { uri: uri.toString() });
                        }
                    }
                }
            }));
            this.rootPathFileWatcher.onDidDelete((uri) => {
                if (uri.scheme !== 'file') {
                    return;
                }
                const fileName = path.basename(uri.fsPath).toLowerCase();
                if (fileName === ".editorconfig") {
                    exports.cachedEditorConfigSettings.clear();
                    exports.cachedEditorConfigLookups.clear();
                }
                if (fileName === ".clang-format" || fileName === "_clang-format") {
                    exports.cachedEditorConfigLookups.clear();
                }
                this.languageClient.sendNotification(FileDeletedNotification, { uri: uri.toString() });
            });
            this.disposables.push(this.rootPathFileWatcher);
        }
        else {
            this.rootPathFileWatcher = undefined;
        }
    }
    addFileAssociations(fileAssociations, languageId) {
        const settings = new settings_1.OtherSettings();
        const assocs = settings.filesAssociations;
        const filesAndPaths = fileAssociations.split(";");
        let foundNewAssociation = false;
        for (let i = 0; i < filesAndPaths.length; ++i) {
            const fileAndPath = filesAndPaths[i].split("@");
            if (fileAndPath.length === 2) {
                const file = fileAndPath[0];
                const filePath = fileAndPath[1];
                if ((file in assocs) || (("**/" + file) in assocs)) {
                    continue;
                }
                const j = file.lastIndexOf('.');
                if (j !== -1) {
                    const ext = file.substr(j);
                    if ((("*" + ext) in assocs) || (("**/*" + ext) in assocs)) {
                        continue;
                    }
                }
                let foundGlobMatch = false;
                for (const assoc in assocs) {
                    if (minimatch(filePath, assoc)) {
                        foundGlobMatch = true;
                        break;
                    }
                }
                if (foundGlobMatch) {
                    continue;
                }
                assocs[file] = languageId;
                foundNewAssociation = true;
            }
        }
        if (foundNewAssociation) {
            settings.filesAssociations = assocs;
        }
    }
    updateStatus(notificationBody) {
        var _a;
        const message = notificationBody.status;
        util.setProgress(util.getProgressExecutableSuccess());
        const testHook = (0, testHook_1.getTestHook)();
        if (message.endsWith("Idle")) {
        }
        else if (message.endsWith("Parsing")) {
            this.model.isParsingWorkspace.Value = true;
            this.model.isParsingWorkspacePausable.Value = false;
            const status = { status: testApi_1.Status.TagParsingBegun };
            testHook.updateStatus(status);
        }
        else if (message.endsWith("files")) {
            this.model.isParsingFiles.Value = true;
        }
        else if (message.endsWith("IntelliSense")) {
            timeStamp = Date.now();
            this.model.isUpdatingIntelliSense.Value = true;
            const status = { status: testApi_1.Status.IntelliSenseCompiling };
            testHook.updateStatus(status);
        }
        else if (message.endsWith("IntelliSense done")) {
            const settings = new settings_1.CppSettings();
            if (settings.loggingLevel === "Debug") {
                const out = logger.getOutputChannelLogger();
                const duration = Date.now() - timeStamp;
                out.appendLine(localize(20, null, duration / 1000));
            }
            this.model.isUpdatingIntelliSense.Value = false;
            const status = { status: testApi_1.Status.IntelliSenseReady };
            testHook.updateStatus(status);
        }
        else if (message.endsWith("Parsing done")) {
            this.model.isParsingWorkspace.Value = false;
            const status = { status: testApi_1.Status.TagParsingDone };
            testHook.updateStatus(status);
            util.setProgress(util.getProgressParseRootSuccess());
        }
        else if (message.endsWith("files done")) {
            this.model.isParsingFiles.Value = false;
        }
        else if (message.endsWith("Analysis")) {
            this.model.isRunningCodeAnalysis.Value = true;
            this.model.codeAnalysisTotal.Value = 1;
            this.model.codeAnalysisProcessed.Value = 0;
        }
        else if (message.endsWith("Analysis done")) {
            this.model.isRunningCodeAnalysis.Value = false;
        }
        else if (message.includes("Squiggles Finished - File name:")) {
            const index = message.lastIndexOf(":");
            const name = message.substring(index + 2);
            const status = { status: testApi_1.Status.IntelliSenseReady, filename: name };
            testHook.updateStatus(status);
        }
        else if (message.endsWith("No Squiggles")) {
            util.setIntelliSenseProgress(util.getProgressIntelliSenseNoSquiggles());
        }
        else if (message.endsWith("Unresolved Headers")) {
            if (notificationBody.workspaceFolderUri) {
                const client = clientCollection.getClientFor(vscode.Uri.file(notificationBody.workspaceFolderUri));
                if (!((_a = client.configuration.CurrentConfiguration) === null || _a === void 0 ? void 0 : _a.configurationProvider)) {
                    const showIntelliSenseFallbackMessage = new persistentState_1.PersistentState("CPP.showIntelliSenseFallbackMessage", true);
                    if (showIntelliSenseFallbackMessage.Value) {
                        ui.showConfigureIncludePathMessage(() => __awaiter(this, void 0, void 0, function* () {
                            const configJSON = localize(21, null);
                            const configUI = localize(22, null);
                            const dontShowAgain = localize(23, null);
                            const fallbackMsg = client.configuration.VcpkgInstalled ?
                                localize(24, null) :
                                localize(25, null);
                            return vscode.window.showInformationMessage(fallbackMsg, configJSON, configUI, dontShowAgain).then((value) => __awaiter(this, void 0, void 0, function* () {
                                let commands;
                                switch (value) {
                                    case configJSON:
                                        commands = yield vscode.commands.getCommands(true);
                                        if (commands.indexOf("workbench.action.problems.focus") >= 0) {
                                            vscode.commands.executeCommand("workbench.action.problems.focus");
                                        }
                                        client.handleConfigurationEditJSONCommand();
                                        telemetry.logLanguageServerEvent("SettingsCommand", { "toast": "json" }, undefined);
                                        break;
                                    case configUI:
                                        commands = yield vscode.commands.getCommands(true);
                                        if (commands.indexOf("workbench.action.problems.focus") >= 0) {
                                            vscode.commands.executeCommand("workbench.action.problems.focus");
                                        }
                                        client.handleConfigurationEditUICommand();
                                        telemetry.logLanguageServerEvent("SettingsCommand", { "toast": "ui" }, undefined);
                                        break;
                                    case dontShowAgain:
                                        showIntelliSenseFallbackMessage.Value = false;
                                        break;
                                }
                                return true;
                            }));
                        }), () => showIntelliSenseFallbackMessage.Value = false);
                    }
                }
            }
        }
    }
    updateTagParseStatus(notificationBody) {
        this.model.parsingWorkspaceStatus.Value = util.getLocalizedString(notificationBody);
        if (notificationBody.text.startsWith("Workspace parsing paused")) {
            this.model.isParsingWorkspacePausable.Value = true;
            this.model.isParsingWorkspacePaused.Value = true;
        }
        else if (notificationBody.text.startsWith("Parsing workspace")) {
            this.model.isParsingWorkspacePausable.Value = true;
            this.model.isParsingWorkspacePaused.Value = false;
        }
        else {
            this.model.isParsingWorkspacePausable.Value = false;
            this.model.isParsingWorkspacePaused.Value = false;
        }
    }
    updateInactiveRegions(params) {
        const settings = new settings_1.CppSettings(this.RootUri);
        const opacity = settings.inactiveRegionOpacity;
        if (opacity !== null && opacity !== undefined) {
            let backgroundColor = settings.inactiveRegionBackgroundColor;
            if (backgroundColor === "") {
                backgroundColor = undefined;
            }
            let color = settings.inactiveRegionForegroundColor;
            if (color === "") {
                color = undefined;
            }
            const decoration = vscode.window.createTextEditorDecorationType({
                opacity: opacity.toString(),
                backgroundColor: backgroundColor,
                color: color,
                rangeBehavior: vscode.DecorationRangeBehavior.OpenOpen
            });
            const ranges = [];
            params.regions.forEach(element => {
                const newRange = new vscode.Range(element.startLine, 0, element.endLine, 0);
                ranges.push(newRange);
            });
            const valuePair = this.inactiveRegionsDecorations.get(params.uri);
            if (valuePair) {
                valuePair.decoration.dispose();
                valuePair.decoration = decoration;
                valuePair.ranges = ranges;
            }
            else {
                const toInsert = {
                    decoration: decoration,
                    ranges: ranges
                };
                this.inactiveRegionsDecorations.set(params.uri, toInsert);
            }
            if (settings.dimInactiveRegions && params.fileVersion === exports.openFileVersions.get(params.uri)) {
                const editors = vscode.window.visibleTextEditors.filter(e => e.document.uri.toString() === params.uri);
                for (const e of editors) {
                    e.setDecorations(decoration, ranges);
                }
            }
        }
        if (this.codeFoldingProvider) {
            this.codeFoldingProvider.refresh();
        }
    }
    logIntellisenseSetupTime(notification) {
        clientCollection.timeTelemetryCollector.setSetupTime(vscode.Uri.parse(notification.uri));
    }
    promptCompileCommands(params) {
        var _a, _b;
        if (!params.workspaceFolderUri) {
            return;
        }
        const client = clientCollection.getClientFor(vscode.Uri.file(params.workspaceFolderUri));
        if (((_a = client.configuration.CurrentConfiguration) === null || _a === void 0 ? void 0 : _a.compileCommands) || ((_b = client.configuration.CurrentConfiguration) === null || _b === void 0 ? void 0 : _b.configurationProvider)) {
            return;
        }
        const rootFolder = client.RootFolder;
        if (!rootFolder) {
            return;
        }
        const ask = new persistentState_1.PersistentFolderState("CPP.showCompileCommandsSelection", true, rootFolder);
        if (!ask.Value) {
            return;
        }
        const aCompileCommandsFile = localize(26, null);
        const compileCommandStr = params.paths.length > 1 ? aCompileCommandsFile : params.paths[0];
        const message = (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 1)
            ? localize(27, null, compileCommandStr, client.Name)
            : localize(28, null, compileCommandStr);
        ui.showConfigureCompileCommandsMessage(() => __awaiter(this, void 0, void 0, function* () {
            const yes = localize(29, null);
            const no = localize(30, null);
            const askLater = localize(31, null);
            return vscode.window.showInformationMessage(message, yes, no, askLater).then((value) => __awaiter(this, void 0, void 0, function* () {
                switch (value) {
                    case yes:
                        if (params.paths.length > 1) {
                            const index = yield ui.showCompileCommands(params.paths);
                            if (index < 0) {
                                return false;
                            }
                            this.configuration.setCompileCommands(params.paths[index]);
                        }
                        else {
                            this.configuration.setCompileCommands(params.paths[0]);
                        }
                        return true;
                    case askLater:
                        break;
                    case no:
                        ask.Value = false;
                        break;
                }
                return false;
            }));
        }), () => ask.Value = false);
    }
    requestSwitchHeaderSource(rootPath, fileName) {
        const params = {
            switchHeaderSourceFileName: fileName,
            workspaceFolderUri: rootPath
        };
        return this.requestWhenReady(() => this.languageClient.sendRequest(SwitchHeaderSourceRequest, params));
    }
    updateActiveDocumentTextOptions() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const editor = vscode.window.activeTextEditor;
            if (((_a = editor === null || editor === void 0 ? void 0 : editor.document) === null || _a === void 0 ? void 0 : _a.uri.scheme) === "file"
                && (editor.document.languageId === "c"
                    || editor.document.languageId === "cpp"
                    || editor.document.languageId === "cuda-cpp")) {
                const settings = new settings_1.CppSettings(this.RootUri);
                if (settings.useVcFormat(editor.document)) {
                    const editorConfigSettings = (0, settings_1.getEditorConfigSettings)(editor.document.uri.fsPath);
                    if (editorConfigSettings.indent_style === "space" || editorConfigSettings.indent_style === "tab") {
                        editor.options.insertSpaces = editorConfigSettings.indent_style === "space";
                        if (editorConfigSettings.indent_size === "tab") {
                            if (!editorConfigSettings.tab_width !== undefined) {
                                editor.options.tabSize = editorConfigSettings.tab_width;
                            }
                        }
                        else if (editorConfigSettings.indent_size !== undefined) {
                            editor.options.tabSize = editorConfigSettings.indent_size;
                        }
                    }
                    if (editorConfigSettings.end_of_line !== undefined) {
                        editor.edit((edit) => {
                            edit.setEndOfLine(editorConfigSettings.end_of_line === "lf" ? vscode.EndOfLine.LF : vscode.EndOfLine.CRLF);
                        });
                    }
                }
            }
        });
    }
    activeDocumentChanged(document) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.updateActiveDocumentTextOptions();
            yield this.awaitUntilLanguageClientReady();
            this.languageClient.sendNotification(ActiveDocumentChangeNotification, this.languageClient.code2ProtocolConverter.asTextDocumentIdentifier(document));
        });
    }
    restartIntelliSenseForFile(document) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.awaitUntilLanguageClientReady();
            this.languageClient.sendNotification(RestartIntelliSenseForFileNotification, this.languageClient.code2ProtocolConverter.asTextDocumentIdentifier(document));
        });
    }
    activate() {
        this.model.activate();
        this.resumeParsing();
    }
    selectionChanged(selection) {
        this.notifyWhenLanguageClientReady(() => {
            this.languageClient.sendNotification(TextEditorSelectionChangeNotification, selection);
        });
    }
    resetDatabase() {
        this.notifyWhenLanguageClientReady(() => this.languageClient.sendNotification(ResetDatabaseNotification));
    }
    deactivate() {
        this.model.deactivate();
    }
    pauseParsing() {
        this.notifyWhenLanguageClientReady(() => this.languageClient.sendNotification(PauseParsingNotification));
    }
    resumeParsing() {
        this.notifyWhenLanguageClientReady(() => this.languageClient.sendNotification(ResumeParsingNotification));
    }
    PauseCodeAnalysis() {
        this.notifyWhenLanguageClientReady(() => this.languageClient.sendNotification(PauseCodeAnalysisNotification));
        this.model.isCodeAnalysisPaused.Value = true;
    }
    ResumeCodeAnalysis() {
        this.notifyWhenLanguageClientReady(() => this.languageClient.sendNotification(ResumeCodeAnalysisNotification));
        this.model.isCodeAnalysisPaused.Value = false;
    }
    CancelCodeAnalysis() {
        this.notifyWhenLanguageClientReady(() => this.languageClient.sendNotification(CancelCodeAnalysisNotification));
    }
    updateCodeAnalysisProcessed(processed) {
        this.model.codeAnalysisProcessed.Value = processed;
    }
    updateCodeAnalysisTotal(total) {
        this.model.codeAnalysisTotal.Value = total;
    }
    onConfigurationsChanged(cppProperties) {
        var _a;
        if (!cppProperties.Configurations) {
            return;
        }
        const configurations = cppProperties.Configurations;
        const params = {
            configurations: configurations,
            currentConfiguration: this.configuration.CurrentConfigurationIndex,
            workspaceFolderUri: this.RootPath,
            isReady: true
        };
        params.configurations.forEach((c) => {
            const compilerPathAndArgs = util.extractCompilerPathAndArgs(c.compilerPath, c.compilerArgs);
            c.compilerPath = compilerPathAndArgs.compilerPath;
            c.compilerArgs = compilerPathAndArgs.additionalArgs;
        });
        this.languageClient.sendNotification(ChangeCppPropertiesNotification, params);
        const lastCustomBrowseConfigurationProviderId = cppProperties.LastCustomBrowseConfigurationProviderId;
        const lastCustomBrowseConfiguration = cppProperties.LastCustomBrowseConfiguration;
        if (!!lastCustomBrowseConfigurationProviderId && !!lastCustomBrowseConfiguration) {
            if (!this.doneInitialCustomBrowseConfigurationCheck) {
                if (lastCustomBrowseConfiguration.Value) {
                    this.sendCustomBrowseConfiguration(lastCustomBrowseConfiguration.Value, lastCustomBrowseConfigurationProviderId.Value);
                    params.isReady = false;
                }
                this.doneInitialCustomBrowseConfigurationCheck = true;
            }
        }
        const configName = (_a = configurations[params.currentConfiguration].name) !== null && _a !== void 0 ? _a : "";
        this.model.activeConfigName.setValueIfActive(configName);
        const newProvider = this.configuration.CurrentConfigurationProvider;
        if (!(0, customProviders_1.isSameProviderExtensionId)(newProvider, this.configurationProvider)) {
            if (this.configurationProvider) {
                this.clearCustomBrowseConfiguration();
            }
            this.configurationProvider = newProvider;
            this.updateCustomBrowseConfiguration();
            this.updateCustomConfigurations();
        }
    }
    onSelectedConfigurationChanged(index) {
        const params = {
            currentConfiguration: index,
            workspaceFolderUri: this.RootPath
        };
        this.notifyWhenLanguageClientReady(() => {
            this.languageClient.sendNotification(ChangeSelectedSettingNotification, params);
            let configName = "";
            if (this.configuration.ConfigurationNames) {
                configName = this.configuration.ConfigurationNames[index];
            }
            this.model.activeConfigName.Value = configName;
            this.configuration.onDidChangeSettings();
        });
    }
    onCompileCommandsChanged(path) {
        const params = {
            uri: vscode.Uri.file(path).toString(),
            workspaceFolderUri: this.RootPath
        };
        this.notifyWhenLanguageClientReady(() => this.languageClient.sendNotification(ChangeCompileCommandsNotification, params));
    }
    isSourceFileConfigurationItem(input, providerVersion) {
        let areOptionalsValid = false;
        if (providerVersion < vscode_cpptools_1.Version.v5) {
            areOptionalsValid = util.isString(input.configuration.intelliSenseMode) && util.isString(input.configuration.standard);
        }
        else {
            areOptionalsValid = util.isOptionalString(input.configuration.intelliSenseMode) && util.isOptionalString(input.configuration.standard);
        }
        return (input && (util.isString(input.uri) || util.isUri(input.uri)) &&
            input.configuration &&
            areOptionalsValid &&
            util.isArrayOfString(input.configuration.includePath) &&
            util.isArrayOfString(input.configuration.defines) &&
            util.isOptionalArrayOfString(input.configuration.compilerArgs) &&
            util.isOptionalArrayOfString(input.configuration.forcedInclude));
    }
    sendCustomConfigurations(configs, providerVersion) {
        if (!configs || !(configs instanceof Array)) {
            console.warn("discarding invalid SourceFileConfigurationItems[]: " + configs);
            return;
        }
        const settings = new settings_1.CppSettings();
        const out = logger.getOutputChannelLogger();
        if (settings.loggingLevel === "Debug") {
            out.appendLine(localize(32, null));
        }
        const sanitized = [];
        configs.forEach(item => {
            if (this.isSourceFileConfigurationItem(item, providerVersion)) {
                this.configurationLogging.set(item.uri.toString(), JSON.stringify(item.configuration, null, 4));
                if (settings.loggingLevel === "Debug") {
                    out.appendLine(`  uri: ${item.uri.toString()}`);
                    out.appendLine(`  config: ${JSON.stringify(item.configuration, null, 2)}`);
                }
                if (item.configuration.includePath.some(path => path.endsWith('**'))) {
                    console.warn("custom include paths should not use recursive includes ('**')");
                }
                const itemConfig = Object.assign({}, item.configuration);
                if (util.isString(itemConfig.compilerPath)) {
                    const compilerPathAndArgs = util.extractCompilerPathAndArgs(itemConfig.compilerPath, util.isArrayOfString(itemConfig.compilerArgs) ? itemConfig.compilerArgs : undefined);
                    itemConfig.compilerPath = compilerPathAndArgs.compilerPath;
                    itemConfig.compilerArgs = compilerPathAndArgs.additionalArgs;
                }
                sanitized.push({
                    uri: item.uri.toString(),
                    configuration: itemConfig
                });
            }
            else {
                console.warn("discarding invalid SourceFileConfigurationItem: " + JSON.stringify(item));
            }
        });
        if (sanitized.length === 0) {
            return;
        }
        const params = {
            configurationItems: sanitized,
            workspaceFolderUri: this.RootPath
        };
        this.languageClient.sendNotification(CustomConfigurationNotification, params);
    }
    isWorkspaceBrowseConfiguration(input) {
        return util.isArrayOfString(input.browsePath) &&
            util.isOptionalString(input.compilerPath) &&
            util.isOptionalString(input.standard) &&
            util.isOptionalArrayOfString(input.compilerArgs) &&
            util.isOptionalString(input.windowsSdkVersion);
    }
    sendCustomBrowseConfiguration(config, providerId, timeoutOccured) {
        const rootFolder = this.RootFolder;
        if (!rootFolder) {
            return;
        }
        const lastCustomBrowseConfiguration = new persistentState_1.PersistentFolderState("CPP.lastCustomBrowseConfiguration", undefined, rootFolder);
        const lastCustomBrowseConfigurationProviderId = new persistentState_1.PersistentFolderState("CPP.lastCustomBrowseConfigurationProviderId", undefined, rootFolder);
        let sanitized;
        this.browseConfigurationLogging = "";
        while (true) {
            if (timeoutOccured || !config || config instanceof Array) {
                if (!timeoutOccured) {
                    console.log("Received an invalid browse configuration from configuration provider.");
                }
                const configValue = lastCustomBrowseConfiguration.Value;
                if (configValue) {
                    sanitized = configValue;
                    console.log("Falling back to last received browse configuration: ", JSON.stringify(sanitized, null, 2));
                    break;
                }
                console.log("No browse configuration is available.");
                return;
            }
            sanitized = Object.assign({}, config);
            if (!this.isWorkspaceBrowseConfiguration(sanitized)) {
                console.log("Received an invalid browse configuration from configuration provider: " + JSON.stringify(sanitized));
                const configValue = lastCustomBrowseConfiguration.Value;
                if (configValue) {
                    sanitized = configValue;
                    console.log("Falling back to last received browse configuration: ", JSON.stringify(sanitized, null, 2));
                    break;
                }
                return;
            }
            const settings = new settings_1.CppSettings();
            if (settings.loggingLevel === "Debug") {
                const out = logger.getOutputChannelLogger();
                out.appendLine(localize(33, null, JSON.stringify(sanitized, null, 2)));
            }
            if (util.isString(sanitized.compilerPath)) {
                const compilerPathAndArgs = util.extractCompilerPathAndArgs(sanitized.compilerPath, util.isArrayOfString(sanitized.compilerArgs) ? sanitized.compilerArgs : undefined);
                sanitized.compilerPath = compilerPathAndArgs.compilerPath;
                sanitized.compilerArgs = compilerPathAndArgs.additionalArgs;
            }
            lastCustomBrowseConfiguration.Value = sanitized;
            if (!providerId) {
                lastCustomBrowseConfigurationProviderId.setDefault();
            }
            else {
                lastCustomBrowseConfigurationProviderId.Value = providerId;
            }
            break;
        }
        this.browseConfigurationLogging = `Custom browse configuration: \n${JSON.stringify(sanitized, null, 4)}\n`;
        const params = {
            browseConfiguration: sanitized,
            workspaceFolderUri: this.RootPath
        };
        this.languageClient.sendNotification(CustomBrowseConfigurationNotification, params);
    }
    clearCustomConfigurations() {
        this.configurationLogging.clear();
        const params = {
            workspaceFolderUri: this.RootPath
        };
        this.notifyWhenLanguageClientReady(() => this.languageClient.sendNotification(ClearCustomConfigurationsNotification, params));
    }
    clearCustomBrowseConfiguration() {
        this.browseConfigurationLogging = "";
        const params = {
            workspaceFolderUri: this.RootPath
        };
        this.notifyWhenLanguageClientReady(() => this.languageClient.sendNotification(ClearCustomBrowseConfigurationNotification, params));
    }
    handleConfigurationSelectCommand() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.awaitUntilLanguageClientReady();
            const configNames = this.configuration.ConfigurationNames;
            if (configNames) {
                const index = yield ui.showConfigurations(configNames);
                if (index < 0) {
                    return;
                }
                this.configuration.select(index);
            }
        });
    }
    handleConfigurationProviderSelectCommand() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.awaitUntilLanguageClientReady();
            const extensionId = yield ui.showConfigurationProviders(this.configuration.CurrentConfigurationProvider);
            if (extensionId === undefined) {
                return;
            }
            yield this.configuration.updateCustomConfigurationProvider(extensionId);
            if (extensionId) {
                const provider = (0, customProviders_1.getCustomConfigProviders)().get(extensionId);
                this.updateCustomBrowseConfiguration(provider);
                this.updateCustomConfigurations(provider);
                telemetry.logLanguageServerEvent("customConfigurationProvider", { "providerId": extensionId });
            }
            else {
                this.clearCustomConfigurations();
                this.clearCustomBrowseConfiguration();
            }
        });
    }
    handleShowParsingCommands() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.awaitUntilLanguageClientReady();
            const index = yield ui.showParsingCommands();
            if (index === 0) {
                this.pauseParsing();
            }
            else if (index === 1) {
                this.resumeParsing();
            }
        });
    }
    handleShowCodeAnalysisCommands() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.awaitUntilLanguageClientReady();
            const index = yield ui.showCodeAnalysisCommands();
            switch (index) {
                case 0:
                    this.CancelCodeAnalysis();
                    break;
                case 1:
                    this.PauseCodeAnalysis();
                    break;
                case 2:
                    this.ResumeCodeAnalysis();
                    break;
            }
        });
    }
    handleConfigurationEditCommand(viewColumn = vscode.ViewColumn.Active) {
        this.notifyWhenLanguageClientReady(() => this.configuration.handleConfigurationEditCommand(undefined, vscode.window.showTextDocument, viewColumn));
    }
    handleConfigurationEditJSONCommand(viewColumn = vscode.ViewColumn.Active) {
        this.notifyWhenLanguageClientReady(() => this.configuration.handleConfigurationEditJSONCommand(undefined, vscode.window.showTextDocument, viewColumn));
    }
    handleConfigurationEditUICommand(viewColumn = vscode.ViewColumn.Active) {
        this.notifyWhenLanguageClientReady(() => this.configuration.handleConfigurationEditUICommand(undefined, vscode.window.showTextDocument, viewColumn));
    }
    handleAddToIncludePathCommand(path) {
        this.notifyWhenLanguageClientReady(() => this.configuration.addToIncludePathCommand(path));
    }
    handleGoToDirectiveInGroup(next) {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = vscode.window.activeTextEditor;
            if (editor) {
                const params = {
                    uri: editor.document.uri.toString(),
                    position: editor.selection.active,
                    next: next
                };
                const response = yield this.languageClient.sendRequest(GoToDirectiveInGroupRequest, params);
                if (response) {
                    const p = new vscode.Position(response.line, response.character);
                    const r = new vscode.Range(p, p);
                    const currentEditor = vscode.window.activeTextEditor;
                    if (currentEditor && editor.document.uri === currentEditor.document.uri) {
                        currentEditor.selection = new vscode.Selection(r.start, r.end);
                        currentEditor.revealRange(r);
                    }
                }
            }
        });
    }
    handleCheckForCompiler() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.awaitUntilLanguageClientReady();
            const compilers = yield this.getKnownCompilers();
            if (!compilers || compilers.length === 0) {
                const compilerName = process.platform === "win32" ? "MSVC" : (process.platform === "darwin" ? "Clang" : "GCC");
                vscode.window.showInformationMessage(localize(34, null, compilerName), { modal: true });
            }
            else {
                const header = localize(35, null);
                let message = "";
                const settings = new settings_1.CppSettings(this.RootUri);
                const pathSeparator = settings.preferredPathSeparator;
                let isFirstLine = true;
                compilers.forEach(compiler => {
                    if (isFirstLine) {
                        isFirstLine = false;
                    }
                    else {
                        message += "\n";
                    }
                    if (pathSeparator !== "Forward Slash") {
                        message += compiler.path.replace(/\//g, '\\');
                    }
                    else {
                        message += compiler.path.replace(/\\/g, '/');
                    }
                });
                vscode.window.showInformationMessage(header, { modal: true, detail: message });
            }
        });
    }
    handleRunCodeAnalysisOnActiveFile() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.awaitUntilLanguageClientReady();
            this.languageClient.sendNotification(CodeAnalysisNotification, CodeAnalysisScope.ActiveFile);
        });
    }
    handleRunCodeAnalysisOnOpenFiles() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.awaitUntilLanguageClientReady();
            this.languageClient.sendNotification(CodeAnalysisNotification, CodeAnalysisScope.OpenFiles);
        });
    }
    handleRunCodeAnalysisOnAllFiles() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.awaitUntilLanguageClientReady();
            this.languageClient.sendNotification(CodeAnalysisNotification, CodeAnalysisScope.AllFiles);
        });
    }
    handleClearCodeAnalysisSquiggles() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.awaitUntilLanguageClientReady();
            if (diagnosticsCollectionCodeAnalysis) {
                diagnosticsCollectionCodeAnalysis.clear();
            }
            this.languageClient.sendNotification(CodeAnalysisNotification, CodeAnalysisScope.ClearSquiggles);
        });
    }
    onInterval() {
        if (this.innerLanguageClient !== undefined && this.configuration !== undefined) {
            const params = {
                freeMemory: os.freemem() / 1048576
            };
            this.languageClient.sendNotification(IntervalTimerNotification, params);
            this.configuration.checkCppProperties();
            this.configuration.checkCompileCommands();
        }
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
        this.disposables = [];
        if (this.documentFormattingProviderDisposable) {
            this.documentFormattingProviderDisposable.dispose();
            this.documentFormattingProviderDisposable = undefined;
        }
        if (this.formattingRangeProviderDisposable) {
            this.formattingRangeProviderDisposable.dispose();
            this.formattingRangeProviderDisposable = undefined;
        }
        if (this.onTypeFormattingProviderDisposable) {
            this.onTypeFormattingProviderDisposable.dispose();
            this.onTypeFormattingProviderDisposable = undefined;
        }
        if (this.codeFoldingProviderDisposable) {
            this.codeFoldingProviderDisposable.dispose();
            this.codeFoldingProviderDisposable = undefined;
        }
        if (this.semanticTokensProviderDisposable) {
            this.semanticTokensProviderDisposable.dispose();
            this.semanticTokensProviderDisposable = undefined;
        }
        this.model.dispose();
    }
    static stopLanguageClient() {
        return languageClient ? languageClient.stop() : Promise.resolve();
    }
    handleReferencesIcon() {
        this.notifyWhenLanguageClientReady(() => {
            const cancelling = DefaultClient.referencesPendingCancellations.length > 0;
            if (!cancelling) {
                exports.workspaceReferences.UpdateProgressUICounter(this.model.referencesCommandMode.Value);
                if (this.ReferencesCommandMode === refs.ReferencesCommandMode.Find) {
                    if (!exports.workspaceReferences.referencesRequestPending) {
                        if (exports.workspaceReferences.referencesRequestHasOccurred) {
                            if (!exports.workspaceReferences.referencesRefreshPending) {
                                exports.workspaceReferences.referencesRefreshPending = true;
                                vscode.commands.executeCommand("references-view.refresh");
                            }
                        }
                        else {
                            exports.workspaceReferences.referencesRequestHasOccurred = true;
                            exports.workspaceReferences.referencesRequestPending = true;
                            this.languageClient.sendNotification(exports.RequestReferencesNotification, false);
                        }
                    }
                }
            }
        });
    }
    cancelReferences() {
        DefaultClient.referencesParams = undefined;
        DefaultClient.renamePending = false;
        if (DefaultClient.referencesRequestPending || exports.workspaceReferences.symbolSearchInProgress) {
            const cancelling = DefaultClient.referencesPendingCancellations.length > 0;
            DefaultClient.referencesPendingCancellations.push({
                reject: () => { },
                callback: () => { }
            });
            if (!cancelling) {
                exports.workspaceReferences.referencesCanceled = true;
                languageClient.sendNotification(exports.CancelReferencesNotification);
            }
        }
    }
    handleReferencesProgress(notificationBody) {
        exports.workspaceReferences.handleProgress(notificationBody);
    }
    processReferencesResult(referencesResult) {
        exports.workspaceReferences.processResults(referencesResult);
    }
    setReferencesCommandMode(mode) {
        this.model.referencesCommandMode.Value = mode;
    }
    abortRequest(id) {
        const params = {
            id: id
        };
        languageClient.sendNotification(AbortRequestNotification, params);
    }
}
exports.DefaultClient = DefaultClient;
DefaultClient.abortRequestId = 0;
DefaultClient.referencesRequestPending = false;
DefaultClient.referencesPendingCancellations = [];
DefaultClient.renameRequestsPending = 0;
DefaultClient.renamePending = false;
function getLanguageServerFileName() {
    let extensionProcessName = 'cpptools';
    const plat = process.platform;
    if (plat === 'win32') {
        extensionProcessName += '.exe';
    }
    else if (plat !== 'linux' && plat !== 'darwin') {
        throw "Invalid Platform";
    }
    return path.resolve(util.getExtensionFilePath("bin"), extensionProcessName);
}
class NullClient {
    constructor() {
        this.booleanEvent = new vscode.EventEmitter();
        this.numberEvent = new vscode.EventEmitter();
        this.stringEvent = new vscode.EventEmitter();
        this.referencesCommandModeEvent = new vscode.EventEmitter();
        this.RootPath = "/";
        this.RootRealPath = "/";
        this.RootUri = vscode.Uri.file("/");
        this.Name = "(empty)";
        this.TrackedDocuments = new Set();
    }
    get ParsingWorkspaceChanged() { return this.booleanEvent.event; }
    get ParsingWorkspacePausableChanged() { return this.booleanEvent.event; }
    get ParsingWorkspacePausedChanged() { return this.booleanEvent.event; }
    get ParsingFilesChanged() { return this.booleanEvent.event; }
    get IntelliSenseParsingChanged() { return this.booleanEvent.event; }
    get RunningCodeAnalysisChanged() { return this.booleanEvent.event; }
    get CodeAnalysisPausedChanged() { return this.booleanEvent.event; }
    get CodeAnalysisProcessedChanged() { return this.numberEvent.event; }
    get CodeAnalysisTotalChanged() { return this.numberEvent.event; }
    get ReferencesCommandModeChanged() { return this.referencesCommandModeEvent.event; }
    get TagParserStatusChanged() { return this.stringEvent.event; }
    get ActiveConfigChanged() { return this.stringEvent.event; }
    onDidChangeSettings(event, isFirstClient) { return {}; }
    onDidOpenTextDocument(document) { }
    onDidCloseTextDocument(document) { }
    onDidChangeVisibleTextEditor(editor) { }
    onDidChangeTextDocument(textDocumentChangeEvent) { }
    onRegisterCustomConfigurationProvider(provider) { return Promise.resolve(); }
    updateCustomConfigurations(requestingProvider) { return Promise.resolve(); }
    updateCustomBrowseConfiguration(requestingProvider) { return Promise.resolve(); }
    provideCustomConfiguration(docUri, requestFile) { return Promise.resolve(); }
    logDiagnostics() { return Promise.resolve(); }
    rescanFolder() { return Promise.resolve(); }
    toggleReferenceResultsView() { }
    setCurrentConfigName(configurationName) { return Promise.resolve(); }
    getCurrentConfigName() { return Promise.resolve(""); }
    getCurrentConfigCustomVariable(variableName) { return Promise.resolve(""); }
    getVcpkgInstalled() { return Promise.resolve(false); }
    getVcpkgEnabled() { return Promise.resolve(false); }
    getCurrentCompilerPathAndArgs() { return Promise.resolve(undefined); }
    getKnownCompilers() { return Promise.resolve([]); }
    takeOwnership(document) { }
    queueTask(task) { return Promise.resolve(task()); }
    requestWhenReady(request) { return request(); }
    notifyWhenLanguageClientReady(notify) { }
    awaitUntilLanguageClientReady() { }
    requestSwitchHeaderSource(rootPath, fileName) { return Promise.resolve(""); }
    activeDocumentChanged(document) { return Promise.resolve(); }
    restartIntelliSenseForFile(document) { return Promise.resolve(); }
    activate() { }
    selectionChanged(selection) { }
    resetDatabase() { }
    deactivate() { }
    pauseParsing() { }
    resumeParsing() { }
    PauseCodeAnalysis() { }
    ResumeCodeAnalysis() { }
    CancelCodeAnalysis() { }
    handleConfigurationSelectCommand() { return Promise.resolve(); }
    handleConfigurationProviderSelectCommand() { return Promise.resolve(); }
    handleShowParsingCommands() { return Promise.resolve(); }
    handleShowCodeAnalysisCommands() { return Promise.resolve(); }
    handleReferencesIcon() { }
    handleConfigurationEditCommand(viewColumn) { }
    handleConfigurationEditJSONCommand(viewColumn) { }
    handleConfigurationEditUICommand(viewColumn) { }
    handleAddToIncludePathCommand(path) { }
    handleGoToDirectiveInGroup(next) { return Promise.resolve(); }
    handleCheckForCompiler() { return Promise.resolve(); }
    handleRunCodeAnalysisOnActiveFile() { return Promise.resolve(); }
    handleRunCodeAnalysisOnOpenFiles() { return Promise.resolve(); }
    handleRunCodeAnalysisOnAllFiles() { return Promise.resolve(); }
    handleClearCodeAnalysisSquiggles() { return Promise.resolve(); }
    onInterval() { }
    dispose() {
        this.booleanEvent.dispose();
        this.stringEvent.dispose();
    }
    addFileAssociations(fileAssociations, languageId) { }
    sendDidChangeSettings(settings) { }
}


/***/ }),

/***/ 3765:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientCollection = void 0;
const vscode = __webpack_require__(7549);
const util = __webpack_require__(5331);
const cpptools = __webpack_require__(9325);
const telemetry = __webpack_require__(1818);
const customProviders_1 = __webpack_require__(4977);
const timeTelemetryCollector_1 = __webpack_require__(9071);
const defaultClientKey = "@@default@@";
class ClientCollection {
    constructor() {
        this.disposables = [];
        this.languageClients = new Map();
        this.timeTelemetryCollector = new timeTelemetryCollector_1.TimeTelemetryCollector();
        let key = defaultClientKey;
        if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
            let isFirstWorkspaceFolder = true;
            vscode.workspace.workspaceFolders.forEach(folder => {
                const newClient = cpptools.createClient(this, folder);
                this.languageClients.set(util.asFolder(folder.uri), newClient);
                if (isFirstWorkspaceFolder) {
                    isFirstWorkspaceFolder = false;
                }
                else {
                    newClient.deactivate();
                }
            });
            key = util.asFolder(vscode.workspace.workspaceFolders[0].uri);
            const client = this.languageClients.get(key);
            if (!client) {
                throw new Error("Failed to construct default client");
            }
            this.activeClient = client;
        }
        else {
            this.activeClient = cpptools.createClient(this);
        }
        this.defaultClient = this.activeClient;
        this.languageClients.set(key, this.activeClient);
        this.disposables.push(vscode.workspace.onDidChangeWorkspaceFolders(e => this.onDidChangeWorkspaceFolders(e)));
        this.disposables.push(vscode.workspace.onDidCloseTextDocument(d => this.onDidCloseTextDocument(d)));
    }
    get ActiveClient() { return this.activeClient; }
    get Names() {
        const result = [];
        this.languageClients.forEach((client, key) => {
            result.push({ name: client.Name, key: key });
        });
        return result;
    }
    get Count() { return this.languageClients.size; }
    activeDocumentChanged(document) {
        return __awaiter(this, void 0, void 0, function* () {
            this.activeDocument = document;
            const activeClient = this.getClientFor(document.uri);
            yield activeClient.activeDocumentChanged(document);
            if (activeClient !== this.activeClient) {
                activeClient.activate();
                this.activeClient.deactivate();
                this.activeClient = activeClient;
            }
        });
    }
    get(key) {
        const client = this.languageClients.get(key);
        console.assert(client, "key not found");
        return client;
    }
    forEach(callback) {
        const languageClients = [];
        this.languageClients.forEach(client => languageClients.push(client));
        languageClients.forEach(callback);
    }
    checkOwnership(client, document) {
        return (this.getClientFor(document.uri) === client);
    }
    replace(client, transferFileOwnership) {
        let key;
        for (const pair of this.languageClients) {
            if (pair[1] === client) {
                key = pair[0];
                break;
            }
        }
        if (key) {
            this.languageClients.delete(key);
            if (transferFileOwnership) {
                client.TrackedDocuments.forEach(document => this.transferOwnership(document, client));
                client.TrackedDocuments.clear();
            }
            else {
                this.languageClients.set(key, cpptools.createNullClient());
            }
            if (this.activeClient === client && this.activeDocument) {
                this.activeClient = this.getClientFor(this.activeDocument.uri);
                this.activeClient.activeDocumentChanged(this.activeDocument);
            }
            client.dispose();
            return this.languageClients.get(key);
        }
        else {
            console.assert(key, "unable to locate language client");
            return undefined;
        }
    }
    onDidChangeWorkspaceFolders(e) {
        const folderCount = vscode.workspace.workspaceFolders ? vscode.workspace.workspaceFolders.length : 0;
        if (folderCount > 1) {
            telemetry.logLanguageServerEvent("workspaceFoldersChange", { "count": folderCount.toString() });
        }
        if (e !== undefined) {
            e.removed.forEach(folder => {
                const path = util.asFolder(folder.uri);
                const client = this.languageClients.get(path);
                if (client) {
                    this.languageClients.delete(path);
                    client.TrackedDocuments.forEach(document => this.transferOwnership(document, client));
                    client.TrackedDocuments.clear();
                    if (this.activeClient === client && this.activeDocument) {
                        this.activeClient = this.getClientFor(this.activeDocument.uri);
                        this.activeClient.activeDocumentChanged(this.activeDocument);
                    }
                    client.dispose();
                }
            });
            e.added.forEach(folder => {
                const path = util.asFolder(folder.uri);
                const client = this.languageClients.get(path);
                if (!client) {
                    const newClient = cpptools.createClient(this, folder);
                    this.languageClients.set(path, newClient);
                    newClient.deactivate();
                    const defaultClient = newClient;
                    defaultClient.sendAllSettings();
                }
            });
        }
    }
    transferOwnership(document, oldOwner) {
        const newOwner = this.getClientFor(document.uri);
        if (newOwner !== oldOwner) {
            newOwner.takeOwnership(document);
        }
    }
    getClientFor(uri) {
        const folder = uri ? vscode.workspace.getWorkspaceFolder(uri) : undefined;
        if (!folder) {
            return this.defaultClient;
        }
        else {
            const key = util.asFolder(folder.uri);
            const client = this.languageClients.get(key);
            if (client) {
                return client;
            }
            const newClient = cpptools.createClient(this, folder);
            this.languageClients.set(key, newClient);
            (0, customProviders_1.getCustomConfigProviders)().forEach(provider => newClient.onRegisterCustomConfigurationProvider(provider));
            const defaultClient = newClient;
            defaultClient.sendAllSettings();
            return newClient;
        }
    }
    onDidCloseTextDocument(document) {
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
        this.languageClients.forEach(client => client.dispose());
        this.languageClients.clear();
        cpptools.disposeWorkspaceData();
        return cpptools.DefaultClient.stopLanguageClient();
    }
}
exports.ClientCollection = ClientCollection;


/***/ }),

/***/ 6932:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CppProperties = void 0;
const path = __webpack_require__(5622);
const fs = __webpack_require__(5747);
const vscode = __webpack_require__(7549);
const util = __webpack_require__(5331);
const telemetry = __webpack_require__(1818);
const persistentState_1 = __webpack_require__(1102);
const settings_1 = __webpack_require__(296);
const customProviders_1 = __webpack_require__(4977);
const settingsPanel_1 = __webpack_require__(7597);
const os = __webpack_require__(2087);
const escapeStringRegExp = __webpack_require__(4419);
const jsonc = __webpack_require__(634);
const nls = __webpack_require__(3463);
const timers_1 = __webpack_require__(8213);
const which = __webpack_require__(8750);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\configurations.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\configurations.ts'));
const configVersion = 4;
function getDefaultConfig() {
    if (process.platform === 'darwin') {
        return { name: "Mac" };
    }
    else if (process.platform === 'win32') {
        return { name: "Win32" };
    }
    else {
        return { name: "Linux" };
    }
}
function getDefaultCppProperties() {
    return {
        configurations: [getDefaultConfig()],
        version: configVersion
    };
}
class CppProperties {
    constructor(rootUri, workspaceFolder) {
        this.propertiesFile = undefined;
        this.configFileWatcher = null;
        this.configFileWatcherFallbackTime = new Date();
        this.compileCommandsFile = undefined;
        this.compileCommandsFileWatchers = [];
        this.compileCommandsFileWatcherFallbackTime = new Date();
        this.defaultCompilerPath = null;
        this.defaultCStandard = null;
        this.defaultCppStandard = null;
        this.defaultIncludes = null;
        this.defaultWindowsSdkVersion = null;
        this.vcpkgIncludes = [];
        this.vcpkgPathReady = false;
        this.nodeAddonIncludes = [];
        this.configurationGlobPattern = "c_cpp_properties.json";
        this.disposables = [];
        this.configurationsChanged = new vscode.EventEmitter();
        this.selectionChanged = new vscode.EventEmitter();
        this.compileCommandsChanged = new vscode.EventEmitter();
        this.prevSquiggleMetrics = new Map();
        this.rootfs = null;
        this.configurationIncomplete = true;
        this.compileCommandsFileWatcherFiles = new Set();
        this.rootUri = rootUri;
        const rootPath = rootUri ? rootUri.fsPath : "";
        if (workspaceFolder) {
            this.currentConfigurationIndex = new persistentState_1.PersistentFolderState("CppProperties.currentConfigurationIndex", -1, workspaceFolder);
            this.lastCustomBrowseConfiguration = new persistentState_1.PersistentFolderState("CPP.lastCustomBrowseConfiguration", undefined, workspaceFolder);
            this.lastCustomBrowseConfigurationProviderId = new persistentState_1.PersistentFolderState("CPP.lastCustomBrowseConfigurationProviderId", undefined, workspaceFolder);
        }
        this.configFolder = path.join(rootPath, ".vscode");
        this.diagnosticCollection = vscode.languages.createDiagnosticCollection(rootPath);
        this.buildVcpkgIncludePath();
        const userSettings = new settings_1.CppSettings();
        if (userSettings.addNodeAddonIncludePaths) {
            this.readNodeAddonIncludeLocations(rootPath);
        }
        this.disposables.push(vscode.Disposable.from(this.configurationsChanged, this.selectionChanged, this.compileCommandsChanged));
    }
    get ConfigurationsChanged() { return this.configurationsChanged.event; }
    get SelectionChanged() { return this.selectionChanged.event; }
    get CompileCommandsChanged() { return this.compileCommandsChanged.event; }
    get Configurations() { return this.configurationJson ? this.configurationJson.configurations : undefined; }
    get CurrentConfigurationIndex() { return this.currentConfigurationIndex === undefined ? 0 : this.currentConfigurationIndex.Value; }
    get CurrentConfiguration() { return this.Configurations ? this.Configurations[this.CurrentConfigurationIndex] : undefined; }
    get KnownCompiler() { return this.knownCompilers; }
    get LastCustomBrowseConfiguration() { return this.lastCustomBrowseConfiguration; }
    get LastCustomBrowseConfigurationProviderId() { return this.lastCustomBrowseConfigurationProviderId; }
    get CurrentConfigurationProvider() {
        var _a;
        if ((_a = this.CurrentConfiguration) === null || _a === void 0 ? void 0 : _a.configurationProvider) {
            return this.CurrentConfiguration.configurationProvider;
        }
        return new settings_1.CppSettings(this.rootUri).defaultConfigurationProvider;
    }
    get ConfigurationNames() {
        const result = [];
        if (this.configurationJson) {
            this.configurationJson.configurations.forEach((config) => {
                result.push(config.name);
            });
        }
        return result;
    }
    set CompilerDefaults(compilerDefaults) {
        this.defaultCompilerPath = compilerDefaults.compilerPath;
        this.knownCompilers = compilerDefaults.knownCompilers;
        this.defaultCStandard = compilerDefaults.cStandard;
        this.defaultCppStandard = compilerDefaults.cppStandard;
        this.defaultIncludes = compilerDefaults.includes;
        this.defaultFrameworks = compilerDefaults.frameworks;
        this.defaultWindowsSdkVersion = compilerDefaults.windowsSdkVersion;
        this.defaultIntelliSenseMode = compilerDefaults.intelliSenseMode;
        this.rootfs = compilerDefaults.rootfs;
        const configFilePath = path.join(this.configFolder, "c_cpp_properties.json");
        if (this.rootUri !== null && fs.existsSync(configFilePath)) {
            this.propertiesFile = vscode.Uri.file(configFilePath);
        }
        else {
            this.propertiesFile = null;
        }
        const settingsPath = path.join(this.configFolder, this.configurationGlobPattern);
        this.configFileWatcher = vscode.workspace.createFileSystemWatcher(settingsPath);
        this.disposables.push(this.configFileWatcher);
        this.configFileWatcher.onDidCreate((uri) => {
            this.propertiesFile = uri;
            this.handleConfigurationChange();
        });
        this.configFileWatcher.onDidDelete(() => {
            this.propertiesFile = null;
            this.resetToDefaultSettings(true);
            this.handleConfigurationChange();
        });
        this.configFileWatcher.onDidChange(() => {
            let alreadyTracking = false;
            for (let i = 0; i < vscode.workspace.textDocuments.length; i++) {
                if (vscode.workspace.textDocuments[i].uri.fsPath === settingsPath) {
                    alreadyTracking = true;
                    break;
                }
            }
            if (!alreadyTracking) {
                this.handleConfigurationChange();
            }
        });
        vscode.workspace.onDidChangeTextDocument((e) => {
            if (e.document.uri.fsPath === settingsPath) {
                this.handleConfigurationChange();
            }
        });
        vscode.workspace.onDidSaveTextDocument((doc) => {
            const savedDocWorkspaceFolder = vscode.workspace.getWorkspaceFolder(doc.uri);
            const notifyingWorkspaceFolder = vscode.workspace.getWorkspaceFolder(vscode.Uri.file(settingsPath));
            if ((!savedDocWorkspaceFolder && vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0 && notifyingWorkspaceFolder === vscode.workspace.workspaceFolders[0])
                || savedDocWorkspaceFolder === notifyingWorkspaceFolder) {
                let fileType;
                const documentPath = doc.uri.fsPath.toLowerCase();
                if (documentPath.endsWith("cmakelists.txt")) {
                    fileType = "CMakeLists";
                }
                else if (documentPath.endsWith("cmakecache.txt")) {
                    fileType = "CMakeCache";
                }
                else if (documentPath.endsWith(".cmake")) {
                    fileType = ".cmake";
                }
                if (fileType) {
                    telemetry.logLanguageServerEvent("cmakeFileWrite", {
                        filetype: fileType,
                        outside: (savedDocWorkspaceFolder === undefined).toString()
                    });
                }
            }
        });
        this.handleConfigurationChange();
    }
    get VcpkgInstalled() {
        return this.vcpkgIncludes.length > 0;
    }
    onConfigurationsChanged() {
        if (this.Configurations) {
            this.configurationsChanged.fire(this);
        }
    }
    onSelectionChanged() {
        this.selectionChanged.fire(this.CurrentConfigurationIndex);
        this.handleSquiggles();
    }
    onCompileCommandsChanged(path) {
        this.compileCommandsChanged.fire(path);
    }
    onDidChangeSettings() {
        if (!this.propertiesFile) {
            this.resetToDefaultSettings(true);
            this.handleConfigurationChange();
        }
        else if (!this.configurationIncomplete) {
            this.handleConfigurationChange();
        }
    }
    resetToDefaultSettings(resetIndex) {
        this.configurationJson = getDefaultCppProperties();
        if (resetIndex || this.CurrentConfigurationIndex < 0 ||
            this.CurrentConfigurationIndex >= this.configurationJson.configurations.length) {
            const index = this.getConfigIndexForPlatform(this.configurationJson);
            if (this.currentConfigurationIndex !== undefined) {
                if (index === undefined) {
                    this.currentConfigurationIndex.setDefault();
                }
                else {
                    this.currentConfigurationIndex.Value = index;
                }
            }
        }
        this.configurationIncomplete = true;
    }
    applyDefaultIncludePathsAndFrameworks() {
        if (this.configurationIncomplete && this.defaultIncludes && this.defaultFrameworks && this.vcpkgPathReady) {
            const configuration = this.CurrentConfiguration;
            if (configuration) {
                this.applyDefaultConfigurationValues(configuration);
                this.configurationIncomplete = false;
            }
        }
    }
    applyDefaultConfigurationValues(configuration) {
        const settings = new settings_1.CppSettings(this.rootUri);
        const isUnset = (input) => input === null || input === undefined;
        const rootFolder = "${workspaceFolder}/**";
        const defaultFolder = "${default}";
        if (isUnset(settings.defaultIncludePath)) {
            configuration.includePath = [rootFolder].concat(this.vcpkgIncludes);
        }
        else {
            configuration.includePath = [defaultFolder];
        }
        if (isUnset(settings.defaultDefines)) {
            configuration.defines = (process.platform === 'win32') ? ["_DEBUG", "UNICODE", "_UNICODE"] : [];
        }
        if (isUnset(settings.defaultMacFrameworkPath) && process.platform === 'darwin') {
            configuration.macFrameworkPath = this.defaultFrameworks;
        }
        if ((isUnset(settings.defaultWindowsSdkVersion) || settings.defaultWindowsSdkVersion === "") && this.defaultWindowsSdkVersion && process.platform === 'win32') {
            configuration.windowsSdkVersion = this.defaultWindowsSdkVersion;
        }
        if (isUnset(settings.defaultCompilerPath) && this.defaultCompilerPath &&
            (isUnset(settings.defaultCompileCommands) || settings.defaultCompileCommands === "") && !configuration.compileCommands) {
            configuration.compilerPath = this.defaultCompilerPath;
        }
        if ((isUnset(settings.defaultCStandard) || settings.defaultCStandard === "") && this.defaultCStandard) {
            configuration.cStandard = this.defaultCStandard;
        }
        if ((isUnset(settings.defaultCppStandard) || settings.defaultCppStandard === "") && this.defaultCppStandard) {
            configuration.cppStandard = this.defaultCppStandard;
        }
        if (isUnset(settings.defaultIntelliSenseMode) || settings.defaultIntelliSenseMode === "") {
            configuration.intelliSenseMode = this.defaultIntelliSenseMode;
        }
        if (isUnset(settings.defaultCustomConfigurationVariables) || settings.defaultCustomConfigurationVariables === {}) {
            configuration.customConfigurationVariables = this.defaultCustomConfigurationVariables;
        }
    }
    get ExtendedEnvironment() {
        var _a;
        const result = {};
        if ((_a = this.configurationJson) === null || _a === void 0 ? void 0 : _a.env) {
            Object.assign(result, this.configurationJson.env);
        }
        result["workspaceFolderBasename"] = this.rootUri ? path.basename(this.rootUri.fsPath) : "";
        result["execPath"] = process.execPath;
        result["pathSeparator"] = (os.platform() === 'win32') ? "\\" : "/";
        return result;
    }
    buildVcpkgIncludePath() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const vcpkgRoot = util.getVcpkgRoot();
                if (vcpkgRoot) {
                    const list = yield util.readDir(vcpkgRoot);
                    if (list !== undefined) {
                        list.forEach((entry) => {
                            if (entry !== "vcpkg") {
                                const pathToCheck = path.join(vcpkgRoot, entry);
                                if (fs.existsSync(pathToCheck)) {
                                    let p = path.join(pathToCheck, "include");
                                    if (fs.existsSync(p)) {
                                        p = p.replace(/\\/g, "/");
                                        p = p.replace(vcpkgRoot, "${vcpkgRoot}");
                                        this.vcpkgIncludes.push(p);
                                    }
                                }
                            }
                        });
                    }
                }
            }
            catch (error) { }
            finally {
                this.vcpkgPathReady = true;
                this.handleConfigurationChange();
            }
        });
    }
    nodeAddonIncludesFound() {
        return this.nodeAddonIncludes.length;
    }
    readNodeAddonIncludeLocations(rootPath) {
        return __awaiter(this, void 0, void 0, function* () {
            let error;
            let pdjFound = false;
            let packageJson;
            try {
                packageJson = JSON.parse(yield fs.promises.readFile(path.join(rootPath, "package.json"), "utf8"));
                pdjFound = true;
            }
            catch (errJS) {
                const err = errJS;
                error = err;
            }
            if (!error) {
                try {
                    const pathToNode = which.sync("node");
                    const nodeAddonMap = [
                        ["node-addon-api", `"${pathToNode}" --no-warnings -p "require('node-addon-api').include"`],
                        ["nan", `"${pathToNode}" --no-warnings -e "require('nan')"`]
                    ];
                    const pathToYarn = which.sync("yarn", { nothrow: true });
                    if (pathToYarn && (yield util.checkDirectoryExists(path.join(rootPath, ".yarn/cache")))) {
                        nodeAddonMap.push(["node-addon-api", `"${pathToYarn}" node --no-warnings -p "require('node-addon-api').include"`], ["nan", `"${pathToYarn}" node --no-warnings -e "require('nan')"`]);
                    }
                    for (const [dep, execCmd] of nodeAddonMap) {
                        if (dep in packageJson.dependencies) {
                            try {
                                let stdout = yield util.execChildProcess(execCmd, rootPath);
                                if (!stdout) {
                                    continue;
                                }
                                if (stdout[stdout.length - 1] === "\n") {
                                    stdout = stdout.slice(0, -1);
                                }
                                if (stdout[0] === "\"" && stdout[stdout.length - 1] === "\"") {
                                    stdout = stdout.slice(1, -1);
                                }
                                if (!(yield util.checkDirectoryExists(stdout))) {
                                    stdout = path.join(rootPath, stdout);
                                    if (!(yield util.checkDirectoryExists(stdout))) {
                                        error = new Error(`${dep} directory ${stdout} doesn't exist`);
                                        stdout = '';
                                    }
                                }
                                if (stdout) {
                                    this.nodeAddonIncludes.push(stdout);
                                }
                            }
                            catch (errJS) {
                                const err = errJS;
                                console.log('readNodeAddonIncludeLocations', err.message);
                            }
                        }
                    }
                }
                catch (errJS) {
                    const e = errJS;
                    error = e;
                }
            }
            if (error) {
                if (pdjFound) {
                    console.log('readNodeAddonIncludeLocations', error.message);
                }
            }
            else {
                this.handleConfigurationChange();
            }
        });
    }
    getConfigIndexForPlatform(config) {
        if (!this.configurationJson) {
            return undefined;
        }
        let plat;
        if (process.platform === 'darwin') {
            plat = "Mac";
        }
        else if (process.platform === 'win32') {
            plat = "Win32";
        }
        else {
            plat = "Linux";
        }
        for (let i = 0; i < this.configurationJson.configurations.length; i++) {
            if (config.configurations[i].name === plat) {
                return i;
            }
        }
        return this.configurationJson.configurations.length - 1;
    }
    getIntelliSenseModeForPlatform(name) {
        if (name === "Linux") {
            return "linux-gcc-x64";
        }
        else if (name === "Mac") {
            return "macos-clang-x64";
        }
        else if (name === "Win32") {
            return "windows-msvc-x64";
        }
        else if (process.platform === 'win32') {
            return "windows-msvc-x64";
        }
        else if (process.platform === 'darwin') {
            return "macos-clang-x64";
        }
        else {
            return "linux-gcc-x64";
        }
    }
    validateIntelliSenseMode(configuration) {
        if (configuration.compilerPath === undefined ||
            configuration.compilerPath === "" ||
            configuration.compilerPath === "${default}" ||
            configuration.intelliSenseMode === undefined ||
            configuration.intelliSenseMode === "" ||
            configuration.intelliSenseMode === "${default}") {
            return "";
        }
        const resolvedCompilerPath = this.resolvePath(configuration.compilerPath, true);
        const compilerPathAndArgs = util.extractCompilerPathAndArgs(resolvedCompilerPath);
        const isValid = ((compilerPathAndArgs.compilerName.toLowerCase() === "cl.exe" || compilerPathAndArgs.compilerName.toLowerCase() === "cl") === configuration.intelliSenseMode.includes("msvc")
            || (compilerPathAndArgs.compilerName.toLowerCase() === "nvcc.exe") || (compilerPathAndArgs.compilerName.toLowerCase() === "nvcc"));
        if (isValid) {
            return "";
        }
        else {
            return localize(0, null, configuration.intelliSenseMode);
        }
    }
    addToIncludePathCommand(path) {
        this.handleConfigurationEditCommand(() => {
            this.parsePropertiesFile();
            const config = this.CurrentConfiguration;
            if (config) {
                telemetry.logLanguageServerEvent("addToIncludePath");
                if (config.includePath === undefined) {
                    config.includePath = ["${default}"];
                }
                config.includePath.splice(config.includePath.length, 0, path);
                this.writeToJson();
                this.handleConfigurationChange();
            }
        }, () => { });
    }
    updateCustomConfigurationProvider(providerId) {
        return new Promise((resolve) => {
            if (this.propertiesFile) {
                this.handleConfigurationEditJSONCommand(() => {
                    this.parsePropertiesFile();
                    const config = this.CurrentConfiguration;
                    if (config) {
                        if (providerId) {
                            config.configurationProvider = providerId;
                        }
                        else {
                            delete config.configurationProvider;
                        }
                        this.writeToJson();
                        this.handleConfigurationChange();
                    }
                    resolve();
                }, () => { });
            }
            else {
                const settings = new settings_1.CppSettings(this.rootUri);
                if (providerId) {
                    settings.update("default.configurationProvider", providerId);
                }
                else {
                    settings.update("default.configurationProvider", undefined);
                }
                const config = this.CurrentConfiguration;
                if (config) {
                    config.configurationProvider = providerId;
                }
                resolve();
            }
        });
    }
    setCompileCommands(path) {
        this.handleConfigurationEditJSONCommand(() => {
            this.parsePropertiesFile();
            const config = this.CurrentConfiguration;
            if (config) {
                config.compileCommands = path;
                this.writeToJson();
                this.handleConfigurationChange();
            }
        }, () => { });
    }
    select(index) {
        if (this.configurationJson) {
            if (index === this.configurationJson.configurations.length) {
                this.handleConfigurationEditUICommand(() => { }, vscode.window.showTextDocument);
                return;
            }
            if (index === this.configurationJson.configurations.length + 1) {
                this.handleConfigurationEditJSONCommand(() => { }, vscode.window.showTextDocument);
                return;
            }
        }
        if (this.currentConfigurationIndex !== undefined) {
            this.currentConfigurationIndex.Value = index;
        }
        this.onSelectionChanged();
    }
    resolveDefaults(entries, defaultValue) {
        let result = [];
        entries.forEach(entry => {
            if (entry === "${default}") {
                if (defaultValue) {
                    result = result.concat(defaultValue);
                }
            }
            else {
                result.push(entry);
            }
        });
        return result;
    }
    resolveDefaultsDictionary(entries, defaultValue, env) {
        const result = {};
        for (const property in entries) {
            if (property === "${default}") {
                if (defaultValue) {
                    for (const defaultProperty in defaultValue) {
                        if (!(defaultProperty in entries)) {
                            result[defaultProperty] = util.resolveVariables(defaultValue[defaultProperty], env);
                        }
                    }
                }
            }
            else {
                result[property] = util.resolveVariables(entries[property], env);
            }
        }
        return result;
    }
    resolve(entries, defaultValue, env) {
        let result = [];
        if (entries) {
            entries = this.resolveDefaults(entries, defaultValue);
            entries.forEach(entry => {
                const entriesResolved = [];
                const entryResolved = util.resolveVariables(entry, env, entriesResolved);
                result = result.concat(entriesResolved.length === 0 ? entryResolved : entriesResolved);
            });
        }
        return result;
    }
    resolveAndSplit(paths, defaultValue, env) {
        let result = [];
        if (paths) {
            paths = this.resolveDefaults(paths, defaultValue);
            paths.forEach(entry => {
                const entries = util.resolveVariables(entry, env).split(util.envDelimiter).filter(e => e);
                result = result.concat(entries);
            });
        }
        return result;
    }
    updateConfigurationString(property, defaultValue, env, acceptBlank) {
        if (property === null || property === undefined || property === "${default}") {
            property = defaultValue;
        }
        if (property === null || property === undefined || (acceptBlank !== true && property === "")) {
            return undefined;
        }
        return util.resolveVariables(property, env);
    }
    updateConfigurationStringArray(property, defaultValue, env) {
        if (property) {
            return this.resolve(property, defaultValue, env);
        }
        if (!property && defaultValue) {
            return this.resolve(defaultValue, [], env);
        }
        return property;
    }
    updateConfigurationPathsArray(paths, defaultValue, env) {
        if (paths) {
            return this.resolveAndSplit(paths, defaultValue, env);
        }
        if (!paths && defaultValue) {
            return this.resolveAndSplit(defaultValue, [], env);
        }
        return paths;
    }
    updateConfigurationStringOrBoolean(property, defaultValue, env) {
        if (!property || property === "${default}") {
            property = defaultValue;
        }
        if (!property || property === "") {
            return undefined;
        }
        if (typeof property === "boolean") {
            return property;
        }
        return util.resolveVariables(property, env);
    }
    updateConfigurationBoolean(property, defaultValue) {
        if (property === null || property === undefined) {
            property = defaultValue;
        }
        if (property === null) {
            return undefined;
        }
        return property;
    }
    updateConfigurationStringDictionary(property, defaultValue, env) {
        if (!property || property === {}) {
            property = defaultValue;
        }
        if (!property || property === {}) {
            return undefined;
        }
        return this.resolveDefaultsDictionary(property, defaultValue, env);
    }
    updateServerOnFolderSettingsChange() {
        if (!this.configurationJson) {
            return;
        }
        const settings = new settings_1.CppSettings(this.rootUri);
        const userSettings = new settings_1.CppSettings();
        const env = this.ExtendedEnvironment;
        for (let i = 0; i < this.configurationJson.configurations.length; i++) {
            const configuration = this.configurationJson.configurations[i];
            configuration.includePath = this.updateConfigurationPathsArray(configuration.includePath, settings.defaultIncludePath, env);
            const origIncludePath = configuration.includePath;
            if (userSettings.addNodeAddonIncludePaths) {
                const includePath = origIncludePath || [];
                configuration.includePath = includePath.concat(this.nodeAddonIncludes.filter(i => includePath.indexOf(i) < 0));
            }
            configuration.defines = this.updateConfigurationStringArray(configuration.defines, settings.defaultDefines, env);
            configuration.macFrameworkPath = this.updateConfigurationPathsArray(configuration.macFrameworkPath, settings.defaultMacFrameworkPath, env);
            configuration.windowsSdkVersion = this.updateConfigurationString(configuration.windowsSdkVersion, settings.defaultWindowsSdkVersion, env);
            configuration.forcedInclude = this.updateConfigurationPathsArray(configuration.forcedInclude, settings.defaultForcedInclude, env);
            configuration.compileCommands = this.updateConfigurationString(configuration.compileCommands, settings.defaultCompileCommands, env);
            configuration.compilerArgs = this.updateConfigurationStringArray(configuration.compilerArgs, settings.defaultCompilerArgs, env);
            configuration.cStandard = this.updateConfigurationString(configuration.cStandard, settings.defaultCStandard, env);
            configuration.cppStandard = this.updateConfigurationString(configuration.cppStandard, settings.defaultCppStandard, env);
            configuration.intelliSenseMode = this.updateConfigurationString(configuration.intelliSenseMode, settings.defaultIntelliSenseMode, env);
            configuration.intelliSenseModeIsExplicit = configuration.intelliSenseModeIsExplicit || settings.defaultIntelliSenseMode !== "";
            configuration.cStandardIsExplicit = configuration.cStandardIsExplicit || settings.defaultCStandard !== "";
            configuration.cppStandardIsExplicit = configuration.cppStandardIsExplicit || settings.defaultCppStandard !== "";
            configuration.mergeConfigurations = this.updateConfigurationBoolean(configuration.mergeConfigurations, settings.defaultMergeConfigurations);
            if (!configuration.compileCommands) {
                configuration.compilerPath = this.updateConfigurationString(configuration.compilerPath, settings.defaultCompilerPath, env, true);
                configuration.compilerPathIsExplicit = configuration.compilerPathIsExplicit || settings.defaultCompilerPath !== undefined;
                if (configuration.compilerPath === undefined) {
                    if (!!this.defaultCompilerPath) {
                        configuration.compilerPath = this.defaultCompilerPath;
                        if (!configuration.cStandard && !!this.defaultCStandard) {
                            configuration.cStandard = this.defaultCStandard;
                            configuration.cStandardIsExplicit = false;
                        }
                        if (!configuration.cppStandard && !!this.defaultCppStandard) {
                            configuration.cppStandard = this.defaultCppStandard;
                            configuration.cppStandardIsExplicit = false;
                        }
                        if (!configuration.intelliSenseMode && !!this.defaultIntelliSenseMode) {
                            configuration.intelliSenseMode = this.defaultIntelliSenseMode;
                            configuration.intelliSenseModeIsExplicit = false;
                        }
                        if (!configuration.windowsSdkVersion && !!this.defaultWindowsSdkVersion) {
                            configuration.windowsSdkVersion = this.defaultWindowsSdkVersion;
                        }
                        if (!origIncludePath && !!this.defaultIncludes) {
                            const includePath = configuration.includePath || [];
                            configuration.includePath = includePath.concat(this.defaultIncludes);
                        }
                        if (!configuration.macFrameworkPath && !!this.defaultFrameworks) {
                            configuration.macFrameworkPath = this.defaultFrameworks;
                        }
                    }
                }
            }
            else {
                if (configuration.compilerPath === "${default}") {
                    configuration.compilerPath = settings.defaultCompilerPath;
                }
                if (configuration.compilerPath === null) {
                    configuration.compilerPath = undefined;
                    configuration.compilerPathIsExplicit = true;
                }
                else if (configuration.compilerPath !== undefined) {
                    configuration.compilerPath = util.resolveVariables(configuration.compilerPath, env);
                    configuration.compilerPathIsExplicit = true;
                }
                else {
                    configuration.compilerPathIsExplicit = false;
                }
            }
            configuration.customConfigurationVariables = this.updateConfigurationStringDictionary(configuration.customConfigurationVariables, settings.defaultCustomConfigurationVariables, env);
            configuration.configurationProvider = this.updateConfigurationString(configuration.configurationProvider, settings.defaultConfigurationProvider, env);
            if (!configuration.browse) {
                configuration.browse = {};
            }
            if (!configuration.browse.path) {
                if (settings.defaultBrowsePath) {
                    configuration.browse.path = settings.defaultBrowsePath;
                }
                else if (configuration.includePath) {
                    configuration.browse.path = configuration.includePath.slice(0);
                    if (configuration.includePath.findIndex((value, index) => !!value.match(/^\$\{(workspaceRoot|workspaceFolder)\}(\\\*{0,2}|\/\*{0,2})?$/g)) === -1) {
                        configuration.browse.path.push("${workspaceFolder}");
                    }
                }
            }
            else {
                configuration.browse.path = this.updateConfigurationPathsArray(configuration.browse.path, settings.defaultBrowsePath, env);
            }
            configuration.browse.limitSymbolsToIncludedHeaders = this.updateConfigurationStringOrBoolean(configuration.browse.limitSymbolsToIncludedHeaders, settings.defaultLimitSymbolsToIncludedHeaders, env);
            configuration.browse.databaseFilename = this.updateConfigurationString(configuration.browse.databaseFilename, settings.defaultDatabaseFilename, env);
            if (i === this.CurrentConfigurationIndex) {
                const providers = (0, customProviders_1.getCustomConfigProviders)();
                const hasEmptyConfiguration = !this.propertiesFile
                    && !settings.defaultCompilerPath
                    && settings.defaultCompilerPath !== ""
                    && !settings.defaultIncludePath
                    && !settings.defaultDefines
                    && !settings.defaultMacFrameworkPath
                    && settings.defaultWindowsSdkVersion === ""
                    && !settings.defaultForcedInclude
                    && settings.defaultCompileCommands === ""
                    && !settings.defaultCompilerArgs
                    && settings.defaultCStandard === ""
                    && settings.defaultCppStandard === ""
                    && settings.defaultIntelliSenseMode === ""
                    && settings.defaultConfigurationProvider === "";
                let keepCachedBrowseConfig = true;
                if (hasEmptyConfiguration) {
                    if (providers.size === 1) {
                        providers.forEach(provider => { configuration.configurationProvider = provider.extensionId; });
                        if (this.lastCustomBrowseConfigurationProviderId !== undefined) {
                            keepCachedBrowseConfig = configuration.configurationProvider === this.lastCustomBrowseConfigurationProviderId.Value;
                        }
                    }
                    else if (this.lastCustomBrowseConfigurationProviderId !== undefined
                        && !!this.lastCustomBrowseConfigurationProviderId.Value) {
                        configuration.configurationProvider = this.lastCustomBrowseConfigurationProviderId.Value;
                    }
                }
                else if (this.lastCustomBrowseConfigurationProviderId !== undefined) {
                    keepCachedBrowseConfig = configuration.configurationProvider === this.lastCustomBrowseConfigurationProviderId.Value;
                }
                if (!keepCachedBrowseConfig && this.lastCustomBrowseConfiguration !== undefined) {
                    this.lastCustomBrowseConfiguration.Value = undefined;
                }
            }
        }
        this.updateCompileCommandsFileWatchers();
        if (!this.configurationIncomplete) {
            this.onConfigurationsChanged();
        }
    }
    updateCompileCommandsFileWatchers() {
        if (this.configurationJson) {
            this.compileCommandsFileWatchers.forEach((watcher) => watcher.close());
            this.compileCommandsFileWatchers = [];
            const filePaths = new Set();
            this.configurationJson.configurations.forEach(c => {
                if (c.compileCommands) {
                    const fileSystemCompileCommandsPath = this.resolvePath(c.compileCommands, os.platform() === "win32");
                    if (fs.existsSync(fileSystemCompileCommandsPath)) {
                        filePaths.add(fileSystemCompileCommandsPath);
                    }
                }
            });
            try {
                filePaths.forEach((path) => {
                    this.compileCommandsFileWatchers.push(fs.watch(path, (event, filename) => {
                        if (this.compileCommandsFileWatcherTimer) {
                            clearInterval(this.compileCommandsFileWatcherTimer);
                        }
                        this.compileCommandsFileWatcherFiles.add(path);
                        this.compileCommandsFileWatcherTimer = (0, timers_1.setTimeout)(() => {
                            this.compileCommandsFileWatcherFiles.forEach((path) => {
                                this.onCompileCommandsChanged(path);
                            });
                            if (this.compileCommandsFileWatcherTimer) {
                                clearInterval(this.compileCommandsFileWatcherTimer);
                            }
                            this.compileCommandsFileWatcherFiles.clear();
                            this.compileCommandsFileWatcherTimer = undefined;
                        }, 1000);
                    }));
                });
            }
            catch (e) {
            }
        }
    }
    handleConfigurationEditCommand(onBeforeOpen, showDocument, viewColumn) {
        const otherSettings = new settings_1.OtherSettings(this.rootUri);
        if (otherSettings.settingsEditor === "ui") {
            this.handleConfigurationEditUICommand(onBeforeOpen, showDocument, viewColumn);
        }
        else {
            this.handleConfigurationEditJSONCommand(onBeforeOpen, showDocument, viewColumn);
        }
    }
    handleConfigurationEditJSONCommand(onBeforeOpen, showDocument, viewColumn) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensurePropertiesFile();
            console.assert(this.propertiesFile);
            if (onBeforeOpen) {
                onBeforeOpen();
            }
            if (this.propertiesFile) {
                const document = yield vscode.workspace.openTextDocument(this.propertiesFile);
                if (showDocument) {
                    showDocument(document, viewColumn);
                }
            }
        });
    }
    ensureSettingsPanelInitlialized() {
        if (this.settingsPanel === undefined) {
            const settings = new settings_1.CppSettings(this.rootUri);
            this.settingsPanel = new settingsPanel_1.SettingsPanel();
            this.settingsPanel.setKnownCompilers(this.knownCompilers, settings.preferredPathSeparator);
            this.settingsPanel.SettingsPanelActivated(() => {
                var _a;
                if ((_a = this.settingsPanel) === null || _a === void 0 ? void 0 : _a.initialized) {
                    this.onSettingsPanelActivated();
                }
            });
            this.settingsPanel.ConfigValuesChanged(() => this.saveConfigurationUI());
            this.settingsPanel.ConfigSelectionChanged(() => this.onConfigSelectionChanged());
            this.settingsPanel.AddConfigRequested((e) => this.onAddConfigRequested(e));
            this.disposables.push(this.settingsPanel);
        }
    }
    handleConfigurationEditUICommand(onBeforeOpen, showDocument, viewColumn) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensurePropertiesFile();
            if (this.propertiesFile) {
                if (onBeforeOpen) {
                    onBeforeOpen();
                }
                if (this.parsePropertiesFile()) {
                    this.ensureSettingsPanelInitlialized();
                    if (this.settingsPanel) {
                        const configNames = this.ConfigurationNames;
                        if (configNames && this.configurationJson) {
                            this.settingsPanel.selectedConfigIndex = this.CurrentConfigurationIndex;
                            this.settingsPanel.createOrShow(configNames, this.configurationJson.configurations[this.settingsPanel.selectedConfigIndex], this.getErrorsForConfigUI(this.settingsPanel.selectedConfigIndex), viewColumn);
                        }
                    }
                }
                else {
                    const document = yield vscode.workspace.openTextDocument(this.propertiesFile);
                    if (showDocument) {
                        showDocument(document, viewColumn);
                    }
                }
            }
        });
    }
    onSettingsPanelActivated() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.configurationJson) {
                yield this.ensurePropertiesFile();
                if (this.propertiesFile) {
                    if (this.parsePropertiesFile()) {
                        const configNames = this.ConfigurationNames;
                        if (configNames && this.settingsPanel && this.configurationJson) {
                            if (this.settingsPanel.selectedConfigIndex >= this.configurationJson.configurations.length) {
                                this.settingsPanel.selectedConfigIndex = this.CurrentConfigurationIndex;
                            }
                            this.settingsPanel.updateConfigUI(configNames, this.configurationJson.configurations[this.settingsPanel.selectedConfigIndex], this.getErrorsForConfigUI(this.settingsPanel.selectedConfigIndex));
                        }
                        else {
                            vscode.workspace.openTextDocument(this.propertiesFile);
                        }
                    }
                }
            }
        });
    }
    saveConfigurationUI() {
        this.parsePropertiesFile();
        if (this.settingsPanel && this.configurationJson) {
            const config = this.settingsPanel.getLastValuesFromConfigUI();
            this.configurationJson.configurations[this.settingsPanel.selectedConfigIndex] = config;
            this.settingsPanel.updateErrors(this.getErrorsForConfigUI(this.settingsPanel.selectedConfigIndex));
            this.writeToJson();
        }
    }
    onConfigSelectionChanged() {
        const configNames = this.ConfigurationNames;
        if (configNames && this.settingsPanel && this.configurationJson) {
            this.settingsPanel.updateConfigUI(configNames, this.configurationJson.configurations[this.settingsPanel.selectedConfigIndex], this.getErrorsForConfigUI(this.settingsPanel.selectedConfigIndex));
        }
    }
    onAddConfigRequested(configName) {
        this.parsePropertiesFile();
        const newConfig = { name: configName };
        this.applyDefaultConfigurationValues(newConfig);
        const configNames = this.ConfigurationNames;
        if (configNames && this.settingsPanel && this.configurationJson) {
            this.configurationJson.configurations.push(newConfig);
            this.settingsPanel.selectedConfigIndex = this.configurationJson.configurations.length - 1;
            this.settingsPanel.updateConfigUI(configNames, this.configurationJson.configurations[this.settingsPanel.selectedConfigIndex], null);
            this.writeToJson();
        }
    }
    handleConfigurationChange() {
        if (this.propertiesFile === undefined) {
            return;
        }
        this.configFileWatcherFallbackTime = new Date();
        if (this.propertiesFile) {
            this.parsePropertiesFile();
            if (this.configurationJson) {
                if (this.CurrentConfigurationIndex < 0 ||
                    this.CurrentConfigurationIndex >= this.configurationJson.configurations.length) {
                    const index = this.getConfigIndexForPlatform(this.configurationJson);
                    if (this.currentConfigurationIndex !== undefined) {
                        if (!index) {
                            this.currentConfigurationIndex.setDefault();
                        }
                        else {
                            this.currentConfigurationIndex.Value = index;
                        }
                    }
                }
            }
        }
        if (!this.configurationJson) {
            this.resetToDefaultSettings(true);
        }
        this.applyDefaultIncludePathsAndFrameworks();
        this.updateServerOnFolderSettingsChange();
    }
    ensurePropertiesFile() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.propertiesFile && (yield util.checkFileExists(this.propertiesFile.fsPath))) {
                return;
            }
            else {
                try {
                    if (!(yield util.checkDirectoryExists(this.configFolder))) {
                        fs.mkdirSync(this.configFolder);
                    }
                    const fullPathToFile = path.join(this.configFolder, "c_cpp_properties.json");
                    const settings = new settings_1.CppSettings(this.rootUri);
                    let providerId = settings.defaultConfigurationProvider;
                    if (this.configurationJson) {
                        if (!providerId) {
                            providerId = this.configurationJson.configurations[0].configurationProvider;
                        }
                        this.resetToDefaultSettings(true);
                    }
                    this.applyDefaultIncludePathsAndFrameworks();
                    if (providerId) {
                        if (this.configurationJson) {
                            this.configurationJson.configurations[0].configurationProvider = providerId;
                        }
                    }
                    yield util.writeFileText(fullPathToFile, jsonc.stringify(this.configurationJson, null, 4));
                    this.propertiesFile = vscode.Uri.file(path.join(this.configFolder, "c_cpp_properties.json"));
                }
                catch (errJS) {
                    const err = errJS;
                    const failedToCreate = localize(1, null, this.configFolder);
                    vscode.window.showErrorMessage(`${failedToCreate}: ${err.message}`);
                }
            }
            return;
        });
    }
    parsePropertiesFile() {
        if (!this.propertiesFile) {
            return false;
        }
        let success = true;
        try {
            const readResults = fs.readFileSync(this.propertiesFile.fsPath, 'utf8');
            if (readResults === "") {
                return false;
            }
            const newJson = jsonc.parse(readResults);
            if (!newJson || !newJson.configurations || newJson.configurations.length === 0) {
                throw { message: localize(2, null) };
            }
            if (!this.configurationIncomplete && this.configurationJson && this.configurationJson.configurations &&
                this.CurrentConfigurationIndex >= 0 && this.CurrentConfigurationIndex < this.configurationJson.configurations.length) {
                for (let i = 0; i < newJson.configurations.length; i++) {
                    if (newJson.configurations[i].name === this.configurationJson.configurations[this.CurrentConfigurationIndex].name) {
                        if (this.currentConfigurationIndex !== undefined) {
                            this.currentConfigurationIndex.Value = i;
                        }
                        break;
                    }
                }
            }
            this.configurationJson = newJson;
            if (this.CurrentConfigurationIndex < 0 || this.CurrentConfigurationIndex >= newJson.configurations.length) {
                const index = this.getConfigIndexForPlatform(newJson);
                if (this.currentConfigurationIndex !== undefined) {
                    if (index === undefined) {
                        this.currentConfigurationIndex.setDefault();
                    }
                    else {
                        this.currentConfigurationIndex.Value = index;
                    }
                }
            }
            let dirty = false;
            for (let i = 0; i < this.configurationJson.configurations.length; i++) {
                const newId = (0, customProviders_1.getCustomConfigProviders)().checkId(this.configurationJson.configurations[i].configurationProvider);
                if (newId !== this.configurationJson.configurations[i].configurationProvider) {
                    dirty = true;
                    this.configurationJson.configurations[i].configurationProvider = newId;
                }
            }
            if (this.configurationJson.env) {
                delete this.configurationJson.env['workspaceRoot'];
                delete this.configurationJson.env['workspaceFolder'];
                delete this.configurationJson.env['workspaceFolderBasename'];
                delete this.configurationJson.env['execPath'];
                delete this.configurationJson.env['pathSeparator'];
                delete this.configurationJson.env['default'];
            }
            this.configurationIncomplete = false;
            if (this.configurationJson.version !== configVersion) {
                dirty = true;
                if (this.configurationJson.version === undefined) {
                    this.updateToVersion2();
                }
                if (this.configurationJson.version === 2) {
                    this.updateToVersion3();
                }
                if (this.configurationJson.version === 3) {
                    this.updateToVersion4();
                }
                else {
                    this.configurationJson.version = configVersion;
                    vscode.window.showErrorMessage(localize(3, null));
                }
            }
            this.configurationJson.configurations.forEach(e => {
                if (e.knownCompilers !== undefined) {
                    delete e.knownCompilers;
                    dirty = true;
                }
            });
            for (let i = 0; i < this.configurationJson.configurations.length; i++) {
                if ((this.configurationJson.configurations[i].compilerPathIsExplicit !== undefined)
                    || (this.configurationJson.configurations[i].cStandardIsExplicit !== undefined)
                    || (this.configurationJson.configurations[i].cppStandardIsExplicit !== undefined)
                    || (this.configurationJson.configurations[i].intelliSenseModeIsExplicit !== undefined)) {
                    dirty = true;
                    break;
                }
            }
            if (dirty) {
                try {
                    this.writeToJson();
                }
                catch (err) {
                    vscode.window.showWarningMessage(localize(4, null, this.propertiesFile.fsPath));
                    success = false;
                }
            }
            this.configurationJson.configurations.forEach(e => {
                e.compilerPathIsExplicit = e.compilerPath !== undefined;
                e.cStandardIsExplicit = e.cStandard !== undefined;
                e.cppStandardIsExplicit = e.cppStandard !== undefined;
                e.intelliSenseModeIsExplicit = e.intelliSenseMode !== undefined;
            });
        }
        catch (errJS) {
            const err = errJS;
            const failedToParse = localize(5, null, this.propertiesFile.fsPath);
            vscode.window.showErrorMessage(`${failedToParse}: ${err.message}`);
            success = false;
        }
        if (success) {
            this.handleSquiggles();
        }
        return success;
    }
    resolvePath(path, isWindows) {
        if (!path || path === "${default}") {
            return "";
        }
        let result = "";
        result = util.resolveVariables(path, this.ExtendedEnvironment);
        if (this.rootUri) {
            if (result.includes("${workspaceFolder}")) {
                result = result.replace("${workspaceFolder}", this.rootUri.fsPath);
            }
            if (result.includes("${workspaceRoot}")) {
                result = result.replace("${workspaceRoot}", this.rootUri.fsPath);
            }
        }
        if (result.includes("${vcpkgRoot}") && util.getVcpkgRoot()) {
            result = result.replace("${vcpkgRoot}", util.getVcpkgRoot());
        }
        if (result.includes("*")) {
            result = result.replace(/\*/g, "");
        }
        if (isWindows && result.startsWith("/")) {
            const mntStr = "/mnt/";
            if (result.length > "/mnt/c/".length && result.substr(0, mntStr.length) === mntStr) {
                result = result.substr(mntStr.length);
                result = result.substr(0, 1) + ":" + result.substr(1);
            }
            else if (this.rootfs && this.rootfs.length > 0) {
                result = this.rootfs + result.substr(1);
            }
        }
        return result;
    }
    getErrorsForConfigUI(configIndex) {
        const errors = {};
        if (!this.configurationJson) {
            return errors;
        }
        const isWindows = os.platform() === 'win32';
        const config = this.configurationJson.configurations[configIndex];
        errors.name = this.isConfigNameUnique(config.name);
        let resolvedCompilerPath = this.resolvePath(config.compilerPath, isWindows);
        const compilerPathAndArgs = util.extractCompilerPathAndArgs(resolvedCompilerPath);
        if (resolvedCompilerPath
            && compilerPathAndArgs.compilerName.toLowerCase() !== "cl.exe"
            && compilerPathAndArgs.compilerName.toLowerCase() !== "cl") {
            resolvedCompilerPath = resolvedCompilerPath.trim();
            const compilerPathNeedsQuotes = (compilerPathAndArgs.additionalArgs && compilerPathAndArgs.additionalArgs.length > 0) &&
                !resolvedCompilerPath.startsWith('"') &&
                compilerPathAndArgs.compilerPath !== undefined &&
                compilerPathAndArgs.compilerPath.includes(" ");
            const compilerPathErrors = [];
            if (compilerPathNeedsQuotes) {
                compilerPathErrors.push(localize(6, null));
            }
            resolvedCompilerPath = compilerPathAndArgs.compilerPath;
            if (resolvedCompilerPath) {
                let pathExists = true;
                const existsWithExeAdded = (path) => isWindows && !path.startsWith("/") && fs.existsSync(path + ".exe");
                if (!fs.existsSync(resolvedCompilerPath)) {
                    if (existsWithExeAdded(resolvedCompilerPath)) {
                        resolvedCompilerPath += ".exe";
                    }
                    else if (!this.rootUri) {
                        pathExists = false;
                    }
                    else {
                        const relativePath = this.rootUri.fsPath + path.sep + resolvedCompilerPath;
                        if (!fs.existsSync(relativePath)) {
                            if (existsWithExeAdded(resolvedCompilerPath)) {
                                resolvedCompilerPath += ".exe";
                            }
                            else {
                                pathExists = false;
                            }
                        }
                        else {
                            resolvedCompilerPath = relativePath;
                        }
                    }
                }
                if (!pathExists) {
                    const message = localize(7, null, resolvedCompilerPath);
                    compilerPathErrors.push(message);
                }
                else if (compilerPathAndArgs.compilerPath === "") {
                    const message = localize(8, null);
                    compilerPathErrors.push(message);
                }
                else if (!util.checkFileExistsSync(resolvedCompilerPath)) {
                    const message = localize(9, null, resolvedCompilerPath);
                    compilerPathErrors.push(message);
                }
                if (compilerPathErrors.length > 0) {
                    errors.compilerPath = compilerPathErrors.join('\n');
                }
            }
        }
        errors.includePath = this.validatePath(config.includePath);
        errors.macFrameworkPath = this.validatePath(config.macFrameworkPath);
        errors.browsePath = this.validatePath(config.browse ? config.browse.path : undefined);
        errors.forcedInclude = this.validatePath(config.forcedInclude, false, true);
        errors.compileCommands = this.validatePath(config.compileCommands, false);
        errors.databaseFilename = this.validatePath((config.browse ? config.browse.databaseFilename : undefined), false);
        if (isWindows) {
            const intelliSenesModeError = this.validateIntelliSenseMode(config);
            if (intelliSenesModeError.length > 0) {
                errors.intelliSenseMode = intelliSenesModeError;
            }
        }
        return errors;
    }
    validatePath(input, isDirectory = true, skipRelativePaths = false) {
        if (!input) {
            return undefined;
        }
        const isWindows = os.platform() === 'win32';
        let errorMsg;
        const errors = [];
        let paths = [];
        if (util.isString(input)) {
            paths.push(input);
        }
        else {
            paths = input;
        }
        paths = this.resolveAndSplit(paths, undefined, this.ExtendedEnvironment);
        for (const p of paths) {
            let pathExists = true;
            let resolvedPath = this.resolvePath(p, isWindows);
            if (!resolvedPath) {
                continue;
            }
            if (!fs.existsSync(resolvedPath)) {
                if (skipRelativePaths && !path.isAbsolute(resolvedPath)) {
                    continue;
                }
                else if (!this.rootUri) {
                    pathExists = false;
                }
                else {
                    const relativePath = this.rootUri.fsPath + path.sep + resolvedPath;
                    if (!fs.existsSync(relativePath)) {
                        pathExists = false;
                    }
                    else {
                        resolvedPath = relativePath;
                    }
                }
            }
            if (!pathExists) {
                const message = localize(10, null, resolvedPath);
                errors.push(message);
                continue;
            }
            if (isDirectory && !util.checkDirectoryExistsSync(resolvedPath)) {
                const message = localize(11, null, resolvedPath);
                errors.push(message);
            }
            else if (!isDirectory && !util.checkFileExistsSync(resolvedPath)) {
                const message = localize(12, null, resolvedPath);
                errors.push(message);
            }
        }
        if (errors.length > 0) {
            errorMsg = errors.join('\n');
        }
        return errorMsg;
    }
    isConfigNameUnique(configName) {
        var _a;
        let errorMsg;
        const occurrences = (_a = this.ConfigurationNames) === null || _a === void 0 ? void 0 : _a.filter(function (name) { return name === configName; }).length;
        if (occurrences && occurrences > 1) {
            errorMsg = localize(13, null, configName);
        }
        return errorMsg;
    }
    handleSquiggles() {
        if (!this.propertiesFile) {
            return;
        }
        const settings = new settings_1.CppSettings(this.rootUri);
        if (!this.configurationJson) {
            return;
        }
        if ((this.configurationJson.enableConfigurationSquiggles !== undefined && !this.configurationJson.enableConfigurationSquiggles) ||
            (this.configurationJson.enableConfigurationSquiggles === undefined && !settings.defaultEnableConfigurationSquiggles)) {
            this.diagnosticCollection.clear();
            return;
        }
        vscode.workspace.openTextDocument(this.propertiesFile).then((document) => {
            var _a, _b, _c, _d, _e;
            const diagnostics = new Array();
            let curText = document.getText();
            const configurationsText = util.escapeForSquiggles(curText);
            const configurations = jsonc.parse(configurationsText);
            const currentConfiguration = configurations.configurations[this.CurrentConfigurationIndex];
            let curTextStartOffset = 0;
            if (!currentConfiguration.name) {
                return;
            }
            let envText = "";
            const envStart = curText.search(/\"env\"\s*:\s*\{/);
            const envEnd = envStart === -1 ? -1 : curText.indexOf("},", envStart);
            envText = curText.substr(envStart, envEnd);
            const envTextStartOffSet = envStart + 1;
            let allConfigText = curText;
            let allConfigTextOffset = envTextStartOffSet;
            const nameRegex = new RegExp(`{\\s*"name"\\s*:\\s*".*"`);
            let configStart = allConfigText.search(new RegExp(nameRegex));
            let configNameStart;
            let configNameEnd;
            let configName;
            const configNames = new Map();
            let dupErrorMsg;
            while (configStart !== -1) {
                allConfigText = allConfigText.substr(configStart);
                allConfigTextOffset += configStart;
                configNameStart = allConfigText.indexOf('"', allConfigText.indexOf(':') + 1) + 1;
                configNameEnd = allConfigText.indexOf('"', configNameStart);
                configName = allConfigText.substr(configNameStart, configNameEnd - configNameStart);
                const newRange = new vscode.Range(0, allConfigTextOffset + configNameStart, 0, allConfigTextOffset + configNameEnd);
                const allRanges = configNames.get(configName);
                if (allRanges) {
                    allRanges.push(newRange);
                    configNames.set(configName, allRanges);
                }
                else {
                    configNames.set(configName, [newRange]);
                }
                allConfigText = allConfigText.substr(configNameEnd + 1);
                allConfigTextOffset += configNameEnd + 1;
                configStart = allConfigText.search(new RegExp(nameRegex));
            }
            for (const [configName, allRanges] of configNames) {
                if (allRanges && allRanges.length > 1) {
                    dupErrorMsg = localize(14, null, configName);
                    allRanges.forEach(nameRange => {
                        const diagnostic = new vscode.Diagnostic(new vscode.Range(document.positionAt(nameRange.start.character), document.positionAt(nameRange.end.character)), dupErrorMsg, vscode.DiagnosticSeverity.Warning);
                        diagnostics.push(diagnostic);
                    });
                }
            }
            configStart = curText.search(new RegExp(`{\\s*"name"\\s*:\\s*"${escapeStringRegExp(currentConfiguration.name)}"`));
            if (configStart === -1) {
                telemetry.logLanguageServerEvent("ConfigSquiggles", { "error": "config name not first" });
                return;
            }
            curTextStartOffset = configStart + 1;
            curText = curText.substr(curTextStartOffset);
            const nameEnd = curText.indexOf(":");
            curTextStartOffset += nameEnd + 1;
            curText = curText.substr(nameEnd + 1);
            const nextNameStart = curText.search(new RegExp('"name"\\s*:\\s*"'));
            if (nextNameStart !== -1) {
                curText = curText.substr(0, nextNameStart + 6);
                const nextNameStart2 = curText.search(new RegExp('\\s*}\\s*,\\s*{\\s*"name"'));
                if (nextNameStart2 === -1) {
                    telemetry.logLanguageServerEvent("ConfigSquiggles", { "error": "next config name not first" });
                    return;
                }
                curText = curText.substr(0, nextNameStart2);
            }
            if (this.prevSquiggleMetrics.get(currentConfiguration.name) === undefined) {
                this.prevSquiggleMetrics.set(currentConfiguration.name, { PathNonExistent: 0, PathNotAFile: 0, PathNotADirectory: 0, CompilerPathMissingQuotes: 0, CompilerModeMismatch: 0 });
            }
            const newSquiggleMetrics = { PathNonExistent: 0, PathNotAFile: 0, PathNotADirectory: 0, CompilerPathMissingQuotes: 0, CompilerModeMismatch: 0 };
            const isWindows = os.platform() === 'win32';
            if (isWindows) {
                const intelliSenseModeStart = curText.search(/\s*\"intelliSenseMode\"\s*:\s*\"/);
                if (intelliSenseModeStart !== -1) {
                    const intelliSenseModeValueStart = curText.indexOf('"', curText.indexOf(":", intelliSenseModeStart));
                    const intelliSenseModeValueEnd = intelliSenseModeStart === -1 ? -1 : curText.indexOf('"', intelliSenseModeValueStart + 1) + 1;
                    const intelliSenseModeError = this.validateIntelliSenseMode(currentConfiguration);
                    if (intelliSenseModeError.length > 0) {
                        const message = intelliSenseModeError;
                        const diagnostic = new vscode.Diagnostic(new vscode.Range(document.positionAt(curTextStartOffset + intelliSenseModeValueStart), document.positionAt(curTextStartOffset + intelliSenseModeValueEnd)), message, vscode.DiagnosticSeverity.Warning);
                        diagnostics.push(diagnostic);
                        newSquiggleMetrics.CompilerModeMismatch++;
                    }
                }
            }
            let paths = [];
            let compilerPath;
            for (const pathArray of [(currentConfiguration.browse ? currentConfiguration.browse.path : undefined),
                currentConfiguration.includePath, currentConfiguration.macFrameworkPath]) {
                if (pathArray) {
                    for (const curPath of pathArray) {
                        paths.push(`${curPath}`);
                    }
                }
            }
            if (currentConfiguration.forcedInclude) {
                for (const file of currentConfiguration.forcedInclude) {
                    const resolvedFilePath = this.resolvePath(file, isWindows);
                    if (path.isAbsolute(resolvedFilePath)) {
                        paths.push(`${file}`);
                    }
                }
            }
            if (currentConfiguration.compileCommands) {
                paths.push(`${currentConfiguration.compileCommands}`);
            }
            if (currentConfiguration.compilerPath) {
                compilerPath = currentConfiguration.compilerPath;
            }
            paths = this.resolveAndSplit(paths, undefined, this.ExtendedEnvironment);
            compilerPath = util.resolveVariables(compilerPath, this.ExtendedEnvironment).trim();
            compilerPath = this.resolvePath(compilerPath, isWindows);
            const forcedIncludeStart = curText.search(/\s*\"forcedInclude\"\s*:\s*\[/);
            const forcedeIncludeEnd = forcedIncludeStart === -1 ? -1 : curText.indexOf("]", forcedIncludeStart);
            const compileCommandsStart = curText.search(/\s*\"compileCommands\"\s*:\s*\"/);
            const compileCommandsEnd = compileCommandsStart === -1 ? -1 : curText.indexOf('"', curText.indexOf('"', curText.indexOf(":", compileCommandsStart)) + 1);
            const compilerPathStart = curText.search(/\s*\"compilerPath\"\s*:\s*\"/);
            const compilerPathValueStart = curText.indexOf('"', curText.indexOf(":", compilerPathStart));
            const compilerPathEnd = compilerPathStart === -1 ? -1 : curText.indexOf('"', compilerPathValueStart + 1) + 1;
            const processedPaths = new Set();
            let compilerPathNeedsQuotes = false;
            let compilerMessage;
            const compilerPathAndArgs = util.extractCompilerPathAndArgs(compilerPath);
            const compilerLowerCase = compilerPathAndArgs.compilerName.toLowerCase();
            const isClCompiler = compilerLowerCase === "cl" || compilerLowerCase === "cl.exe";
            if (compilerPathAndArgs.compilerPath && !isClCompiler) {
                compilerPathNeedsQuotes = (compilerPathAndArgs.additionalArgs && compilerPathAndArgs.additionalArgs.length > 0)
                    && !compilerPath.startsWith('"')
                    && compilerPathAndArgs.compilerPath.includes(" ");
                compilerPath = compilerPathAndArgs.compilerPath;
                if (compilerPathNeedsQuotes || (compilerPath && !which.sync(compilerPath, { nothrow: true }))) {
                    if (compilerPathNeedsQuotes) {
                        compilerMessage = localize(15, null);
                        newSquiggleMetrics.CompilerPathMissingQuotes++;
                    }
                    else if (!util.checkFileExistsSync(compilerPath)) {
                        compilerMessage = localize(16, null, compilerPath);
                        newSquiggleMetrics.PathNotAFile++;
                    }
                }
            }
            const isWSL = isWindows && compilerPath.startsWith("/");
            let compilerPathExists = true;
            if (this.rootUri && !isClCompiler) {
                const checkPathExists = util.checkPathExistsSync(compilerPath, this.rootUri.fsPath + path.sep, isWindows, isWSL, true);
                compilerPathExists = checkPathExists.pathExists;
                compilerPath = checkPathExists.path;
            }
            if (!compilerPathExists) {
                compilerMessage = localize(17, null, compilerPath);
                newSquiggleMetrics.PathNonExistent++;
            }
            if (compilerMessage) {
                const diagnostic = new vscode.Diagnostic(new vscode.Range(document.positionAt(curTextStartOffset + compilerPathValueStart), document.positionAt(curTextStartOffset + compilerPathEnd)), compilerMessage, vscode.DiagnosticSeverity.Warning);
                diagnostics.push(diagnostic);
            }
            for (const curPath of paths) {
                if (processedPaths.has(curPath)) {
                    continue;
                }
                processedPaths.add(curPath);
                if (curPath === "${default}") {
                    continue;
                }
                let resolvedPath = this.resolvePath(curPath, isWindows);
                if (!resolvedPath) {
                    continue;
                }
                let pathExists = true;
                if (this.rootUri) {
                    const checkPathExists = util.checkPathExistsSync(resolvedPath, this.rootUri.fsPath + path.sep, isWindows, isWSL, false);
                    pathExists = checkPathExists.pathExists;
                    resolvedPath = checkPathExists.path;
                }
                if (path.sep === "/") {
                    resolvedPath = resolvedPath.replace(/\\/g, path.sep);
                }
                else {
                    resolvedPath = resolvedPath.replace(/\//g, path.sep);
                }
                let escapedPath = curPath.replace(/\"/g, '\\\"');
                escapedPath = escapedPath.replace(/[-\"\/\\^$*+?.()|[\]{}]/g, '\\$&');
                const pattern = new RegExp(`"[^"]*?(?<="|;)${escapedPath}(?="|;).*?"`, "g");
                const configMatches = curText.match(pattern);
                if (configMatches) {
                    let curOffset = 0;
                    let endOffset = 0;
                    for (const curMatch of configMatches) {
                        curOffset = curText.substr(endOffset).search(pattern) + endOffset;
                        endOffset = curOffset + curMatch.length;
                        if (curOffset >= compilerPathStart && curOffset <= compilerPathEnd) {
                            continue;
                        }
                        let message;
                        if (!pathExists) {
                            if (curOffset >= forcedIncludeStart && curOffset <= forcedeIncludeEnd
                                && !path.isAbsolute(resolvedPath)) {
                                continue;
                            }
                            message = localize(18, null, resolvedPath);
                            newSquiggleMetrics.PathNonExistent++;
                        }
                        else {
                            if ((curOffset >= forcedIncludeStart && curOffset <= forcedeIncludeEnd) ||
                                (curOffset >= compileCommandsStart && curOffset <= compileCommandsEnd)) {
                                if (util.checkFileExistsSync(resolvedPath)) {
                                    continue;
                                }
                                message = localize(19, null, resolvedPath);
                                newSquiggleMetrics.PathNotAFile++;
                            }
                            else {
                                if (util.checkDirectoryExistsSync(resolvedPath)) {
                                    continue;
                                }
                                message = localize(20, null, resolvedPath);
                                newSquiggleMetrics.PathNotADirectory++;
                            }
                        }
                        const diagnostic = new vscode.Diagnostic(new vscode.Range(document.positionAt(curTextStartOffset + curOffset), document.positionAt(curTextStartOffset + endOffset)), message, vscode.DiagnosticSeverity.Warning);
                        diagnostics.push(diagnostic);
                    }
                }
                else if (envText) {
                    const envMatches = envText.match(pattern);
                    if (envMatches) {
                        let curOffset = 0;
                        let endOffset = 0;
                        for (const curMatch of envMatches) {
                            curOffset = envText.substr(endOffset).search(pattern) + endOffset;
                            endOffset = curOffset + curMatch.length;
                            let message;
                            if (!pathExists) {
                                message = localize(21, null, resolvedPath);
                                newSquiggleMetrics.PathNonExistent++;
                                const diagnostic = new vscode.Diagnostic(new vscode.Range(document.positionAt(envTextStartOffSet + curOffset), document.positionAt(envTextStartOffSet + endOffset)), message, vscode.DiagnosticSeverity.Warning);
                                diagnostics.push(diagnostic);
                            }
                        }
                    }
                }
            }
            if (diagnostics.length !== 0) {
                this.diagnosticCollection.set(document.uri, diagnostics);
            }
            else {
                this.diagnosticCollection.clear();
            }
            const changedSquiggleMetrics = {};
            if (newSquiggleMetrics.PathNonExistent !== ((_a = this.prevSquiggleMetrics.get(currentConfiguration.name)) === null || _a === void 0 ? void 0 : _a.PathNonExistent)) {
                changedSquiggleMetrics.PathNonExistent = newSquiggleMetrics.PathNonExistent;
            }
            if (newSquiggleMetrics.PathNotAFile !== ((_b = this.prevSquiggleMetrics.get(currentConfiguration.name)) === null || _b === void 0 ? void 0 : _b.PathNotAFile)) {
                changedSquiggleMetrics.PathNotAFile = newSquiggleMetrics.PathNotAFile;
            }
            if (newSquiggleMetrics.PathNotADirectory !== ((_c = this.prevSquiggleMetrics.get(currentConfiguration.name)) === null || _c === void 0 ? void 0 : _c.PathNotADirectory)) {
                changedSquiggleMetrics.PathNotADirectory = newSquiggleMetrics.PathNotADirectory;
            }
            if (newSquiggleMetrics.CompilerPathMissingQuotes !== ((_d = this.prevSquiggleMetrics.get(currentConfiguration.name)) === null || _d === void 0 ? void 0 : _d.CompilerPathMissingQuotes)) {
                changedSquiggleMetrics.CompilerPathMissingQuotes = newSquiggleMetrics.CompilerPathMissingQuotes;
            }
            if (newSquiggleMetrics.CompilerModeMismatch !== ((_e = this.prevSquiggleMetrics.get(currentConfiguration.name)) === null || _e === void 0 ? void 0 : _e.CompilerModeMismatch)) {
                changedSquiggleMetrics.CompilerModeMismatch = newSquiggleMetrics.CompilerModeMismatch;
            }
            if (Object.keys(changedSquiggleMetrics).length > 0) {
                telemetry.logLanguageServerEvent("ConfigSquiggles", undefined, changedSquiggleMetrics);
            }
            this.prevSquiggleMetrics.set(currentConfiguration.name, newSquiggleMetrics);
        });
    }
    updateToVersion2() {
        if (this.configurationJson) {
            this.configurationJson.version = 2;
        }
    }
    updateToVersion3() {
        if (this.configurationJson) {
            this.configurationJson.version = 3;
            for (let i = 0; i < this.configurationJson.configurations.length; i++) {
                const config = this.configurationJson.configurations[i];
                if (config.name === "Mac" || (process.platform === 'darwin' && config.name !== "Win32" && config.name !== "Linux")) {
                    if (config.macFrameworkPath === undefined) {
                        config.macFrameworkPath = [
                            "/System/Library/Frameworks",
                            "/Library/Frameworks"
                        ];
                    }
                }
            }
        }
    }
    updateToVersion4() {
        if (this.configurationJson) {
            this.configurationJson.version = 4;
            const settings = new settings_1.CppSettings(this.rootUri);
            for (let i = 0; i < this.configurationJson.configurations.length; i++) {
                const config = this.configurationJson.configurations[i];
                if (config.intelliSenseMode === undefined && !settings.defaultIntelliSenseMode) {
                    config.intelliSenseMode = this.getIntelliSenseModeForPlatform(config.name);
                }
                if (config.compilerPath === undefined && this.defaultCompilerPath && !config.compileCommands && !settings.defaultCompilerPath) {
                    config.compilerPath = this.defaultCompilerPath;
                }
                if (!config.cStandard && this.defaultCStandard && !settings.defaultCStandard) {
                    config.cStandard = this.defaultCStandard;
                }
                if (!config.cppStandard && this.defaultCppStandard && !settings.defaultCppStandard) {
                    config.cppStandard = this.defaultCppStandard;
                }
            }
        }
    }
    writeToJson() {
        const savedCompilerPathIsExplicit = [];
        const savedCStandardIsExplicit = [];
        const savedCppStandardIsExplicit = [];
        const savedIntelliSenseModeIsExplicit = [];
        if (this.configurationJson) {
            this.configurationJson.configurations.forEach(e => {
                savedCompilerPathIsExplicit.push(!!e.compilerPathIsExplicit);
                if (e.compilerPathIsExplicit !== undefined) {
                    delete e.compilerPathIsExplicit;
                }
                savedCStandardIsExplicit.push(!!e.cStandardIsExplicit);
                if (e.cStandardIsExplicit !== undefined) {
                    delete e.cStandardIsExplicit;
                }
                savedCppStandardIsExplicit.push(!!e.cppStandardIsExplicit);
                if (e.cppStandardIsExplicit !== undefined) {
                    delete e.cppStandardIsExplicit;
                }
                savedIntelliSenseModeIsExplicit.push(!!e.intelliSenseModeIsExplicit);
                if (e.intelliSenseModeIsExplicit !== undefined) {
                    delete e.intelliSenseModeIsExplicit;
                }
            });
        }
        console.assert(this.propertiesFile);
        if (this.propertiesFile) {
            fs.writeFileSync(this.propertiesFile.fsPath, jsonc.stringify(this.configurationJson, null, 4));
        }
        if (this.configurationJson) {
            for (let i = 0; i < this.configurationJson.configurations.length; i++) {
                this.configurationJson.configurations[i].compilerPathIsExplicit = savedCompilerPathIsExplicit[i];
                this.configurationJson.configurations[i].cStandardIsExplicit = savedCStandardIsExplicit[i];
                this.configurationJson.configurations[i].cppStandardIsExplicit = savedCppStandardIsExplicit[i];
                this.configurationJson.configurations[i].intelliSenseModeIsExplicit = savedIntelliSenseModeIsExplicit[i];
            }
        }
    }
    checkCppProperties() {
        const propertiesFile = path.join(this.configFolder, "c_cpp_properties.json");
        fs.stat(propertiesFile, (err, stats) => {
            if (err) {
                if (err.code === "ENOENT" && this.propertiesFile) {
                    this.propertiesFile = null;
                    this.resetToDefaultSettings(true);
                    this.handleConfigurationChange();
                }
            }
            else if (stats.mtime > this.configFileWatcherFallbackTime) {
                if (!this.propertiesFile) {
                    this.propertiesFile = vscode.Uri.file(propertiesFile);
                }
                this.handleConfigurationChange();
            }
        });
    }
    checkCompileCommands() {
        var _a;
        const compileCommands = (_a = this.CurrentConfiguration) === null || _a === void 0 ? void 0 : _a.compileCommands;
        if (!compileCommands) {
            return;
        }
        const compileCommandsFile = this.resolvePath(compileCommands, os.platform() === "win32");
        fs.stat(compileCommandsFile, (err, stats) => {
            if (err) {
                if (err.code === "ENOENT" && this.compileCommandsFile) {
                    this.compileCommandsFileWatchers = [];
                    this.onCompileCommandsChanged(compileCommandsFile);
                    this.compileCommandsFile = null;
                }
            }
            else if (stats.mtime > this.compileCommandsFileWatcherFallbackTime) {
                this.compileCommandsFileWatcherFallbackTime = new Date();
                this.onCompileCommandsChanged(compileCommandsFile);
                this.compileCommandsFile = vscode.Uri.file(compileCommandsFile);
            }
        });
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
        this.disposables = [];
        this.compileCommandsFileWatchers.forEach((watcher) => watcher.close());
        this.compileCommandsFileWatchers = [];
        this.diagnosticCollection.dispose();
    }
}
exports.CppProperties = CppProperties;


/***/ }),

/***/ 7523:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CppBuildTaskProvider = exports.CppBuildTask = void 0;
const path = __webpack_require__(5622);
const vscode_1 = __webpack_require__(7549);
const os = __webpack_require__(2087);
const util = __webpack_require__(5331);
const telemetry = __webpack_require__(1818);
const ext = __webpack_require__(2973);
const cp = __webpack_require__(3129);
const settings_1 = __webpack_require__(296);
const nls = __webpack_require__(3463);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\cppBuildTaskProvider.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\cppBuildTaskProvider.ts'));
class CppBuildTask extends vscode_1.Task {
}
exports.CppBuildTask = CppBuildTask;
class CppBuildTaskProvider {
    constructor() {
        this.getTask = (compilerPath, appendSourceToName, compilerArgs, definition, detail) => {
            var _a;
            const compilerPathBase = path.basename(compilerPath);
            const isCl = compilerPathBase.toLowerCase() === "cl.exe";
            let resolvedcompilerPath = isCl ? compilerPathBase : compilerPath;
            if (resolvedcompilerPath && !resolvedcompilerPath.startsWith("\"") && resolvedcompilerPath.includes(" ")) {
                resolvedcompilerPath = "\"" + resolvedcompilerPath + "\"";
            }
            if (!definition) {
                const taskLabel = ((appendSourceToName && !compilerPathBase.startsWith(CppBuildTaskProvider.CppBuildSourceStr)) ?
                    CppBuildTaskProvider.CppBuildSourceStr + ": " : "") + compilerPathBase + " " + localize(0, null);
                const filePath = path.join('${fileDirname}', '${fileBasenameNoExtension}');
                const isWindows = os.platform() === 'win32';
                let args = isCl ? ['/Zi', '/EHsc', '/nologo', '/Fe:', filePath + '.exe', '${file}'] : ['-fdiagnostics-color=always', '-g', '${file}', '-o', filePath + (isWindows ? '.exe' : '')];
                if (compilerArgs && compilerArgs.length > 0) {
                    args = args.concat(compilerArgs);
                }
                const cwd = isWindows && !isCl && !((_a = process.env.PATH) === null || _a === void 0 ? void 0 : _a.includes(path.dirname(compilerPath))) ? path.dirname(compilerPath) : "${fileDirname}";
                const options = { cwd: cwd };
                definition = {
                    type: CppBuildTaskProvider.CppBuildScriptType,
                    label: taskLabel,
                    command: isCl ? compilerPathBase : compilerPath,
                    args: args,
                    options: options
                };
            }
            const editor = vscode_1.window.activeTextEditor;
            const folder = editor ? vscode_1.workspace.getWorkspaceFolder(editor.document.uri) : undefined;
            if (folder) {
                const activeClient = ext.getActiveClient();
                const uri = activeClient.RootUri;
                if (!uri) {
                    throw new Error("No client URI found in getBuildTasks()");
                }
                if (!vscode_1.workspace.getWorkspaceFolder(uri)) {
                    throw new Error("No target WorkspaceFolder found in getBuildTasks()");
                }
            }
            const taskUsesActiveFile = definition.args.some(arg => arg.indexOf('${file}') >= 0);
            const scope = folder ? folder : vscode_1.TaskScope.Workspace;
            const task = new vscode_1.Task(definition, scope, definition.label, CppBuildTaskProvider.CppBuildSourceStr, new vscode_1.CustomExecution((resolvedDefinition) => __awaiter(this, void 0, void 0, function* () { return new CustomBuildTaskTerminal(resolvedcompilerPath, resolvedDefinition.args, resolvedDefinition.options, taskUsesActiveFile); })), isCl ? '$msCompile' : '$gcc');
            task.group = vscode_1.TaskGroup.Build;
            task.detail = detail ? detail : localize(1, null) + " " + resolvedcompilerPath;
            return task;
        };
    }
    provideTasks() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getTasks(false);
        });
    }
    resolveTask(_task) {
        const execution = _task.execution;
        if (!execution) {
            const definition = _task.definition;
            _task = this.getTask(definition.command, false, definition.args ? definition.args : [], definition, _task.detail);
            return _task;
        }
        return undefined;
    }
    getTasks(appendSourceToName) {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = vscode_1.window.activeTextEditor;
            const emptyTasks = [];
            if (!editor) {
                return emptyTasks;
            }
            const fileExt = path.extname(editor.document.fileName);
            if (!fileExt) {
                return emptyTasks;
            }
            const fileExtLower = fileExt.toLowerCase();
            const isHeader = !fileExt || [".cuh", ".hpp", ".hh", ".hxx", ".h++", ".hp", ".h", ".ii", ".inl", ".idl", ""].some(ext => fileExtLower === ext);
            if (isHeader) {
                return emptyTasks;
            }
            let fileIsCpp;
            let fileIsC;
            if (fileExt === ".C") {
                fileIsCpp = true;
                fileIsC = true;
            }
            else {
                fileIsCpp = [".cu", ".cpp", ".cc", ".cxx", ".c++", ".cp", ".ino", ".ipp", ".tcc"].some(ext => fileExtLower === ext);
                fileIsC = fileExtLower === ".c";
            }
            if (!(fileIsCpp || fileIsC)) {
                return emptyTasks;
            }
            const isWindows = os.platform() === 'win32';
            let activeClient;
            try {
                activeClient = ext.getActiveClient();
            }
            catch (errJS) {
                const e = errJS;
                if (!e || e.message !== ext.intelliSenseDisabledError) {
                    console.error("Unknown error calling getActiveClient().");
                }
                return emptyTasks;
            }
            const userCompilerPathAndArgs = yield activeClient.getCurrentCompilerPathAndArgs();
            let userCompilerPath;
            if (userCompilerPathAndArgs) {
                userCompilerPath = userCompilerPathAndArgs.compilerPath;
                if (userCompilerPath && userCompilerPathAndArgs.compilerName) {
                    userCompilerPath = userCompilerPath.trim();
                    if (isWindows && userCompilerPath.startsWith("/")) {
                        userCompilerPath = undefined;
                    }
                    else {
                        userCompilerPath = userCompilerPath.replace(/\\\\/g, "\\");
                    }
                }
            }
            const isCompilerValid = userCompilerPath ? yield util.checkFileExists(userCompilerPath) : false;
            const userCompilerIsCl = isCompilerValid && !!userCompilerPathAndArgs && userCompilerPathAndArgs.compilerName === "cl.exe";
            const knownCompilerPathsSet = new Set();
            let knownCompilers = yield activeClient.getKnownCompilers();
            if (knownCompilers) {
                const compiler_condition = info => ((fileIsCpp && !info.isC) || (fileIsC && info.isC)) &&
                    (!isCompilerValid || (!!userCompilerPathAndArgs &&
                        (path.basename(info.path) !== userCompilerPathAndArgs.compilerName))) &&
                    (!isWindows || !info.path.startsWith("/"));
                const cl_to_add = userCompilerIsCl ? undefined : knownCompilers.find(info => ((path.basename(info.path) === "cl.exe") && compiler_condition(info)));
                knownCompilers = knownCompilers.filter(info => ((info === cl_to_add) || (path.basename(info.path) !== "cl.exe" && compiler_condition(info))));
                knownCompilers.map(info => {
                    knownCompilerPathsSet.add(info.path);
                });
            }
            const knownCompilerPaths = knownCompilerPathsSet.size ?
                Array.from(knownCompilerPathsSet) : undefined;
            if (!knownCompilerPaths && !userCompilerPath) {
                telemetry.logLanguageServerEvent('noCompilerFound');
                return emptyTasks;
            }
            let result = [];
            if (knownCompilerPaths) {
                result = knownCompilerPaths.map(compilerPath => this.getTask(compilerPath, appendSourceToName, undefined));
            }
            if (isCompilerValid && userCompilerPath) {
                result.push(this.getTask(userCompilerPath, appendSourceToName, userCompilerPathAndArgs === null || userCompilerPathAndArgs === void 0 ? void 0 : userCompilerPathAndArgs.additionalArgs));
            }
            return result;
        });
    }
    getJsonTasks() {
        return __awaiter(this, void 0, void 0, function* () {
            const rawJson = yield this.getRawTasksJson();
            const rawTasksJson = (!rawJson.tasks) ? new Array() : rawJson.tasks;
            const buildTasksJson = rawTasksJson.map((task) => {
                if (!task.label) {
                    return null;
                }
                const definition = {
                    type: task.type,
                    label: task.label,
                    command: task.command,
                    args: task.args,
                    options: task.options
                };
                const cppBuildTask = new vscode_1.Task(definition, vscode_1.TaskScope.Workspace, task.label, "C/C++");
                cppBuildTask.detail = task.detail;
                return cppBuildTask;
            });
            return buildTasksJson.filter((task) => task !== null);
        });
    }
    ensureBuildTaskExists(taskLabel) {
        return __awaiter(this, void 0, void 0, function* () {
            const rawTasksJson = yield this.getRawTasksJson();
            if (!rawTasksJson.tasks) {
                rawTasksJson.tasks = new Array();
            }
            let selectedTask = rawTasksJson.tasks.find((task) => task.label && task.label === taskLabel);
            if (selectedTask) {
                return;
            }
            const buildTasks = yield this.getTasks(true);
            const normalizedLabel = (taskLabel.indexOf("ver(") !== -1) ? taskLabel.slice(0, taskLabel.indexOf("ver(")).trim() : taskLabel;
            selectedTask = buildTasks.find(task => task.name === normalizedLabel);
            console.assert(selectedTask);
            if (!selectedTask) {
                throw new Error("Failed to get selectedTask in ensureBuildTaskExists()");
            }
            else {
                selectedTask.definition.label = taskLabel;
                selectedTask.name = taskLabel;
            }
            rawTasksJson.version = "2.0.0";
            rawTasksJson.tasks.forEach((task) => {
                if (task.label === (selectedTask === null || selectedTask === void 0 ? void 0 : selectedTask.definition.label)) {
                    task.group = { kind: "build", "isDefault": true };
                }
                else if (task.group.kind && task.group.kind === "build" && task.group.isDefault && task.group.isDefault === true) {
                    task.group = "build";
                }
            });
            if (!rawTasksJson.tasks.find((task) => task.label === (selectedTask === null || selectedTask === void 0 ? void 0 : selectedTask.definition.label))) {
                const newTask = Object.assign(Object.assign({}, selectedTask.definition), { problemMatcher: selectedTask.problemMatchers, group: { kind: "build", "isDefault": true }, detail: localize(2, null) });
                rawTasksJson.tasks.push(newTask);
            }
            const settings = new settings_1.OtherSettings();
            const tasksJsonPath = this.getTasksJsonPath();
            if (!tasksJsonPath) {
                throw new Error("Failed to get tasksJsonPath in ensureBuildTaskExists()");
            }
            yield util.writeFileText(tasksJsonPath, JSON.stringify(rawTasksJson, null, settings.editorTabSize));
        });
    }
    ensureDebugConfigExists(configName) {
        return __awaiter(this, void 0, void 0, function* () {
            const launchJsonPath = this.getLaunchJsonPath();
            if (!launchJsonPath) {
                throw new Error("Failed to get launchJsonPath in ensureDebugConfigExists()");
            }
            const rawLaunchJson = yield this.getRawLaunchJson();
            if (!rawLaunchJson || !rawLaunchJson.configurations) {
                throw new Error(`Configuration '${configName}' is missing in 'launch.json'.`);
            }
            const selectedConfig = rawLaunchJson.configurations.find((config) => config.name && config.name === configName);
            if (!selectedConfig) {
                throw new Error(`Configuration '${configName}' is missing in 'launch.json'.`);
            }
            return;
        });
    }
    provideUniqueTaskLabel(label, buildTasksJson) {
        const taskNameDictionary = {};
        buildTasksJson.forEach(task => {
            taskNameDictionary[task.definition.label] = {};
        });
        let newLabel = label;
        let version = 0;
        do {
            version = version + 1;
            newLabel = label + ` ver(${version})`;
        } while (taskNameDictionary[newLabel]);
        return newLabel;
    }
    getLaunchJsonPath() {
        return util.getJsonPath("launch.json");
    }
    getTasksJsonPath() {
        return util.getJsonPath("tasks.json");
    }
    getRawLaunchJson() {
        const path = this.getLaunchJsonPath();
        return util.getRawJson(path);
    }
    getRawTasksJson() {
        const path = this.getTasksJsonPath();
        return util.getRawJson(path);
    }
}
exports.CppBuildTaskProvider = CppBuildTaskProvider;
CppBuildTaskProvider.CppBuildScriptType = 'cppbuild';
CppBuildTaskProvider.CppBuildSourceStr = "C/C++";
class CustomBuildTaskTerminal {
    constructor(command, args, options, taskUsesActiveFile) {
        this.command = command;
        this.args = args;
        this.options = options;
        this.taskUsesActiveFile = taskUsesActiveFile;
        this.writeEmitter = new vscode_1.EventEmitter();
        this.closeEmitter = new vscode_1.EventEmitter();
        this.endOfLine = "\r\n";
    }
    get onDidWrite() { return this.writeEmitter.event; }
    get onDidClose() { return this.closeEmitter.event; }
    open(_initialDimensions) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.taskUsesActiveFile && !util.fileIsCOrCppSource((_a = vscode_1.window.activeTextEditor) === null || _a === void 0 ? void 0 : _a.document.fileName)) {
                this.writeEmitter.fire(localize(3, null) + this.endOfLine);
                this.closeEmitter.fire(-1);
                return;
            }
            telemetry.logLanguageServerEvent("cppBuildTaskStarted");
            this.writeEmitter.fire(localize(4, null) + this.endOfLine);
            yield this.doBuild();
        });
    }
    close() {
    }
    doBuild() {
        return __awaiter(this, void 0, void 0, function* () {
            let command = util.resolveVariables(this.command);
            let activeCommand = command;
            this.args.forEach((value, index) => {
                value = util.normalizeArg(util.resolveVariables(value));
                activeCommand = activeCommand + " " + value;
                this.args[index] = value;
            });
            if (this.options) {
                this.options.shell = true;
            }
            else {
                this.options = { "shell": true };
            }
            if (this.options.cwd) {
                this.options.cwd = util.resolveVariables(this.options.cwd);
            }
            const splitWriteEmitter = (lines) => {
                const splitLines = lines.toString().split(/\r?\n/g);
                for (let i = 0; i < splitLines.length; i++) {
                    let line = splitLines[i];
                    if (i !== splitLines.length - 1) {
                        line += this.endOfLine;
                    }
                    this.writeEmitter.fire(line);
                }
            };
            if (os.platform() === 'win32') {
                command = `cmd /c chcp 65001>nul && ${command}`;
            }
            this.writeEmitter.fire(activeCommand + this.endOfLine);
            let child;
            try {
                child = cp.spawn(command, this.args, this.options ? this.options : {});
                let error = "";
                let stdout = "";
                let stderr = "";
                const result = yield new Promise(resolve => {
                    var _a, _b;
                    if (child) {
                        child.on('error', err => {
                            splitWriteEmitter(err.message);
                            error = err.message;
                            resolve(-1);
                        });
                        (_a = child.stdout) === null || _a === void 0 ? void 0 : _a.on('data', data => {
                            const str = data.toString();
                            splitWriteEmitter(str);
                            stdout += str;
                        });
                        (_b = child.stderr) === null || _b === void 0 ? void 0 : _b.on('data', data => {
                            const str = data.toString();
                            splitWriteEmitter(str);
                            stderr += str;
                        });
                        child.on('close', result => {
                            this.writeEmitter.fire(this.endOfLine);
                            if (result === null) {
                                this.writeEmitter.fire(localize(5, null) + this.endOfLine);
                                resolve(-1);
                            }
                            resolve(0);
                        });
                    }
                });
                this.printBuildSummary(error, stdout, stderr);
                this.closeEmitter.fire(result);
            }
            catch (_a) {
                this.closeEmitter.fire(-1);
            }
        });
    }
    printBuildSummary(error, stdout, stderr) {
        if (error || (!stdout && stderr && stderr.includes("error")) ||
            (stdout && stdout.includes("error C"))) {
            telemetry.logLanguageServerEvent("cppBuildTaskError");
            this.writeEmitter.fire(localize(6, null) + this.endOfLine);
        }
        else if ((!stdout && stderr) ||
            (stdout && stdout.includes("warning C"))) {
            telemetry.logLanguageServerEvent("cppBuildTaskWarnings");
            this.writeEmitter.fire(localize(7, null) + this.endOfLine);
        }
        else {
            this.writeEmitter.fire(localize(8, null) + this.endOfLine);
        }
    }
}


/***/ }),

/***/ 4977:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSameProviderExtensionId = exports.getCustomConfigProviders = exports.CustomConfigurationProviderCollection = void 0;
const vscode_cpptools_1 = __webpack_require__(3286);
const settings_1 = __webpack_require__(296);
const ext = __webpack_require__(2973);
const oldCmakeToolsExtensionId = "vector-of-bool.cmake-tools";
const newCmakeToolsExtensionId = "ms-vscode.cmake-tools";
class CustomProviderWrapper {
    constructor(provider, version) {
        this._isReady = version < vscode_cpptools_1.Version.v2;
        this.provider = provider;
        if (provider.extensionId && version === vscode_cpptools_1.Version.v0) {
            version = vscode_cpptools_1.Version.v1;
        }
        this._version = version;
    }
    get isReady() {
        return this._isReady;
    }
    set isReady(ready) {
        this._isReady = ready;
    }
    get isValid() {
        let valid = !!this.provider.name && !!this.provider.canProvideConfiguration && !!this.provider.provideConfigurations;
        if (valid && this._version > vscode_cpptools_1.Version.v0) {
            valid = !!this.provider.extensionId && !!this.provider.dispose;
        }
        if (valid && this._version > vscode_cpptools_1.Version.v1) {
            valid = !!this.provider.canProvideBrowseConfiguration && !!this.provider.provideBrowseConfiguration;
        }
        if (valid && this._version > vscode_cpptools_1.Version.v2) {
            valid = !!this.provider.canProvideBrowseConfigurationsPerFolder && !!this.provider.provideFolderBrowseConfiguration;
        }
        return valid;
    }
    get version() {
        return this._version;
    }
    get name() {
        return this.provider.name;
    }
    get extensionId() {
        return this._version === vscode_cpptools_1.Version.v0 ? this.provider.name : this.provider.extensionId;
    }
    canProvideConfiguration(uri, token) {
        return this.provider.canProvideConfiguration(uri, token);
    }
    provideConfigurations(uris, token) {
        return this.provider.provideConfigurations(uris, token);
    }
    canProvideBrowseConfiguration(token) {
        return this._version < vscode_cpptools_1.Version.v2 ? Promise.resolve(false) : this.provider.canProvideBrowseConfiguration(token);
    }
    provideBrowseConfiguration(token) {
        console.assert(this._version >= vscode_cpptools_1.Version.v2);
        return this._version < vscode_cpptools_1.Version.v2 ? Promise.resolve({ browsePath: [] }) : this.provider.provideBrowseConfiguration(token);
    }
    canProvideBrowseConfigurationsPerFolder(token) {
        return this._version < vscode_cpptools_1.Version.v3 ? Promise.resolve(false) : this.provider.canProvideBrowseConfigurationsPerFolder(token);
    }
    provideFolderBrowseConfiguration(uri, token) {
        console.assert(this._version >= vscode_cpptools_1.Version.v3);
        return this._version < vscode_cpptools_1.Version.v3 ? Promise.resolve({ browsePath: [] }) : this.provider.provideFolderBrowseConfiguration(uri, token);
    }
    dispose() {
        if (this._version !== vscode_cpptools_1.Version.v0) {
            this.provider.dispose();
        }
    }
}
class CustomConfigurationProviderCollection {
    constructor() {
        this.providers = new Map();
    }
    logProblems(provider, version) {
        const missing = [];
        if (!provider.name) {
            missing.push("'name'");
        }
        if (version !== vscode_cpptools_1.Version.v0 && !provider.extensionId) {
            missing.push("'extensionId'");
        }
        if (!provider.canProvideConfiguration) {
            missing.push("'canProvideConfiguration'");
        }
        if (!provider.provideConfigurations) {
            missing.push("'canProvideConfiguration'");
        }
        if (version !== vscode_cpptools_1.Version.v0 && !provider.dispose) {
            missing.push("'dispose'");
        }
        if (version >= vscode_cpptools_1.Version.v2 && !provider.canProvideBrowseConfiguration) {
            missing.push("'canProvideBrowseConfiguration'");
        }
        if (version >= vscode_cpptools_1.Version.v2 && !provider.provideBrowseConfiguration) {
            missing.push("'provideBrowseConfiguration'");
        }
        if (version >= vscode_cpptools_1.Version.v3 && !provider.canProvideBrowseConfigurationsPerFolder) {
            missing.push("'canProvideBrowseConfigurationsPerFolder'");
        }
        if (version >= vscode_cpptools_1.Version.v3 && !provider.provideFolderBrowseConfiguration) {
            missing.push("'provideFolderBrowseConfiguration'");
        }
        console.error(`CustomConfigurationProvider was not registered. The following properties are missing from the implementation: ${missing.join(", ")}.`);
    }
    getId(provider) {
        if (typeof provider === "string") {
            return provider;
        }
        else if (provider.extensionId) {
            return provider.extensionId;
        }
        else if (provider.name) {
            return provider.name;
        }
        else {
            console.error(`invalid provider: ${provider}`);
            return "";
        }
    }
    get size() {
        return this.providers.size;
    }
    add(provider, version) {
        if (new settings_1.CppSettings(ext.getActiveClient().RootUri).intelliSenseEngine === "Disabled") {
            console.warn("Language service is disabled. Provider will not be registered.");
            return false;
        }
        const wrapper = new CustomProviderWrapper(provider, version);
        if (!wrapper.isValid) {
            this.logProblems(provider, version);
            return false;
        }
        let exists = false;
        const existing = this.providers.get(wrapper.extensionId);
        if (existing) {
            exists = (existing.version === vscode_cpptools_1.Version.v0 && wrapper.version === vscode_cpptools_1.Version.v0);
        }
        if (!exists) {
            this.providers.set(wrapper.extensionId, wrapper);
        }
        else {
            console.error(`CustomConfigurationProvider '${wrapper.extensionId}' has already been registered.`);
        }
        return !exists;
    }
    get(provider) {
        let id = this.getId(provider);
        if (this.providers.has(id)) {
            return this.providers.get(id);
        }
        if (typeof provider === "string") {
            if (provider === newCmakeToolsExtensionId) {
                id = oldCmakeToolsExtensionId;
            }
            else if (provider === oldCmakeToolsExtensionId) {
                id = newCmakeToolsExtensionId;
            }
            if (this.providers.has(id)) {
                return this.providers.get(id);
            }
        }
        return undefined;
    }
    forEach(func) {
        this.providers.forEach(func);
    }
    remove(provider) {
        const id = this.getId(provider);
        if (this.providers.has(id)) {
            this.providers.delete(id);
        }
        else {
            console.warn(`${id} is not registered`);
        }
    }
    checkId(providerId) {
        if (!providerId) {
            return undefined;
        }
        const found = [];
        let noUpdate = false;
        this.forEach(provider => {
            if (provider.extensionId === providerId) {
                noUpdate = true;
            }
            else if (provider.name === providerId && provider.version !== vscode_cpptools_1.Version.v0) {
                found.push(provider);
            }
        });
        if (noUpdate) {
            return providerId;
        }
        if (found.length === 1) {
            return found[0].extensionId;
        }
        else if (found.length > 1) {
            console.warn("duplicate provider name found. Not upgrading.");
        }
        return providerId;
    }
}
exports.CustomConfigurationProviderCollection = CustomConfigurationProviderCollection;
const providerCollection = new CustomConfigurationProviderCollection();
function getCustomConfigProviders() {
    return providerCollection;
}
exports.getCustomConfigProviders = getCustomConfigProviders;
function isSameProviderExtensionId(settingExtensionId, providerExtensionId) {
    if (!settingExtensionId && !providerExtensionId) {
        return true;
    }
    if (settingExtensionId === providerExtensionId) {
        return true;
    }
    if ((settingExtensionId === newCmakeToolsExtensionId && providerExtensionId === oldCmakeToolsExtensionId)
        || (settingExtensionId === oldCmakeToolsExtensionId && providerExtensionId === newCmakeToolsExtensionId)) {
        return true;
    }
    return false;
}
exports.isSameProviderExtensionId = isSameProviderExtensionId;


/***/ }),

/***/ 1748:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataBinding = void 0;
const vscode = __webpack_require__(7549);
class DataBinding {
    constructor(value) {
        this.valueChanged = new vscode.EventEmitter();
        this.isActive = true;
        this.value = value;
        this.isActive = true;
    }
    get Value() {
        return this.value;
    }
    set Value(value) {
        if (value !== this.value) {
            this.value = value;
            this.valueChanged.fire(this.value);
        }
    }
    setValueIfActive(value) {
        if (value !== this.value) {
            this.value = value;
            if (this.isActive) {
                this.valueChanged.fire(this.value);
            }
        }
    }
    get ValueChanged() {
        return this.valueChanged.event;
    }
    activate() {
        this.isActive = true;
        this.valueChanged.fire(this.value);
    }
    deactivate() {
        this.isActive = false;
    }
    dispose() {
        this.deactivate();
        this.valueChanged.dispose();
    }
}
exports.DataBinding = DataBinding;


/***/ }),

/***/ 2973:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getActiveClient = exports.getClients = exports.isFolderOpen = exports.deactivate = exports.registerCommands = exports.processDelayedDidOpen = exports.onDidChangeActiveTextEditor = exports.updateLanguageConfigurations = exports.activate = exports.intelliSenseDisabledError = exports.cppBuildTaskProvider = void 0;
const path = __webpack_require__(5622);
const vscode = __webpack_require__(7549);
const os = __webpack_require__(2087);
const fs = __webpack_require__(5747);
const util = __webpack_require__(5331);
const telemetry = __webpack_require__(1818);
const referencesModel_1 = __webpack_require__(9997);
const ui_1 = __webpack_require__(6713);
const client_1 = __webpack_require__(9325);
const clientCollection_1 = __webpack_require__(3765);
const settings_1 = __webpack_require__(296);
const persistentState_1 = __webpack_require__(1102);
const languageConfig_1 = __webpack_require__(1626);
const customProviders_1 = __webpack_require__(4977);
const vscode_languageclient_1 = __webpack_require__(3094);
const rd = __webpack_require__(1058);
const yauzl = __webpack_require__(8798);
const nls = __webpack_require__(3463);
const cppBuildTaskProvider_1 = __webpack_require__(7523);
const main_1 = __webpack_require__(7114);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\extension.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\extension.ts'));
exports.cppBuildTaskProvider = new cppBuildTaskProvider_1.CppBuildTaskProvider();
let prevCrashFile;
let clients;
let activeDocument;
let ui;
const disposables = [];
let languageConfigurations = [];
let intervalTimer;
let taskProvider;
let codeActionProvider;
exports.intelliSenseDisabledError = "Do not activate the extension when IntelliSense is disabled.";
let vcpkgDbPromise;
function initVcpkgDatabase() {
    return new Promise((resolve, reject) => {
        yauzl.open(util.getExtensionFilePath('VCPkgHeadersDatabase.zip'), { lazyEntries: true }, (err, zipfile) => {
            const database = {};
            if (err || !zipfile) {
                resolve(database);
                return;
            }
            zipfile.on('close', () => {
                resolve(database);
            });
            zipfile.on('entry', entry => {
                if (entry.fileName !== 'VCPkgHeadersDatabase.txt') {
                    zipfile.readEntry();
                    return;
                }
                zipfile.openReadStream(entry, (err, stream) => {
                    if (err || !stream) {
                        zipfile.close();
                        return;
                    }
                    const reader = rd.createInterface(stream);
                    reader.on('line', (lineText) => {
                        const portFilePair = lineText.split(':');
                        if (portFilePair.length !== 2) {
                            return;
                        }
                        const portName = portFilePair[0];
                        const relativeHeader = portFilePair[1];
                        if (!database[relativeHeader]) {
                            database[relativeHeader] = [];
                        }
                        database[relativeHeader].push(portName);
                    });
                    reader.on('close', () => {
                        zipfile.close();
                    });
                });
            });
            zipfile.readEntry();
        });
    });
}
function getVcpkgHelpAction() {
    const dummy = [{}];
    return {
        command: { title: 'vcpkgOnlineHelpSuggested', command: 'C_Cpp.VcpkgOnlineHelpSuggested', arguments: dummy },
        title: localize(0, null),
        kind: vscode.CodeActionKind.QuickFix
    };
}
function getVcpkgClipboardInstallAction(port) {
    return {
        command: { title: 'vcpkgClipboardInstallSuggested', command: 'C_Cpp.VcpkgClipboardInstallSuggested', arguments: [[port]] },
        title: localize(1, null, port),
        kind: vscode.CodeActionKind.QuickFix
    };
}
function lookupIncludeInVcpkg(document, line) {
    return __awaiter(this, void 0, void 0, function* () {
        const matches = document.lineAt(line).text.match(/#include\s*[<"](?<includeFile>[^>"]*)[>"]/);
        if (!matches || !matches.length || !matches.groups) {
            return [];
        }
        const missingHeader = matches.groups['includeFile'].replace(/\//g, '\\');
        let portsWithHeader;
        const vcpkgDb = yield vcpkgDbPromise;
        if (vcpkgDb) {
            portsWithHeader = vcpkgDb[missingHeader];
        }
        return portsWithHeader ? portsWithHeader : [];
    });
}
function isMissingIncludeDiagnostic(diagnostic) {
    const missingIncludeCode = 1696;
    if (diagnostic.code === null || diagnostic.code === undefined || !diagnostic.source) {
        return false;
    }
    return diagnostic.code === missingIncludeCode && diagnostic.source === 'C/C++';
}
function sendActivationTelemetry() {
    const activateEvent = {};
    if (vscode.env.machineId !== "someValue.machineId") {
        const machineIdPersistentState = new persistentState_1.PersistentState("CPP.machineId", undefined);
        if (!machineIdPersistentState.Value) {
            activateEvent["newMachineId"] = vscode.env.machineId;
        }
        else if (machineIdPersistentState.Value !== vscode.env.machineId) {
            activateEvent["newMachineId"] = vscode.env.machineId;
            activateEvent["oldMachineId"] = machineIdPersistentState.Value;
        }
        machineIdPersistentState.Value = vscode.env.machineId;
    }
    if (vscode.env.uiKind === vscode.UIKind.Web) {
        activateEvent["WebUI"] = "1";
    }
    telemetry.logLanguageServerEvent("Activate", activateEvent);
}
function activate() {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
            for (let i = 0; i < vscode.workspace.workspaceFolders.length; ++i) {
                const config = path.join(vscode.workspace.workspaceFolders[i].uri.fsPath, ".vscode/c_cpp_properties.json");
                if (yield util.checkFileExists(config)) {
                    const doc = yield vscode.workspace.openTextDocument(config);
                    vscode.languages.setTextDocumentLanguage(doc, "jsonc");
                }
            }
        }
        taskProvider = vscode.tasks.registerTaskProvider(cppBuildTaskProvider_1.CppBuildTaskProvider.CppBuildScriptType, exports.cppBuildTaskProvider);
        vscode.tasks.onDidStartTask(event => {
            getActiveClient().PauseCodeAnalysis();
            if (event.execution.task.definition.type === cppBuildTaskProvider_1.CppBuildTaskProvider.CppBuildScriptType
                || event.execution.task.name.startsWith(cppBuildTaskProvider_1.CppBuildTaskProvider.CppBuildSourceStr)) {
                telemetry.logLanguageServerEvent('buildTaskStarted');
            }
        });
        vscode.tasks.onDidEndTask(event => {
            getActiveClient().ResumeCodeAnalysis();
            if (event.execution.task.definition.type === cppBuildTaskProvider_1.CppBuildTaskProvider.CppBuildScriptType
                || event.execution.task.name.startsWith(cppBuildTaskProvider_1.CppBuildTaskProvider.CppBuildSourceStr)) {
                telemetry.logLanguageServerEvent('buildTaskFinished');
                if (event.execution.task.scope !== vscode.TaskScope.Global && event.execution.task.scope !== vscode.TaskScope.Workspace) {
                    const folder = event.execution.task.scope;
                    if (folder) {
                        const settings = new settings_1.CppSettings(folder.uri);
                        if (settings.codeAnalysisRunOnBuild && settings.clangTidyEnabled) {
                            clients.getClientFor(folder.uri).handleRunCodeAnalysisOnAllFiles();
                        }
                        return;
                    }
                }
                const settings = new settings_1.CppSettings();
                if (settings.codeAnalysisRunOnBuild && settings.clangTidyEnabled) {
                    clients.ActiveClient.handleRunCodeAnalysisOnAllFiles();
                }
            }
        });
        const selector = [
            { scheme: 'file', language: 'c' },
            { scheme: 'file', language: 'cpp' },
            { scheme: 'file', language: 'cuda-cpp' }
        ];
        codeActionProvider = vscode.languages.registerCodeActionsProvider(selector, {
            provideCodeActions: (document, range, context, token) => __awaiter(this, void 0, void 0, function* () {
                if (!(yield clients.ActiveClient.getVcpkgEnabled())) {
                    return [];
                }
                if (!context.diagnostics.some(isMissingIncludeDiagnostic)) {
                    return [];
                }
                telemetry.logLanguageServerEvent('codeActionsProvided', { "source": "vcpkg" });
                if (!(yield clients.ActiveClient.getVcpkgInstalled())) {
                    return [getVcpkgHelpAction()];
                }
                const ports = yield lookupIncludeInVcpkg(document, range.start.line);
                const actions = ports.map(getVcpkgClipboardInstallAction);
                return actions;
            })
        });
        if (new settings_1.CppSettings((vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) ? (_a = vscode.workspace.workspaceFolders[0]) === null || _a === void 0 ? void 0 : _a.uri : undefined).intelliSenseEngine === "Disabled") {
            throw new Error(exports.intelliSenseDisabledError);
        }
        else {
            console.log("activating extension");
            sendActivationTelemetry();
            const checkForConflictingExtensions = new persistentState_1.PersistentState("CPP." + util.packageJson.version + ".checkForConflictingExtensions", true);
            if (checkForConflictingExtensions.Value) {
                checkForConflictingExtensions.Value = false;
                const clangCommandAdapterActive = vscode.extensions.all.some((extension, index, array) => extension.isActive && extension.id === "mitaki28.vscode-clang");
                if (clangCommandAdapterActive) {
                    telemetry.logLanguageServerEvent("conflictingExtension");
                }
            }
        }
        console.log("starting language server");
        clients = new clientCollection_1.ClientCollection();
        ui = (0, ui_1.getUI)();
        const activeEditor = vscode.window.activeTextEditor;
        if (activeEditor) {
            clients.timeTelemetryCollector.setFirstFile(activeEditor.document.uri);
        }
        clients.forEach(client => {
            (0, customProviders_1.getCustomConfigProviders)().forEach(provider => client.onRegisterCustomConfigurationProvider(provider));
        });
        disposables.push(vscode.workspace.onDidChangeConfiguration(onDidChangeSettings));
        disposables.push(vscode.window.onDidChangeActiveTextEditor(onDidChangeActiveTextEditor));
        ui.activeDocumentChanged();
        disposables.push(vscode.window.onDidChangeTextEditorSelection(onDidChangeTextEditorSelection));
        disposables.push(vscode.window.onDidChangeVisibleTextEditors(onDidChangeVisibleTextEditors));
        updateLanguageConfigurations();
        reportMacCrashes();
        vcpkgDbPromise = initVcpkgDatabase();
        clients.ActiveClient.notifyWhenLanguageClientReady(() => {
            intervalTimer = global.setInterval(onInterval, 2500);
        });
    });
}
exports.activate = activate;
function updateLanguageConfigurations() {
    languageConfigurations.forEach(d => d.dispose());
    languageConfigurations = [];
    languageConfigurations.push(vscode.languages.setLanguageConfiguration('c', (0, languageConfig_1.getLanguageConfig)('c')));
    languageConfigurations.push(vscode.languages.setLanguageConfiguration('cpp', (0, languageConfig_1.getLanguageConfig)('cpp')));
    languageConfigurations.push(vscode.languages.setLanguageConfiguration('cuda-cpp', (0, languageConfig_1.getLanguageConfig)('cuda-cpp')));
}
exports.updateLanguageConfigurations = updateLanguageConfigurations;
function onDidChangeSettings(event) {
    const activeClient = clients.ActiveClient;
    const changedActiveClientSettings = activeClient.onDidChangeSettings(event, true);
    clients.forEach(client => {
        if (client !== activeClient) {
            client.onDidChangeSettings(event, false);
        }
    });
    const newUpdateChannel = changedActiveClientSettings['updateChannel'];
    if (newUpdateChannel || event.affectsConfiguration("extensions.autoUpdate")) {
        (0, main_1.UpdateInsidersAccess)();
    }
}
function onDidChangeActiveTextEditor(editor) {
    console.assert(clients !== undefined, "client should be available before active editor is changed");
    if (clients === undefined) {
        return;
    }
    const activeEditor = vscode.window.activeTextEditor;
    if (!editor || !activeEditor || activeEditor.document.uri.scheme !== "file" || (activeEditor.document.languageId !== "c" && activeEditor.document.languageId !== "cpp" && activeEditor.document.languageId !== "cuda-cpp")) {
        activeDocument = "";
    }
    else {
        activeDocument = editor.document.uri.toString();
        clients.activeDocumentChanged(editor.document);
        clients.ActiveClient.selectionChanged(vscode_languageclient_1.Range.create(editor.selection.start, editor.selection.end));
    }
    ui.activeDocumentChanged();
}
exports.onDidChangeActiveTextEditor = onDidChangeActiveTextEditor;
function onDidChangeTextEditorSelection(event) {
    if (!event.textEditor || !vscode.window.activeTextEditor || event.textEditor.document.uri !== vscode.window.activeTextEditor.document.uri ||
        event.textEditor.document.uri.scheme !== "file" ||
        (event.textEditor.document.languageId !== "cpp" && event.textEditor.document.languageId !== "c")) {
        return;
    }
    if (activeDocument !== event.textEditor.document.uri.toString()) {
        activeDocument = event.textEditor.document.uri.toString();
        clients.activeDocumentChanged(event.textEditor.document);
        ui.activeDocumentChanged();
    }
    clients.ActiveClient.selectionChanged(vscode_languageclient_1.Range.create(event.selections[0].start, event.selections[0].end));
}
function processDelayedDidOpen(document) {
    const client = clients.getClientFor(document.uri);
    if (client) {
        if (clients.checkOwnership(client, document)) {
            if (!client.TrackedDocuments.has(document)) {
                clients.timeTelemetryCollector.setDidOpenTime(document.uri);
                client.TrackedDocuments.add(document);
                const finishDidOpen = (doc) => {
                    client.provideCustomConfiguration(doc.uri, undefined);
                    client.notifyWhenLanguageClientReady(() => {
                        client.takeOwnership(doc);
                        client.onDidOpenTextDocument(doc);
                    });
                };
                let languageChanged = false;
                if ((document.uri.path.endsWith(".C") || document.uri.path.endsWith(".H")) && document.languageId === "c") {
                    const cppSettings = new settings_1.CppSettings();
                    if (cppSettings.autoAddFileAssociations) {
                        const fileName = path.basename(document.uri.fsPath);
                        const mappingString = fileName + "@" + document.uri.fsPath;
                        client.addFileAssociations(mappingString, "cpp");
                        client.sendDidChangeSettings({ files: { associations: new settings_1.OtherSettings().filesAssociations } });
                        vscode.languages.setTextDocumentLanguage(document, "cpp").then((newDoc) => {
                            finishDidOpen(newDoc);
                        });
                        languageChanged = true;
                    }
                }
                if (!languageChanged) {
                    finishDidOpen(document);
                }
                return true;
            }
        }
    }
    return false;
}
exports.processDelayedDidOpen = processDelayedDidOpen;
function onDidChangeVisibleTextEditors(editors) {
    editors.forEach(editor => {
        if ((editor.document.uri.scheme === "file") && (editor.document.languageId === "c" || editor.document.languageId === "cpp" || editor.document.languageId === "cuda-cpp")) {
            if (!processDelayedDidOpen(editor.document)) {
                const client = clients.getClientFor(editor.document.uri);
                client.onDidChangeVisibleTextEditor(editor);
            }
        }
    });
}
function onInterval() {
    clients.ActiveClient.onInterval();
}
let commandsRegistered = false;
function registerCommands() {
    if (commandsRegistered) {
        return;
    }
    commandsRegistered = true;
    disposables.push(vscode.commands.registerCommand('C_Cpp.SwitchHeaderSource', onSwitchHeaderSource));
    disposables.push(vscode.commands.registerCommand('C_Cpp.ResetDatabase', onResetDatabase));
    disposables.push(vscode.commands.registerCommand('C_Cpp.ConfigurationSelect', onSelectConfiguration));
    disposables.push(vscode.commands.registerCommand('C_Cpp.ConfigurationProviderSelect', onSelectConfigurationProvider));
    disposables.push(vscode.commands.registerCommand('C_Cpp.ConfigurationEditJSON', onEditConfigurationJSON));
    disposables.push(vscode.commands.registerCommand('C_Cpp.ConfigurationEditUI', onEditConfigurationUI));
    disposables.push(vscode.commands.registerCommand('C_Cpp.ConfigurationEdit', onEditConfiguration));
    disposables.push(vscode.commands.registerCommand('C_Cpp.AddToIncludePath', onAddToIncludePath));
    disposables.push(vscode.commands.registerCommand('C_Cpp.EnableErrorSquiggles', onEnableSquiggles));
    disposables.push(vscode.commands.registerCommand('C_Cpp.DisableErrorSquiggles', onDisableSquiggles));
    disposables.push(vscode.commands.registerCommand('C_Cpp.ToggleIncludeFallback', onToggleIncludeFallback));
    disposables.push(vscode.commands.registerCommand('C_Cpp.ToggleDimInactiveRegions', onToggleDimInactiveRegions));
    disposables.push(vscode.commands.registerCommand('C_Cpp.PauseParsing', onPauseParsing));
    disposables.push(vscode.commands.registerCommand('C_Cpp.ResumeParsing', onResumeParsing));
    disposables.push(vscode.commands.registerCommand('C_Cpp.PauseCodeAnalysis', onPauseCodeAnalysis));
    disposables.push(vscode.commands.registerCommand('C_Cpp.ResumeCodeAnalysis', onResumeCodeAnalysis));
    disposables.push(vscode.commands.registerCommand('C_Cpp.CancelCodeAnalysis', onCancelCodeAnalysis));
    disposables.push(vscode.commands.registerCommand('C_Cpp.ShowParsingCommands', onShowParsingCommands));
    disposables.push(vscode.commands.registerCommand('C_Cpp.ShowCodeAnalysisCommands', onShowCodeAnalysisCommands));
    disposables.push(vscode.commands.registerCommand('C_Cpp.ShowReferencesProgress', onShowReferencesProgress));
    disposables.push(vscode.commands.registerCommand('C_Cpp.TakeSurvey', onTakeSurvey));
    disposables.push(vscode.commands.registerCommand('C_Cpp.LogDiagnostics', onLogDiagnostics));
    disposables.push(vscode.commands.registerCommand('C_Cpp.RescanWorkspace', onRescanWorkspace));
    disposables.push(vscode.commands.registerCommand('C_Cpp.ShowReferenceItem', onShowRefCommand));
    disposables.push(vscode.commands.registerCommand('C_Cpp.referencesViewGroupByType', onToggleRefGroupView));
    disposables.push(vscode.commands.registerCommand('C_Cpp.referencesViewUngroupByType', onToggleRefGroupView));
    disposables.push(vscode.commands.registerCommand('C_Cpp.VcpkgClipboardInstallSuggested', onVcpkgClipboardInstallSuggested));
    disposables.push(vscode.commands.registerCommand('C_Cpp.VcpkgOnlineHelpSuggested', onVcpkgOnlineHelpSuggested));
    disposables.push(vscode.commands.registerCommand('C_Cpp.GenerateEditorConfig', onGenerateEditorConfig));
    disposables.push(vscode.commands.registerCommand('C_Cpp.GoToNextDirectiveInGroup', onGoToNextDirectiveInGroup));
    disposables.push(vscode.commands.registerCommand('C_Cpp.GoToPrevDirectiveInGroup', onGoToPrevDirectiveInGroup));
    disposables.push(vscode.commands.registerCommand('C_Cpp.CheckForCompiler', onCheckForCompiler));
    disposables.push(vscode.commands.registerCommand('C_Cpp.RunCodeAnalysisOnActiveFile', onRunCodeAnalysisOnActiveFile));
    disposables.push(vscode.commands.registerCommand('C_Cpp.RunCodeAnalysisOnOpenFiles', onRunCodeAnalysisOnOpenFiles));
    disposables.push(vscode.commands.registerCommand('C_Cpp.RunCodeAnalysisOnAllFiles', onRunCodeAnalysisOnAllFiles));
    disposables.push(vscode.commands.registerCommand('C_Cpp.ClearCodeAnalysisSquiggles', onClearCodeAnalysisSquiggles));
    disposables.push(vscode.commands.registerCommand('cpptools.activeConfigName', onGetActiveConfigName));
    disposables.push(vscode.commands.registerCommand('cpptools.activeConfigCustomVariable', onGetActiveConfigCustomVariable));
    disposables.push(vscode.commands.registerCommand('cpptools.setActiveConfigName', onSetActiveConfigName));
    disposables.push(vscode.commands.registerCommand('C_Cpp.RestartIntelliSenseForFile', onRestartIntelliSenseForFile));
}
exports.registerCommands = registerCommands;
function onRestartIntelliSenseForFile() {
    const activeEditor = vscode.window.activeTextEditor;
    if (!activeEditor || !activeEditor.document || activeEditor.document.uri.scheme !== "file" ||
        (activeEditor.document.languageId !== "c" && activeEditor.document.languageId !== "cpp" && activeEditor.document.languageId !== "cuda-cpp")) {
        return;
    }
    clients.ActiveClient.restartIntelliSenseForFile(activeEditor.document);
}
function onSwitchHeaderSource() {
    return __awaiter(this, void 0, void 0, function* () {
        const activeEditor = vscode.window.activeTextEditor;
        if (!activeEditor || !activeEditor.document) {
            return;
        }
        if (activeEditor.document.languageId !== "c" && activeEditor.document.languageId !== "cpp" && activeEditor.document.languageId !== "cuda-cpp") {
            return;
        }
        let rootPath = clients.ActiveClient.RootPath;
        const fileName = activeEditor.document.fileName;
        if (!rootPath) {
            rootPath = path.dirname(fileName);
        }
        let targetFileName = yield clients.ActiveClient.requestSwitchHeaderSource(rootPath, fileName);
        let targetFileNameReplaced = false;
        clients.forEach(client => {
            if (!targetFileNameReplaced && client.RootRealPath && client.RootPath !== client.RootRealPath
                && targetFileName.indexOf(client.RootRealPath) === 0) {
                targetFileName = client.RootPath + targetFileName.substr(client.RootRealPath.length);
                targetFileNameReplaced = true;
            }
        });
        const document = yield vscode.workspace.openTextDocument(targetFileName);
        let foundEditor = false;
        vscode.window.visibleTextEditors.forEach((editor, index, array) => {
            if (editor.document === document && !foundEditor) {
                foundEditor = true;
                vscode.window.showTextDocument(document, editor.viewColumn);
            }
        });
        if (!foundEditor) {
            vscode.window.showTextDocument(document);
        }
    });
}
function selectClient() {
    return __awaiter(this, void 0, void 0, function* () {
        if (clients.Count === 1) {
            return clients.ActiveClient;
        }
        else {
            const key = yield ui.showWorkspaces(clients.Names);
            if (key !== "") {
                const client = clients.get(key);
                if (client) {
                    return client;
                }
                else {
                    console.assert("client not found");
                }
            }
            throw new Error(localize(2, null));
        }
    });
}
function onResetDatabase() {
    clients.ActiveClient.resetDatabase();
}
function onSelectConfiguration() {
    if (!isFolderOpen()) {
        vscode.window.showInformationMessage(localize(3, null));
    }
    else {
        clients.ActiveClient.handleConfigurationSelectCommand();
    }
}
function onSelectConfigurationProvider() {
    if (!isFolderOpen()) {
        vscode.window.showInformationMessage(localize(4, null));
    }
    else {
        selectClient().then(client => client.handleConfigurationProviderSelectCommand(), rejected => { });
    }
}
function onEditConfigurationJSON(viewColumn = vscode.ViewColumn.Active) {
    telemetry.logLanguageServerEvent("SettingsCommand", { "palette": "json" }, undefined);
    if (!isFolderOpen()) {
        vscode.window.showInformationMessage(localize(5, null));
    }
    else {
        selectClient().then(client => client.handleConfigurationEditJSONCommand(viewColumn), rejected => { });
    }
}
function onEditConfigurationUI(viewColumn = vscode.ViewColumn.Active) {
    telemetry.logLanguageServerEvent("SettingsCommand", { "palette": "ui" }, undefined);
    if (!isFolderOpen()) {
        vscode.window.showInformationMessage(localize(6, null));
    }
    else {
        selectClient().then(client => client.handleConfigurationEditUICommand(viewColumn), rejected => { });
    }
}
function onEditConfiguration(viewColumn = vscode.ViewColumn.Active) {
    if (!isFolderOpen()) {
        vscode.window.showInformationMessage(localize(7, null));
    }
    else {
        selectClient().then(client => client.handleConfigurationEditCommand(viewColumn), rejected => { });
    }
}
function onGenerateEditorConfig() {
    if (!isFolderOpen()) {
        const settings = new settings_1.CppSettings();
        settings.generateEditorConfig();
    }
    else {
        selectClient().then(client => {
            const settings = new settings_1.CppSettings(client.RootUri);
            settings.generateEditorConfig();
        });
    }
}
function onGoToNextDirectiveInGroup() {
    const client = getActiveClient();
    client.handleGoToDirectiveInGroup(true);
}
function onGoToPrevDirectiveInGroup() {
    const client = getActiveClient();
    client.handleGoToDirectiveInGroup(false);
}
function onCheckForCompiler() {
    const client = getActiveClient();
    client.handleCheckForCompiler();
}
function onRunCodeAnalysisOnActiveFile() {
    return __awaiter(this, void 0, void 0, function* () {
        if (activeDocument !== "") {
            yield vscode.commands.executeCommand("workbench.action.files.saveAll");
            getActiveClient().handleRunCodeAnalysisOnActiveFile();
        }
    });
}
function onRunCodeAnalysisOnOpenFiles() {
    return __awaiter(this, void 0, void 0, function* () {
        if (client_1.openFileVersions.size > 0) {
            yield vscode.commands.executeCommand("workbench.action.files.saveAll");
            getActiveClient().handleRunCodeAnalysisOnOpenFiles();
        }
    });
}
function onRunCodeAnalysisOnAllFiles() {
    return __awaiter(this, void 0, void 0, function* () {
        yield vscode.commands.executeCommand("workbench.action.files.saveAll");
        getActiveClient().handleRunCodeAnalysisOnAllFiles();
    });
}
function onClearCodeAnalysisSquiggles() {
    return __awaiter(this, void 0, void 0, function* () {
        getActiveClient().handleClearCodeAnalysisSquiggles();
    });
}
function onAddToIncludePath(path) {
    if (!isFolderOpen()) {
        vscode.window.showInformationMessage(localize(8, null, "includePath"));
    }
    else {
        clients.ActiveClient.handleAddToIncludePathCommand(path);
    }
}
function onEnableSquiggles() {
    const settings = new settings_1.CppSettings(clients.ActiveClient.RootUri);
    settings.update("errorSquiggles", "Enabled");
}
function onDisableSquiggles() {
    const settings = new settings_1.CppSettings(clients.ActiveClient.RootUri);
    settings.update("errorSquiggles", "Disabled");
}
function onToggleIncludeFallback() {
    const settings = new settings_1.CppSettings(clients.ActiveClient.RootUri);
    settings.toggleSetting("intelliSenseEngineFallback", "Enabled", "Disabled");
}
function onToggleDimInactiveRegions() {
    const settings = new settings_1.CppSettings(clients.ActiveClient.RootUri);
    settings.update("dimInactiveRegions", !settings.dimInactiveRegions);
}
function onPauseParsing() {
    clients.ActiveClient.pauseParsing();
}
function onResumeParsing() {
    clients.ActiveClient.resumeParsing();
}
function onPauseCodeAnalysis() {
    clients.ActiveClient.PauseCodeAnalysis();
}
function onResumeCodeAnalysis() {
    clients.ActiveClient.ResumeCodeAnalysis();
}
function onCancelCodeAnalysis() {
    clients.ActiveClient.CancelCodeAnalysis();
}
function onShowParsingCommands() {
    clients.ActiveClient.handleShowParsingCommands();
}
function onShowCodeAnalysisCommands() {
    clients.ActiveClient.handleShowCodeAnalysisCommands();
}
function onShowReferencesProgress() {
    clients.ActiveClient.handleReferencesIcon();
}
function onToggleRefGroupView() {
    const client = getActiveClient();
    client.toggleReferenceResultsView();
}
function onTakeSurvey() {
    telemetry.logLanguageServerEvent("onTakeSurvey");
    const uri = vscode.Uri.parse(`https://www.research.net/r/VBVV6C6?o=${os.platform()}&m=${vscode.env.machineId}`);
    vscode.commands.executeCommand('vscode.open', uri);
}
function onVcpkgOnlineHelpSuggested(dummy) {
    telemetry.logLanguageServerEvent('vcpkgAction', { 'source': dummy ? 'CodeAction' : 'CommandPalette', 'action': 'vcpkgOnlineHelpSuggested' });
    const uri = vscode.Uri.parse(`https://aka.ms/vcpkg`);
    vscode.commands.executeCommand('vscode.open', uri);
}
function onVcpkgClipboardInstallSuggested(ports) {
    return __awaiter(this, void 0, void 0, function* () {
        let source;
        if (ports && ports.length) {
            source = 'CodeAction';
        }
        else {
            source = 'CommandPalette';
            const missingIncludeLocations = [];
            vscode.languages.getDiagnostics().forEach(uriAndDiagnostics => {
                const textDocument = vscode.workspace.textDocuments.find(doc => doc.uri.fsPath === uriAndDiagnostics[0].fsPath);
                if (!textDocument) {
                    return;
                }
                let lines = uriAndDiagnostics[1].filter(isMissingIncludeDiagnostic).map(d => d.range.start.line);
                if (!lines.length) {
                    return;
                }
                lines = lines.filter((line, index) => {
                    const foundIndex = lines.indexOf(line);
                    return foundIndex === index;
                });
                missingIncludeLocations.push([textDocument, lines]);
            });
            if (!missingIncludeLocations.length) {
                return;
            }
            const portsPromises = [];
            missingIncludeLocations.forEach(docAndLineNumbers => {
                docAndLineNumbers[1].forEach((line) => __awaiter(this, void 0, void 0, function* () {
                    portsPromises.push(lookupIncludeInVcpkg(docAndLineNumbers[0], line));
                }));
            });
            ports = [].concat(...(yield Promise.all(portsPromises)));
            if (!ports.length) {
                return;
            }
            const ports2 = ports;
            ports = ports2.filter((port, index) => ports2.indexOf(port) === index);
        }
        let installCommand = 'vcpkg install';
        ports.forEach(port => installCommand += ` ${port}`);
        telemetry.logLanguageServerEvent('vcpkgAction', { 'source': source, 'action': 'vcpkgClipboardInstallSuggested', 'ports': ports.toString() });
        yield vscode.env.clipboard.writeText(installCommand);
    });
}
function onSetActiveConfigName(configurationName) {
    return clients.ActiveClient.setCurrentConfigName(configurationName);
}
function onGetActiveConfigName() {
    return clients.ActiveClient.getCurrentConfigName();
}
function onGetActiveConfigCustomVariable(variableName) {
    return clients.ActiveClient.getCurrentConfigCustomVariable(variableName);
}
function onLogDiagnostics() {
    clients.ActiveClient.logDiagnostics();
}
function onRescanWorkspace() {
    clients.ActiveClient.rescanFolder();
}
function onShowRefCommand(arg) {
    if (!arg) {
        return;
    }
    const { node } = arg;
    if (node === referencesModel_1.NodeType.reference) {
        const { referenceLocation } = arg;
        if (referenceLocation) {
            vscode.window.showTextDocument(referenceLocation.uri, {
                selection: referenceLocation.range.with({ start: referenceLocation.range.start, end: referenceLocation.range.end })
            });
        }
    }
    else if (node === referencesModel_1.NodeType.fileWithPendingRef) {
        const { fileUri } = arg;
        if (fileUri) {
            vscode.window.showTextDocument(fileUri);
        }
    }
}
function reportMacCrashes() {
    if (process.platform === "darwin") {
        prevCrashFile = "";
        const home = os.homedir();
        const crashFolder = path.resolve(home, "Library/Logs/DiagnosticReports");
        fs.stat(crashFolder, (err, stats) => {
            const crashObject = {};
            if (err === null || err === void 0 ? void 0 : err.code) {
                crashObject["fs.stat: err.code"] = err.code;
                telemetry.logLanguageServerEvent("MacCrash", crashObject, undefined);
                return;
            }
            try {
                fs.watch(crashFolder, (event, filename) => {
                    if (event !== "rename") {
                        return;
                    }
                    if (filename === prevCrashFile) {
                        return;
                    }
                    prevCrashFile = filename;
                    if (!filename.startsWith("cpptools")) {
                        return;
                    }
                    setTimeout(() => {
                        fs.readFile(path.resolve(crashFolder, filename), 'utf8', (err, data) => {
                            if (err) {
                                fs.readFile(path.resolve(crashFolder, filename), 'utf8', handleMacCrashFileRead);
                                return;
                            }
                            handleMacCrashFileRead(err, data);
                        });
                    }, 5000);
                });
            }
            catch (e) {
            }
        });
    }
}
let previousMacCrashData;
let previousMacCrashCount = 0;
function logMacCrashTelemetry(data) {
    const crashObject = {};
    const crashCountObject = {};
    crashObject["CrashingThreadCallStack"] = data;
    previousMacCrashCount = data === previousMacCrashData ? previousMacCrashCount + 1 : 0;
    previousMacCrashData = data;
    crashCountObject["CrashCount"] = previousMacCrashCount;
    telemetry.logLanguageServerEvent("MacCrash", crashObject, crashCountObject);
}
function handleMacCrashFileRead(err, data) {
    if (err) {
        return logMacCrashTelemetry("readFile: " + err.code);
    }
    let binaryVersion = "";
    const startVersion = data.indexOf("Version:");
    if (startVersion >= 0) {
        data = data.substr(startVersion);
        const binaryVersionMatches = data.match(/^Version:\s*(\d*\.\d*\.\d*\.\d*|\d)/);
        binaryVersion = binaryVersionMatches && binaryVersionMatches.length > 1 ? binaryVersionMatches[1] : "";
    }
    const crashStart = " Crashed:";
    let startCrash = data.indexOf(crashStart);
    if (startCrash < 0) {
        return logMacCrashTelemetry("No crash start");
    }
    startCrash += crashStart.length + 1;
    let endCrash = data.indexOf("Thread ", startCrash);
    if (endCrash < 0) {
        endCrash = data.length - 1;
    }
    if (endCrash <= startCrash) {
        return logMacCrashTelemetry("No crash end");
    }
    data = data.substr(startCrash, endCrash - startCrash);
    data = data.replace(/0x................ /g, "");
    data = data.replace(/0x1........ \+ 0/g, "");
    const process1 = "cpptools-srv";
    const process2 = "cpptools";
    if (data.includes(process1)) {
        data = data.replace(new RegExp(process1 + "\\s+", "g"), "");
        data = `${process1}\t${binaryVersion}\n${data}`;
    }
    else if (data.includes(process2)) {
        data = data.replace(new RegExp(process2 + "\\s+", "g"), "");
        data = `${process2}\t${binaryVersion}\n${data}`;
    }
    else {
        data = `cpptools?\t${binaryVersion}\n${data}`;
    }
    const lines = data.split("\n");
    data = "";
    lines.forEach((line) => {
        if (!line.includes(".dylib") && !line.includes("???")) {
            line = line.replace(/^\d+\s+/, "");
            line = line.replace(/std::__1::/g, "std::");
            data += (line + "\n");
        }
    });
    data = data.trimRight();
    if (data.length > 8192) {
        data = data.substr(0, 8189) + "...";
    }
    logMacCrashTelemetry(data);
}
function deactivate() {
    clients.timeTelemetryCollector.clear();
    console.log("deactivating extension");
    telemetry.logLanguageServerEvent("LanguageServerShutdown");
    clearInterval(intervalTimer);
    disposables.forEach(d => d.dispose());
    languageConfigurations.forEach(d => d.dispose());
    ui.dispose();
    if (taskProvider) {
        taskProvider.dispose();
    }
    if (codeActionProvider) {
        codeActionProvider.dispose();
    }
    return clients.dispose();
}
exports.deactivate = deactivate;
function isFolderOpen() {
    return vscode.workspace.workspaceFolders !== undefined && vscode.workspace.workspaceFolders.length > 0;
}
exports.isFolderOpen = isFolderOpen;
function getClients() {
    return clients;
}
exports.getClients = getClients;
function getActiveClient() {
    return clients.ActiveClient;
}
exports.getActiveClient = getActiveClient;


/***/ }),

/***/ 1626:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLanguageConfigFromPatterns = exports.getLanguageConfig = void 0;
const vscode = __webpack_require__(7549);
const settings_1 = __webpack_require__(296);
const logger_1 = __webpack_require__(5610);
const nls = __webpack_require__(3463);
const common_1 = __webpack_require__(5331);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\languageConfig.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\languageConfig.ts'));
const escapeChars = /[\\\^\$\*\+\?\{\}\(\)\.\!\=\|\[\]\ \/]/;
function escape(chars) {
    let result = "";
    for (const char of chars) {
        if (char.match(escapeChars)) {
            result += `\\${char}`;
        }
        else {
            result += char;
        }
    }
    return result;
}
function getMLBeginPattern(insert) {
    if (insert.startsWith("/*")) {
        const match = escape(insert.substr(2));
        return `^\\s*\\/\\*${match}(?!\\/)([^\\*]|\\*(?!\\/))*$`;
    }
    return undefined;
}
function getMLSplitAfterPattern() {
    return "^\\s*\\*\\/$";
}
function getMLPreviousLinePattern(insert) {
    if (insert.startsWith("/*")) {
        return `(?=^(\\s*(\\/\\*\\*|\\*)).*)(?=(?!(\\s*\\*\\/)))`;
    }
    return undefined;
}
function getMLContinuePattern(insert) {
    if (insert) {
        const match = escape(insert.trimRight());
        if (match) {
            const right = escape(insert.substr(insert.trimRight().length));
            return `^(\\t|[ ])*${match}(${right}([^\\*]|\\*(?!\\/))*)?$`;
        }
    }
    return undefined;
}
function getMLEmptyEndPattern(insert) {
    insert = insert.trimRight();
    if (insert !== "") {
        if (insert.endsWith('*')) {
            insert = insert.substr(0, insert.length - 1);
        }
        const match = escape(insert.trimRight());
        return `^(\\t|[ ])*${match}\\*\\/\\s*$`;
    }
    return undefined;
}
function getMLEndPattern(insert) {
    const match = escape(insert.trimRight().trimLeft());
    if (match) {
        return `^(\\t|[ ])*${match}[^/]*\\*\\/\\s*$`;
    }
    return undefined;
}
function getSLBeginPattern(insert) {
    const match = escape(insert.trimRight());
    return `^\\s*${match}.*$`;
}
function getSLContinuePattern(insert) {
    const match = escape(insert.trimRight());
    return `^\\s*${match}.+$`;
}
function getSLEndPattern(insert) {
    let match = escape(insert);
    const trimmed = escape(insert.trimRight());
    if (match !== trimmed) {
        match = `(${match}|${trimmed})`;
    }
    return `^\\s*${match}$`;
}
function getMLSplitRule(comment) {
    const beforePattern = getMLBeginPattern(comment.begin);
    if (beforePattern) {
        return {
            beforeText: new RegExp(beforePattern),
            afterText: new RegExp(getMLSplitAfterPattern()),
            action: {
                indentAction: vscode.IndentAction.IndentOutdent,
                appendText: comment.continue ? comment.continue : ''
            }
        };
    }
    return undefined;
}
function getMLFirstLineRule(comment) {
    const beforePattern = getMLBeginPattern(comment.begin);
    if (beforePattern) {
        return {
            beforeText: new RegExp(beforePattern),
            action: {
                indentAction: vscode.IndentAction.None,
                appendText: comment.continue ? comment.continue : ''
            }
        };
    }
    return undefined;
}
function getMLContinuationRule(comment) {
    const previousLinePattern = getMLPreviousLinePattern(comment.begin);
    if (previousLinePattern) {
        const beforePattern = getMLContinuePattern(comment.continue);
        if (beforePattern) {
            return {
                beforeText: new RegExp(beforePattern),
                previousLineText: new RegExp(previousLinePattern),
                action: {
                    indentAction: vscode.IndentAction.None,
                    appendText: comment.continue.trimLeft()
                }
            };
        }
    }
    return undefined;
}
function getMLEndRule(comment) {
    const beforePattern = getMLEndPattern(comment.continue);
    if (beforePattern) {
        return {
            beforeText: new RegExp(beforePattern),
            action: {
                indentAction: vscode.IndentAction.None,
                removeText: comment.continue.length - comment.continue.trimLeft().length
            }
        };
    }
    return undefined;
}
function getMLEmptyEndRule(comment) {
    const beforePattern = getMLEmptyEndPattern(comment.continue);
    if (beforePattern) {
        return {
            beforeText: new RegExp(beforePattern),
            action: {
                indentAction: vscode.IndentAction.None,
                removeText: comment.continue.length - comment.continue.trimLeft().length
            }
        };
    }
    return undefined;
}
function getSLFirstLineRule(comment) {
    const beforePattern = getSLBeginPattern(comment.begin);
    return {
        beforeText: new RegExp(beforePattern),
        action: {
            indentAction: vscode.IndentAction.None,
            appendText: comment.continue.trimLeft()
        }
    };
}
function getSLContinuationRule(comment) {
    const beforePattern = getSLContinuePattern(comment.continue);
    return {
        beforeText: new RegExp(beforePattern),
        action: {
            indentAction: vscode.IndentAction.None,
            appendText: comment.continue.trimLeft()
        }
    };
}
function getSLEndRule(comment) {
    const beforePattern = getSLEndPattern(comment.continue);
    return {
        beforeText: new RegExp(beforePattern),
        action: {
            indentAction: vscode.IndentAction.None,
            removeText: comment.continue.length - comment.continue.trimLeft().length
        }
    };
}
function getLanguageConfig(languageId) {
    const settings = new settings_1.CppSettings();
    const patterns = settings.commentContinuationPatterns;
    return getLanguageConfigFromPatterns(languageId, patterns);
}
exports.getLanguageConfig = getLanguageConfig;
function getLanguageConfigFromPatterns(languageId, patterns) {
    const beginPatterns = [];
    const continuePatterns = [];
    let duplicates = false;
    let beginRules = [];
    let continueRules = [];
    let endRules = [];
    if (!patterns) {
        patterns = ["/**"];
    }
    patterns.forEach(pattern => {
        const c = (0, common_1.isString)(pattern) ? { begin: pattern, continue: pattern.startsWith('/*') ? " * " : pattern } : pattern;
        const r = constructCommentRules(c, languageId);
        if (beginPatterns.indexOf(c.begin) < 0) {
            if (r.begin && r.begin.length > 0) {
                beginRules = beginRules.concat(r.begin);
            }
            beginPatterns.push(c.begin);
        }
        else {
            duplicates = true;
        }
        if (continuePatterns.indexOf(c.continue) < 0) {
            if (r.continue && r.continue.length > 0) {
                continueRules = continueRules.concat(r.continue);
            }
            if (r.end && r.end.length > 0) {
                endRules = endRules.concat(r.end);
            }
            continuePatterns.push(c.continue);
        }
    });
    if (duplicates) {
        (0, logger_1.getOutputChannel)().appendLine(localize(0, null));
    }
    return { onEnterRules: beginRules.concat(continueRules).concat(endRules).filter(e => (e)) };
}
exports.getLanguageConfigFromPatterns = getLanguageConfigFromPatterns;
function constructCommentRules(comment, languageId) {
    var _a, _b;
    if (((_a = comment === null || comment === void 0 ? void 0 : comment.begin) === null || _a === void 0 ? void 0 : _a.startsWith('/*')) && (languageId === 'c' || languageId === 'cpp' || languageId === 'cuda-cpp')) {
        const mlBegin1 = getMLSplitRule(comment);
        if (!mlBegin1) {
            throw new Error("Failure in constructCommentRules() - mlBegin1");
        }
        const mlBegin2 = getMLFirstLineRule(comment);
        if (!mlBegin2) {
            throw new Error("Failure in constructCommentRules() - mlBegin2");
        }
        const mlContinue = getMLContinuationRule(comment);
        if (!mlContinue) {
            throw new Error("Failure in constructCommentRules() - mlContinue");
        }
        const mlEnd1 = getMLEmptyEndRule(comment);
        if (!mlEnd1) {
            throw new Error("Failure in constructCommentRules() - mlEnd1");
        }
        const mlEnd2 = getMLEndRule(comment);
        if (!mlEnd2) {
            throw new Error("Failure in constructCommentRules() = mlEnd2");
        }
        return {
            begin: [mlBegin1, mlBegin2],
            continue: [mlContinue],
            end: [mlEnd1, mlEnd2]
        };
    }
    else if (((_b = comment === null || comment === void 0 ? void 0 : comment.begin) === null || _b === void 0 ? void 0 : _b.startsWith('//')) && (languageId === 'cpp' || languageId === 'cuda-cpp')) {
        const slContinue = getSLContinuationRule(comment);
        const slEnd = getSLEndRule(comment);
        if (comment.begin !== comment.continue) {
            const slBegin = getSLFirstLineRule(comment);
            return {
                begin: (comment.begin === comment.continue) ? [] : [slBegin],
                continue: [slContinue],
                end: [slEnd]
            };
        }
        else {
            return {
                begin: [],
                continue: [slContinue],
                end: [slEnd]
            };
        }
    }
    return {
        begin: [],
        continue: [],
        end: []
    };
}


/***/ }),

/***/ 1102:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersistentFolderState = exports.PersistentWorkspaceState = exports.PersistentState = void 0;
const util = __webpack_require__(5331);
const path = __webpack_require__(5622);
class PersistentStateBase {
    constructor(key, defaultValue, state) {
        this.key = key;
        this.defaultvalue = defaultValue;
        this.state = state;
        this.curvalue = defaultValue;
    }
    get Value() {
        return this.state ? this.state.get(this.key, this.defaultvalue) : this.curvalue;
    }
    set Value(newValue) {
        if (this.state) {
            this.state.update(this.key, newValue);
        }
        this.curvalue = newValue;
    }
    get DefaultValue() {
        return this.defaultvalue;
    }
    setDefault() {
        if (this.state) {
            this.state.update(this.key, this.defaultvalue);
        }
        this.curvalue = this.defaultvalue;
    }
}
class PersistentState extends PersistentStateBase {
    constructor(key, defaultValue) {
        super(key, defaultValue, util.extensionContext ? util.extensionContext.globalState : undefined);
    }
}
exports.PersistentState = PersistentState;
class PersistentWorkspaceState extends PersistentStateBase {
    constructor(key, defaultValue) {
        super(key, defaultValue, util.extensionContext ? util.extensionContext.workspaceState : undefined);
    }
}
exports.PersistentWorkspaceState = PersistentWorkspaceState;
class PersistentFolderState extends PersistentWorkspaceState {
    constructor(key, defaultValue, folder) {
        const old_key = key + (folder ? `-${path.basename(folder.uri.fsPath)}` : "-untitled");
        let old_val;
        if (util.extensionContext) {
            old_val = util.extensionContext.workspaceState.get(old_key);
            if (old_val !== undefined) {
                util.extensionContext.workspaceState.update(old_key, undefined);
            }
        }
        const newKey = key + (folder ? `-${folder.uri.fsPath}` : "-untitled");
        super(newKey, defaultValue);
        if (old_val !== undefined) {
            this.Value = old_val;
        }
    }
}
exports.PersistentFolderState = PersistentFolderState;


/***/ }),

/***/ 9696:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolFilter = void 0;
const path = __webpack_require__(5622);
const vscode = __webpack_require__(7549);
const settings_1 = __webpack_require__(296);
const extension_1 = __webpack_require__(2973);
function createProtocolFilter(clients) {
    const defaultHandler = (data, callback) => { clients.ActiveClient.notifyWhenLanguageClientReady(() => callback(data)); };
    const invoke2 = (a, b, callback) => clients.ActiveClient.requestWhenReady(() => callback(a, b));
    const invoke3 = (a, b, c, callback) => clients.ActiveClient.requestWhenReady(() => callback(a, b, c));
    const invoke4 = (a, b, c, d, callback) => clients.ActiveClient.requestWhenReady(() => callback(a, b, c, d));
    const invoke5 = (a, b, c, d, e, callback) => clients.ActiveClient.requestWhenReady(() => callback(a, b, c, d, e));
    return {
        didOpen: (document, sendMessage) => {
            const editor = vscode.window.visibleTextEditors.find(e => e.document === document);
            if (editor) {
                const me = clients.getClientFor(document.uri);
                if (!me.TrackedDocuments.has(document)) {
                    clients.timeTelemetryCollector.setDidOpenTime(document.uri);
                    if (clients.checkOwnership(me, document)) {
                        me.TrackedDocuments.add(document);
                        const finishDidOpen = (doc) => {
                            me.provideCustomConfiguration(doc.uri, undefined);
                            me.notifyWhenLanguageClientReady(() => {
                                sendMessage(doc);
                                me.onDidOpenTextDocument(doc);
                                if (editor && editor === vscode.window.activeTextEditor) {
                                    (0, extension_1.onDidChangeActiveTextEditor)(editor);
                                }
                            });
                        };
                        let languageChanged = false;
                        if ((document.uri.path.endsWith(".C") || document.uri.path.endsWith(".H")) && document.languageId === "c") {
                            const cppSettings = new settings_1.CppSettings();
                            if (cppSettings.autoAddFileAssociations) {
                                const fileName = path.basename(document.uri.fsPath);
                                const mappingString = fileName + "@" + document.uri.fsPath;
                                me.addFileAssociations(mappingString, "cpp");
                                me.sendDidChangeSettings({ files: { associations: new settings_1.OtherSettings().filesAssociations } });
                                vscode.languages.setTextDocumentLanguage(document, "cpp").then((newDoc) => {
                                    finishDidOpen(newDoc);
                                });
                                languageChanged = true;
                            }
                        }
                        if (!languageChanged) {
                            finishDidOpen(document);
                        }
                    }
                }
            }
            else {
            }
        },
        didChange: (textDocumentChangeEvent, sendMessage) => {
            const me = clients.getClientFor(textDocumentChangeEvent.document.uri);
            if (!me.TrackedDocuments.has(textDocumentChangeEvent.document)) {
                (0, extension_1.processDelayedDidOpen)(textDocumentChangeEvent.document);
            }
            me.onDidChangeTextDocument(textDocumentChangeEvent);
            me.notifyWhenLanguageClientReady(() => sendMessage(textDocumentChangeEvent));
        },
        willSave: defaultHandler,
        willSaveWaitUntil: (event, sendMessage) => {
            const me = clients.getClientFor(event.document.uri);
            if (me.TrackedDocuments.has(event.document)) {
                return sendMessage(event);
            }
            return Promise.resolve([]);
        },
        didSave: defaultHandler,
        didClose: (document, sendMessage) => {
            const me = clients.getClientFor(document.uri);
            if (me.TrackedDocuments.has(document)) {
                me.onDidCloseTextDocument(document);
                me.TrackedDocuments.delete(document);
                me.notifyWhenLanguageClientReady(() => sendMessage(document));
            }
        },
        provideCompletionItem: invoke4,
        resolveCompletionItem: invoke2,
        provideHover: (document, position, token, next) => {
            const me = clients.getClientFor(document.uri);
            if (clients.checkOwnership(me, document)) {
                return clients.ActiveClient.requestWhenReady(() => next(document, position, token));
            }
            return null;
        },
        provideSignatureHelp: invoke3,
        provideDefinition: invoke3,
        provideReferences: invoke4,
        provideDocumentHighlights: invoke3,
        provideDocumentSymbols: invoke2,
        provideWorkspaceSymbols: invoke2,
        provideCodeActions: invoke4,
        provideCodeLenses: invoke2,
        resolveCodeLens: invoke2,
        provideDocumentFormattingEdits: invoke3,
        provideDocumentRangeFormattingEdits: invoke4,
        provideOnTypeFormattingEdits: invoke5,
        provideRenameEdits: invoke4,
        provideDocumentLinks: invoke2,
        resolveDocumentLink: invoke2,
        provideDeclaration: invoke3
    };
}
exports.createProtocolFilter = createProtocolFilter;


/***/ }),

/***/ 2664:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReferencesManager = exports.getReferenceItemIconPath = exports.getReferenceTypeIconPath = exports.getReferenceTagString = exports.convertReferenceTypeToString = exports.referencesCommandModeToString = exports.ReferencesCommandMode = exports.ReferenceType = void 0;
const vscode = __webpack_require__(7549);
const referencesView_1 = __webpack_require__(3053);
const telemetry = __webpack_require__(1818);
const nls = __webpack_require__(3463);
const logger = __webpack_require__(5610);
const persistentState_1 = __webpack_require__(1102);
const util = __webpack_require__(5331);
const timers_1 = __webpack_require__(8213);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\references.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\references.ts'));
var ReferenceType;
(function (ReferenceType) {
    ReferenceType[ReferenceType["Confirmed"] = 0] = "Confirmed";
    ReferenceType[ReferenceType["ConfirmationInProgress"] = 1] = "ConfirmationInProgress";
    ReferenceType[ReferenceType["Comment"] = 2] = "Comment";
    ReferenceType[ReferenceType["String"] = 3] = "String";
    ReferenceType[ReferenceType["Inactive"] = 4] = "Inactive";
    ReferenceType[ReferenceType["CannotConfirm"] = 5] = "CannotConfirm";
    ReferenceType[ReferenceType["NotAReference"] = 6] = "NotAReference";
})(ReferenceType = exports.ReferenceType || (exports.ReferenceType = {}));
var ReferencesProgress;
(function (ReferencesProgress) {
    ReferencesProgress[ReferencesProgress["Started"] = 0] = "Started";
    ReferencesProgress[ReferencesProgress["StartedRename"] = 1] = "StartedRename";
    ReferencesProgress[ReferencesProgress["ProcessingSource"] = 2] = "ProcessingSource";
    ReferencesProgress[ReferencesProgress["ProcessingTargets"] = 3] = "ProcessingTargets";
})(ReferencesProgress || (ReferencesProgress = {}));
var TargetReferencesProgress;
(function (TargetReferencesProgress) {
    TargetReferencesProgress[TargetReferencesProgress["WaitingToLex"] = 0] = "WaitingToLex";
    TargetReferencesProgress[TargetReferencesProgress["Lexing"] = 1] = "Lexing";
    TargetReferencesProgress[TargetReferencesProgress["WaitingToParse"] = 2] = "WaitingToParse";
    TargetReferencesProgress[TargetReferencesProgress["Parsing"] = 3] = "Parsing";
    TargetReferencesProgress[TargetReferencesProgress["ConfirmingReferences"] = 4] = "ConfirmingReferences";
    TargetReferencesProgress[TargetReferencesProgress["FinishedWithoutConfirming"] = 5] = "FinishedWithoutConfirming";
    TargetReferencesProgress[TargetReferencesProgress["FinishedConfirming"] = 6] = "FinishedConfirming";
})(TargetReferencesProgress || (TargetReferencesProgress = {}));
var ReferencesCommandMode;
(function (ReferencesCommandMode) {
    ReferencesCommandMode[ReferencesCommandMode["None"] = 0] = "None";
    ReferencesCommandMode[ReferencesCommandMode["Find"] = 1] = "Find";
    ReferencesCommandMode[ReferencesCommandMode["Peek"] = 2] = "Peek";
    ReferencesCommandMode[ReferencesCommandMode["Rename"] = 3] = "Rename";
})(ReferencesCommandMode = exports.ReferencesCommandMode || (exports.ReferencesCommandMode = {}));
function referencesCommandModeToString(referencesCommandMode) {
    switch (referencesCommandMode) {
        case ReferencesCommandMode.Find:
            return localize(0, null);
        case ReferencesCommandMode.Peek:
            return localize(1, null);
        case ReferencesCommandMode.Rename:
            return localize(2, null);
        default:
            return "";
    }
}
exports.referencesCommandModeToString = referencesCommandModeToString;
function convertReferenceTypeToString(referenceType, upperCase) {
    if (upperCase) {
        switch (referenceType) {
            case ReferenceType.Confirmed: return localize(3, null);
            case ReferenceType.ConfirmationInProgress: return localize(4, null);
            case ReferenceType.Comment: return localize(5, null);
            case ReferenceType.String: return localize(6, null);
            case ReferenceType.Inactive: return localize(7, null);
            case ReferenceType.CannotConfirm: return localize(8, null);
            case ReferenceType.NotAReference: return localize(9, null);
        }
    }
    else {
        switch (referenceType) {
            case ReferenceType.Confirmed: return localize(10, null);
            case ReferenceType.ConfirmationInProgress: return localize(11, null);
            case ReferenceType.Comment: return localize(12, null);
            case ReferenceType.String: return localize(13, null);
            case ReferenceType.Inactive: return localize(14, null);
            case ReferenceType.CannotConfirm: return localize(15, null);
            case ReferenceType.NotAReference: return localize(16, null);
        }
    }
    return "";
}
exports.convertReferenceTypeToString = convertReferenceTypeToString;
function getReferenceCanceledString(upperCase) {
    return upperCase ?
        localize(17, null) :
        localize(18, null);
}
function getReferenceTagString(referenceType, referenceCanceled, upperCase) {
    return referenceCanceled && referenceType === ReferenceType.ConfirmationInProgress ? getReferenceCanceledString(upperCase) : convertReferenceTypeToString(referenceType, upperCase);
}
exports.getReferenceTagString = getReferenceTagString;
function getReferenceTypeIconPath(referenceType) {
    const assetsFolder = "assets/";
    const postFixLight = "-light.svg";
    const postFixDark = "-dark.svg";
    let basePath = "ref-cannot-confirm";
    switch (referenceType) {
        case ReferenceType.Confirmed:
            basePath = "ref-confirmed";
            break;
        case ReferenceType.Comment:
            basePath = "ref-comment";
            break;
        case ReferenceType.String:
            basePath = "ref-string";
            break;
        case ReferenceType.Inactive:
            basePath = "ref-inactive";
            break;
        case ReferenceType.CannotConfirm:
            basePath = "ref-cannot-confirm";
            break;
        case ReferenceType.NotAReference:
            basePath = "ref-not-a-reference";
            break;
        case ReferenceType.ConfirmationInProgress:
            basePath = "ref-confirmation-in-progress";
            break;
    }
    const lightPath = util.getExtensionFilePath(assetsFolder + basePath + postFixLight);
    const lightPathUri = vscode.Uri.file(lightPath);
    const darkPath = util.getExtensionFilePath(assetsFolder + basePath + postFixDark);
    const darkPathUri = vscode.Uri.file(darkPath);
    return {
        light: lightPathUri,
        dark: darkPathUri
    };
}
exports.getReferenceTypeIconPath = getReferenceTypeIconPath;
function getReferenceCanceledIconPath() {
    const lightPath = util.getExtensionFilePath("assets/ref-canceled-light.svg");
    const lightPathUri = vscode.Uri.file(lightPath);
    const darkPath = util.getExtensionFilePath("assets/ref-canceled-dark.svg");
    const darkPathUri = vscode.Uri.file(darkPath);
    return {
        light: lightPathUri,
        dark: darkPathUri
    };
}
function getReferenceItemIconPath(type, isCanceled) {
    return (isCanceled && type === ReferenceType.ConfirmationInProgress) ? getReferenceCanceledIconPath() : getReferenceTypeIconPath(type);
}
exports.getReferenceItemIconPath = getReferenceItemIconPath;
class ReferencesManager {
    constructor(client) {
        this.disposables = [];
        this.viewsInitialized = false;
        this.symbolSearchInProgress = false;
        this.referencesPrevProgressIncrement = 0;
        this.referencesPrevProgressMessage = "";
        this.referencesRequestHasOccurred = false;
        this.referencesFinished = false;
        this.referencesRequestPending = false;
        this.referencesRefreshPending = false;
        this.referencesCanceled = false;
        this.referencesCurrentProgressUICounter = 0;
        this.referencesProgressUpdateInterval = 1000;
        this.referencesProgressDelayInterval = 2000;
        this.prevVisibleRangesLength = 0;
        this.visibleRangesDecreased = false;
        this.visibleRangesDecreasedTicks = 0;
        this.ticksForDetectingPeek = 1000;
        this.groupByFile = new persistentState_1.PersistentState("CPP.referencesGroupByFile", false);
        this.lastResults = null;
        this.client = client;
    }
    initializeViews() {
        if (!this.viewsInitialized) {
            this.findAllRefsView = new referencesView_1.FindAllRefsView();
            this.viewsInitialized = true;
        }
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
        this.disposables = [];
    }
    toggleGroupView() {
        this.groupByFile.Value = !this.groupByFile.Value;
        if (this.findAllRefsView) {
            this.findAllRefsView.setGroupBy(this.groupByFile.Value);
        }
    }
    UpdateProgressUICounter(mode) {
        if (mode !== ReferencesCommandMode.None) {
            ++this.referencesCurrentProgressUICounter;
        }
    }
    updateVisibleRange(visibleRangesLength) {
        this.visibleRangesDecreased = visibleRangesLength < this.prevVisibleRangesLength;
        if (this.visibleRangesDecreased) {
            this.visibleRangesDecreasedTicks = Date.now();
        }
        this.prevVisibleRangesLength = visibleRangesLength;
    }
    reportProgress(progress, forceUpdate, mode) {
        const helpMessage = (mode !== ReferencesCommandMode.Find) ? "" : ` ${localize(19, null)}`;
        if (this.referencesCurrentProgress) {
            switch (this.referencesCurrentProgress.referencesProgress) {
                case ReferencesProgress.Started:
                case ReferencesProgress.StartedRename:
                    progress.report({ message: localize(20, null), increment: 0 });
                    break;
                case ReferencesProgress.ProcessingSource:
                    progress.report({ message: localize(21, null), increment: 0 });
                    break;
                case ReferencesProgress.ProcessingTargets:
                    let numWaitingToLex = 0;
                    let numLexing = 0;
                    let numParsing = 0;
                    let numConfirmingReferences = 0;
                    let numFinishedWithoutConfirming = 0;
                    let numFinishedConfirming = 0;
                    for (const targetLocationProgress of this.referencesCurrentProgress.targetReferencesProgress) {
                        switch (targetLocationProgress) {
                            case TargetReferencesProgress.WaitingToLex:
                                ++numWaitingToLex;
                                break;
                            case TargetReferencesProgress.Lexing:
                                ++numLexing;
                                break;
                            case TargetReferencesProgress.WaitingToParse:
                                break;
                            case TargetReferencesProgress.Parsing:
                                ++numParsing;
                                break;
                            case TargetReferencesProgress.ConfirmingReferences:
                                ++numConfirmingReferences;
                                break;
                            case TargetReferencesProgress.FinishedWithoutConfirming:
                                ++numFinishedWithoutConfirming;
                                break;
                            case TargetReferencesProgress.FinishedConfirming:
                                ++numFinishedConfirming;
                                break;
                            default:
                                break;
                        }
                    }
                    let currentMessage;
                    const numTotalToLex = this.referencesCurrentProgress.targetReferencesProgress.length;
                    const numFinishedLexing = numTotalToLex - numWaitingToLex - numLexing;
                    const numTotalToParse = this.referencesCurrentProgress.targetReferencesProgress.length - numFinishedWithoutConfirming;
                    if (numLexing >= (numParsing + numConfirmingReferences) && numFinishedConfirming === 0) {
                        if (numTotalToLex === 0) {
                            currentMessage = localize(22, null);
                        }
                        else {
                            currentMessage = localize(23, null, numFinishedLexing, numTotalToLex, helpMessage);
                        }
                    }
                    else {
                        currentMessage = localize(24, null, numFinishedConfirming, numTotalToParse, helpMessage);
                    }
                    const currentLexProgress = numFinishedLexing / numTotalToLex;
                    const confirmingWeight = 0.5;
                    const currentParseProgress = (numConfirmingReferences * confirmingWeight + numFinishedConfirming) / numTotalToParse;
                    const averageLexingPercent = 25;
                    const currentIncrement = currentLexProgress * averageLexingPercent + currentParseProgress * (100 - averageLexingPercent);
                    if (forceUpdate || currentIncrement > this.referencesPrevProgressIncrement || currentMessage !== this.referencesPrevProgressMessage) {
                        progress.report({ message: currentMessage, increment: currentIncrement - this.referencesPrevProgressIncrement });
                        this.referencesPrevProgressIncrement = currentIncrement;
                        this.referencesPrevProgressMessage = currentMessage;
                    }
                    break;
            }
        }
    }
    handleProgressStarted(referencesProgress) {
        this.referencesStartedWhileTagParsing = this.client.IsTagParsing;
        const mode = (referencesProgress === ReferencesProgress.StartedRename) ? ReferencesCommandMode.Rename :
            (this.visibleRangesDecreased && (Date.now() - this.visibleRangesDecreasedTicks < this.ticksForDetectingPeek) ?
                ReferencesCommandMode.Peek : ReferencesCommandMode.Find);
        this.client.setReferencesCommandMode(mode);
        this.referencesPrevProgressIncrement = 0;
        this.referencesPrevProgressMessage = "";
        this.referencesCurrentProgressUICounter = 0;
        this.currentUpdateProgressTimer = undefined;
        this.currentUpdateProgressResolve = undefined;
        let referencePreviousProgressUICounter = 0;
        this.clearViews();
        this.referencesDelayProgress = (0, timers_1.setInterval)(() => {
            this.referencesProgressOptions = { location: vscode.ProgressLocation.Notification, title: referencesCommandModeToString(this.client.ReferencesCommandMode), cancellable: true };
            this.referencesProgressMethod = (progress, token) => new Promise((resolve) => {
                this.currentUpdateProgressResolve = resolve;
                this.reportProgress(progress, true, mode);
                this.currentUpdateProgressTimer = (0, timers_1.setInterval)(() => {
                    if (token.isCancellationRequested && !this.referencesCanceled) {
                        this.client.cancelReferences();
                        this.referencesCanceled = true;
                    }
                    if (this.referencesCurrentProgressUICounter !== referencePreviousProgressUICounter) {
                        if (this.currentUpdateProgressTimer) {
                            clearInterval(this.currentUpdateProgressTimer);
                        }
                        this.currentUpdateProgressTimer = undefined;
                        if (this.referencesCurrentProgressUICounter !== referencePreviousProgressUICounter) {
                            referencePreviousProgressUICounter = this.referencesCurrentProgressUICounter;
                            this.referencesPrevProgressIncrement = 0;
                            if (this.referencesProgressOptions && this.referencesProgressMethod) {
                                vscode.window.withProgress(this.referencesProgressOptions, this.referencesProgressMethod);
                            }
                        }
                        resolve(undefined);
                    }
                    else {
                        this.reportProgress(progress, false, mode);
                    }
                }, this.referencesProgressUpdateInterval);
            });
            vscode.window.withProgress(this.referencesProgressOptions, this.referencesProgressMethod);
            if (this.referencesDelayProgress) {
                clearInterval(this.referencesDelayProgress);
            }
        }, this.referencesProgressDelayInterval);
    }
    handleProgress(notificationBody) {
        this.initializeViews();
        switch (notificationBody.referencesProgress) {
            case ReferencesProgress.StartedRename:
            case ReferencesProgress.Started:
                if (this.client.ReferencesCommandMode === ReferencesCommandMode.Peek) {
                    telemetry.logLanguageServerEvent("peekReferences");
                }
                this.handleProgressStarted(notificationBody.referencesProgress);
                break;
            default:
                this.referencesCurrentProgress = notificationBody;
                break;
        }
    }
    startRename(params) {
        this.lastResults = null;
        this.referencesFinished = false;
        this.referencesRequestHasOccurred = false;
        this.referencesRequestPending = false;
        this.referencesCanceledWhilePreviewing = false;
        if (this.referencesCanceled) {
            this.referencesCanceled = false;
            if (this.resultsCallback) {
                this.resultsCallback(null, true);
            }
        }
        else {
            this.client.sendRenameNofication(params);
        }
    }
    startFindAllReferences(params) {
        this.lastResults = null;
        this.referencesFinished = false;
        this.referencesRequestHasOccurred = false;
        this.referencesRequestPending = false;
        this.referencesCanceledWhilePreviewing = false;
        if (this.referencesCanceled) {
            this.referencesCanceled = false;
            if (this.resultsCallback) {
                this.resultsCallback(null, true);
            }
        }
        else {
            this.client.sendFindAllReferencesNotification(params);
        }
    }
    processResults(referencesResult) {
        if (this.referencesFinished) {
            return;
        }
        this.initializeViews();
        this.clearViews();
        if (this.client.ReferencesCommandMode === ReferencesCommandMode.Peek && !this.referencesChannel) {
            this.referencesChannel = vscode.window.createOutputChannel(localize(25, null));
            this.disposables.push(this.referencesChannel);
        }
        if (this.referencesStartedWhileTagParsing) {
            const msg = localize(26, null, referencesCommandModeToString(this.client.ReferencesCommandMode));
            if (this.client.ReferencesCommandMode === ReferencesCommandMode.Peek) {
                if (this.referencesChannel) {
                    this.referencesChannel.appendLine(msg);
                    this.referencesChannel.appendLine("");
                    this.referencesChannel.show(true);
                }
            }
            else if (this.client.ReferencesCommandMode === ReferencesCommandMode.Find) {
                const logChannel = logger.getOutputChannel();
                logChannel.appendLine(msg);
                logChannel.appendLine("");
                logChannel.show(true);
            }
        }
        const referencesRequestPending = this.referencesRequestPending;
        const referencesCanceled = this.referencesCanceled;
        this.referencesRequestPending = false;
        this.referencesCanceled = false;
        const currentReferenceCommandMode = this.client.ReferencesCommandMode;
        if (referencesResult.isFinished) {
            this.symbolSearchInProgress = false;
            if (this.referencesDelayProgress) {
                clearInterval(this.referencesDelayProgress);
            }
            if (this.currentUpdateProgressTimer) {
                if (this.currentUpdateProgressTimer) {
                    clearInterval(this.currentUpdateProgressTimer);
                }
                if (this.currentUpdateProgressResolve) {
                    this.currentUpdateProgressResolve(undefined);
                }
                this.currentUpdateProgressResolve = undefined;
                this.currentUpdateProgressTimer = undefined;
            }
            this.client.setReferencesCommandMode(ReferencesCommandMode.None);
        }
        if (currentReferenceCommandMode === ReferencesCommandMode.Rename) {
            if (!referencesCanceled) {
                if (this.resultsCallback) {
                    this.resultsCallback(referencesResult, true);
                }
            }
            else {
                if (this.resultsCallback) {
                    this.resultsCallback(null, true);
                }
            }
        }
        else {
            if (this.findAllRefsView) {
                this.findAllRefsView.setData(referencesResult, referencesCanceled, this.groupByFile.Value);
            }
            if (currentReferenceCommandMode === ReferencesCommandMode.Peek) {
                const showConfirmedReferences = referencesCanceled;
                if (this.findAllRefsView) {
                    const peekReferencesResults = this.findAllRefsView.getResultsAsText(showConfirmedReferences);
                    if (peekReferencesResults) {
                        if (this.referencesChannel) {
                            this.referencesChannel.appendLine(peekReferencesResults);
                            this.referencesChannel.show(true);
                        }
                    }
                }
            }
            else if (currentReferenceCommandMode === ReferencesCommandMode.Find) {
                if (this.findAllRefsView) {
                    this.findAllRefsView.show(true);
                }
            }
            if (referencesResult.isFinished) {
                this.lastResults = referencesResult;
                this.referencesFinished = true;
            }
            if (!this.referencesRefreshPending) {
                if (referencesResult.isFinished && this.referencesRequestHasOccurred && !referencesRequestPending && !this.referencesCanceledWhilePreviewing) {
                    this.referencesRefreshPending = true;
                    vscode.commands.executeCommand("references-view.refresh");
                }
                else {
                    if (this.resultsCallback) {
                        this.resultsCallback(referencesResult, !this.referencesCanceledWhilePreviewing);
                    }
                }
            }
        }
    }
    setResultsCallback(callback) {
        this.symbolSearchInProgress = true;
        this.resultsCallback = callback;
    }
    clearViews() {
        if (this.client.ReferencesCommandMode !== ReferencesCommandMode.Rename) {
            if (this.referencesChannel) {
                this.referencesChannel.clear();
            }
            if (this.findAllRefsView) {
                this.findAllRefsView.show(false);
            }
        }
    }
}
exports.ReferencesManager = ReferencesManager;


/***/ }),

/***/ 9997:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TreeNode = exports.NodeType = exports.ReferencesModel = void 0;
const vscode = __webpack_require__(7549);
const references_1 = __webpack_require__(2664);
class ReferencesModel {
    constructor(resultsInput, isCanceled, groupByFile, refreshCallback) {
        this.isCanceled = isCanceled;
        this.refreshCallback = refreshCallback;
        this.nodes = [];
        this.originalSymbol = "";
        this.originalSymbol = resultsInput.text;
        this.groupByFile = groupByFile;
        const results = resultsInput.referenceInfos.filter(r => r.type !== references_1.ReferenceType.Confirmed);
        for (const r of results) {
            const noReferenceLocation = (r.position.line === 0 && r.position.character === 0);
            if (noReferenceLocation) {
                const node = new TreeNode(this, NodeType.fileWithPendingRef);
                node.fileUri = vscode.Uri.file(r.file);
                node.filename = r.file;
                node.referenceType = r.type;
                this.nodes.push(node);
            }
            else {
                const range = new vscode.Range(r.position.line, r.position.character, r.position.line, r.position.character + this.originalSymbol.length);
                const uri = vscode.Uri.file(r.file);
                const location = new vscode.Location(uri, range);
                const node = new TreeNode(this, NodeType.reference);
                node.fileUri = uri;
                node.filename = r.file;
                node.referencePosition = r.position;
                node.referenceLocation = location;
                node.referenceText = r.text;
                node.referenceType = r.type;
                this.nodes.push(node);
            }
        }
    }
    hasResults() {
        return this.nodes.length > 0;
    }
    getReferenceTypeNodes() {
        const result = [];
        for (const n of this.nodes) {
            const i = result.findIndex(e => e.referenceType === n.referenceType);
            if (i < 0) {
                const node = new TreeNode(this, NodeType.referenceType);
                node.referenceType = n.referenceType;
                result.push(node);
            }
        }
        return result;
    }
    getFileNodes(refType) {
        const result = [];
        let filteredFiles = [];
        if (refType !== undefined) {
            filteredFiles = this.nodes.filter(i => i.referenceType === refType);
        }
        else {
            filteredFiles = this.nodes;
        }
        for (const n of filteredFiles) {
            const i = result.findIndex(item => item.filename === n.filename);
            if (i < 0) {
                const nodeType = (n.node === NodeType.fileWithPendingRef ? NodeType.fileWithPendingRef : NodeType.file);
                const node = new TreeNode(this, nodeType);
                node.filename = n.filename;
                node.fileUri = n.fileUri;
                node.referenceType = refType;
                result.push(node);
            }
        }
        result.sort((a, b) => {
            if (a.filename === undefined) {
                if (b.filename === undefined) {
                    return 0;
                }
                else {
                    return -1;
                }
            }
            else if (b.filename === undefined) {
                return 1;
            }
            else {
                return a.filename.localeCompare(b.filename);
            }
        });
        return result;
    }
    getReferenceNodes(filename, refType) {
        if (refType === undefined || refType === null) {
            if (filename === undefined || filename === null) {
                return this.nodes;
            }
            return this.nodes.filter(i => i.filename === filename);
        }
        if (filename === undefined || filename === null) {
            return this.nodes.filter(i => i.referenceType === refType);
        }
        return this.nodes.filter(i => i.filename === filename && i.referenceType === refType);
    }
    getAllReferenceNodes() {
        return this.nodes.filter(i => i.node === NodeType.reference);
    }
    getAllFilesWithPendingReferenceNodes() {
        const result = this.nodes.filter(i => i.node === NodeType.fileWithPendingRef);
        result.sort((a, b) => {
            if (a.filename === undefined) {
                if (b.filename === undefined) {
                    return 0;
                }
                else {
                    return -1;
                }
            }
            else if (b.filename === undefined) {
                return 1;
            }
            else {
                return a.filename.localeCompare(b.filename);
            }
        });
        return result;
    }
}
exports.ReferencesModel = ReferencesModel;
var NodeType;
(function (NodeType) {
    NodeType[NodeType["undefined"] = 0] = "undefined";
    NodeType[NodeType["referenceType"] = 1] = "referenceType";
    NodeType[NodeType["file"] = 2] = "file";
    NodeType[NodeType["fileWithPendingRef"] = 3] = "fileWithPendingRef";
    NodeType[NodeType["reference"] = 4] = "reference";
})(NodeType = exports.NodeType || (exports.NodeType = {}));
class TreeNode {
    constructor(model, node) {
        this.model = model;
        this.node = node;
    }
}
exports.TreeNode = TreeNode;


/***/ }),

/***/ 6673:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReferencesTreeDataProvider = void 0;
const vscode = __webpack_require__(7549);
const referencesModel_1 = __webpack_require__(9997);
const references_1 = __webpack_require__(2664);
const nls = __webpack_require__(3463);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\referencesTreeDataProvider.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\referencesTreeDataProvider.ts'));
class ReferencesTreeDataProvider {
    constructor() {
        this._onDidChangeTreeData = new vscode.EventEmitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
    }
    refresh() {
        if (this.referencesModel) {
            vscode.commands.executeCommand('setContext', 'refView.isGroupedByFile', this.referencesModel.groupByFile);
            this._onDidChangeTreeData.fire();
        }
    }
    setModel(model) {
        this.referencesModel = model;
        vscode.commands.executeCommand('setContext', 'refView.isGroupedByFile', this.referencesModel.groupByFile);
        this._onDidChangeTreeData.fire();
    }
    clear() {
        this.referencesModel = undefined;
        this._onDidChangeTreeData.fire();
    }
    getTreeItem(element) {
        if (this.referencesModel === undefined) {
            throw new Error("Undefined RefrencesModel in getTreeItem()");
        }
        switch (element.node) {
            case referencesModel_1.NodeType.referenceType:
                if (element.referenceType === undefined) {
                    throw new Error("Undefined referenceType in getTreeItem()");
                }
                const label = (0, references_1.getReferenceTagString)(element.referenceType, this.referencesModel.isCanceled, true);
                const resultRefType = new vscode.TreeItem(label, vscode.TreeItemCollapsibleState.Expanded);
                return resultRefType;
            case referencesModel_1.NodeType.file:
            case referencesModel_1.NodeType.fileWithPendingRef:
                if (element.fileUri === undefined) {
                    throw new Error("Undefined fileUri in getTreeItem()");
                }
                const resultFile = new vscode.TreeItem(element.fileUri);
                resultFile.collapsibleState = vscode.TreeItemCollapsibleState.Expanded;
                resultFile.iconPath = vscode.ThemeIcon.File;
                resultFile.description = true;
                if (element.node === referencesModel_1.NodeType.fileWithPendingRef) {
                    resultFile.command = {
                        title: localize(0, null),
                        command: 'C_Cpp.ShowReferenceItem',
                        arguments: [element]
                    };
                    const tag = (0, references_1.getReferenceTagString)(references_1.ReferenceType.ConfirmationInProgress, this.referencesModel.isCanceled);
                    resultFile.tooltip = `[${tag}]\n${element.filename}`;
                    resultFile.collapsibleState = vscode.TreeItemCollapsibleState.None;
                }
                return resultFile;
            case referencesModel_1.NodeType.reference:
                if (element.referenceText === undefined) {
                    throw new Error("Undefined referenceText in getTreeItem()");
                }
                if (element.referenceType === undefined) {
                    throw new Error("Undefined referenceType in getTreeItem()");
                }
                const resultRef = new vscode.TreeItem(element.referenceText, vscode.TreeItemCollapsibleState.None);
                resultRef.iconPath = (0, references_1.getReferenceItemIconPath)(element.referenceType, this.referencesModel.isCanceled);
                const tag = (0, references_1.getReferenceTagString)(element.referenceType, this.referencesModel.isCanceled);
                resultRef.tooltip = `[${tag}]\n${element.referenceText}`;
                resultRef.command = {
                    title: localize(1, null),
                    command: 'C_Cpp.ShowReferenceItem',
                    arguments: [element]
                };
                return resultRef;
        }
        throw new Error("Invalid NoteType in getTreeItem()");
    }
    getChildren(element) {
        if (!this.referencesModel) {
            return undefined;
        }
        if (element instanceof referencesModel_1.TreeNode) {
            if (element.node === referencesModel_1.NodeType.file) {
                let type;
                if (!this.referencesModel.groupByFile) {
                    type = element.referenceType;
                }
                return this.referencesModel.getReferenceNodes(element.filename, type);
            }
            if (element.node === referencesModel_1.NodeType.referenceType) {
                return this.referencesModel.getFileNodes(element.referenceType);
            }
        }
        if (this.referencesModel.groupByFile) {
            return this.referencesModel.getFileNodes();
        }
        else {
            return this.referencesModel.getReferenceTypeNodes();
        }
    }
}
exports.ReferencesTreeDataProvider = ReferencesTreeDataProvider;


/***/ }),

/***/ 3053:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FindAllRefsView = void 0;
const vscode = __webpack_require__(7549);
const references_1 = __webpack_require__(2664);
const referencesTreeDataProvider_1 = __webpack_require__(6673);
const referencesModel_1 = __webpack_require__(9997);
class FindAllRefsView {
    constructor() {
        this.referenceViewProvider = new referencesTreeDataProvider_1.ReferencesTreeDataProvider();
        vscode.window.createTreeView('CppReferencesView', { treeDataProvider: this.referenceViewProvider, showCollapseAll: true });
    }
    show(showView) {
        if (!showView) {
            this.clearData();
        }
        let hasResults = false;
        if (this.referencesModel) {
            hasResults = this.referencesModel.hasResults();
        }
        vscode.commands.executeCommand('setContext', 'cppReferenceTypes:hasResults', hasResults);
    }
    setData(results, isCanceled, groupByFile) {
        this.referencesModel = new referencesModel_1.ReferencesModel(results, isCanceled, groupByFile, () => { this.referenceViewProvider.refresh(); });
        this.referenceViewProvider.setModel(this.referencesModel);
    }
    clearData() {
        this.referenceViewProvider.clear();
    }
    setGroupBy(groupByFile) {
        if (this.referencesModel) {
            this.referencesModel.groupByFile = groupByFile;
            this.referenceViewProvider.refresh();
        }
    }
    getResultsAsText(includeConfirmedReferences) {
        let results = [];
        const confirmedRefs = [];
        const otherRefs = [];
        const fileRefs = [];
        if (!this.referencesModel) {
            throw new Error("Missiung ReferencesModel in getResultsAsText()");
        }
        for (const ref of this.referencesModel.getAllReferenceNodes()) {
            let line = "";
            if (ref.referenceType !== null && ref.referenceType !== undefined) {
                line = "[" + (0, references_1.getReferenceTagString)(ref.referenceType, this.referencesModel.isCanceled) + "] ";
            }
            line += ref.filename;
            if (ref.referencePosition !== null && ref.referencePosition !== undefined) {
                line += ":" + (ref.referencePosition.line + 1) + ":" + (ref.referencePosition.character + 1)
                    + " " + ref.referenceText;
            }
            if (includeConfirmedReferences && ref.referenceType === references_1.ReferenceType.Confirmed) {
                confirmedRefs.push(line);
            }
            else {
                otherRefs.push(line);
            }
        }
        const fileReferences = this.referencesModel.getAllFilesWithPendingReferenceNodes();
        for (const fileRef of fileReferences) {
            const line = ("[" + (0, references_1.getReferenceTagString)(references_1.ReferenceType.ConfirmationInProgress, this.referencesModel.isCanceled) + "] "
                + fileRef.filename);
            fileRefs.push(line);
        }
        results = results.concat(confirmedRefs, otherRefs, fileRefs);
        return results.join('\n');
    }
}
exports.FindAllRefsView = FindAllRefsView;


/***/ }),

/***/ 296:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEditorConfigSettings = exports.OtherSettings = exports.CppSettings = void 0;
const vscode = __webpack_require__(7549);
const common_1 = __webpack_require__(5331);
const os = __webpack_require__(2087);
const which = __webpack_require__(8750);
const child_process_1 = __webpack_require__(3129);
const semver = __webpack_require__(2751);
const fs = __webpack_require__(5747);
const path = __webpack_require__(5622);
const client_1 = __webpack_require__(9325);
const editorConfig = __webpack_require__(9138);
const persistentState_1 = __webpack_require__(1102);
const nls = __webpack_require__(3463);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\settings.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\settings.ts'));
function getTarget() {
    return (vscode.workspace.workspaceFolders) ? vscode.ConfigurationTarget.WorkspaceFolder : vscode.ConfigurationTarget.Global;
}
class Settings {
    constructor(section, resource) {
        this.resource = resource;
        this.settings = vscode.workspace.getConfiguration(section, resource ? resource : null);
    }
    get Section() { return this.settings; }
    getWithFallback(section, deprecatedSection) {
        const info = this.settings.inspect(section);
        if (info.workspaceFolderValue !== undefined) {
            return info.workspaceFolderValue;
        }
        else if (info.workspaceValue !== undefined) {
            return info.workspaceValue;
        }
        else if (info.globalValue !== undefined) {
            return info.globalValue;
        }
        const value = this.settings.get(deprecatedSection);
        if (value !== undefined) {
            return value;
        }
        return info.defaultValue;
    }
    getWithNullAsUndefined(section) {
        const result = this.settings.get(section);
        if (result === null) {
            return undefined;
        }
        return result;
    }
    getWithUndefinedDefault(section) {
        const info = this.settings.inspect(section);
        if (info.workspaceFolderValue !== undefined) {
            return info.workspaceFolderValue;
        }
        else if (info.workspaceValue !== undefined) {
            return info.workspaceValue;
        }
        else if (info.globalValue !== undefined) {
            return info.globalValue;
        }
        return undefined;
    }
}
class CppSettings extends Settings {
    constructor(resource) {
        super("C_Cpp", resource);
    }
    get LLVMExtension() {
        return os.platform() === "win32" ? ".exe" : "";
    }
    get clangFormatStr() {
        return "clang-format";
    }
    get clangTidyStr() {
        return "clang-tidy";
    }
    get clangFormatName() {
        return this.clangFormatStr + this.LLVMExtension;
    }
    get clangTidyName() {
        return this.clangTidyStr + this.LLVMExtension;
    }
    get clangTidyPath() {
        return this.getClangPath(false);
    }
    get clangFormatPath() {
        return this.getClangPath(true);
    }
    getClangPath(isFormat) {
        let path = super.Section.get(isFormat ? "clang_format_path" : "codeAnalysis.clangTidy.path");
        if (!path) {
            const cachedClangPath = isFormat ? (0, common_1.getCachedClangFormatPath)() : (0, common_1.getCachedClangTidyPath)();
            if (cachedClangPath !== undefined) {
                if (cachedClangPath === null) {
                    return undefined;
                }
                return cachedClangPath;
            }
            const clangStr = isFormat ? this.clangFormatStr : this.clangTidyStr;
            const clangName = isFormat ? this.clangFormatName : this.clangTidyName;
            const setCachedClangPath = isFormat ? common_1.setCachedClangFormatPath : common_1.setCachedClangTidyPath;
            path = which.sync(clangName, { nothrow: true });
            setCachedClangPath(path);
            if (!path) {
                return undefined;
            }
            else {
                let clangVersion;
                try {
                    const exePath = (0, common_1.getExtensionFilePath)(`./LLVM/bin/${clangName}`);
                    const output = (0, child_process_1.execSync)(`${exePath} --version`).toString().split(" ");
                    if (output.length < 3 || output[0] !== clangStr || output[1] !== "version" || !semver.valid(output[2])) {
                        if (output.length === 3) {
                            return path;
                        }
                        const versionIndex = output.findIndex((value) => value === "version");
                        if (versionIndex < 0 || versionIndex + 1 >= output.length || !semver.valid(output[versionIndex + 1].trim())) {
                            return path;
                        }
                    }
                    clangVersion = output[2];
                }
                catch (e) {
                    return path;
                }
                try {
                    const output = (0, child_process_1.execSync)(`"${path}" --version`).toString().split(" ");
                    if (output.length < 3 || output[0] !== clangStr || output[1] !== "version" || semver.ltr(output[2], clangVersion)) {
                        path = "";
                        setCachedClangPath(path);
                    }
                }
                catch (e) {
                    path = "";
                    setCachedClangPath(path);
                }
            }
        }
        return path;
    }
    get maxConcurrentThreads() { return super.Section.get("maxConcurrentThreads"); }
    get maxMemory() { return super.Section.get("maxMemory"); }
    get maxCachedProcesses() { return super.Section.get("maxCachedProcesses"); }
    get intelliSenseMaxCachedProcesses() { return super.Section.get("intelliSense.maxCachedProcesses"); }
    get intelliSenseMaxMemory() { return super.Section.get("intelliSense.maxMemory"); }
    get referencesMaxConcurrentThreads() { return super.Section.get("references.maxConcurrentThreads"); }
    get referencesMaxCachedProcesses() { return super.Section.get("references.maxCachedProcesses"); }
    get referencesMaxMemory() { return super.Section.get("references.maxMemory"); }
    get codeAnalysisMaxConcurrentThreads() { return super.Section.get("codeAnalysis.maxConcurrentThreads"); }
    get codeAnalysisMaxMemory() { return super.Section.get("codeAnalysis.maxMemory"); }
    get codeAnalysisUpdateDelay() { return super.Section.get("codeAnalysis.updateDelay"); }
    get codeAnalysisExclude() { return super.Section.get("codeAnalysis.exclude"); }
    get codeAnalysisRunAutomatically() { return super.Section.get("codeAnalysis.runAutomatically"); }
    get codeAnalysisRunOnBuild() { return false; }
    get clangTidyEnabled() { return super.Section.get("codeAnalysis.clangTidy.enabled"); }
    get clangTidyConfig() { return super.Section.get("codeAnalysis.clangTidy.config"); }
    get clangTidyFallbackConfig() { return super.Section.get("codeAnalysis.clangTidy.fallbackConfig"); }
    get clangTidyFixWarnings() { return false; }
    get clangTidyFixErrors() { return false; }
    get clangTidyFixNotes() { return false; }
    get clangTidyHeaderFilter() { return super.Section.get("codeAnalysis.clangTidy.headerFilter"); }
    get clangTidyArgs() { return super.Section.get("codeAnalysis.clangTidy.args"); }
    get clangTidyChecksEnabled() { return super.Section.get("codeAnalysis.clangTidy.checks.enabled"); }
    get clangTidyChecksDisabled() { return super.Section.get("codeAnalysis.clangTidy.checks.disabled"); }
    get clangFormatStyle() { return super.Section.get("clang_format_style"); }
    get clangFormatFallbackStyle() { return super.Section.get("clang_format_fallbackStyle"); }
    get clangFormatSortIncludes() { return super.Section.get("clang_format_sortIncludes"); }
    get experimentalFeatures() { return super.Section.get("experimentalFeatures"); }
    get suggestSnippets() { return super.Section.get("suggestSnippets"); }
    get intelliSenseEngine() { return super.Section.get("intelliSenseEngine"); }
    get intelliSenseEngineFallback() { return super.Section.get("intelliSenseEngineFallback"); }
    get intelliSenseCachePath() { return super.Section.get("intelliSenseCachePath"); }
    get intelliSenseCacheSize() { return super.Section.get("intelliSenseCacheSize"); }
    get intelliSenseMemoryLimit() { return super.Section.get("intelliSenseMemoryLimit"); }
    get intelliSenseUpdateDelay() { return super.Section.get("intelliSenseUpdateDelay"); }
    get errorSquiggles() { return super.Section.get("errorSquiggles"); }
    get inactiveRegionOpacity() { return super.Section.get("inactiveRegionOpacity"); }
    get inactiveRegionForegroundColor() { return super.Section.get("inactiveRegionForegroundColor"); }
    get inactiveRegionBackgroundColor() { return super.Section.get("inactiveRegionBackgroundColor"); }
    get autocomplete() { return super.Section.get("autocomplete"); }
    get autocompleteAddParentheses() { return super.Section.get("autocompleteAddParentheses"); }
    get loggingLevel() { return super.Section.get("loggingLevel"); }
    get autoAddFileAssociations() { return super.Section.get("autoAddFileAssociations"); }
    get workspaceParsingPriority() { return super.Section.get("workspaceParsingPriority"); }
    get workspaceSymbols() { return super.Section.get("workspaceSymbols"); }
    get exclusionPolicy() { return super.Section.get("exclusionPolicy"); }
    get simplifyStructuredComments() { return super.Section.get("simplifyStructuredComments"); }
    get commentContinuationPatterns() { return super.Section.get("commentContinuationPatterns"); }
    get configurationWarnings() { return super.Section.get("configurationWarnings"); }
    get preferredPathSeparator() { return super.Section.get("preferredPathSeparator"); }
    get updateChannel() { return super.Section.get("updateChannel"); }
    get vcpkgEnabled() { return super.Section.get("vcpkg.enabled"); }
    get addNodeAddonIncludePaths() { return super.Section.get("addNodeAddonIncludePaths"); }
    get renameRequiresIdentifier() { return super.Section.get("renameRequiresIdentifier"); }
    get filesExclude() { return super.Section.get("files.exclude"); }
    get defaultIncludePath() { return super.getWithUndefinedDefault("default.includePath"); }
    get defaultDefines() { return super.getWithUndefinedDefault("default.defines"); }
    get defaultMacFrameworkPath() { return super.getWithUndefinedDefault("default.macFrameworkPath"); }
    get defaultWindowsSdkVersion() { return super.Section.get("default.windowsSdkVersion"); }
    get defaultCompileCommands() { return super.Section.get("default.compileCommands"); }
    get defaultForcedInclude() { return super.getWithUndefinedDefault("default.forcedInclude"); }
    get defaultIntelliSenseMode() { return super.Section.get("default.intelliSenseMode"); }
    get defaultCompilerPath() { var _a; return (_a = super.Section.get("default.compilerPath")) !== null && _a !== void 0 ? _a : undefined; }
    get defaultCompilerArgs() { return super.getWithUndefinedDefault("default.compilerArgs"); }
    get defaultCStandard() { return super.Section.get("default.cStandard"); }
    get defaultCppStandard() { return super.Section.get("default.cppStandard"); }
    get defaultConfigurationProvider() { return super.Section.get("default.configurationProvider"); }
    get defaultMergeConfigurations() { return super.Section.get("default.mergeConfigurations"); }
    get defaultBrowsePath() { var _a; return (_a = super.getWithUndefinedDefault("default.browse.path")) !== null && _a !== void 0 ? _a : undefined; }
    get defaultDatabaseFilename() { return super.Section.get("default.browse.databaseFilename"); }
    get defaultLimitSymbolsToIncludedHeaders() { return super.Section.get("default.browse.limitSymbolsToIncludedHeaders"); }
    get defaultSystemIncludePath() { return super.getWithUndefinedDefault("default.systemIncludePath"); }
    get defaultEnableConfigurationSquiggles() { return super.Section.get("default.enableConfigurationSquiggles"); }
    get defaultCustomConfigurationVariables() { return super.Section.get("default.customConfigurationVariables"); }
    get useBacktickCommandSubstitution() { return super.Section.get("debugger.useBacktickCommandSubstitution"); }
    get codeFolding() { return super.Section.get("codeFolding") === "Enabled"; }
    get enhancedColorization() {
        return super.Section.get("enhancedColorization") === "Enabled"
            && super.Section.get("intelliSenseEngine") === "Default"
            && vscode.workspace.getConfiguration("workbench").get("colorTheme") !== "Default High Contrast";
    }
    get formattingEngine() {
        return super.Section.get("formatting");
    }
    get vcFormatIndentBraces() {
        return super.Section.get("vcFormat.indent.braces") === true;
    }
    get vcFormatIndentMultiLineRelativeTo() {
        return super.Section.get("vcFormat.indent.multiLineRelativeTo");
    }
    get vcFormatIndentWithinParentheses() {
        return super.Section.get("vcFormat.indent.withinParentheses");
    }
    get vcFormatIndentPreserveWithinParentheses() {
        return super.Section.get("vcFormat.indent.preserveWithinParentheses") === true;
    }
    get vcFormatIndentCaseLabels() {
        return super.Section.get("vcFormat.indent.caseLabels") === true;
    }
    get vcFormatIndentCaseContents() {
        return super.Section.get("vcFormat.indent.caseContents") === true;
    }
    get vcFormatIndentCaseContentsWhenBlock() {
        return super.Section.get("vcFormat.indent.caseContentsWhenBlock") === true;
    }
    get vcFormatIndentLambdaBracesWhenParameter() {
        return super.Section.get("vcFormat.indent.lambdaBracesWhenParameter") === true;
    }
    get vcFormatIndentGotoLables() {
        return super.Section.get("vcFormat.indent.gotoLabels");
    }
    get vcFormatIndentPreprocessor() {
        return super.Section.get("vcFormat.indent.preprocessor");
    }
    get vcFormatIndentAccessSpecifiers() {
        return super.Section.get("vcFormat.indent.accessSpecifiers") === true;
    }
    get vcFormatIndentNamespaceContents() {
        return super.Section.get("vcFormat.indent.namespaceContents") === true;
    }
    get vcFormatIndentPreserveComments() {
        return super.Section.get("vcFormat.indent.preserveComments") === true;
    }
    get vcFormatNewlineBeforeOpenBraceNamespace() {
        return super.Section.get("vcFormat.newLine.beforeOpenBrace.namespace");
    }
    get vcFormatNewlineBeforeOpenBraceType() {
        return super.Section.get("vcFormat.newLine.beforeOpenBrace.type");
    }
    get vcFormatNewlineBeforeOpenBraceFunction() {
        return super.Section.get("vcFormat.newLine.beforeOpenBrace.function");
    }
    get vcFormatNewlineBeforeOpenBraceBlock() {
        return super.Section.get("vcFormat.newLine.beforeOpenBrace.block");
    }
    get vcFormatNewlineBeforeOpenBraceLambda() {
        return super.Section.get("vcFormat.newLine.beforeOpenBrace.lambda");
    }
    get vcFormatNewlineScopeBracesOnSeparateLines() {
        return super.Section.get("vcFormat.newLine.scopeBracesOnSeparateLines") === true;
    }
    get vcFormatNewlineCloseBraceSameLineEmptyType() {
        return super.Section.get("vcFormat.newLine.closeBraceSameLine.emptyType") === true;
    }
    get vcFormatNewlineCloseBraceSameLineEmptyFunction() {
        return super.Section.get("vcFormat.newLine.closeBraceSameLine.emptyFunction") === true;
    }
    get vcFormatNewlineBeforeCatch() {
        return super.Section.get("vcFormat.newLine.beforeCatch") === true;
    }
    get vcFormatNewlineBeforeElse() {
        return super.Section.get("vcFormat.newLine.beforeElse") === true;
    }
    get vcFormatNewlineBeforeWhileInDoWhile() {
        return super.Section.get("vcFormat.newLine.beforeWhileInDoWhile") === true;
    }
    get vcFormatSpaceBeforeFunctionOpenParenthesis() {
        return super.Section.get("vcFormat.space.beforeFunctionOpenParenthesis");
    }
    get vcFormatSpaceWithinParameterListParentheses() {
        return super.Section.get("vcFormat.space.withinParameterListParentheses") === true;
    }
    get vcFormatSpaceBetweenEmptyParameterListParentheses() {
        return super.Section.get("vcFormat.space.betweenEmptyParameterListParentheses") === true;
    }
    get vcFormatSpaceAfterKeywordsInControlFlowStatements() {
        return super.Section.get("vcFormat.space.afterKeywordsInControlFlowStatements") === true;
    }
    get vcFormatSpaceWithinControlFlowStatementParentheses() {
        return super.Section.get("vcFormat.space.withinControlFlowStatementParentheses") === true;
    }
    get vcFormatSpaceBeforeLambdaOpenParenthesis() {
        return super.Section.get("vcFormat.space.beforeLambdaOpenParenthesis") === true;
    }
    get vcFormatSpaceWithinCastParentheses() {
        return super.Section.get("vcFormat.space.withinCastParentheses") === true;
    }
    get vcFormatSpaceAfterCastCloseParenthesis() {
        return super.Section.get("vcFormat.space.afterCastCloseParenthesis") === true;
    }
    get vcFormatSpaceWithinExpressionParentheses() {
        return super.Section.get("vcFormat.space.withinExpressionParentheses") === true;
    }
    get vcFormatSpaceBeforeBlockOpenBrace() {
        return super.Section.get("vcFormat.space.beforeBlockOpenBrace") === true;
    }
    get vcFormatSpaceBetweenEmptyBraces() {
        return super.Section.get("vcFormat.space.betweenEmptyBraces") === true;
    }
    get vcFormatSpaceBeforeInitializerListOpenBrace() {
        return super.Section.get("vcFormat.space.beforeInitializerListOpenBrace") === true;
    }
    get vcFormatSpaceWithinInitializerListBraces() {
        return super.Section.get("vcFormat.space.withinInitializerListBraces") === true;
    }
    get vcFormatSpacePreserveInInitializerList() {
        return super.Section.get("vcFormat.space.preserveInInitializerList") === true;
    }
    get vcFormatSpaceBeforeOpenSquareBracket() {
        return super.Section.get("vcFormat.space.beforeOpenSquareBracket") === true;
    }
    get vcFormatSpaceWithinSquareBrackets() {
        return super.Section.get("vcFormat.space.withinSquareBrackets") === true;
    }
    get vcFormatSpaceBeforeEmptySquareBrackets() {
        return super.Section.get("vcFormat.space.beforeEmptySquareBrackets") === true;
    }
    get vcFormatSpaceBetweenEmptySquareBrackets() {
        return super.Section.get("vcFormat.space.betweenEmptySquareBrackets") === true;
    }
    get vcFormatSpaceGroupSquareBrackets() {
        return super.Section.get("vcFormat.space.groupSquareBrackets") === true;
    }
    get vcFormatSpaceWithinLambdaBrackets() {
        return super.Section.get("vcFormat.space.withinLambdaBrackets") === true;
    }
    get vcFormatSpaceBetweenEmptyLambdaBrackets() {
        return super.Section.get("vcFormat.space.betweenEmptyLambdaBrackets") === true;
    }
    get vcFormatSpaceBeforeComma() {
        return super.Section.get("vcFormat.space.beforeComma") === true;
    }
    get vcFormatSpaceAfterComma() {
        return super.Section.get("vcFormat.space.afterComma") === true;
    }
    get vcFormatSpaceRemoveAroundMemberOperators() {
        return super.Section.get("vcFormat.space.removeAroundMemberOperators") === true;
    }
    get vcFormatSpaceBeforeInheritanceColon() {
        return super.Section.get("vcFormat.space.beforeInheritanceColon") === true;
    }
    get vcFormatSpaceBeforeConstructorColon() {
        return super.Section.get("vcFormat.space.beforeConstructorColon") === true;
    }
    get vcFormatSpaceRemoveBeforeSemicolon() {
        return super.Section.get("vcFormat.space.removeBeforeSemicolon") === true;
    }
    get vcFormatSpaceInsertAfterSemicolon() {
        return super.Section.get("vcFormat.space.insertAfterSemicolon") === true;
    }
    get vcFormatSpaceRemoveAroundUnaryOperator() {
        return super.Section.get("vcFormat.space.removeAroundUnaryOperator") === true;
    }
    get vcFormatSpaceAroundBinaryOperator() {
        return super.Section.get("vcFormat.space.aroundBinaryOperator");
    }
    get vcFormatSpaceAroundAssignmentOperator() {
        return super.Section.get("vcFormat.space.aroundAssignmentOperator");
    }
    get vcFormatSpacePointerReferenceAlignment() {
        return super.Section.get("vcFormat.space.pointerReferenceAlignment");
    }
    get vcFormatSpaceAroundTernaryOperator() {
        return super.Section.get("vcFormat.space.aroundTernaryOperator");
    }
    get vcFormatWrapPreserveBlocks() {
        return super.Section.get("vcFormat.wrap.preserveBlocks");
    }
    get dimInactiveRegions() {
        return super.Section.get("dimInactiveRegions") === true
            && super.Section.get("intelliSenseEngine") === "Default"
            && vscode.workspace.getConfiguration("workbench").get("colorTheme") !== "Default High Contrast";
    }
    toggleSetting(name, value1, value2) {
        const value = super.Section.get(name);
        super.Section.update(name, value === value1 ? value2 : value1, getTarget());
    }
    update(name, value) {
        super.Section.update(name, value);
    }
    populateEditorConfig(document) {
        const settingMap = new Map();
        settingMap.set("cpp_indent_braces", this.vcFormatIndentBraces.toString());
        settingMap.set("cpp_indent_multi_line_relative_to", mapIndentationReferenceToEditorConfig(this.vcFormatIndentMultiLineRelativeTo));
        settingMap.set("cpp_indent_within_parentheses", this.vcFormatIndentWithinParentheses.toString());
        settingMap.set("cpp_indent_preserve_within_parentheses", this.vcFormatIndentPreserveWithinParentheses.toString());
        settingMap.set("cpp_indent_case_labels", this.vcFormatIndentCaseLabels.toString());
        settingMap.set("cpp_indent_case_contents", this.vcFormatIndentCaseContents.toString());
        settingMap.set("cpp_indent_case_contents_when_block", this.vcFormatIndentCaseContentsWhenBlock.toString());
        settingMap.set("cpp_indent_lambda_braces_when_parameter", this.vcFormatIndentLambdaBracesWhenParameter.toString());
        settingMap.set("cpp_indent_goto_labels", mapIndentToEditorConfig(this.vcFormatIndentGotoLables));
        settingMap.set("cpp_indent_preprocessor", mapIndentToEditorConfig(this.vcFormatIndentPreprocessor));
        settingMap.set("cpp_indent_access_specifiers", this.vcFormatIndentAccessSpecifiers.toString());
        settingMap.set("cpp_indent_namespace_contents", this.vcFormatIndentNamespaceContents.toString());
        settingMap.set("cpp_indent_preserve_comments", this.vcFormatIndentPreserveComments.toString());
        settingMap.set("cpp_new_line_before_open_brace_namespace", mapNewOrSameLineToEditorConfig(this.vcFormatNewlineBeforeOpenBraceNamespace));
        settingMap.set("cpp_new_line_before_open_brace_type", mapNewOrSameLineToEditorConfig(this.vcFormatNewlineBeforeOpenBraceType));
        settingMap.set("cpp_new_line_before_open_brace_function", mapNewOrSameLineToEditorConfig(this.vcFormatNewlineBeforeOpenBraceFunction));
        settingMap.set("cpp_new_line_before_open_brace_block", mapNewOrSameLineToEditorConfig(this.vcFormatNewlineBeforeOpenBraceBlock));
        settingMap.set("cpp_new_line_before_open_brace_lambda", mapNewOrSameLineToEditorConfig(this.vcFormatNewlineBeforeOpenBraceLambda));
        settingMap.set("cpp_new_line_scope_braces_on_separate_lines", this.vcFormatNewlineScopeBracesOnSeparateLines.toString());
        settingMap.set("cpp_new_line_close_brace_same_line_empty_type", this.vcFormatNewlineCloseBraceSameLineEmptyType.toString());
        settingMap.set("cpp_new_line_close_brace_same_line_empty_function", this.vcFormatNewlineCloseBraceSameLineEmptyFunction.toString());
        settingMap.set("cpp_new_line_before_catch", this.vcFormatNewlineBeforeCatch.toString().toString());
        settingMap.set("cpp_new_line_before_else", this.vcFormatNewlineBeforeElse.toString().toString());
        settingMap.set("cpp_new_line_before_while_in_do_while", this.vcFormatNewlineBeforeWhileInDoWhile.toString());
        settingMap.set("cpp_space_before_function_open_parenthesis", this.vcFormatSpaceBeforeFunctionOpenParenthesis.toString());
        settingMap.set("cpp_space_within_parameter_list_parentheses", this.vcFormatSpaceWithinParameterListParentheses.toString());
        settingMap.set("cpp_space_between_empty_parameter_list_parentheses", this.vcFormatSpaceBetweenEmptyParameterListParentheses.toString());
        settingMap.set("cpp_space_after_keywords_in_control_flow_statements", this.vcFormatSpaceAfterKeywordsInControlFlowStatements.toString());
        settingMap.set("cpp_space_within_control_flow_statement_parentheses", this.vcFormatSpaceWithinControlFlowStatementParentheses.toString());
        settingMap.set("cpp_space_before_lambda_open_parenthesis", this.vcFormatSpaceBeforeLambdaOpenParenthesis.toString());
        settingMap.set("cpp_space_within_cast_parentheses", this.vcFormatSpaceWithinCastParentheses.toString());
        settingMap.set("cpp_space_after_cast_close_parenthesis", this.vcFormatSpaceAfterCastCloseParenthesis.toString());
        settingMap.set("cpp_space_within_expression_parentheses", this.vcFormatSpaceWithinExpressionParentheses.toString());
        settingMap.set("cpp_space_before_block_open_brace", this.vcFormatSpaceBeforeBlockOpenBrace.toString());
        settingMap.set("cpp_space_between_empty_braces", this.vcFormatSpaceBetweenEmptyBraces.toString());
        settingMap.set("cpp_space_before_initializer_list_open_brace", this.vcFormatSpaceBeforeInitializerListOpenBrace.toString());
        settingMap.set("cpp_space_within_initializer_list_braces", this.vcFormatSpaceWithinInitializerListBraces.toString());
        settingMap.set("cpp_space_preserve_in_initializer_list", this.vcFormatSpacePreserveInInitializerList.toString());
        settingMap.set("cpp_space_before_open_square_bracket", this.vcFormatSpaceBeforeOpenSquareBracket.toString());
        settingMap.set("cpp_space_within_square_brackets", this.vcFormatSpaceWithinSquareBrackets.toString());
        settingMap.set("cpp_space_before_empty_square_brackets", this.vcFormatSpaceBeforeEmptySquareBrackets.toString());
        settingMap.set("cpp_space_between_empty_square_brackets", this.vcFormatSpaceBetweenEmptySquareBrackets.toString());
        settingMap.set("cpp_space_group_square_brackets", this.vcFormatSpaceGroupSquareBrackets.toString());
        settingMap.set("cpp_space_within_lambda_brackets", this.vcFormatSpaceWithinLambdaBrackets.toString());
        settingMap.set("cpp_space_between_empty_lambda_brackets", this.vcFormatSpaceBetweenEmptyLambdaBrackets.toString());
        settingMap.set("cpp_space_before_comma", this.vcFormatSpaceBeforeComma.toString());
        settingMap.set("cpp_space_after_comma", this.vcFormatSpaceAfterComma.toString());
        settingMap.set("cpp_space_remove_around_member_operators", this.vcFormatSpaceRemoveAroundMemberOperators.toString());
        settingMap.set("cpp_space_before_inheritance_colon", this.vcFormatSpaceBeforeInheritanceColon.toString());
        settingMap.set("cpp_space_before_constructor_colon", this.vcFormatSpaceBeforeConstructorColon.toString());
        settingMap.set("cpp_space_remove_before_semicolon", this.vcFormatSpaceRemoveBeforeSemicolon.toString());
        settingMap.set("cpp_space_after_semicolon", this.vcFormatSpaceInsertAfterSemicolon.toString());
        settingMap.set("cpp_space_remove_around_unary_operator", this.vcFormatSpaceRemoveAroundUnaryOperator.toString());
        settingMap.set("cpp_space_around_binary_operator", this.vcFormatSpaceAroundBinaryOperator.toString());
        settingMap.set("cpp_space_around_assignment_operator", this.vcFormatSpaceAroundAssignmentOperator.toString());
        settingMap.set("cpp_space_pointer_reference_alignment", this.vcFormatSpacePointerReferenceAlignment.toString());
        settingMap.set("cpp_space_around_ternary_operator", this.vcFormatSpaceAroundTernaryOperator.toString());
        settingMap.set("cpp_wrap_preserve_blocks", mapWrapToEditorConfig(this.vcFormatWrapPreserveBlocks));
        const edits = new vscode.WorkspaceEdit();
        let isInWildcardSection = false;
        let trailingBlankLines = 0;
        for (let i = 0; i < document.lineCount; ++i) {
            let textLine = document.lineAt(i);
            if (textLine.range.end.character === 0) {
                trailingBlankLines++;
                continue;
            }
            trailingBlankLines = 0;
            let text = textLine.text.trim();
            if (text.startsWith("[")) {
                isInWildcardSection = text.startsWith("[*]");
                continue;
            }
            for (const setting of settingMap) {
                if (text.startsWith(setting[0])) {
                    if (text.length > setting[0].length) {
                        const c = text[setting[0].length];
                        if (c !== '=' && c.trim() !== "") {
                            continue;
                        }
                    }
                    edits.replace(document.uri, textLine.range, setting[0] + "=" + setting[1]);
                    for (let j = i + 1; j < document.lineCount; ++j) {
                        textLine = document.lineAt(j);
                        text = textLine.text.trim();
                        if (text.startsWith(setting[0])) {
                            if (text.length > setting[0].length) {
                                const c = text[setting[0].length];
                                if (c !== '=' && c.trim() !== "") {
                                    continue;
                                }
                            }
                            edits.replace(document.uri, textLine.range, setting[0] + "=" + setting[1]);
                        }
                    }
                    settingMap.delete(setting[0]);
                    break;
                }
            }
            if (settingMap.size === 0) {
                break;
            }
        }
        if (settingMap.size > 0) {
            let remainingSettingsText = "";
            if (document.lineCount > 0) {
                while (++trailingBlankLines < 2) {
                    remainingSettingsText += "\n";
                }
            }
            if (!isInWildcardSection) {
                remainingSettingsText += "[*]\n";
            }
            for (const setting of settingMap) {
                remainingSettingsText += setting[0] + "=" + setting[1] + "\n";
            }
            const lastPosition = document.lineAt(document.lineCount - 1).range.end;
            edits.insert(document.uri, lastPosition, remainingSettingsText);
        }
        vscode.workspace.applyEdit(edits).then(() => vscode.window.showTextDocument(document));
    }
    generateEditorConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            let document;
            if (this.resource) {
                const uri = vscode.Uri.joinPath(this.resource, ".editorconfig");
                const edits = new vscode.WorkspaceEdit();
                edits.createFile(uri, { ignoreIfExists: true, overwrite: false });
                try {
                    yield vscode.workspace.applyEdit(edits);
                    document = yield vscode.workspace.openTextDocument(uri);
                }
                catch (e) {
                    document = yield vscode.workspace.openTextDocument();
                }
            }
            else {
                document = yield vscode.workspace.openTextDocument();
            }
            this.populateEditorConfig(document);
        });
    }
    useVcFormat(document) {
        if (this.formattingEngine !== "Default") {
            return this.formattingEngine === "vcFormat";
        }
        if (this.clangFormatStyle !== "file") {
            return false;
        }
        const cachedValue = client_1.cachedEditorConfigLookups.get(document.uri.fsPath);
        if (cachedValue !== undefined) {
            return cachedValue;
        }
        let foundEditorConfigWithVcFormatSettings = false;
        const findConfigFile = (parentPath) => {
            var _a;
            const editorConfigPath = path.join(parentPath, ".editorconfig");
            if (fs.existsSync(editorConfigPath)) {
                const editorConfigSettings = getEditorConfigSettings(document.uri.fsPath);
                const keys = Object.keys(editorConfigSettings);
                for (let i = 0; i < keys.length; ++i) {
                    if (keys[i].startsWith("cpp_")) {
                        foundEditorConfigWithVcFormatSettings = true;
                        const didEditorConfigNotice = new persistentState_1.PersistentState("Cpp.didEditorConfigNotice", false);
                        if (!didEditorConfigNotice.Value) {
                            vscode.window.showInformationMessage(localize(0, null));
                            didEditorConfigNotice.Value = true;
                        }
                        return true;
                    }
                }
                if (((_a = editorConfigSettings.root) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "true") {
                    return true;
                }
            }
            else {
                const clangFormatPath1 = path.join(parentPath, ".clang-format");
                if (fs.existsSync(clangFormatPath1)) {
                    return true;
                }
                else {
                    const clangFormatPath2 = path.join(parentPath, "_clang-format");
                    if (fs.existsSync(clangFormatPath2)) {
                        return true;
                    }
                }
            }
            return false;
        };
        const fsPath = document.uri.fsPath;
        let parentPath = path.dirname(fsPath);
        let currentParentPath;
        do {
            currentParentPath = parentPath;
            if (findConfigFile(currentParentPath)) {
                client_1.cachedEditorConfigLookups.set(document.uri.fsPath, foundEditorConfigWithVcFormatSettings);
                return foundEditorConfigWithVcFormatSettings;
            }
            parentPath = path.dirname(parentPath);
        } while (parentPath !== currentParentPath);
        client_1.cachedEditorConfigLookups.set(document.uri.fsPath, false);
        return false;
    }
}
exports.CppSettings = CppSettings;
class OtherSettings {
    constructor(resource) {
        if (!resource) {
            resource = undefined;
        }
        this.resource = resource;
    }
    get editorTabSize() { return vscode.workspace.getConfiguration("editor", this.resource).get("tabSize"); }
    get editorAutoClosingBrackets() { return vscode.workspace.getConfiguration("editor", this.resource).get("autoClosingBrackets"); }
    get filesEncoding() { return vscode.workspace.getConfiguration("files", { uri: this.resource, languageId: "cpp" }).get("encoding"); }
    get filesAssociations() { return vscode.workspace.getConfiguration("files").get("associations"); }
    set filesAssociations(value) {
        vscode.workspace.getConfiguration("files").update("associations", value, vscode.ConfigurationTarget.Workspace);
    }
    get filesExclude() { return vscode.workspace.getConfiguration("files", this.resource).get("exclude"); }
    get filesAutoSaveAfterDelay() { return vscode.workspace.getConfiguration("files").get("autoSave") === "afterDelay"; }
    get searchExclude() { return vscode.workspace.getConfiguration("search", this.resource).get("exclude"); }
    get settingsEditor() { return vscode.workspace.getConfiguration("workbench.settings").get("editor"); }
    get colorTheme() { return vscode.workspace.getConfiguration("workbench").get("colorTheme"); }
    getCustomColorToken(colorTokenName) { return vscode.workspace.getConfiguration("editor.tokenColorCustomizations").get(colorTokenName); }
    getCustomThemeSpecificColorToken(themeName, colorTokenName) { return vscode.workspace.getConfiguration(`editor.tokenColorCustomizations.[${themeName}]`, this.resource).get(colorTokenName); }
    get customTextMateRules() { return vscode.workspace.getConfiguration("editor.tokenColorCustomizations").get("textMateRules"); }
    getCustomThemeSpecificTextMateRules(themeName) { return vscode.workspace.getConfiguration(`editor.tokenColorCustomizations.[${themeName}]`, this.resource).get("textMateRules"); }
}
exports.OtherSettings = OtherSettings;
function mapIndentationReferenceToEditorConfig(value) {
    if (value !== undefined) {
        if (value === "statementBegin") {
            return "statement_begin";
        }
        if (value === "outermostParenthesis") {
            return "outermost_parenthesis";
        }
    }
    return "innermost_parenthesis";
}
function mapIndentToEditorConfig(value) {
    if (value !== undefined) {
        if (value === "leftmostColumn") {
            return "leftmost_column";
        }
        if (value === "oneLeft") {
            return "one_left";
        }
    }
    return "none";
}
function mapNewOrSameLineToEditorConfig(value) {
    if (value !== undefined) {
        if (value === "newLine") {
            return "new_line";
        }
        if (value === "sameLine") {
            return "same_line";
        }
    }
    return "ignore";
}
function mapWrapToEditorConfig(value) {
    if (value !== undefined) {
        if (value === "allOneLineScopes") {
            return "all_one_line_scopes";
        }
        if (value === "oneLiners") {
            return "one_liners";
        }
    }
    return "never";
}
function getEditorConfigSettings(fsPath) {
    let editorConfigSettings = client_1.cachedEditorConfigSettings.get(fsPath);
    if (!editorConfigSettings) {
        editorConfigSettings = editorConfig.parseSync(fsPath);
        client_1.cachedEditorConfigSettings.set(fsPath, editorConfigSettings);
    }
    return editorConfigSettings;
}
exports.getEditorConfigSettings = getEditorConfigSettings;


/***/ }),

/***/ 7597:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingsPanel = void 0;
const path = __webpack_require__(5622);
const fs = __webpack_require__(5747);
const vscode = __webpack_require__(7549);
const util = __webpack_require__(5331);
const telemetry = __webpack_require__(1818);
const elementId = {
    configName: "configName",
    configNameInvalid: "configNameInvalid",
    configSelection: "configSelection",
    addConfigBtn: "addConfigBtn",
    addConfigOk: "addConfigOk",
    addConfigCancel: "addConfigCancel",
    addConfigName: "addConfigName",
    compilerPath: "compilerPath",
    compilerPathInvalid: "compilerPathInvalid",
    knownCompilers: "knownCompilers",
    compilerArgs: "compilerArgs",
    intelliSenseMode: "intelliSenseMode",
    intelliSenseModeInvalid: "intelliSenseModeInvalid",
    includePath: "includePath",
    includePathInvalid: "includePathInvalid",
    defines: "defines",
    cStandard: "cStandard",
    cppStandard: "cppStandard",
    windowsSdkVersion: "windowsSdkVersion",
    macFrameworkPath: "macFrameworkPath",
    compileCommands: "compileCommands",
    mergeConfigurations: "mergeConfigurations",
    configurationProvider: "configurationProvider",
    forcedInclude: "forcedInclude",
    browsePath: "browsePath",
    limitSymbolsToIncludedHeaders: "limitSymbolsToIncludedHeaders",
    databaseFilename: "databaseFilename",
    showAdvancedBtn: "showAdvancedBtn"
};
class SettingsPanel {
    constructor() {
        this.telemetry = {};
        this.settingsPanelActivated = new vscode.EventEmitter();
        this.configValuesChanged = new vscode.EventEmitter();
        this.configSelectionChanged = new vscode.EventEmitter();
        this.addConfigRequested = new vscode.EventEmitter();
        this.configValues = { name: "" };
        this.isIntelliSenseModeDefined = false;
        this.configIndexSelected = 0;
        this.compilerPaths = [];
        this.initialized = false;
        this.disposable = vscode.Disposable.from(this.settingsPanelActivated, this.configValuesChanged, this.configSelectionChanged, this.addConfigRequested);
    }
    createOrShow(configSelection, activeConfiguration, errors, viewColumn) {
        var _a;
        const column = viewColumn !== null && viewColumn !== void 0 ? viewColumn : (_a = vscode.window.activeTextEditor) === null || _a === void 0 ? void 0 : _a.viewColumn;
        if (this.panel) {
            this.panel.reveal(column, false);
            return;
        }
        this.initialized = false;
        this.panel = vscode.window.createWebviewPanel(SettingsPanel.viewType, SettingsPanel.title, column || vscode.ViewColumn.One, {
            enableCommandUris: true,
            enableScripts: true,
            localResourceRoots: [
                vscode.Uri.file(util.extensionPath),
                vscode.Uri.file(path.join(util.extensionPath, 'ui')),
                vscode.Uri.file(path.join(util.extensionPath, 'out', 'ui'))
            ]
        });
        this.panel.iconPath = vscode.Uri.file(util.getExtensionFilePath("LanguageCCPP_color_128x.png"));
        this.disposablesPanel = vscode.Disposable.from(this.panel, this.panel.onDidDispose(this.onPanelDisposed, this), this.panel.onDidChangeViewState(this.onViewStateChanged, this), this.panel.webview.onDidReceiveMessage(this.onMessageReceived, this), vscode.window.onDidChangeWindowState(this.onWindowStateChanged, this));
        this.panel.webview.html = this.getHtml();
        this.updateWebview(configSelection, activeConfiguration, errors);
    }
    get SettingsPanelActivated() {
        return this.settingsPanelActivated.event;
    }
    get ConfigValuesChanged() {
        return this.configValuesChanged.event;
    }
    get ConfigSelectionChanged() {
        return this.configSelectionChanged.event;
    }
    get AddConfigRequested() {
        return this.addConfigRequested.event;
    }
    get selectedConfigIndex() {
        return this.configIndexSelected;
    }
    set selectedConfigIndex(index) {
        this.configIndexSelected = index;
    }
    getLastValuesFromConfigUI() {
        return this.configValues;
    }
    updateConfigUI(configSelection, configuration, errors) {
        if (this.panel) {
            this.updateWebview(configSelection, configuration, errors);
        }
    }
    setKnownCompilers(knownCompilers, pathSeparator) {
        if (knownCompilers && knownCompilers.length) {
            for (const compiler of knownCompilers) {
                let path = compiler.path;
                if (pathSeparator === "Forward Slash") {
                    path = path.replace(/\\/g, '/');
                }
                else {
                    path = path.replace(/\//g, '\\');
                }
                if (this.compilerPaths.indexOf(path) === -1) {
                    this.compilerPaths.push(path);
                }
            }
        }
    }
    updateErrors(errors) {
        if (this.panel) {
            this.panel.webview.postMessage({ command: 'updateErrors', errors: errors });
        }
    }
    dispose() {
        if (Object.keys(this.telemetry).length) {
            telemetry.logLanguageServerEvent("ConfigUI", undefined, this.telemetry);
        }
        if (this.panel) {
            this.panel.dispose();
        }
        if (this.disposable) {
            this.disposable.dispose();
        }
        if (this.disposablesPanel) {
            this.disposablesPanel.dispose();
        }
    }
    onPanelDisposed() {
        if (this.disposablesPanel) {
            this.disposablesPanel.dispose();
            this.panel = undefined;
        }
    }
    updateWebview(configSelection, configuration, errors) {
        this.configValues = Object.assign({}, configuration);
        this.isIntelliSenseModeDefined = (this.configValues.intelliSenseMode !== undefined);
        if (this.panel && this.initialized) {
            this.panel.webview.postMessage({ command: 'setKnownCompilers', compilers: this.compilerPaths });
            this.panel.webview.postMessage({ command: 'updateConfigSelection', selections: configSelection, selectedIndex: this.configIndexSelected });
            this.panel.webview.postMessage({ command: 'updateConfig', config: this.configValues });
            if (errors !== null) {
                this.panel.webview.postMessage({ command: 'updateErrors', errors: errors });
            }
        }
    }
    onViewStateChanged(e) {
        if (e.webviewPanel.active) {
            this.settingsPanelActivated.fire();
        }
    }
    onWindowStateChanged(e) {
        if (e.focused) {
            this.settingsPanelActivated.fire();
        }
    }
    onMessageReceived(message) {
        if (message === null || message === undefined) {
            return;
        }
        switch (message.command) {
            case 'change':
                this.updateConfig(message);
                break;
            case 'configSelect':
                this.configSelect(message.index);
                break;
            case 'addConfig':
                this.addConfig(message.name);
                break;
            case 'knownCompilerSelect':
                this.knownCompilerSelect();
                break;
            case "initialized":
                this.initialized = true;
                this.settingsPanelActivated.fire();
                break;
        }
    }
    addConfig(name) {
        this.addConfigRequested.fire(name);
        this.logTelemetryForElement(elementId.addConfigName);
    }
    configSelect(index) {
        this.configIndexSelected = index;
        this.configSelectionChanged.fire();
        this.logTelemetryForElement(elementId.configSelection);
    }
    knownCompilerSelect() {
        this.logTelemetryForElement(elementId.knownCompilers);
        if (this.telemetry[elementId.compilerPath]) {
            this.telemetry[elementId.compilerPath]--;
        }
    }
    updateConfig(message) {
        const splitEntries = (input) => input.split("\n").filter((e) => e);
        switch (message.key) {
            case elementId.configName:
                this.configValues.name = message.value;
                break;
            case elementId.compilerPath:
                this.configValues.compilerPath = message.value;
                break;
            case elementId.compilerArgs:
                this.configValues.compilerArgs = splitEntries(message.value);
                break;
            case elementId.includePath:
                this.configValues.includePath = splitEntries(message.value);
                break;
            case elementId.defines:
                this.configValues.defines = splitEntries(message.value);
                break;
            case elementId.intelliSenseMode:
                if (message.value !== "${default}" || this.isIntelliSenseModeDefined) {
                    this.configValues.intelliSenseMode = message.value;
                }
                else {
                    this.configValues.intelliSenseMode = undefined;
                }
                break;
            case elementId.cStandard:
                this.configValues.cStandard = message.value;
                break;
            case elementId.cppStandard:
                this.configValues.cppStandard = message.value;
                break;
            case elementId.windowsSdkVersion:
                this.configValues.windowsSdkVersion = message.value;
                break;
            case elementId.macFrameworkPath:
                this.configValues.macFrameworkPath = splitEntries(message.value);
                break;
            case elementId.compileCommands:
                this.configValues.compileCommands = message.value;
                break;
            case elementId.mergeConfigurations:
                this.configValues.mergeConfigurations = message.value;
                break;
            case elementId.configurationProvider:
                this.configValues.configurationProvider = message.value;
                break;
            case elementId.forcedInclude:
                this.configValues.forcedInclude = splitEntries(message.value);
                break;
            case elementId.browsePath:
                if (!this.configValues.browse) {
                    this.configValues.browse = {};
                }
                this.configValues.browse.path = splitEntries(message.value);
                break;
            case elementId.limitSymbolsToIncludedHeaders:
                if (!this.configValues.browse) {
                    this.configValues.browse = {};
                }
                this.configValues.browse.limitSymbolsToIncludedHeaders = message.value;
                break;
            case elementId.databaseFilename:
                if (!this.configValues.browse) {
                    this.configValues.browse = {};
                }
                this.configValues.browse.databaseFilename = message.value;
                break;
        }
        this.configValuesChanged.fire();
        this.logTelemetryForElement(message.key);
    }
    logTelemetryForElement(elementId) {
        if (this.telemetry[elementId] === undefined) {
            this.telemetry[elementId] = 0;
        }
        this.telemetry[elementId]++;
    }
    getHtml() {
        let content;
        content = fs.readFileSync(util.getLocalizedHtmlPath("ui/settings.html")).toString();
        if (this.panel && this.panel.webview) {
            const cppImageUri = this.panel.webview.asWebviewUri(vscode.Uri.file(path.join(util.extensionPath, 'LanguageCCPP_color_128x.png')));
            content = content.replace(/{{cpp_image_uri}}/g, cppImageUri.toString());
            const settingsJsUri = this.panel.webview.asWebviewUri(vscode.Uri.file(path.join(util.extensionPath, 'out/ui/settings.js')));
            content = content.replace(/{{settings_js_uri}}/g, settingsJsUri.toString());
        }
        content = content.replace(/{{nonce}}/g, this.getNonce());
        return content;
    }
    getNonce() {
        let nonce = "";
        const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        for (let i = 0; i < 32; i++) {
            nonce += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        return nonce;
    }
}
exports.SettingsPanel = SettingsPanel;
SettingsPanel.viewType = 'settingsPanel';
SettingsPanel.title = 'C/C++ Configurations';


/***/ }),

/***/ 5313:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTracker = exports.SettingsTracker = void 0;
const vscode = __webpack_require__(7549);
const util = __webpack_require__(5331);
const maxSettingLengthForTelemetry = 50;
let cache;
class SettingsTracker {
    constructor(resource) {
        this.previousCppSettings = {};
        this.resource = resource;
        this.collectSettings(() => true);
    }
    getUserModifiedSettings() {
        const filter = (key, val, settings) => { var _a; return !this.areEqual(val, (_a = settings.inspect(key)) === null || _a === void 0 ? void 0 : _a.defaultValue); };
        return this.collectSettings(filter);
    }
    getChangedSettings() {
        const filter = (key, val) => !(key in this.previousCppSettings) || !this.areEqual(val, this.previousCppSettings[key]);
        return this.collectSettings(filter);
    }
    collectSettings(filter) {
        const settingsResourceScope = vscode.workspace.getConfiguration("C_Cpp", this.resource);
        const settingsNonScoped = vscode.workspace.getConfiguration("C_Cpp");
        const selectCorrectlyScopedSettings = (rawSetting) => (!rawSetting || rawSetting.scope === "resource" || rawSetting.scope === "machine-overridable") ? settingsResourceScope : settingsNonScoped;
        const result = {};
        for (const key in settingsResourceScope) {
            const rawSetting = util.packageJson.contributes.configuration.properties["C_Cpp." + key];
            const correctlyScopedSettings = selectCorrectlyScopedSettings(rawSetting);
            const val = this.getSetting(correctlyScopedSettings, key);
            if (val === undefined) {
                continue;
            }
            const collectSettingsRecursive = (key, val, depth) => {
                if (depth > 4) {
                    return;
                }
                for (const subKey in val) {
                    const newKey = key + "." + subKey;
                    const newRawSetting = util.packageJson.contributes.configuration.properties["C_Cpp." + newKey];
                    const correctlyScopedSubSettings = selectCorrectlyScopedSettings(newRawSetting);
                    const subVal = this.getSetting(correctlyScopedSubSettings, newKey);
                    if (subVal === undefined) {
                        continue;
                    }
                    if (subVal instanceof Object && !(subVal instanceof Array)) {
                        collectSettingsRecursive(newKey, subVal, depth + 1);
                    }
                    else {
                        const entry = this.filterAndSanitize(newKey, subVal, correctlyScopedSubSettings, filter);
                        if (entry && entry.key && entry.value) {
                            result[entry.key] = entry.value;
                        }
                    }
                }
            };
            if (val instanceof Object && !(val instanceof Array)) {
                collectSettingsRecursive(key, val, 1);
                continue;
            }
            const entry = this.filterAndSanitize(key, val, correctlyScopedSettings, filter);
            if (entry && entry.key && entry.value) {
                result[entry.key] = entry.value;
            }
        }
        return result;
    }
    getSetting(settings, key) {
        var _a;
        if (((_a = settings.inspect(key)) === null || _a === void 0 ? void 0 : _a.defaultValue) !== undefined) {
            const val = settings.get(key);
            if (val instanceof Object) {
                return val;
            }
            const curSetting = util.packageJson.contributes.configuration.properties["C_Cpp." + key];
            if (curSetting) {
                const type = this.typeMatch(val, curSetting["type"]);
                if (type) {
                    if (type !== "string") {
                        return val;
                    }
                    const curEnum = curSetting["enum"];
                    if (curEnum && curEnum.indexOf(val) === -1) {
                        return "<invalid>";
                    }
                    return val;
                }
            }
        }
        return undefined;
    }
    typeMatch(value, type) {
        if (type) {
            if (type instanceof Array) {
                for (let i = 0; i < type.length; i++) {
                    const t = type[i];
                    if (t) {
                        if (typeof value === t) {
                            return t;
                        }
                        if (t === "array" && value instanceof Array) {
                            return t;
                        }
                        if (t === "null" && value === null) {
                            return t;
                        }
                    }
                }
            }
            else if (typeof type === "string" && typeof value === type) {
                return type;
            }
        }
        return undefined;
    }
    filterAndSanitize(key, val, settings, filter) {
        var _a, _b;
        if (filter(key, val, settings)) {
            let value;
            this.previousCppSettings[key] = val;
            switch (key) {
                case "clang_format_style":
                case "clang_format_fallbackStyle": {
                    const newKey = key + "2";
                    if (val) {
                        switch (String(val).toLowerCase()) {
                            case "emulated visual studio":
                            case "visual studio":
                            case "llvm":
                            case "google":
                            case "chromium":
                            case "mozilla":
                            case "webkit":
                            case "file":
                            case "none": {
                                value = String(this.previousCppSettings[key]);
                                break;
                            }
                            default: {
                                value = "...";
                                break;
                            }
                        }
                    }
                    else {
                        value = "null";
                    }
                    key = newKey;
                    break;
                }
                case "commentContinuationPatterns": {
                    key = "commentContinuationPatterns2";
                    value = this.areEqual(val, (_a = settings.inspect(key)) === null || _a === void 0 ? void 0 : _a.defaultValue) ? "<default>" : "...";
                    break;
                }
                default: {
                    if (key === "clang_format_path" || key === "intelliSenseCachePath" || key.startsWith("default.")
                        || key === "codeAnalysis.clangTidy.path"
                        || key === "codeAnalysis.clangTidy.headerFilter" || key === "codeAnalysis.clangTidy.args"
                        || key === "codeAnalysis.clangTidy.config" || key === "codeAnalysis.clangTidy.fallbackConfig"
                        || key === "files.exclude" || key === "codeAnalysis.exclude") {
                        value = this.areEqual(val, (_b = settings.inspect(key)) === null || _b === void 0 ? void 0 : _b.defaultValue) ? "<default>" : "...";
                    }
                    else {
                        value = String(this.previousCppSettings[key]);
                    }
                }
            }
            if (value && value.length > maxSettingLengthForTelemetry) {
                value = value.substr(0, maxSettingLengthForTelemetry) + "...";
            }
            return { key: key, value: value };
        }
        return undefined;
    }
    areEqual(value1, value2) {
        if (value1 instanceof Object && value2 instanceof Object) {
            return JSON.stringify(value1) === JSON.stringify(value2);
        }
        return value1 === value2;
    }
}
exports.SettingsTracker = SettingsTracker;
function getTracker(resource) {
    if (!cache) {
        cache = new SettingsTracker(resource);
    }
    return cache;
}
exports.getTracker = getTracker;


/***/ }),

/***/ 9071:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeTelemetryCollector = void 0;
const telemetry = __webpack_require__(1818);
const util = __webpack_require__(5331);
class TimeTelemetryCollector {
    constructor() {
        this.cachedTimeStamps = new Map();
    }
    setFirstFile(uri) {
        if (util.fileIsCOrCppSource(uri.path)) {
            const curTimeStamps = this.getTimeStamp(uri.path);
            curTimeStamps.firstFile = new Date().getTime();
            this.cachedTimeStamps.set(uri.path, curTimeStamps);
        }
    }
    setDidOpenTime(uri) {
        const curTimeStamps = this.getTimeStamp(uri.path);
        curTimeStamps.didOpen = new Date().getTime();
        this.cachedTimeStamps.set(uri.path, curTimeStamps);
    }
    setSetupTime(uri) {
        const curTimeStamps = this.getTimeStamp(uri.path);
        curTimeStamps.setup = new Date().getTime();
        this.cachedTimeStamps.set(uri.path, curTimeStamps);
        if (curTimeStamps.didOpen && curTimeStamps.updateRange) {
            this.logTelemetry(uri.path, curTimeStamps);
        }
    }
    setUpdateRangeTime(uri) {
        const curTimeStamps = this.getTimeStamp(uri.path);
        if (!curTimeStamps.updateRange) {
            curTimeStamps.updateRange = new Date().getTime();
            this.cachedTimeStamps.set(uri.path, curTimeStamps);
        }
        if (curTimeStamps.didOpen && curTimeStamps.setup) {
            this.logTelemetry(uri.path, curTimeStamps);
        }
    }
    clear() {
        console.log("clearing timestamp log");
        this.cachedTimeStamps.clear();
    }
    getTimeStamp(uri) {
        return this.cachedTimeStamps.get(uri) ? this.cachedTimeStamps.get(uri) :
            { firstFile: 0, didOpen: 0, setup: 0, updateRange: 0 };
    }
    removeTimeStamp(uri) {
        this.cachedTimeStamps.delete(uri);
    }
    logTelemetry(uri, timeStamps) {
        const startTime = timeStamps.firstFile ? timeStamps.firstFile : timeStamps.didOpen;
        let properties = {};
        let metrics = {
            "setupTime": (timeStamps.setup - timeStamps.didOpen),
            "updateRangeTime": (timeStamps.updateRange - timeStamps.setup),
            "totalTime": (timeStamps.updateRange - startTime)
        };
        if (timeStamps.firstFile) {
            properties = { "coldstart": "true" };
            metrics = Object.assign({ "activationTime": (timeStamps.didOpen - startTime) }, metrics);
        }
        telemetry.logLanguageServerEvent("timeStamps", properties, metrics);
        this.removeTimeStamp(uri);
    }
}
exports.TimeTelemetryCollector = TimeTelemetryCollector;


/***/ }),

/***/ 6713:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUI = exports.UI = void 0;
const vscode = __webpack_require__(7549);
const references_1 = __webpack_require__(2664);
const customProviders_1 = __webpack_require__(4977);
const nls = __webpack_require__(3463);
const timers_1 = __webpack_require__(8213);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\ui.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\LanguageServer\\ui.ts'));
let ui;
var ConfigurationPriority;
(function (ConfigurationPriority) {
    ConfigurationPriority[ConfigurationPriority["IncludePath"] = 1] = "IncludePath";
    ConfigurationPriority[ConfigurationPriority["CompileCommands"] = 2] = "CompileCommands";
    ConfigurationPriority[ConfigurationPriority["CustomProvider"] = 3] = "CustomProvider";
})(ConfigurationPriority || (ConfigurationPriority = {}));
class UI {
    constructor() {
        this.isParsingWorkspace = false;
        this.isParsingWorkspacePaused = false;
        this.isParsingFiles = false;
        this.isUpdatingIntelliSense = false;
        this.isRunningCodeAnalysis = false;
        this.isCodeAnalysisPaused = false;
        this.codeAnalysisProcessed = 0;
        this.codeAnalysisTotal = 0;
        this.workspaceParsingStatus = "";
        this.codeAnalysisProgram = "";
        this.parsingFilesTooltip = localize(0, null);
        this.referencesPreviewTooltip = ` (${localize(1, null)})`;
        this.updatingIntelliSenseTooltip = localize(2, null);
        this.codeAnalysisTranslationHint = "{0} is a program name, such as clang-tidy";
        this.runningCodeAnalysisTooltip = "";
        this.codeAnalysisPausedTooltip = "";
        this.iconDelayTime = 1000;
        this.selectACommandString = localize(3, null);
        const configTooltip = localize(4, null);
        this.configStatusBarItem = vscode.window.createStatusBarItem("c.cpp.configuration.tooltip", vscode.StatusBarAlignment.Right, 0);
        this.configStatusBarItem.name = configTooltip;
        this.configStatusBarItem.command = "C_Cpp.ConfigurationSelect";
        this.configStatusBarItem.tooltip = configTooltip;
        this.ShowConfiguration = true;
        this.referencesStatusBarItem = vscode.window.createStatusBarItem("c.cpp.references.statusbar", vscode.StatusBarAlignment.Right, 901);
        this.referencesStatusBarItem.name = localize(5, null);
        this.referencesStatusBarItem.tooltip = "";
        this.referencesStatusBarItem.command = "C_Cpp.ShowReferencesProgress";
        this.ShowReferencesIcon = false;
        this.intelliSenseStatusBarItem = vscode.window.createStatusBarItem("c.cpp.intellisense.statusbar", vscode.StatusBarAlignment.Right, 903);
        this.intelliSenseStatusBarItem.name = localize(6, null);
        this.intelliSenseStatusBarItem.tooltip = this.updatingIntelliSenseTooltip;
        this.ShowFlameIcon = false;
        this.browseEngineStatusBarItem = vscode.window.createStatusBarItem("c.cpp.tagparser.statusbar", vscode.StatusBarAlignment.Right, 902);
        this.browseEngineStatusBarItem.name = localize(7, null);
        this.browseEngineStatusBarItem.tooltip = localize(8, null);
        this.ShowDBIcon = false;
        this.codeAnalysisProgram = "clang-tidy";
        this.runningCodeAnalysisTooltip = localize(9, null, this.codeAnalysisProgram);
        this.codeAnalysisPausedTooltip = localize(10, null, this.codeAnalysisProgram);
    }
    set ActiveConfig(label) {
        this.configStatusBarItem.text = label;
    }
    set TagParseStatus(label) {
        this.workspaceParsingStatus = label;
        this.browseEngineStatusBarItem.tooltip = (this.isParsingFiles ? `${this.parsingFilesTooltip} | ` : "") + label;
    }
    setIsParsingWorkspace(val) {
        this.isParsingWorkspace = val;
        const showIcon = val || this.isParsingFiles;
        const twoStatus = val && this.isParsingFiles;
        this.ShowDBIcon = showIcon;
        this.browseEngineStatusBarItem.text = showIcon ? "$(database)" : "";
        this.browseEngineStatusBarItem.tooltip = (this.isParsingFiles ? this.parsingFilesTooltip : "")
            + (twoStatus ? " | " : "")
            + (val ? this.workspaceParsingStatus : "");
    }
    setIsParsingWorkspacePausable(val) {
        if (val) {
            this.browseEngineStatusBarItem.command = "C_Cpp.ShowParsingCommands";
        }
        else {
            this.browseEngineStatusBarItem.command = undefined;
        }
    }
    setIsParsingWorkspacePaused(val) {
        this.isParsingWorkspacePaused = val;
    }
    setIsCodeAnalysisPaused(val) {
        this.isCodeAnalysisPaused = val;
        const twoStatus = val && this.isUpdatingIntelliSense;
        this.intelliSenseStatusBarItem.tooltip = (this.isUpdatingIntelliSense ? this.updatingIntelliSenseTooltip : "")
            + (twoStatus ? " | " : "")
            + (val ? this.codeAnalysisPausedTooltip : this.runningCodeAnalysisTooltip);
    }
    setIsParsingFiles(val) {
        this.isParsingFiles = val;
        const showIcon = val || this.isParsingWorkspace;
        const twoStatus = val && this.isParsingWorkspace;
        this.ShowDBIcon = showIcon;
        this.browseEngineStatusBarItem.text = showIcon ? "$(database)" : "";
        this.browseEngineStatusBarItem.tooltip = (val ? this.parsingFilesTooltip : "")
            + (twoStatus ? " | " : "")
            + (this.isParsingWorkspace ? this.workspaceParsingStatus : "");
    }
    setIsUpdatingIntelliSense(val) {
        this.isUpdatingIntelliSense = val;
        const showIcon = val || this.isRunningCodeAnalysis;
        const twoStatus = val && this.isRunningCodeAnalysis;
        this.ShowFlameIcon = showIcon;
        this.intelliSenseStatusBarItem.text = showIcon ? "$(flame)" : "";
        this.intelliSenseStatusBarItem.tooltip = (val ? this.updatingIntelliSenseTooltip : "")
            + (twoStatus ? " | " : "")
            + (this.isRunningCodeAnalysis ? this.runningCodeAnalysisTooltip : "");
    }
    setIsRunningCodeAnalysis(val) {
        if (this.isRunningCodeAnalysis && !val) {
            this.codeAnalysisTotal = 0;
            this.codeAnalysisProcessed = 0;
        }
        this.isRunningCodeAnalysis = val;
        const showIcon = val || this.isUpdatingIntelliSense;
        const twoStatus = val && this.isUpdatingIntelliSense;
        this.ShowFlameIcon = showIcon;
        this.intelliSenseStatusBarItem.text = showIcon ? "$(flame)" : "";
        this.intelliSenseStatusBarItem.tooltip = (this.isUpdatingIntelliSense ? this.updatingIntelliSenseTooltip : "")
            + (twoStatus ? " | " : "")
            + (val ? this.runningCodeAnalysisTooltip : "");
        this.intelliSenseStatusBarItem.command = val ? "C_Cpp.ShowCodeAnalysisCommands" : undefined;
    }
    updateCodeAnalysisTooltip() {
        this.runningCodeAnalysisTooltip = localize(11, null, this.codeAnalysisProgram, this.codeAnalysisProcessed, Math.max(this.codeAnalysisTotal, 1), Math.floor(100 * this.codeAnalysisProcessed / Math.max(this.codeAnalysisTotal, 1)));
        this.setIsRunningCodeAnalysis(true);
    }
    setCodeAnalysisProcessed(processed) {
        this.codeAnalysisProcessed = processed;
        if (this.codeAnalysisProcessed > this.codeAnalysisTotal) {
            this.codeAnalysisTotal = this.codeAnalysisProcessed + 1;
        }
        this.updateCodeAnalysisTooltip();
    }
    setCodeAnalysisTotal(total) {
        this.codeAnalysisTotal = total;
        this.updateCodeAnalysisTooltip();
    }
    get ReferencesCommand() {
        return this.referencesStatusBarItem.tooltip === "" ? references_1.ReferencesCommandMode.None :
            (this.referencesStatusBarItem.tooltip === (0, references_1.referencesCommandModeToString)(references_1.ReferencesCommandMode.Find) ? references_1.ReferencesCommandMode.Find :
                (this.referencesStatusBarItem.tooltip === (0, references_1.referencesCommandModeToString)(references_1.ReferencesCommandMode.Rename) ? references_1.ReferencesCommandMode.Rename :
                    references_1.ReferencesCommandMode.Peek));
    }
    set ReferencesCommand(val) {
        if (val === references_1.ReferencesCommandMode.None) {
            this.referencesStatusBarItem.text = "";
            this.ShowReferencesIcon = false;
        }
        else {
            this.referencesStatusBarItem.text = "$(search)";
            this.referencesStatusBarItem.tooltip = (0, references_1.referencesCommandModeToString)(val) + (val !== references_1.ReferencesCommandMode.Find ? "" : this.referencesPreviewTooltip);
            this.ShowReferencesIcon = true;
        }
    }
    set ShowDBIcon(show) {
        if (this.dbTimeout) {
            clearTimeout(this.dbTimeout);
        }
        if (show && (this.isParsingWorkspace || this.isParsingFiles)) {
            this.dbTimeout = (0, timers_1.setTimeout)(() => { this.browseEngineStatusBarItem.show(); }, this.iconDelayTime);
        }
        else {
            this.dbTimeout = (0, timers_1.setTimeout)(() => { this.browseEngineStatusBarItem.hide(); }, this.iconDelayTime);
        }
    }
    set ShowFlameIcon(show) {
        if (this.flameTimeout) {
            clearTimeout(this.flameTimeout);
        }
        if (show && (this.isUpdatingIntelliSense || this.isRunningCodeAnalysis)) {
            this.flameTimeout = (0, timers_1.setTimeout)(() => { this.intelliSenseStatusBarItem.show(); }, this.iconDelayTime);
        }
        else {
            this.flameTimeout = (0, timers_1.setTimeout)(() => { this.intelliSenseStatusBarItem.hide(); }, this.iconDelayTime);
        }
    }
    set ShowReferencesIcon(show) {
        if (show && this.ReferencesCommand !== references_1.ReferencesCommandMode.None) {
            this.referencesStatusBarItem.show();
        }
        else {
            this.referencesStatusBarItem.hide();
        }
    }
    set ShowConfiguration(show) {
        if (show) {
            this.configStatusBarItem.show();
        }
        else {
            this.configStatusBarItem.hide();
        }
    }
    activeDocumentChanged() {
        const activeEditor = vscode.window.activeTextEditor;
        if (!activeEditor) {
            this.ShowConfiguration = false;
        }
        else {
            const isCpp = (activeEditor.document.uri.scheme === "file" && (activeEditor.document.languageId === "c" || activeEditor.document.languageId === "cpp" || activeEditor.document.languageId === "cuda-cpp"));
            let isCppPropertiesJson = false;
            if (activeEditor.document.languageId === "json" || activeEditor.document.languageId === "jsonc") {
                isCppPropertiesJson = activeEditor.document.fileName.endsWith("c_cpp_properties.json");
                if (isCppPropertiesJson) {
                    vscode.languages.setTextDocumentLanguage(activeEditor.document, "jsonc");
                }
            }
            this.ShowConfiguration = isCpp || isCppPropertiesJson ||
                activeEditor.document.uri.scheme === "output" ||
                activeEditor.document.fileName.endsWith("settings.json") ||
                activeEditor.document.fileName.endsWith("tasks.json") ||
                activeEditor.document.fileName.endsWith("launch.json") ||
                activeEditor.document.fileName.endsWith(".code-workspace");
        }
    }
    bind(client) {
        client.ParsingWorkspaceChanged(value => { this.setIsParsingWorkspace(value); });
        client.ParsingWorkspacePausableChanged(value => { this.setIsParsingWorkspacePausable(value); });
        client.ParsingWorkspacePausedChanged(value => { this.setIsParsingWorkspacePaused(value); });
        client.ParsingFilesChanged(value => { this.setIsParsingFiles(value); });
        client.IntelliSenseParsingChanged(value => { this.setIsUpdatingIntelliSense(value); });
        client.RunningCodeAnalysisChanged(value => { this.setIsRunningCodeAnalysis(value); });
        client.CodeAnalysisPausedChanged(value => { this.setIsCodeAnalysisPaused(value); });
        client.CodeAnalysisProcessedChanged(value => { this.setCodeAnalysisProcessed(value); });
        client.CodeAnalysisTotalChanged(value => { this.setCodeAnalysisTotal(value); });
        client.ReferencesCommandModeChanged(value => { this.ReferencesCommand = value; });
        client.TagParserStatusChanged(value => { this.TagParseStatus = value; });
        client.ActiveConfigChanged(value => { this.ActiveConfig = value; });
    }
    showConfigurations(configurationNames) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = {};
            options.placeHolder = localize(12, null);
            const items = [];
            for (let i = 0; i < configurationNames.length; i++) {
                items.push({ label: configurationNames[i], description: "", index: i });
            }
            items.push({ label: localize(13, null), description: "", index: configurationNames.length });
            items.push({ label: localize(14, null), description: "", index: configurationNames.length + 1 });
            const selection = yield vscode.window.showQuickPick(items, options);
            return (selection) ? selection.index : -1;
        });
    }
    showConfigurationProviders(currentProvider) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = {};
            options.placeHolder = localize(15, null);
            const providers = (0, customProviders_1.getCustomConfigProviders)();
            const items = [];
            providers.forEach(provider => {
                let label = provider.name;
                if ((0, customProviders_1.isSameProviderExtensionId)(currentProvider, provider.extensionId)) {
                    label += ` (${localize(16, null)})`;
                }
                items.push({ label: label, description: "", key: provider.extensionId });
            });
            items.push({ label: `(${localize(17, null)})`, description: localize(18, null), key: "" });
            const selection = yield vscode.window.showQuickPick(items, options);
            return (selection) ? selection.key : undefined;
        });
    }
    showCompileCommands(paths) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = {};
            options.placeHolder = localize(19, null);
            const items = [];
            for (let i = 0; i < paths.length; i++) {
                items.push({ label: paths[i], description: "", index: i });
            }
            const selection = yield vscode.window.showQuickPick(items, options);
            return (selection) ? selection.index : -1;
        });
    }
    showWorkspaces(workspaceNames) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = {};
            options.placeHolder = localize(20, null);
            const items = [];
            workspaceNames.forEach(name => items.push({ label: name.name, description: "", key: name.key }));
            const selection = yield vscode.window.showQuickPick(items, options);
            return (selection) ? selection.key : "";
        });
    }
    showParsingCommands() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = {};
            options.placeHolder = this.selectACommandString;
            const items = [];
            if (this.isParsingWorkspacePaused) {
                items.push({ label: localize(21, null), description: "", index: 1 });
            }
            else {
                items.push({ label: localize(22, null), description: "", index: 0 });
            }
            const selection = yield vscode.window.showQuickPick(items, options);
            return (selection) ? selection.index : -1;
        });
    }
    showCodeAnalysisCommands() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = {};
            options.placeHolder = this.selectACommandString;
            const items = [];
            items.push({ label: localize(23, null, this.codeAnalysisProgram), description: "", index: 0 });
            if (this.isCodeAnalysisPaused) {
                items.push({ label: localize(24, null, this.codeAnalysisProgram), description: "", index: 2 });
            }
            else {
                items.push({ label: localize(25, null, this.codeAnalysisProgram), description: "", index: 1 });
            }
            const selection = yield vscode.window.showQuickPick(items, options);
            return (selection) ? selection.index : -1;
        });
    }
    showConfigureIncludePathMessage(prompt, onSkip) {
        (0, timers_1.setTimeout)(() => {
            this.showConfigurationPrompt(ConfigurationPriority.IncludePath, prompt, onSkip);
        }, 10000);
    }
    showConfigureCompileCommandsMessage(prompt, onSkip) {
        (0, timers_1.setTimeout)(() => {
            this.showConfigurationPrompt(ConfigurationPriority.CompileCommands, prompt, onSkip);
        }, 5000);
    }
    showConfigureCustomProviderMessage(prompt, onSkip) {
        this.showConfigurationPrompt(ConfigurationPriority.CustomProvider, prompt, onSkip);
    }
    showConfigurationPrompt(priority, prompt, onSkip) {
        const showPrompt = () => __awaiter(this, void 0, void 0, function* () {
            const configured = yield prompt();
            return Promise.resolve({
                priority: priority,
                configured: configured
            });
        });
        if (this.curConfigurationStatus) {
            this.curConfigurationStatus = this.curConfigurationStatus.then(result => {
                if (priority > result.priority) {
                    return showPrompt();
                }
                else if (!result.configured) {
                    return showPrompt();
                }
                onSkip();
                return Promise.resolve({
                    priority: result.priority,
                    configured: true
                });
            });
        }
        else {
            this.curConfigurationStatus = showPrompt();
        }
    }
    dispose() {
        this.configStatusBarItem.dispose();
        this.browseEngineStatusBarItem.dispose();
        this.intelliSenseStatusBarItem.dispose();
        this.referencesStatusBarItem.dispose();
    }
}
exports.UI = UI;
function getUI() {
    if (!ui) {
        ui = new UI();
    }
    return ui;
}
exports.getUI = getUI;


/***/ }),

/***/ 5331:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkDirectoryExists = exports.checkFileExists = exports.getHttpsProxyAgent = exports.getDebugAdaptersPath = exports.getOpenCommand = exports.asFolder = exports.resolveVariables = exports.resolveCachePath = exports.isOptionalArrayOfString = exports.isArrayOfString = exports.isOptionalString = exports.isArray = exports.isObject = exports.isBoolean = exports.isNumber = exports.isString = exports.isUri = exports.getProgressIntelliSenseNoSquiggles = exports.getProgressParseRootSuccess = exports.getProgressExecutableSuccess = exports.getProgressExecutableStarted = exports.getProgressInstallSuccess = exports.setIntelliSenseProgress = exports.setProgress = exports.getIntelliSenseProgress = exports.getProgress = exports.displayExtensionNotReadyPrompt = exports.extensionNotReadyString = exports.isHeader = exports.getVcpkgRoot = exports.getVcpkgPathDescriptorFile = exports.getJsonPath = exports.getPackageJsonPath = exports.getExtensionFilePath = exports.stringifyPackageJson = exports.isEditorFileCpp = exports.fileIsCOrCppSource = exports.getRawJson = exports.getRawPackageJson = exports.packageJson = exports.setCachedClangTidyPath = exports.getCachedClangTidyPath = exports.setCachedClangFormatPath = exports.getCachedClangFormatPath = exports.setExtensionPath = exports.setExtensionContext = exports.extensionContext = exports.extensionPath = exports.envDelimiter = exports.failedToParseJson = void 0;
exports.isVsCodeInsiders = exports.getCppToolsTargetPopulation = exports.findPowerShell = exports.normalizeArg = exports.sequentialResolve = exports.isCodespaces = exports.getUniqueWorkspaceStorageName = exports.getUniqueWorkspaceName = exports.isValidIdentifier = exports.getLocalizedSymbolScope = exports.getLocalizedString = exports.getLocalizedHtmlPath = exports.getLocaleId = exports.BlockingTask = exports.escapeForSquiggles = exports.extractCompilerPathAndArgs = exports.downloadFileToStr = exports.downloadFileToDestination = exports.createTempFileWithPostfix = exports.promptReloadWindow = exports.promptForReloadWindowDueToSettingsChange = exports.renameAsync = exports.unlinkAsync = exports.checkDistro = exports.removePotentialPII = exports.chmodAsync = exports.allowExecution = exports.isExecutable = exports.spawnChildProcess = exports.execChildProcess = exports.logToFile = exports.getReadmeMessage = exports.deleteFile = exports.writeFileText = exports.readFileText = exports.readDir = exports.checkPathExistsSync = exports.checkDirectoryExistsSync = exports.checkFileExistsSync = void 0;
const path = __webpack_require__(5622);
const fs = __webpack_require__(5747);
const os = __webpack_require__(2087);
const child_process = __webpack_require__(3129);
const vscode = __webpack_require__(7549);
const Telemetry = __webpack_require__(1818);
const HttpsProxyAgent = __webpack_require__(6638);
const url = __webpack_require__(8835);
const logger_1 = __webpack_require__(5610);
const assert = __webpack_require__(2357);
const https = __webpack_require__(7211);
const tmp = __webpack_require__(7010);
const nativeStrings_1 = __webpack_require__(5391);
const nls = __webpack_require__(3463);
const jsonc = __webpack_require__(634);
const vscode_tas_client_1 = __webpack_require__(2579);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\common.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\common.ts'));
exports.failedToParseJson = localize(0, null);
exports.envDelimiter = (process.platform === 'win32') ? ";" : ":";
function setExtensionContext(context) {
    exports.extensionContext = context;
    exports.extensionPath = exports.extensionContext.extensionPath;
}
exports.setExtensionContext = setExtensionContext;
function setExtensionPath(path) {
    exports.extensionPath = path;
}
exports.setExtensionPath = setExtensionPath;
let cachedClangFormatPath;
function getCachedClangFormatPath() {
    return cachedClangFormatPath;
}
exports.getCachedClangFormatPath = getCachedClangFormatPath;
function setCachedClangFormatPath(path) {
    cachedClangFormatPath = path;
}
exports.setCachedClangFormatPath = setCachedClangFormatPath;
let cachedClangTidyPath;
function getCachedClangTidyPath() {
    return cachedClangTidyPath;
}
exports.getCachedClangTidyPath = getCachedClangTidyPath;
function setCachedClangTidyPath(path) {
    cachedClangTidyPath = path;
}
exports.setCachedClangTidyPath = setCachedClangTidyPath;
exports.packageJson = (_a = vscode.extensions.getExtension("ms-vscode.cpptools")) === null || _a === void 0 ? void 0 : _a.packageJSON;
let rawPackageJson = null;
function getRawPackageJson() {
    if (rawPackageJson === null || rawPackageJson === undefined) {
        const fileContents = fs.readFileSync(getPackageJsonPath());
        rawPackageJson = JSON.parse(fileContents.toString());
    }
    return rawPackageJson;
}
exports.getRawPackageJson = getRawPackageJson;
function getRawJson(path) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!path) {
            return {};
        }
        const fileExists = yield checkFileExists(path);
        if (!fileExists) {
            return {};
        }
        const fileContents = yield readFileText(path);
        let rawElement = {};
        try {
            rawElement = jsonc.parse(fileContents);
        }
        catch (error) {
            throw new Error(exports.failedToParseJson);
        }
        return rawElement;
    });
}
exports.getRawJson = getRawJson;
function fileIsCOrCppSource(file) {
    if (file === undefined) {
        return false;
    }
    const fileExtLower = path.extname(file).toLowerCase();
    return [".cu", ".c", ".cpp", ".cc", ".cxx", ".c++", ".cp", ".tcc", ".mm", ".ino", ".ipp", ".inl"].some(ext => fileExtLower === ext);
}
exports.fileIsCOrCppSource = fileIsCOrCppSource;
function isEditorFileCpp(file) {
    const editor = vscode.window.visibleTextEditors.find(e => e.document.uri.toString() === file);
    if (!editor) {
        return false;
    }
    return editor.document.languageId === "cpp";
}
exports.isEditorFileCpp = isEditorFileCpp;
function stringifyPackageJson(packageJson) {
    return JSON.stringify(packageJson, null, 2);
}
exports.stringifyPackageJson = stringifyPackageJson;
function getExtensionFilePath(extensionfile) {
    return path.resolve(exports.extensionPath, extensionfile);
}
exports.getExtensionFilePath = getExtensionFilePath;
function getPackageJsonPath() {
    return getExtensionFilePath("package.json");
}
exports.getPackageJsonPath = getPackageJsonPath;
function getJsonPath(jsonFilaName) {
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
        return undefined;
    }
    const folder = vscode.workspace.getWorkspaceFolder(editor.document.uri);
    if (!folder) {
        return undefined;
    }
    return path.join(folder.uri.fsPath, ".vscode", jsonFilaName);
}
exports.getJsonPath = getJsonPath;
function getVcpkgPathDescriptorFile() {
    if (process.platform === 'win32') {
        const pathPrefix = process.env.LOCALAPPDATA;
        if (!pathPrefix) {
            throw new Error("Unable to read process.env.LOCALAPPDATA");
        }
        return path.join(pathPrefix, "vcpkg/vcpkg.path.txt");
    }
    else {
        const pathPrefix = os.homedir();
        return path.join(pathPrefix, ".vcpkg/vcpkg.path.txt");
    }
}
exports.getVcpkgPathDescriptorFile = getVcpkgPathDescriptorFile;
let vcpkgRoot;
function getVcpkgRoot() {
    if (!vcpkgRoot && vcpkgRoot !== "") {
        vcpkgRoot = "";
        if (fs.existsSync(getVcpkgPathDescriptorFile())) {
            let vcpkgRootTemp = fs.readFileSync(getVcpkgPathDescriptorFile()).toString();
            vcpkgRootTemp = vcpkgRootTemp.trim();
            if (fs.existsSync(vcpkgRootTemp)) {
                vcpkgRoot = path.join(vcpkgRootTemp, "/installed").replace(/\\/g, "/");
            }
        }
    }
    return vcpkgRoot;
}
exports.getVcpkgRoot = getVcpkgRoot;
function isHeader(uri) {
    const ext = path.extname(uri.fsPath);
    return !ext || ext.startsWith(".h") || ext.startsWith(".H");
}
exports.isHeader = isHeader;
let isExtensionNotReadyPromptDisplayed = false;
exports.extensionNotReadyString = localize(1, null);
function displayExtensionNotReadyPrompt() {
    if (!isExtensionNotReadyPromptDisplayed) {
        isExtensionNotReadyPromptDisplayed = true;
        (0, logger_1.showOutputChannel)();
        (0, logger_1.getOutputChannelLogger)().showInformationMessage(exports.extensionNotReadyString).then(() => { isExtensionNotReadyPromptDisplayed = false; }, () => { isExtensionNotReadyPromptDisplayed = false; });
    }
}
exports.displayExtensionNotReadyPrompt = displayExtensionNotReadyPrompt;
const progressInstallSuccess = 100;
const progressExecutableStarted = 150;
const progressExecutableSuccess = 200;
const progressParseRootSuccess = 300;
const progressIntelliSenseNoSquiggles = 1000;
const installProgressStr = "CPP." + exports.packageJson.version + ".Progress";
const intelliSenseProgressStr = "CPP." + exports.packageJson.version + ".IntelliSenseProgress";
function getProgress() {
    return exports.extensionContext ? exports.extensionContext.globalState.get(installProgressStr, -1) : -1;
}
exports.getProgress = getProgress;
function getIntelliSenseProgress() {
    return exports.extensionContext ? exports.extensionContext.globalState.get(intelliSenseProgressStr, -1) : -1;
}
exports.getIntelliSenseProgress = getIntelliSenseProgress;
function setProgress(progress) {
    if (exports.extensionContext && getProgress() < progress) {
        exports.extensionContext.globalState.update(installProgressStr, progress);
        const telemetryProperties = {};
        let progressName;
        switch (progress) {
            case 0:
                progressName = "install started";
                break;
            case progressInstallSuccess:
                progressName = "install succeeded";
                break;
            case progressExecutableStarted:
                progressName = "executable started";
                break;
            case progressExecutableSuccess:
                progressName = "executable succeeded";
                break;
            case progressParseRootSuccess:
                progressName = "parse root succeeded";
                break;
        }
        if (progressName) {
            telemetryProperties['progress'] = progressName;
        }
        Telemetry.logDebuggerEvent("progress", telemetryProperties);
    }
}
exports.setProgress = setProgress;
function setIntelliSenseProgress(progress) {
    if (exports.extensionContext && getIntelliSenseProgress() < progress) {
        exports.extensionContext.globalState.update(intelliSenseProgressStr, progress);
        const telemetryProperties = {};
        let progressName;
        switch (progress) {
            case progressIntelliSenseNoSquiggles:
                progressName = "IntelliSense no squiggles";
                break;
        }
        if (progressName) {
            telemetryProperties['progress'] = progressName;
        }
        Telemetry.logDebuggerEvent("progress", telemetryProperties);
    }
}
exports.setIntelliSenseProgress = setIntelliSenseProgress;
function getProgressInstallSuccess() { return progressInstallSuccess; }
exports.getProgressInstallSuccess = getProgressInstallSuccess;
function getProgressExecutableStarted() { return progressExecutableStarted; }
exports.getProgressExecutableStarted = getProgressExecutableStarted;
function getProgressExecutableSuccess() { return progressExecutableSuccess; }
exports.getProgressExecutableSuccess = getProgressExecutableSuccess;
function getProgressParseRootSuccess() { return progressParseRootSuccess; }
exports.getProgressParseRootSuccess = getProgressParseRootSuccess;
function getProgressIntelliSenseNoSquiggles() { return progressIntelliSenseNoSquiggles; }
exports.getProgressIntelliSenseNoSquiggles = getProgressIntelliSenseNoSquiggles;
function isUri(input) {
    return input && input instanceof vscode.Uri;
}
exports.isUri = isUri;
function isString(input) {
    return typeof (input) === "string";
}
exports.isString = isString;
function isNumber(input) {
    return typeof (input) === "number";
}
exports.isNumber = isNumber;
function isBoolean(input) {
    return typeof (input) === "boolean";
}
exports.isBoolean = isBoolean;
function isObject(input) {
    return typeof (input) === "object";
}
exports.isObject = isObject;
function isArray(input) {
    return input instanceof Array;
}
exports.isArray = isArray;
function isOptionalString(input) {
    return input === undefined || isString(input);
}
exports.isOptionalString = isOptionalString;
function isArrayOfString(input) {
    return isArray(input) && input.every(isString);
}
exports.isArrayOfString = isArrayOfString;
function isOptionalArrayOfString(input) {
    return input === undefined || isArrayOfString(input);
}
exports.isOptionalArrayOfString = isOptionalArrayOfString;
function resolveCachePath(input, additionalEnvironment) {
    let resolvedPath = "";
    if (!input) {
        return resolvedPath;
    }
    resolvedPath = resolveVariables(input, additionalEnvironment);
    return resolvedPath;
}
exports.resolveCachePath = resolveCachePath;
function resolveVariables(input, additionalEnvironment, arrayResults) {
    if (!input) {
        return "";
    }
    let regexp = () => /\$\{((env|config|workspaceFolder|file|fileDirname|fileBasenameNoExtension|execPath|pathSeparator)(\.|:))?(.*?)\}/g;
    let ret = input;
    const cycleCache = new Set();
    while (!cycleCache.has(ret)) {
        cycleCache.add(ret);
        ret = ret.replace(regexp(), (match, ignored1, varType, ignored2, name) => {
            if (!varType) {
                varType = "env";
            }
            let newValue;
            switch (varType) {
                case "env": {
                    if (additionalEnvironment) {
                        const v = additionalEnvironment[name];
                        if (isString(v)) {
                            newValue = v;
                        }
                        else if (input === match && isArrayOfString(v)) {
                            if (arrayResults !== undefined) {
                                arrayResults.push(...v);
                                newValue = "";
                                break;
                            }
                            else {
                                newValue = v.join(exports.envDelimiter);
                            }
                        }
                    }
                    if (newValue === undefined) {
                        newValue = process.env[name];
                    }
                    break;
                }
                case "config": {
                    const config = vscode.workspace.getConfiguration();
                    if (config) {
                        newValue = config.get(name);
                    }
                    break;
                }
                case "workspaceFolder": {
                    if (name && vscode.workspace && vscode.workspace.workspaceFolders) {
                        const folder = vscode.workspace.workspaceFolders.find(folder => folder.name.toLocaleLowerCase() === name.toLocaleLowerCase());
                        if (folder) {
                            newValue = folder.uri.fsPath;
                        }
                    }
                    break;
                }
                default: {
                    assert.fail("unknown varType matched");
                }
            }
            return newValue !== undefined ? newValue : match;
        });
    }
    regexp = () => /^\~/g;
    ret = ret.replace(regexp(), (match, name) => os.homedir());
    return ret;
}
exports.resolveVariables = resolveVariables;
function asFolder(uri) {
    let result = uri.toString();
    if (result.charAt(result.length - 1) !== '/') {
        result += '/';
    }
    return result;
}
exports.asFolder = asFolder;
function getOpenCommand() {
    if (os.platform() === 'win32') {
        return 'explorer';
    }
    else if (os.platform() === 'darwin') {
        return '/usr/bin/open';
    }
    else {
        return '/usr/bin/xdg-open';
    }
}
exports.getOpenCommand = getOpenCommand;
function getDebugAdaptersPath(file) {
    return path.resolve(getExtensionFilePath("debugAdapters"), file);
}
exports.getDebugAdaptersPath = getDebugAdaptersPath;
function getHttpsProxyAgent() {
    let proxy = vscode.workspace.getConfiguration().get('http.proxy');
    if (!proxy) {
        proxy = process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy;
        if (!proxy) {
            return undefined;
        }
    }
    const proxyUrl = url.parse(proxy);
    if (proxyUrl.protocol !== "https:" && proxyUrl.protocol !== "http:") {
        return undefined;
    }
    const strictProxy = vscode.workspace.getConfiguration().get("http.proxyStrictSSL", true);
    const proxyOptions = {
        host: proxyUrl.hostname,
        port: parseInt(proxyUrl.port, 10),
        auth: proxyUrl.auth,
        rejectUnauthorized: strictProxy
    };
    return new HttpsProxyAgent(proxyOptions);
}
exports.getHttpsProxyAgent = getHttpsProxyAgent;
function checkFileExists(filePath) {
    return new Promise((resolve, reject) => {
        fs.stat(filePath, (err, stats) => {
            if (stats && stats.isFile()) {
                resolve(true);
            }
            else {
                resolve(false);
            }
        });
    });
}
exports.checkFileExists = checkFileExists;
function checkDirectoryExists(dirPath) {
    return new Promise((resolve, reject) => {
        fs.stat(dirPath, (err, stats) => {
            if (stats && stats.isDirectory()) {
                resolve(true);
            }
            else {
                resolve(false);
            }
        });
    });
}
exports.checkDirectoryExists = checkDirectoryExists;
function checkFileExistsSync(filePath) {
    try {
        return fs.statSync(filePath).isFile();
    }
    catch (e) {
    }
    return false;
}
exports.checkFileExistsSync = checkFileExistsSync;
function checkDirectoryExistsSync(dirPath) {
    try {
        return fs.statSync(dirPath).isDirectory();
    }
    catch (e) {
    }
    return false;
}
exports.checkDirectoryExistsSync = checkDirectoryExistsSync;
function checkPathExistsSync(path, relativePath, isWindows, isWSL, isCompilerPath) {
    let pathExists = true;
    const existsWithExeAdded = (path) => isCompilerPath && isWindows && !isWSL && fs.existsSync(path + ".exe");
    if (!fs.existsSync(path)) {
        if (existsWithExeAdded(path)) {
            path += ".exe";
        }
        else if (!relativePath) {
            pathExists = false;
        }
        else {
            relativePath = relativePath + path;
            if (!fs.existsSync(relativePath)) {
                if (existsWithExeAdded(path)) {
                    path += ".exe";
                }
                else {
                    pathExists = false;
                }
            }
            else {
                path = relativePath;
            }
        }
    }
    return { pathExists, path };
}
exports.checkPathExistsSync = checkPathExistsSync;
function readDir(dirPath) {
    return new Promise((resolve) => {
        fs.readdir(dirPath, (err, list) => {
            resolve(list);
        });
    });
}
exports.readDir = readDir;
function readFileText(filePath, encoding = "utf8") {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, encoding, (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        });
    });
}
exports.readFileText = readFileText;
function writeFileText(filePath, content, encoding = "utf8") {
    const folders = filePath.split(path.sep).slice(0, -1);
    if (folders.length) {
        folders.reduce((previous, folder) => {
            const folderPath = previous + path.sep + folder;
            if (!fs.existsSync(folderPath)) {
                fs.mkdirSync(folderPath);
            }
            return folderPath;
        });
    }
    return new Promise((resolve, reject) => {
        fs.writeFile(filePath, content, { encoding }, (err) => {
            if (err) {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}
exports.writeFileText = writeFileText;
function deleteFile(filePath) {
    return new Promise((resolve, reject) => {
        if (fs.existsSync(filePath)) {
            fs.unlink(filePath, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        }
        else {
            resolve();
        }
    });
}
exports.deleteFile = deleteFile;
function getReadmeMessage() {
    const readmePath = getExtensionFilePath("README.md");
    const readmeMessage = localize(2, null, readmePath, "https://github.com/Microsoft/vscode-cpptools/issues");
    return readmeMessage;
}
exports.getReadmeMessage = getReadmeMessage;
function logToFile(message) {
    const logFolder = getExtensionFilePath("extension.log");
    fs.writeFileSync(logFolder, `${message}${os.EOL}`, { flag: 'a' });
}
exports.logToFile = logToFile;
function execChildProcess(process, workingDirectory, channel) {
    return new Promise((resolve, reject) => {
        child_process.exec(process, { cwd: workingDirectory, maxBuffer: 500 * 1024 }, (error, stdout, stderr) => {
            if (channel) {
                let message = "";
                let err = false;
                if (stdout && stdout.length > 0) {
                    message += stdout;
                }
                if (stderr && stderr.length > 0) {
                    message += stderr;
                    err = true;
                }
                if (error) {
                    message += error.message;
                    err = true;
                }
                if (err) {
                    channel.append(message);
                    channel.show();
                }
            }
            if (error) {
                reject(error);
                return;
            }
            if (stderr && stderr.length > 0) {
                reject(new Error(stderr));
                return;
            }
            resolve(stdout);
        });
    });
}
exports.execChildProcess = execChildProcess;
function spawnChildProcess(process, args, workingDirectory, dataCallback, errorCallback) {
    return new Promise(function (resolve, reject) {
        const child = child_process.spawn(process, args, { cwd: workingDirectory });
        const stdout = child.stdout;
        if (stdout) {
            stdout.on('data', (data) => {
                dataCallback(`${data}`);
            });
        }
        const stderr = child.stderr;
        if (stderr) {
            stderr.on('data', (data) => {
                errorCallback(`${data}`);
            });
        }
        child.on('exit', (code) => {
            if (code !== 0) {
                reject(new Error(localize(3, null, process, code)));
            }
            else {
                resolve();
            }
        });
    });
}
exports.spawnChildProcess = spawnChildProcess;
function isExecutable(file) {
    return new Promise((resolve) => {
        fs.access(file, fs.constants.X_OK, (err) => {
            if (err) {
                resolve(false);
            }
            else {
                resolve(true);
            }
        });
    });
}
exports.isExecutable = isExecutable;
function allowExecution(file) {
    return __awaiter(this, void 0, void 0, function* () {
        if (process.platform !== 'win32') {
            const exists = yield checkFileExists(file);
            if (exists) {
                const isExec = yield isExecutable(file);
                if (!isExec) {
                    yield chmodAsync(file, '755');
                }
            }
            else {
                (0, logger_1.getOutputChannelLogger)().appendLine("");
                (0, logger_1.getOutputChannelLogger)().appendLine(localize(4, null, file));
            }
        }
    });
}
exports.allowExecution = allowExecution;
function chmodAsync(path, mode) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            fs.chmod(path, mode, (err) => {
                if (err) {
                    return reject(err);
                }
                return resolve();
            });
        });
    });
}
exports.chmodAsync = chmodAsync;
function removePotentialPII(str) {
    const words = str.split(" ");
    let result = "";
    for (const word of words) {
        if (word.indexOf(".") === -1 && word.indexOf("/") === -1 && word.indexOf("\\") === -1 && word.indexOf(":") === -1) {
            result += word + " ";
        }
        else {
            result += "? ";
        }
    }
    return result;
}
exports.removePotentialPII = removePotentialPII;
function checkDistro(platformInfo) {
    if (platformInfo.platform !== 'win32' && platformInfo.platform !== 'linux' && platformInfo.platform !== 'darwin') {
        (0, logger_1.getOutputChannelLogger)().appendLine(localize(5, null) + " " + getReadmeMessage());
    }
}
exports.checkDistro = checkDistro;
function unlinkAsync(fileName) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            fs.unlink(fileName, err => {
                if (err) {
                    return reject(err);
                }
                return resolve();
            });
        });
    });
}
exports.unlinkAsync = unlinkAsync;
function renameAsync(oldName, newName) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            fs.rename(oldName, newName, err => {
                if (err) {
                    return reject(err);
                }
                return resolve();
            });
        });
    });
}
exports.renameAsync = renameAsync;
function promptForReloadWindowDueToSettingsChange() {
    promptReloadWindow(localize(6, null));
}
exports.promptForReloadWindowDueToSettingsChange = promptForReloadWindowDueToSettingsChange;
function promptReloadWindow(message) {
    const reload = localize(7, null);
    vscode.window.showInformationMessage(message, reload).then((value) => {
        if (value === reload) {
            vscode.commands.executeCommand("workbench.action.reloadWindow");
        }
    });
}
exports.promptReloadWindow = promptReloadWindow;
function createTempFileWithPostfix(postfix) {
    return new Promise((resolve, reject) => {
        tmp.file({ postfix: postfix }, (err, path, fd, cleanupCallback) => {
            if (err) {
                return reject(err);
            }
            return resolve({ name: path, fd: fd, removeCallback: cleanupCallback });
        });
    });
}
exports.createTempFileWithPostfix = createTempFileWithPostfix;
function downloadFileToDestination(urlStr, destinationPath, headers) {
    return new Promise((resolve, reject) => {
        const parsedUrl = url.parse(urlStr);
        const request = https.request({
            host: parsedUrl.host,
            path: parsedUrl.path,
            agent: getHttpsProxyAgent(),
            rejectUnauthorized: vscode.workspace.getConfiguration().get('http.proxyStrictSSL', true),
            headers: headers
        }, (response) => {
            if (response.statusCode === 301 || response.statusCode === 302) {
                let redirectUrl;
                if (typeof response.headers.location === 'string') {
                    redirectUrl = response.headers.location;
                }
                else {
                    if (!response.headers.location) {
                        return reject(new Error(localize(8, null)));
                    }
                    redirectUrl = response.headers.location[0];
                }
                return resolve(downloadFileToDestination(redirectUrl, destinationPath, headers));
            }
            if (response.statusCode !== 200) {
                return reject();
            }
            const createdFile = fs.createWriteStream(destinationPath);
            createdFile.on('finish', () => { resolve(); });
            response.on('error', (error) => { reject(error); });
            response.pipe(createdFile);
        });
        request.on('error', (error) => { reject(error); });
        request.end();
    });
}
exports.downloadFileToDestination = downloadFileToDestination;
function downloadFileToStr(urlStr, headers) {
    return new Promise((resolve, reject) => {
        const parsedUrl = url.parse(urlStr);
        const request = https.request({
            host: parsedUrl.host,
            path: parsedUrl.path,
            agent: getHttpsProxyAgent(),
            rejectUnauthorized: vscode.workspace.getConfiguration().get('http.proxyStrictSSL', true),
            headers: headers
        }, (response) => {
            if (response.statusCode === 301 || response.statusCode === 302) {
                let redirectUrl;
                if (typeof response.headers.location === 'string') {
                    redirectUrl = response.headers.location;
                }
                else {
                    if (!response.headers.location) {
                        return reject(new Error(localize(9, null)));
                    }
                    redirectUrl = response.headers.location[0];
                }
                return resolve(downloadFileToStr(redirectUrl, headers));
            }
            if (response.statusCode !== 200) {
                return reject();
            }
            let downloadedData = '';
            response.on('data', (data) => { downloadedData += data; });
            response.on('error', (error) => { reject(error); });
            response.on('end', () => { resolve(downloadedData); });
        });
        request.on('error', (error) => { reject(error); });
        request.end();
    });
}
exports.downloadFileToStr = downloadFileToStr;
function extractArgs(argsString) {
    const isWindows = os.platform() === 'win32';
    const result = [];
    let currentArg = "";
    let isWithinDoubleQuote = false;
    let isWithinSingleQuote = false;
    for (let i = 0; i < argsString.length; i++) {
        const c = argsString[i];
        if (c === '\\') {
            currentArg += c;
            if (++i === argsString.length) {
                if (currentArg !== "") {
                    result.push(currentArg);
                }
                return result;
            }
            currentArg += argsString[i];
            continue;
        }
        if (c === '"') {
            if (!isWithinSingleQuote) {
                isWithinDoubleQuote = !isWithinDoubleQuote;
            }
        }
        else if (c === '\'') {
            if (!isWindows) {
                if (!isWithinDoubleQuote) {
                    isWithinSingleQuote = !isWithinSingleQuote;
                }
            }
        }
        else if (c === ' ') {
            if (!isWithinDoubleQuote && !isWithinSingleQuote) {
                if (currentArg !== "") {
                    result.push(currentArg);
                    currentArg = "";
                }
                continue;
            }
        }
        currentArg += c;
    }
    if (currentArg !== "") {
        result.push(currentArg);
    }
    return result;
}
function extractCompilerPathAndArgs(inputCompilerPath, inputCompilerArgs) {
    let compilerPath = inputCompilerPath;
    const compilerPathLowercase = inputCompilerPath === null || inputCompilerPath === void 0 ? void 0 : inputCompilerPath.toLowerCase();
    let compilerName = "";
    let additionalArgs = [];
    if (compilerPath) {
        if ((compilerPathLowercase === null || compilerPathLowercase === void 0 ? void 0 : compilerPathLowercase.endsWith("\\cl.exe")) || (compilerPathLowercase === null || compilerPathLowercase === void 0 ? void 0 : compilerPathLowercase.endsWith("/cl.exe")) || (compilerPathLowercase === "cl.exe")
            || (compilerPathLowercase === null || compilerPathLowercase === void 0 ? void 0 : compilerPathLowercase.endsWith("\\cl")) || (compilerPathLowercase === null || compilerPathLowercase === void 0 ? void 0 : compilerPathLowercase.endsWith("/cl")) || (compilerPathLowercase === "cl")) {
            compilerName = path.basename(compilerPath);
        }
        else if (compilerPath.startsWith("\"")) {
            const endQuote = compilerPath.substr(1).search("\"") + 1;
            if (endQuote !== -1) {
                additionalArgs = extractArgs(compilerPath.substr(endQuote + 1));
                compilerPath = compilerPath.substr(1, endQuote - 1);
                compilerName = path.basename(compilerPath);
            }
        }
        else {
            let spaceStart = compilerPath.lastIndexOf(" ");
            if (checkFileExistsSync(compilerPath)) {
                compilerName = path.basename(compilerPath);
            }
            else if (spaceStart !== -1 && !checkFileExistsSync(compilerPath)) {
                let potentialCompilerPath = compilerPath.substr(0, spaceStart);
                while (!checkFileExistsSync(potentialCompilerPath)) {
                    spaceStart = potentialCompilerPath.lastIndexOf(" ");
                    if (spaceStart === -1) {
                        potentialCompilerPath = compilerPath;
                        break;
                    }
                    potentialCompilerPath = potentialCompilerPath.substr(0, spaceStart);
                }
                if (compilerPath !== potentialCompilerPath) {
                    additionalArgs = extractArgs(compilerPath.substr(spaceStart + 1));
                    compilerPath = potentialCompilerPath;
                    compilerName = path.basename(potentialCompilerPath);
                }
            }
        }
    }
    if (inputCompilerArgs && inputCompilerArgs.length) {
        additionalArgs = inputCompilerArgs.concat(additionalArgs.filter(function (item) {
            return inputCompilerArgs.indexOf(item) < 0;
        }));
    }
    return { compilerPath, compilerName, additionalArgs };
}
exports.extractCompilerPathAndArgs = extractCompilerPathAndArgs;
function escapeForSquiggles(s) {
    let newResults = "";
    let lastWasBackslash = false;
    let lastBackslashWasEscaped = false;
    for (let i = 0; i < s.length; i++) {
        if (s[i] === '\\') {
            if (lastWasBackslash) {
                newResults += "\\";
                lastBackslashWasEscaped = !lastBackslashWasEscaped;
            }
            else {
                lastBackslashWasEscaped = false;
            }
            newResults += "\\";
            lastWasBackslash = true;
        }
        else {
            if (lastWasBackslash && (lastBackslashWasEscaped || (s[i] !== '"'))) {
                newResults += "\\";
            }
            lastWasBackslash = false;
            lastBackslashWasEscaped = false;
            newResults += s[i];
        }
    }
    if (lastWasBackslash) {
        newResults += "\\";
    }
    return newResults;
}
exports.escapeForSquiggles = escapeForSquiggles;
class BlockingTask {
    constructor(task, dependency) {
        this.done = false;
        if (!dependency) {
            this.promise = task();
        }
        else {
            this.promise = new Promise((resolve, reject) => {
                const f1 = () => {
                    task().then(resolve, reject);
                };
                const f2 = (err) => {
                    console.log(err);
                    task().then(resolve, reject);
                };
                dependency.promise.then(f1, f2);
            });
        }
        this.promise.then(() => this.done = true, () => this.done = true);
    }
    get Done() {
        return this.done;
    }
    getPromise() {
        return this.promise;
    }
}
exports.BlockingTask = BlockingTask;
function getLocaleId() {
    if (isString(process.env.VSCODE_NLS_CONFIG)) {
        const vscodeOptions = JSON.parse(process.env.VSCODE_NLS_CONFIG);
        if (vscodeOptions.availableLanguages) {
            const value = vscodeOptions.availableLanguages['*'];
            if (isString(value)) {
                return value;
            }
        }
        if (isString(vscodeOptions.locale)) {
            return vscodeOptions.locale.toLowerCase();
        }
    }
    return "en";
}
exports.getLocaleId = getLocaleId;
function getLocalizedHtmlPath(originalPath) {
    const locale = getLocaleId();
    const localizedFilePath = getExtensionFilePath(path.join("dist/html/", locale, originalPath));
    if (!fs.existsSync(localizedFilePath)) {
        return getExtensionFilePath(originalPath);
    }
    return localizedFilePath;
}
exports.getLocalizedHtmlPath = getLocalizedHtmlPath;
function getLocalizedString(params) {
    let indent = "";
    if (params.indentSpaces) {
        indent = " ".repeat(params.indentSpaces);
    }
    let text = params.text;
    if (params.stringId !== 0) {
        text = (0, nativeStrings_1.lookupString)(params.stringId, params.stringArgs);
    }
    return indent + text;
}
exports.getLocalizedString = getLocalizedString;
function getLocalizedSymbolScope(scope, detail) {
    return localize(10, null, scope, detail);
}
exports.getLocalizedSymbolScope = getLocalizedSymbolScope;
function decodeUCS16(input) {
    const output = [];
    let counter = 0;
    const length = input.length;
    let value;
    let extra;
    while (counter < length) {
        value = input.charCodeAt(counter++);
        if ((value & 0xF800) === 0xD800 && counter < length) {
            extra = input.charCodeAt(counter++);
            if ((extra & 0xFC00) === 0xDC00) {
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            }
            else {
                output.push(value, extra);
            }
        }
        else {
            output.push(value);
        }
    }
    return output;
}
const allowedIdentifierUnicodeRanges = [
    [0x0030, 0x0039],
    [0x0041, 0x005A],
    [0x005F, 0x005F],
    [0x0061, 0x007A],
    [0x00A8, 0x00A8],
    [0x00AA, 0x00AA],
    [0x00AD, 0x00AD],
    [0x00AF, 0x00AF],
    [0x00B2, 0x00B5],
    [0x00B7, 0x00BA],
    [0x00BC, 0x00BE],
    [0x00C0, 0x00D6],
    [0x00D8, 0x00F6],
    [0x00F8, 0x167F],
    [0x1681, 0x180D],
    [0x180F, 0x1FFF],
    [0x200B, 0x200D],
    [0x202A, 0x202E],
    [0x203F, 0x2040],
    [0x2054, 0x2054],
    [0x2060, 0x218F],
    [0x2460, 0x24FF],
    [0x2776, 0x2793],
    [0x2C00, 0x2DFF],
    [0x2E80, 0x2FFF],
    [0x3004, 0x3007],
    [0x3021, 0x302F],
    [0x3031, 0xD7FF],
    [0xF900, 0xFD3D],
    [0xFD40, 0xFDCF],
    [0xFDF0, 0xFE44],
    [0xFE47, 0xFFFD],
    [0x10000, 0x1FFFD],
    [0x20000, 0x2FFFD],
    [0x30000, 0x3FFFD],
    [0x40000, 0x4FFFD],
    [0x50000, 0x5FFFD],
    [0x60000, 0x6FFFD],
    [0x70000, 0x7FFFD],
    [0x80000, 0x8FFFD],
    [0x90000, 0x9FFFD],
    [0xA0000, 0xAFFFD],
    [0xB0000, 0xBFFFD],
    [0xC0000, 0xCFFFD],
    [0xD0000, 0xDFFFD],
    [0xE0000, 0xEFFFD]
];
const disallowedFirstCharacterIdentifierUnicodeRanges = [
    [0x0030, 0x0039],
    [0x0300, 0x036F],
    [0x1DC0, 0x1DFF],
    [0x20D0, 0x20FF],
    [0xFE20, 0xFE2F]
];
function isValidIdentifier(candidate) {
    if (!candidate) {
        return false;
    }
    const decoded = decodeUCS16(candidate);
    if (!decoded || !decoded.length) {
        return false;
    }
    for (let i = 0; i < disallowedFirstCharacterIdentifierUnicodeRanges.length; i++) {
        const disallowedCharacters = disallowedFirstCharacterIdentifierUnicodeRanges[i];
        if (decoded[0] >= disallowedCharacters[0] && decoded[0] <= disallowedCharacters[1]) {
            return false;
        }
    }
    for (let position = 0; position < decoded.length; position++) {
        let found = false;
        for (let i = 0; i < allowedIdentifierUnicodeRanges.length; i++) {
            const allowedCharacters = allowedIdentifierUnicodeRanges[i];
            if (decoded[position] >= allowedCharacters[0] && decoded[position] <= allowedCharacters[1]) {
                found = true;
                break;
            }
        }
        if (!found) {
            return false;
        }
    }
    return true;
}
exports.isValidIdentifier = isValidIdentifier;
function getUniqueWorkspaceNameHelper(workspaceFolder, addSubfolder) {
    const workspaceFolderName = workspaceFolder ? workspaceFolder.name : "untitled";
    if (!workspaceFolder || workspaceFolder.index < 1) {
        return workspaceFolderName;
    }
    for (let i = 0; i < workspaceFolder.index; ++i) {
        if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0 && vscode.workspace.workspaceFolders[i].name === workspaceFolderName) {
            return addSubfolder ? path.join(workspaceFolderName, String(workspaceFolder.index)) :
                workspaceFolderName + String(workspaceFolder.index);
        }
    }
    return workspaceFolderName;
}
function getUniqueWorkspaceName(workspaceFolder) {
    return getUniqueWorkspaceNameHelper(workspaceFolder, false);
}
exports.getUniqueWorkspaceName = getUniqueWorkspaceName;
function getUniqueWorkspaceStorageName(workspaceFolder) {
    return getUniqueWorkspaceNameHelper(workspaceFolder, true);
}
exports.getUniqueWorkspaceStorageName = getUniqueWorkspaceStorageName;
function isCodespaces() {
    return !!process.env["CODESPACES"];
}
exports.isCodespaces = isCodespaces;
function sequentialResolve(items, promiseBuilder) {
    return items.reduce((previousPromise, nextItem) => __awaiter(this, void 0, void 0, function* () {
        yield previousPromise;
        return promiseBuilder(nextItem);
    }), Promise.resolve());
}
exports.sequentialResolve = sequentialResolve;
function normalizeArg(arg) {
    arg = arg.trimLeft().trimRight();
    if (/^`.*`$/g.test(arg) || /.*[^\\]".*/g.test(arg) ||
        (process.platform.includes("win") && /.*[^\\]'.*/g.test(arg)) ||
        (!process.platform.includes("win") && /.*[^\\]'.*/g.test(arg))) {
        return arg;
    }
    const unescapedSpaces = arg.split('').find((char, index) => index > 0 && char === " " && arg[index - 1] !== "\\");
    if (!unescapedSpaces && !process.platform.includes("win")) {
        return arg;
    }
    else if (arg.includes(" ")) {
        arg = arg.replace(/\\\s/g, " ");
        return "\"" + arg + "\"";
    }
    else {
        return arg;
    }
}
exports.normalizeArg = normalizeArg;
function findPowerShell() {
    const dirs = (process.env.PATH || '').replace(/"+/g, '').split(';').filter(x => x);
    const exts = (process.env.PATHEXT || '').split(';');
    const names = ['pwsh', 'powershell'];
    for (const name of names) {
        const candidates = dirs.reduce((paths, dir) => [
            ...paths, ...exts.map(ext => path.join(dir, name + ext))
        ], []);
        for (const candidate of candidates) {
            try {
                if (fs.statSync(candidate).isFile()) {
                    return name;
                }
            }
            catch (e) {
            }
        }
    }
}
exports.findPowerShell = findPowerShell;
function getCppToolsTargetPopulation() {
    if (checkFileExistsSync(getExtensionFilePath("insiders.flag"))) {
        return vscode_tas_client_1.TargetPopulation.Insiders;
    }
    else if (checkFileExistsSync(getExtensionFilePath("release.flag"))) {
        return vscode_tas_client_1.TargetPopulation.Public;
    }
    return vscode_tas_client_1.TargetPopulation.Internal;
}
exports.getCppToolsTargetPopulation = getCppToolsTargetPopulation;
function isVsCodeInsiders() {
    return exports.extensionPath.includes(".vscode-insiders") ||
        exports.extensionPath.includes(".vscode-server-insiders") ||
        exports.extensionPath.includes(".vscode-exploration") ||
        exports.extensionPath.includes(".vscode-server-exploration");
}
exports.isVsCodeInsiders = isVsCodeInsiders;


/***/ }),

/***/ 2451:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CppTools = void 0;
const vscode_cpptools_1 = __webpack_require__(3286);
const customProviders_1 = __webpack_require__(4977);
const logger_1 = __webpack_require__(5610);
const LanguageServer = __webpack_require__(2973);
const test = __webpack_require__(5648);
const nls = __webpack_require__(3463);
const settings_1 = __webpack_require__(296);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\cppTools.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\cppTools.ts'));
class CppTools {
    constructor(version) {
        this.providers = [];
        this.failedRegistrations = [];
        this.timers = new Map();
        if (version > vscode_cpptools_1.Version.latest) {
            console.warn(`version ${version} is not supported by this version of cpptools`);
            console.warn(`  using ${vscode_cpptools_1.Version.latest} instead`);
            version = vscode_cpptools_1.Version.latest;
        }
        this.version = version;
    }
    addNotifyReadyTimer(provider) {
        if (this.version >= vscode_cpptools_1.Version.v2) {
            const timeout = 30;
            const timer = global.setTimeout(() => {
                console.warn(`registered provider ${provider.extensionId} did not call 'notifyReady' within ${timeout} seconds`);
            }, timeout * 1000);
            this.timers.set(provider.extensionId, timer);
        }
    }
    removeNotifyReadyTimer(provider) {
        if (this.version >= vscode_cpptools_1.Version.v2) {
            const timer = this.timers.get(provider.extensionId);
            if (timer) {
                this.timers.delete(provider.extensionId);
                clearTimeout(timer);
            }
        }
    }
    getVersion() {
        return this.version;
    }
    registerCustomConfigurationProvider(provider) {
        const providers = (0, customProviders_1.getCustomConfigProviders)();
        if (providers.add(provider, this.version)) {
            const added = providers.get(provider);
            if (added) {
                const settings = new settings_1.CppSettings();
                if (settings.loggingLevel === "Information" || settings.loggingLevel === "Debug") {
                    (0, logger_1.getOutputChannel)().appendLine(localize(0, null, added.name));
                }
                this.providers.push(added);
                LanguageServer.getClients().forEach(client => client.onRegisterCustomConfigurationProvider(added));
                this.addNotifyReadyTimer(added);
            }
        }
        else {
            this.failedRegistrations.push(provider);
        }
    }
    notifyReady(provider) {
        const providers = (0, customProviders_1.getCustomConfigProviders)();
        const p = providers.get(provider);
        if (p) {
            this.removeNotifyReadyTimer(p);
            p.isReady = true;
            LanguageServer.getClients().forEach(client => {
                client.updateCustomBrowseConfiguration(p);
                client.updateCustomConfigurations(p);
            });
        }
        else if (this.failedRegistrations.find(p => p === provider)) {
            console.warn("provider not successfully registered; 'notifyReady' ignored");
        }
        else {
            console.warn("provider should be registered before signaling it's ready to provide configurations");
        }
    }
    didChangeCustomConfiguration(provider) {
        const providers = (0, customProviders_1.getCustomConfigProviders)();
        const p = providers.get(provider);
        if (p) {
            if (!p.isReady) {
                console.warn("didChangeCustomConfiguration was invoked before notifyReady");
            }
            LanguageServer.getClients().forEach(client => client.updateCustomConfigurations(p));
        }
        else if (this.failedRegistrations.find(p => p === provider)) {
            console.warn("provider not successfully registered, 'didChangeCustomConfiguration' ignored");
        }
        else {
            console.warn("provider should be registered before sending config change messages");
        }
    }
    didChangeCustomBrowseConfiguration(provider) {
        const providers = (0, customProviders_1.getCustomConfigProviders)();
        const p = providers.get(provider);
        if (p) {
            LanguageServer.getClients().forEach(client => client.updateCustomBrowseConfiguration(p));
        }
        else if (this.failedRegistrations.find(p => p === provider)) {
            console.warn("provider not successfully registered, 'didChangeCustomBrowseConfiguration' ignored");
        }
        else {
            console.warn("provider should be registered before sending config change messages");
        }
    }
    dispose() {
        this.providers.forEach(provider => {
            (0, customProviders_1.getCustomConfigProviders)().remove(provider);
            provider.dispose();
        });
        this.providers = [];
    }
    getTestHook() {
        return test.getTestHook();
    }
}
exports.CppTools = CppTools;


/***/ }),

/***/ 8674:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NullCppTools = exports.CppTools1 = void 0;
const vscode_cpptools_1 = __webpack_require__(3286);
const cppTools_1 = __webpack_require__(2451);
class CppTools1 {
    get BackupApi() {
        if (!this.backupApi) {
            this.backupApi = new cppTools_1.CppTools(vscode_cpptools_1.Version.v0);
        }
        return this.backupApi;
    }
    getApi(version) {
        switch (version) {
            case vscode_cpptools_1.Version.v0:
                return this.BackupApi;
            default:
                return new cppTools_1.CppTools(version);
        }
    }
    getTestApi(version) {
        return this.getApi(version);
    }
    getVersion() {
        return this.BackupApi.getVersion();
    }
    registerCustomConfigurationProvider(provider) {
        this.BackupApi.registerCustomConfigurationProvider(provider);
    }
    notifyReady(provider) {
        this.BackupApi.notifyReady(provider);
    }
    didChangeCustomConfiguration(provider) {
        this.BackupApi.didChangeCustomConfiguration(provider);
    }
    didChangeCustomBrowseConfiguration(provider) {
        this.BackupApi.didChangeCustomBrowseConfiguration(provider);
    }
    dispose() {
    }
    getTestHook() {
        return this.BackupApi.getTestHook();
    }
}
exports.CppTools1 = CppTools1;
class NullCppTools {
    constructor() {
        this.version = vscode_cpptools_1.Version.v0;
    }
    getApi(version) {
        this.version = version;
        return this;
    }
    getVersion() {
        return this.version;
    }
    registerCustomConfigurationProvider(provider) {
    }
    notifyReady(provider) {
    }
    didChangeCustomConfiguration(provider) {
    }
    didChangeCustomBrowseConfiguration(provider) {
    }
    dispose() {
    }
}
exports.NullCppTools = NullCppTools;


/***/ }),

/***/ 6547:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinuxDistribution = void 0;
const fs = __webpack_require__(5747);
const os = __webpack_require__(2087);
class LinuxDistribution {
    constructor(name, version) {
        this.name = name;
        this.version = version;
    }
    static GetDistroInformation() {
        const linuxDistro = LinuxDistribution.getDistroInformationFromFile('/etc/os-release')
            .catch(() => LinuxDistribution.getDistroInformationFromFile('/usr/lib/os-release'))
            .catch(() => Promise.resolve(new LinuxDistribution('unknown', 'unknown')));
        return linuxDistro;
    }
    static getDistroInformationFromFile(path) {
        return new Promise((resolve, reject) => {
            fs.readFile(path, 'utf8', (error, data) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(LinuxDistribution.getDistroInformation(data));
            });
        });
    }
    static getDistroInformation(data) {
        const idKey = 'ID';
        const versionKey = 'VERSION_ID';
        let distroName = 'unknown';
        let distroVersion = 'unknown';
        const keyValues = data.split(os.EOL);
        for (let i = 0; i < keyValues.length; i++) {
            const keyValue = keyValues[i].split('=');
            if (keyValue.length === 2) {
                if (keyValue[0] === idKey) {
                    distroName = keyValue[1];
                }
                else if (keyValue[0] === versionKey) {
                    distroVersion = keyValue[1];
                }
            }
        }
        return new LinuxDistribution(distroName, distroVersion);
    }
}
exports.LinuxDistribution = LinuxDistribution;


/***/ }),

/***/ 5610:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOutputChannelLogger = exports.showOutputChannel = exports.getOutputChannel = exports.Logger = exports.subscribeToAllLoggers = void 0;
const vscode = __webpack_require__(7549);
const os = __webpack_require__(2087);
const settings_1 = __webpack_require__(296);
let Subscriber;
function subscribeToAllLoggers(subscriber) {
    Subscriber = subscriber;
}
exports.subscribeToAllLoggers = subscribeToAllLoggers;
class Logger {
    constructor(writer) {
        this.writer = writer;
    }
    append(message) {
        this.writer(message);
        if (Subscriber) {
            Subscriber(message);
        }
    }
    appendLine(message) {
        this.writer(message + os.EOL);
        if (Subscriber) {
            Subscriber(message + os.EOL);
        }
    }
    showInformationMessage(message, items) {
        this.appendLine(message);
        if (!items) {
            return vscode.window.showInformationMessage(message);
        }
        return vscode.window.showInformationMessage(message, ...items);
    }
    showWarningMessage(message, items) {
        this.appendLine(message);
        if (!items) {
            return vscode.window.showWarningMessage(message);
        }
        return vscode.window.showWarningMessage(message, ...items);
    }
    showErrorMessage(message, items) {
        this.appendLine(message);
        if (!items) {
            return vscode.window.showErrorMessage(message);
        }
        return vscode.window.showErrorMessage(message, ...items);
    }
}
exports.Logger = Logger;
let outputChannel;
function getOutputChannel() {
    if (!outputChannel) {
        outputChannel = vscode.window.createOutputChannel("C/C++");
        const settings = new settings_1.CppSettings();
        const loggingLevel = settings.loggingLevel;
        if (!!loggingLevel && loggingLevel !== "None" && loggingLevel !== "Error") {
            outputChannel.appendLine(`loggingLevel: ${loggingLevel}`);
        }
    }
    return outputChannel;
}
exports.getOutputChannel = getOutputChannel;
function showOutputChannel() {
    getOutputChannel().show();
}
exports.showOutputChannel = showOutputChannel;
let outputChannelLogger;
function getOutputChannelLogger() {
    if (!outputChannelLogger) {
        outputChannelLogger = new Logger(message => getOutputChannel().append(message));
    }
    return outputChannelLogger;
}
exports.getOutputChannelLogger = getOutputChannelLogger;


/***/ }),

/***/ 7114:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateInsidersAccess = exports.deactivate = exports.activate = void 0;
const DebuggerExtension = __webpack_require__(2763);
const LanguageServer = __webpack_require__(2973);
const os = __webpack_require__(2087);
const path = __webpack_require__(5622);
const Telemetry = __webpack_require__(1818);
const util = __webpack_require__(5331);
const vscode = __webpack_require__(7549);
const platform_1 = __webpack_require__(3383);
const cppTools1_1 = __webpack_require__(8674);
const settings_1 = __webpack_require__(296);
const persistentState_1 = __webpack_require__(1102);
const vscode_tas_client_1 = __webpack_require__(2579);
const cppTools = new cppTools1_1.CppTools1();
let languageServiceDisabled = false;
let reloadMessageShown = false;
const disposables = [];
function activate(context) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        util.setExtensionContext(context);
        Telemetry.activate();
        util.setProgress(0);
        class SchemaProvider {
            provideTextDocumentContent(uri) {
                return __awaiter(this, void 0, void 0, function* () {
                    console.assert(uri.path[0] === '/', "A preceeding slash is expected on schema uri path");
                    const fileName = uri.path.substr(1);
                    const locale = util.getLocaleId();
                    let localizedFilePath = util.getExtensionFilePath(path.join("dist/schema/", locale, fileName));
                    const fileExists = yield util.checkFileExists(localizedFilePath);
                    if (!fileExists) {
                        localizedFilePath = util.getExtensionFilePath(fileName);
                    }
                    return util.readFileText(localizedFilePath);
                });
            }
        }
        vscode.workspace.registerTextDocumentContentProvider('cpptools-schema', new SchemaProvider());
        DebuggerExtension.initialize(context);
        const info = yield platform_1.PlatformInformation.GetPlatformInformation();
        sendTelemetry(info);
        yield makeBinariesExecutable();
        util.checkDistro(info);
        const settings = new settings_1.CppSettings((vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) ? (_a = vscode.workspace.workspaceFolders[0]) === null || _a === void 0 ? void 0 : _a.uri : undefined);
        if (settings.intelliSenseEngine === "Disabled") {
            languageServiceDisabled = true;
            disposables.push(vscode.workspace.onDidChangeConfiguration(() => {
                if (!reloadMessageShown && settings.intelliSenseEngine !== "Disabled") {
                    reloadMessageShown = true;
                    util.promptForReloadWindowDueToSettingsChange();
                }
            }));
        }
        else {
            disposables.push(vscode.workspace.onDidChangeConfiguration(() => {
                if (!reloadMessageShown && settings.intelliSenseEngine === "Disabled") {
                    reloadMessageShown = true;
                    util.promptForReloadWindowDueToSettingsChange();
                }
            }));
        }
        LanguageServer.activate();
        UpdateInsidersAccess();
        return cppTools;
    });
}
exports.activate = activate;
function deactivate() {
    DebuggerExtension.dispose();
    Telemetry.deactivate();
    disposables.forEach(d => d.dispose());
    if (languageServiceDisabled) {
        return Promise.resolve();
    }
    return LanguageServer.deactivate();
}
exports.deactivate = deactivate;
function makeBinariesExecutable() {
    return __awaiter(this, void 0, void 0, function* () {
        const promises = [];
        if (process.platform !== 'win32') {
            const commonBinaries = [
                "./bin/cpptools",
                "./bin/cpptools-srv",
                "./LLVM/bin/clang-format",
                "./LLVM/bin/clang-tidy",
                "./debugAdapters/bin/OpenDebugAD7"
            ];
            commonBinaries.forEach(binary => promises.push(util.allowExecution(util.getExtensionFilePath(binary))));
            if (process.platform === "darwin") {
                const macBinaries = [
                    "./debugAdapters/lldb-mi/bin/lldb-mi"
                ];
                macBinaries.forEach(binary => promises.push(util.allowExecution(util.getExtensionFilePath(binary))));
                if (os.arch() === "x64") {
                    const oldMacBinaries = [
                        "./debugAdapters/lldb/bin/debugserver",
                        "./debugAdapters/lldb/bin/lldb-mi",
                        "./debugAdapters/lldb/bin/lldb-argdumper",
                        "./debugAdapters/lldb/bin/lldb-launcher"
                    ];
                    oldMacBinaries.forEach(binary => promises.push(util.allowExecution(util.getExtensionFilePath(binary))));
                }
            }
        }
        yield Promise.all(promises);
    });
}
function sendTelemetry(info) {
    const telemetryProperties = {};
    if (info.distribution) {
        telemetryProperties['linuxDistroName'] = info.distribution.name;
        telemetryProperties['linuxDistroVersion'] = info.distribution.version;
    }
    telemetryProperties['osArchitecture'] = os.arch();
    telemetryProperties['infoArchitecture'] = info.architecture;
    const targetPopulation = util.getCppToolsTargetPopulation();
    switch (targetPopulation) {
        case vscode_tas_client_1.TargetPopulation.Public:
            telemetryProperties['targetPopulation'] = "Public";
            break;
        case vscode_tas_client_1.TargetPopulation.Internal:
            telemetryProperties['targetPopulation'] = "Internal";
            break;
        case vscode_tas_client_1.TargetPopulation.Insiders:
            telemetryProperties['targetPopulation'] = "Insiders";
            break;
        default:
            break;
    }
    Telemetry.logDebuggerEvent("acquisition", telemetryProperties);
}
function UpdateInsidersAccess() {
    let installPrerelease = false;
    const settings = new settings_1.CppSettings();
    const migratedInsiders = new persistentState_1.PersistentState("CPP.migratedInsiders", false);
    if (settings.updateChannel === "Insiders") {
        if (!migratedInsiders.Value && vscode.workspace.getConfiguration("extensions", null).get("autoUpdate")) {
            installPrerelease = true;
            migratedInsiders.Value = true;
        }
    }
    else {
        if (migratedInsiders.Value) {
            migratedInsiders.Value = false;
        }
    }
    if (util.isVsCodeInsiders()) {
        const insidersMitigationDone = new persistentState_1.PersistentState("CPP.insidersMitigationDone", false);
        if (!insidersMitigationDone.Value) {
            if (vscode.workspace.getConfiguration("extensions", null).get("autoUpdate")) {
                if (settings.getWithUndefinedDefault("updateChannel") === undefined) {
                    installPrerelease = true;
                }
            }
            insidersMitigationDone.Value = true;
        }
    }
    if (installPrerelease) {
        vscode.commands.executeCommand("workbench.extensions.installExtension", "ms-vscode.cpptools", { installPreReleaseVersion: true });
    }
}
exports.UpdateInsidersAccess = UpdateInsidersAccess;


/***/ }),

/***/ 5391:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lookupString = exports.localizedStringCount = void 0;
const nls = __webpack_require__(3463);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\nativeStrings.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\nativeStrings.ts'));
exports.localizedStringCount = 214;
function lookupString(stringId, stringArgs) {
    let message = "";
    switch (stringId) {
        case 0:
            break;
        case 1:
            message = localize(0, null);
            break;
        case 2:
            message = localize(1, null);
            break;
        case 3:
            message = localize(2, null);
            break;
        case 4:
            if (stringArgs) {
                message = localize(3, null, stringArgs[0]);
                break;
            }
            message = localize(4, null);
            break;
        case 5:
            message = localize(5, null);
            break;
        case 6:
            message = localize(6, null);
            break;
        case 7:
            message = localize(7, null);
            break;
        case 8:
            if (stringArgs) {
                message = localize(8, null, stringArgs[0]);
                break;
            }
            message = localize(9, null);
            break;
        case 9:
            if (stringArgs) {
                message = localize(10, null, stringArgs[0]);
                break;
            }
            message = localize(11, null);
            break;
        case 10:
            if (stringArgs) {
                message = localize(12, null, stringArgs[0]);
                break;
            }
            message = localize(13, null);
            break;
        case 11:
            if (stringArgs) {
                message = localize(14, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(15, null);
            break;
        case 12:
            if (stringArgs) {
                message = localize(16, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(17, null);
            break;
        case 13:
            if (stringArgs) {
                message = localize(18, null, stringArgs[0], stringArgs[1], stringArgs[2]);
                break;
            }
            message = localize(19, null);
            break;
        case 14:
            message = localize(20, null);
            break;
        case 15:
            if (stringArgs) {
                message = localize(21, null, stringArgs[0]);
                break;
            }
            message = localize(22, null);
            break;
        case 16:
            if (stringArgs) {
                message = localize(23, null, stringArgs[0]);
                break;
            }
            message = localize(24, null);
            break;
        case 17:
            if (stringArgs) {
                message = localize(25, null, stringArgs[0]);
                break;
            }
            message = localize(26, null);
            break;
        case 18:
            if (stringArgs) {
                message = localize(27, null, stringArgs[0]);
                break;
            }
            message = localize(28, null);
            break;
        case 19:
            if (stringArgs) {
                message = localize(29, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(30, null);
            break;
        case 20:
            if (stringArgs) {
                message = localize(31, null, stringArgs[0]);
                break;
            }
            message = localize(32, null);
            break;
        case 21:
            if (stringArgs) {
                message = localize(33, null, stringArgs[0]);
                break;
            }
            message = localize(34, null);
            break;
        case 22:
            if (stringArgs) {
                message = localize(35, null, stringArgs[0]);
                break;
            }
            message = localize(36, null);
            break;
        case 23:
            if (stringArgs) {
                message = localize(37, null, stringArgs[0]);
                break;
            }
            message = localize(38, null);
            break;
        case 24:
            if (stringArgs) {
                message = localize(39, null, stringArgs[0]);
                break;
            }
            message = localize(40, null);
            break;
        case 25:
            message = localize(41, null);
            break;
        case 26:
            if (stringArgs) {
                message = localize(42, null, stringArgs[0]);
                break;
            }
            message = localize(43, null);
            break;
        case 27:
            if (stringArgs) {
                message = localize(44, null, stringArgs[0]);
                break;
            }
            message = localize(45, null);
            break;
        case 28:
            if (stringArgs) {
                message = localize(46, null, stringArgs[0]);
                break;
            }
            message = localize(47, null);
            break;
        case 29:
            message = localize(48, null);
            break;
        case 30:
            if (stringArgs) {
                message = localize(49, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(50, null);
            break;
        case 31:
            if (stringArgs) {
                message = localize(51, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(52, null);
            break;
        case 32:
            if (stringArgs) {
                message = localize(53, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(54, null);
            break;
        case 33:
            if (stringArgs) {
                message = localize(55, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(56, null);
            break;
        case 34:
            if (stringArgs) {
                message = localize(57, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(58, null);
            break;
        case 35:
            if (stringArgs) {
                message = localize(59, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(60, null);
            break;
        case 36:
            if (stringArgs) {
                message = localize(61, null, stringArgs[0]);
                break;
            }
            message = localize(62, null);
            break;
        case 37:
            message = localize(63, null);
            break;
        case 38:
            if (stringArgs) {
                message = localize(64, null, stringArgs[0]);
                break;
            }
            message = localize(65, null);
            break;
        case 39:
            message = localize(66, null);
            break;
        case 40:
            if (stringArgs) {
                message = localize(67, null, stringArgs[0]);
                break;
            }
            message = localize(68, null);
            break;
        case 41:
            if (stringArgs) {
                message = localize(69, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(70, null);
            break;
        case 42:
            message = localize(71, null);
            break;
        case 43:
            if (stringArgs) {
                message = localize(72, null, stringArgs[0]);
                break;
            }
            message = localize(73, null);
            break;
        case 44:
            message = localize(74, null);
            break;
        case 45:
            if (stringArgs) {
                message = localize(75, null, stringArgs[0]);
                break;
            }
            message = localize(76, null);
            break;
        case 46:
            if (stringArgs) {
                message = localize(77, null, stringArgs[0]);
                break;
            }
            message = localize(78, null);
            break;
        case 47:
            if (stringArgs) {
                message = localize(79, null, stringArgs[0]);
                break;
            }
            message = localize(80, null);
            break;
        case 48:
            if (stringArgs) {
                message = localize(81, null, stringArgs[0]);
                break;
            }
            message = localize(82, null);
            break;
        case 49:
            if (stringArgs) {
                message = localize(83, null, stringArgs[0]);
                break;
            }
            message = localize(84, null);
            break;
        case 50:
            if (stringArgs) {
                message = localize(85, null, stringArgs[0]);
                break;
            }
            message = localize(86, null);
            break;
        case 51:
            if (stringArgs) {
                message = localize(87, null, stringArgs[0]);
                break;
            }
            message = localize(88, null);
            break;
        case 52:
            if (stringArgs) {
                message = localize(89, null, stringArgs[0]);
                break;
            }
            message = localize(90, null);
            break;
        case 53:
            if (stringArgs) {
                message = localize(91, null, stringArgs[0]);
                break;
            }
            message = localize(92, null);
            break;
        case 54:
            if (stringArgs) {
                message = localize(93, null, stringArgs[0]);
                break;
            }
            message = localize(94, null);
            break;
        case 55:
            if (stringArgs) {
                message = localize(95, null, stringArgs[0]);
                break;
            }
            message = localize(96, null);
            break;
        case 56:
            message = localize(97, null);
            break;
        case 57:
            if (stringArgs) {
                message = localize(98, null, stringArgs[0]);
                break;
            }
            message = localize(99, null);
            break;
        case 58:
            message = localize(100, null);
            break;
        case 59:
            message = localize(101, null);
            break;
        case 60:
            message = localize(102, null);
            break;
        case 61:
            message = localize(103, null);
            break;
        case 62:
            message = localize(104, null);
            break;
        case 63:
            message = localize(105, null);
            break;
        case 64:
            message = localize(106, null);
            break;
        case 65:
            if (stringArgs) {
                message = localize(107, null, stringArgs[0]);
                break;
            }
            message = localize(108, null);
            break;
        case 66:
            if (stringArgs) {
                message = localize(109, null, stringArgs[0]);
                break;
            }
            message = localize(110, null);
            break;
        case 67:
            if (stringArgs) {
                message = localize(111, null, stringArgs[0]);
                break;
            }
            message = localize(112, null);
            break;
        case 68:
            if (stringArgs) {
                message = localize(113, null, stringArgs[0]);
                break;
            }
            message = localize(114, null);
            break;
        case 69:
            message = localize(115, null);
            break;
        case 70:
            message = localize(116, null);
            break;
        case 71:
            message = localize(117, null);
            break;
        case 72:
            message = localize(118, null);
            break;
        case 73:
            message = localize(119, null);
            break;
        case 74:
            message = localize(120, null);
            break;
        case 75:
            message = localize(121, null);
            break;
        case 76:
            message = localize(122, null);
            break;
        case 77:
            if (stringArgs) {
                message = localize(123, null, stringArgs[0]);
                break;
            }
            message = localize(124, null);
            break;
        case 78:
            if (stringArgs) {
                message = localize(125, null, stringArgs[0]);
                break;
            }
            message = localize(126, null);
            break;
        case 79:
            if (stringArgs) {
                message = localize(127, null, stringArgs[0]);
                break;
            }
            message = localize(128, null);
            break;
        case 80:
            if (stringArgs) {
                message = localize(129, null, stringArgs[0]);
                break;
            }
            message = localize(130, null);
            break;
        case 81:
            if (stringArgs) {
                message = localize(131, null, stringArgs[0], stringArgs[1], stringArgs[2]);
                break;
            }
            message = localize(132, null);
            break;
        case 82:
            if (stringArgs) {
                message = localize(133, null, stringArgs[0]);
                break;
            }
            message = localize(134, null);
            break;
        case 83:
            message = localize(135, null);
            break;
        case 84:
            message = localize(136, null);
            break;
        case 85:
            if (stringArgs) {
                message = localize(137, null, stringArgs[0]);
                break;
            }
            message = localize(138, null);
            break;
        case 86:
            if (stringArgs) {
                message = localize(139, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(140, null);
            break;
        case 87:
            message = localize(141, null);
            break;
        case 88:
            if (stringArgs) {
                message = localize(142, null, stringArgs[0]);
                break;
            }
            message = localize(143, null);
            break;
        case 89:
            if (stringArgs) {
                message = localize(144, null, stringArgs[0]);
                break;
            }
            message = localize(145, null);
            break;
        case 90:
            if (stringArgs) {
                message = localize(146, null, stringArgs[0]);
                break;
            }
            message = localize(147, null);
            break;
        case 91:
            message = localize(148, null);
            break;
        case 92:
            message = localize(149, null);
            break;
        case 93:
            message = localize(150, null);
            break;
        case 94:
            if (stringArgs) {
                message = localize(151, null, stringArgs[0]);
                break;
            }
            message = localize(152, null);
            break;
        case 95:
            if (stringArgs) {
                message = localize(153, null, stringArgs[0]);
                break;
            }
            message = localize(154, null);
            break;
        case 96:
            if (stringArgs) {
                message = localize(155, null, stringArgs[0]);
                break;
            }
            message = localize(156, null);
            break;
        case 97:
            if (stringArgs) {
                message = localize(157, null, stringArgs[0]);
                break;
            }
            message = localize(158, null);
            break;
        case 98:
            if (stringArgs) {
                message = localize(159, null, stringArgs[0]);
                break;
            }
            message = localize(160, null);
            break;
        case 99:
            if (stringArgs) {
                message = localize(161, null, stringArgs[0]);
                break;
            }
            message = localize(162, null);
            break;
        case 100:
            if (stringArgs) {
                message = localize(163, null, stringArgs[0]);
                break;
            }
            message = localize(164, null);
            break;
        case 101:
            if (stringArgs) {
                message = localize(165, null, stringArgs[0]);
                break;
            }
            message = localize(166, null);
            break;
        case 102:
            message = localize(167, null);
            break;
        case 103:
            message = localize(168, null);
            break;
        case 104:
            if (stringArgs) {
                message = localize(169, null, stringArgs[0]);
                break;
            }
            message = localize(170, null);
            break;
        case 105:
            message = localize(171, null);
            break;
        case 106:
            message = localize(172, null);
            break;
        case 107:
            if (stringArgs) {
                message = localize(173, null, stringArgs[0]);
                break;
            }
            message = localize(174, null);
            break;
        case 108:
            if (stringArgs) {
                message = localize(175, null, stringArgs[0]);
                break;
            }
            message = localize(176, null);
            break;
        case 109:
            if (stringArgs) {
                message = localize(177, null, stringArgs[0]);
                break;
            }
            message = localize(178, null);
            break;
        case 110:
            message = localize(179, null);
            break;
        case 111:
            message = localize(180, null);
            break;
        case 112:
            message = localize(181, null);
            break;
        case 113:
            message = localize(182, null);
            break;
        case 114:
            message = localize(183, null);
            break;
        case 115:
            message = localize(184, null);
            break;
        case 116:
            if (stringArgs) {
                message = localize(185, null, stringArgs[0]);
                break;
            }
            message = localize(186, null);
            break;
        case 117:
            if (stringArgs) {
                message = localize(187, null, stringArgs[0]);
                break;
            }
            message = localize(188, null);
            break;
        case 118:
            if (stringArgs) {
                message = localize(189, null, stringArgs[0]);
                break;
            }
            message = localize(190, null);
            break;
        case 119:
            message = localize(191, null);
            break;
        case 120:
            message = localize(192, null);
            break;
        case 121:
            if (stringArgs) {
                message = localize(193, null, stringArgs[0]);
                break;
            }
            message = localize(194, null);
            break;
        case 122:
            message = localize(195, null);
            break;
        case 123:
            message = localize(196, null);
            break;
        case 124:
            message = localize(197, null);
            break;
        case 125:
            if (stringArgs) {
                message = localize(198, null, stringArgs[0]);
                break;
            }
            message = localize(199, null);
            break;
        case 126:
            if (stringArgs) {
                message = localize(200, null, stringArgs[0], stringArgs[1], stringArgs[2]);
                break;
            }
            message = localize(201, null);
            break;
        case 127:
            if (stringArgs) {
                message = localize(202, null, stringArgs[0], stringArgs[1], stringArgs[2]);
                break;
            }
            message = localize(203, null);
            break;
        case 128:
            message = localize(204, null);
            break;
        case 129:
            if (stringArgs) {
                message = localize(205, null, stringArgs[0]);
                break;
            }
            message = localize(206, null);
            break;
        case 130:
            message = localize(207, null);
            break;
        case 131:
            if (stringArgs) {
                message = localize(208, null, stringArgs[0]);
                break;
            }
            message = localize(209, null);
            break;
        case 132:
            if (stringArgs) {
                message = localize(210, null, stringArgs[0]);
                break;
            }
            message = localize(211, null);
            break;
        case 133:
            if (stringArgs) {
                message = localize(212, null, stringArgs[0]);
                break;
            }
            message = localize(213, null);
            break;
        case 134:
            if (stringArgs) {
                message = localize(214, null, stringArgs[0]);
                break;
            }
            message = localize(215, null);
            break;
        case 135:
            if (stringArgs) {
                message = localize(216, null, stringArgs[0]);
                break;
            }
            message = localize(217, null);
            break;
        case 136:
            if (stringArgs) {
                message = localize(218, null, stringArgs[0]);
                break;
            }
            message = localize(219, null);
            break;
        case 137:
            message = localize(220, null);
            break;
        case 138:
            message = localize(221, null);
            break;
        case 139:
            message = localize(222, null);
            break;
        case 140:
            message = localize(223, null);
            break;
        case 141:
            if (stringArgs) {
                message = localize(224, null, stringArgs[0]);
                break;
            }
            message = localize(225, null);
            break;
        case 142:
            if (stringArgs) {
                message = localize(226, null, stringArgs[0]);
                break;
            }
            message = localize(227, null);
            break;
        case 143:
            if (stringArgs) {
                message = localize(228, null, stringArgs[0]);
                break;
            }
            message = localize(229, null);
            break;
        case 144:
            message = localize(230, null);
            break;
        case 145:
            if (stringArgs) {
                message = localize(231, null, stringArgs[0]);
                break;
            }
            message = localize(232, null);
            break;
        case 146:
            if (stringArgs) {
                message = localize(233, null, stringArgs[0]);
                break;
            }
            message = localize(234, null);
            break;
        case 147:
            message = localize(235, null);
            break;
        case 148:
            message = localize(236, null);
            break;
        case 149:
            message = localize(237, null);
            break;
        case 150:
            message = localize(238, null);
            break;
        case 151:
            message = localize(239, null);
            break;
        case 152:
            message = localize(240, null);
            break;
        case 153:
            message = localize(241, null);
            break;
        case 154:
            if (stringArgs) {
                message = localize(242, null, stringArgs[0]);
                break;
            }
            message = localize(243, null);
            break;
        case 155:
            if (stringArgs) {
                message = localize(244, null, stringArgs[0]);
                break;
            }
            message = localize(245, null);
            break;
        case 156:
            if (stringArgs) {
                message = localize(246, null, stringArgs[0]);
                break;
            }
            message = localize(247, null);
            break;
        case 157:
            message = localize(248, null);
            break;
        case 158:
            message = localize(249, null);
            break;
        case 159:
            message = localize(250, null);
            break;
        case 160:
            message = localize(251, null);
            break;
        case 161:
            message = localize(252, null);
            break;
        case 162:
            message = localize(253, null);
            break;
        case 163:
            message = localize(254, null);
            break;
        case 164:
            message = localize(255, null);
            break;
        case 165:
            message = localize(256, null);
            break;
        case 166:
            message = localize(257, null);
            break;
        case 167:
            message = localize(258, null);
            break;
        case 168:
            message = localize(259, null);
            break;
        case 169:
            message = localize(260, null);
            break;
        case 170:
            message = localize(261, null);
            break;
        case 171:
            if (stringArgs) {
                message = localize(262, null, stringArgs[0]);
                break;
            }
            message = localize(263, null);
            break;
        case 172:
            if (stringArgs) {
                message = localize(264, null, stringArgs[0]);
                break;
            }
            message = localize(265, null);
            break;
        case 173:
            if (stringArgs) {
                message = localize(266, null, stringArgs[0]);
                break;
            }
            message = localize(267, null);
            break;
        case 174:
            if (stringArgs) {
                message = localize(268, null, stringArgs[0]);
                break;
            }
            message = localize(269, null);
            break;
        case 175:
            if (stringArgs) {
                message = localize(270, null, stringArgs[0]);
                break;
            }
            message = localize(271, null);
            break;
        case 176:
            if (stringArgs) {
                message = localize(272, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(273, null);
            break;
        case 177:
            if (stringArgs) {
                message = localize(274, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(275, null);
            break;
        case 178:
            if (stringArgs) {
                message = localize(276, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(277, null);
            break;
        case 179:
            if (stringArgs) {
                message = localize(278, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(279, null);
            break;
        case 180:
            if (stringArgs) {
                message = localize(280, null, stringArgs[0], stringArgs[1], stringArgs[2], stringArgs[3]);
                break;
            }
            message = localize(281, null);
            break;
        case 181:
            if (stringArgs) {
                message = localize(282, null, stringArgs[0], stringArgs[1], stringArgs[2], stringArgs[3]);
                break;
            }
            message = localize(283, null);
            break;
        case 182:
            if (stringArgs) {
                message = localize(284, null, stringArgs[0], stringArgs[1], stringArgs[2]);
                break;
            }
            message = localize(285, null);
            break;
        case 183:
            if (stringArgs) {
                message = localize(286, null, stringArgs[0], stringArgs[1], stringArgs[2]);
                break;
            }
            message = localize(287, null);
            break;
        case 184:
            if (stringArgs) {
                message = localize(288, null, stringArgs[0], stringArgs[1], stringArgs[2]);
                break;
            }
            message = localize(289, null);
            break;
        case 185:
            if (stringArgs) {
                message = localize(290, null, stringArgs[0], stringArgs[1], stringArgs[2]);
                break;
            }
            message = localize(291, null);
            break;
        case 186:
            if (stringArgs) {
                message = localize(292, null, stringArgs[0], stringArgs[1], stringArgs[2], stringArgs[3], stringArgs[4]);
                break;
            }
            message = localize(293, null);
            break;
        case 187:
            if (stringArgs) {
                message = localize(294, null, stringArgs[0], stringArgs[1], stringArgs[2], stringArgs[3], stringArgs[4]);
                break;
            }
            message = localize(295, null);
            break;
        case 188:
            if (stringArgs) {
                message = localize(296, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(297, null);
            break;
        case 189:
            if (stringArgs) {
                message = localize(298, null, stringArgs[0]);
                break;
            }
            message = localize(299, null);
            break;
        case 190:
            message = localize(300, null);
            break;
        case 191:
            message = localize(301, null);
            break;
        case 192:
            message = localize(302, null);
            break;
        case 193:
            if (stringArgs) {
                message = localize(303, null, stringArgs[0], stringArgs[1]);
                break;
            }
            message = localize(304, null);
            break;
        case 194:
            if (stringArgs) {
                message = localize(305, null, stringArgs[0]);
                break;
            }
            message = localize(306, null);
            break;
        case 195:
            if (stringArgs) {
                message = localize(307, null, stringArgs[0]);
                break;
            }
            message = localize(308, null);
            break;
        case 196:
            if (stringArgs) {
                message = localize(309, null, stringArgs[0]);
                break;
            }
            message = localize(310, null);
            break;
        case 197:
            if (stringArgs) {
                message = localize(311, null, stringArgs[0]);
                break;
            }
            message = localize(312, null);
            break;
        case 198:
            if (stringArgs) {
                message = localize(313, null, stringArgs[0]);
                break;
            }
            message = localize(314, null);
            break;
        case 199:
            if (stringArgs) {
                message = localize(315, null, stringArgs[0]);
                break;
            }
            message = localize(316, null);
            break;
        case 200:
            if (stringArgs) {
                message = localize(317, null, stringArgs[0], stringArgs[1], stringArgs[2]);
                break;
            }
            message = localize(318, null);
            break;
        case 201:
            if (stringArgs) {
                message = localize(319, null, stringArgs[0]);
                break;
            }
            message = localize(320, null);
            break;
        case 202:
            message = localize(321, null);
            break;
        case 203:
            message = localize(322, null);
            break;
        case 204:
            message = localize(323, null);
            break;
        case 205:
            if (stringArgs) {
                message = localize(324, null, stringArgs[0]);
                break;
            }
            message = localize(325, null);
            break;
        case 206:
            if (stringArgs) {
                message = localize(326, null, stringArgs[0]);
                break;
            }
            message = localize(327, null);
            break;
        case 207:
            if (stringArgs) {
                message = localize(328, null, stringArgs[0]);
                break;
            }
            message = localize(329, null);
            break;
        case 208:
            message = localize(330, null);
            break;
        case 209:
            if (stringArgs) {
                message = localize(331, null, stringArgs[0]);
                break;
            }
            message = localize(332, null);
            break;
        case 210:
            message = localize(333, null);
            break;
        case 211:
            if (stringArgs) {
                message = localize(334, null, stringArgs[0]);
                break;
            }
            message = localize(335, null);
            break;
        case 212:
            message = localize(336, null);
            break;
        case 213:
            message = localize(337, null);
            break;
        default:
            console.assert("Unrecognized string ID");
            break;
    }
    return message;
}
exports.lookupString = lookupString;


/***/ }),

/***/ 3383:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlatformInformation = exports.GetOSName = void 0;
const os = __webpack_require__(2087);
const linuxDistribution_1 = __webpack_require__(6547);
const plist = __webpack_require__(6540);
const fs = __webpack_require__(5747);
const logger = __webpack_require__(5610);
const nls = __webpack_require__(3463);
nls.config({ messageFormat: nls.MessageFormat.bundle, bundleFormat: nls.BundleFormat.standalone })(__webpack_require__(5622).join(__dirname, 'src\\platform.ts'));
const localize = nls.loadMessageBundle(__webpack_require__(5622).join(__dirname, 'src\\platform.ts'));
function GetOSName(processPlatform) {
    switch (processPlatform) {
        case "win32": return "Windows";
        case "darwin": return "macOS";
        case "linux": return "Linux";
        default: return undefined;
    }
}
exports.GetOSName = GetOSName;
class PlatformInformation {
    constructor(platform, architecture, distribution, version) {
        this.platform = platform;
        this.architecture = architecture;
        this.distribution = distribution;
        this.version = version;
    }
    static GetPlatformInformation() {
        return __awaiter(this, void 0, void 0, function* () {
            const platform = os.platform();
            const architecture = PlatformInformation.GetArchitecture();
            let distribution;
            let version;
            switch (platform) {
                case "win32":
                    break;
                case "linux":
                    distribution = yield linuxDistribution_1.LinuxDistribution.GetDistroInformation();
                    break;
                case "darwin":
                    version = yield PlatformInformation.GetDarwinVersion();
                    break;
                default:
                    throw new Error(localize(0, null));
            }
            return new PlatformInformation(platform, architecture, distribution, version);
        });
    }
    static GetArchitecture() {
        const arch = os.arch();
        switch (arch) {
            case "arm64":
            case "arm":
                return arch;
            case "x32":
            case "ia32":
                return "x86";
            default:
                return "x64";
        }
    }
    static GetDarwinVersion() {
        const DARWIN_SYSTEM_VERSION_PLIST = "/System/Library/CoreServices/SystemVersion.plist";
        let productDarwinVersion = "";
        let errorMessage = "";
        if (fs.existsSync(DARWIN_SYSTEM_VERSION_PLIST)) {
            const systemVersionPListBuffer = fs.readFileSync(DARWIN_SYSTEM_VERSION_PLIST);
            const systemVersionData = plist.parse(systemVersionPListBuffer.toString());
            if (systemVersionData) {
                productDarwinVersion = systemVersionData.ProductVersion;
            }
            else {
                errorMessage = localize(1, null);
            }
        }
        else {
            errorMessage = localize(2, null, DARWIN_SYSTEM_VERSION_PLIST);
        }
        if (errorMessage) {
            logger.getOutputChannel().appendLine(errorMessage);
            logger.showOutputChannel();
        }
        return Promise.resolve(productDarwinVersion);
    }
}
exports.PlatformInformation = PlatformInformation;


/***/ }),

/***/ 1818:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logLanguageServerEvent = exports.logDebuggerEvent = exports.deactivate = exports.getExperimentationService = exports.activate = exports.ExperimentationTelemetry = void 0;
const vscode_extension_telemetry_1 = __webpack_require__(5719);
const vscode_tas_client_1 = __webpack_require__(2579);
const util = __webpack_require__(5331);
class ExperimentationTelemetry {
    constructor(baseReporter) {
        this.baseReporter = baseReporter;
        this.sharedProperties = {};
    }
    sendTelemetryEvent(eventName, properties, measurements) {
        this.baseReporter.sendTelemetryEvent(eventName, Object.assign(Object.assign({}, this.sharedProperties), properties), measurements);
    }
    sendTelemetryErrorEvent(eventName, properties, _measurements) {
        this.baseReporter.sendTelemetryErrorEvent(eventName, Object.assign(Object.assign({}, this.sharedProperties), properties));
    }
    setSharedProperty(name, value) {
        this.sharedProperties[name] = value;
    }
    postEvent(eventName, props) {
        const event = {};
        for (const [key, value] of props) {
            event[key] = value;
        }
        this.sendTelemetryEvent(eventName, event);
    }
    dispose() {
        return this.baseReporter.dispose();
    }
}
exports.ExperimentationTelemetry = ExperimentationTelemetry;
let initializationPromise;
let experimentationTelemetry;
const appInsightsKey = "AIF-d9b70cd4-b9f9-4d70-929b-a071c400b217";
function activate() {
    try {
        if (util.extensionContext) {
            const packageInfo = getPackageInfo();
            if (packageInfo) {
                const targetPopulation = util.getCppToolsTargetPopulation();
                experimentationTelemetry = new ExperimentationTelemetry(new vscode_extension_telemetry_1.default(packageInfo.name, packageInfo.version, appInsightsKey));
                initializationPromise = (0, vscode_tas_client_1.getExperimentationServiceAsync)(packageInfo.name, packageInfo.version, targetPopulation, experimentationTelemetry, util.extensionContext.globalState);
            }
        }
    }
    catch (e) {
    }
}
exports.activate = activate;
function getExperimentationService() {
    return initializationPromise;
}
exports.getExperimentationService = getExperimentationService;
function deactivate() {
    return __awaiter(this, void 0, void 0, function* () {
        if (initializationPromise) {
            try {
                yield initializationPromise;
            }
            catch (e) {
            }
        }
        if (experimentationTelemetry) {
            experimentationTelemetry.dispose();
        }
    });
}
exports.deactivate = deactivate;
function logDebuggerEvent(eventName, properties) {
    const sendTelemetry = () => {
        if (experimentationTelemetry) {
            const eventNamePrefix = "cppdbg/VS/Diagnostics/Debugger/";
            experimentationTelemetry.sendTelemetryEvent(eventNamePrefix + eventName, properties);
        }
    };
    if (initializationPromise) {
        try {
            initializationPromise.then(sendTelemetry);
            return;
        }
        catch (e) {
        }
    }
    sendTelemetry();
}
exports.logDebuggerEvent = logDebuggerEvent;
function logLanguageServerEvent(eventName, properties, metrics) {
    const sendTelemetry = () => {
        if (experimentationTelemetry) {
            const eventNamePrefix = "C_Cpp/LanguageServer/";
            experimentationTelemetry.sendTelemetryEvent(eventNamePrefix + eventName, properties, metrics);
        }
    };
    if (initializationPromise) {
        try {
            initializationPromise.then(sendTelemetry);
            return;
        }
        catch (e) {
        }
    }
    sendTelemetry();
}
exports.logLanguageServerEvent = logLanguageServerEvent;
function getPackageInfo() {
    return {
        name: util.packageJson.publisher + "." + util.packageJson.name,
        version: util.packageJson.version
    };
}


/***/ }),

/***/ 5648:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTestHook = exports.TestHook = void 0;
const vscode = __webpack_require__(7549);
class TestHook {
    constructor() {
        this.intelliSenseStatusChangedEvent = new vscode.EventEmitter();
        this.statusChangedEvent = new vscode.EventEmitter();
    }
    get StatusChanged() {
        return this.statusChangedEvent.event;
    }
    get IntelliSenseStatusChanged() {
        return this.intelliSenseStatusChangedEvent.event;
    }
    get valid() {
        return !!this.intelliSenseStatusChangedEvent && !!this.statusChangedEvent;
    }
    updateStatus(status) {
        this.intelliSenseStatusChangedEvent.fire(status);
        this.statusChangedEvent.fire(status.status);
    }
    dispose() {
        this.intelliSenseStatusChangedEvent.dispose();
        this.statusChangedEvent.dispose();
    }
}
exports.TestHook = TestHook;
let testHook;
function getTestHook() {
    if (!testHook || !testHook.valid) {
        testHook = new TestHook();
    }
    return testHook;
}
exports.getTestHook = getTestHook;


/***/ }),

/***/ 3286:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT license.
 * ------------------------------------------------------------------------------------------ */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCppToolsApi = exports.Version = void 0;
const vscode = __webpack_require__(7549);
/**
 * API version information.
 */
var Version;
(function (Version) {
    Version[Version["v0"] = 0] = "v0";
    Version[Version["v1"] = 1] = "v1";
    Version[Version["v2"] = 2] = "v2";
    Version[Version["v3"] = 3] = "v3";
    Version[Version["v4"] = 4] = "v4";
    Version[Version["v5"] = 5] = "v5";
    Version[Version["latest"] = 5] = "latest";
})(Version = exports.Version || (exports.Version = {}));
/**
 * Check if an object satisfies the contract of the CppToolsExtension interface.
 */
function isCppToolsExtension(extension) {
    return extension && extension.getApi;
}
/**
 * Check if an object satisfies the contract of the first version of the CppToolsApi.
 * (The first release of the API only had two functions)
 */
function isLegacyCppToolsApi(api) {
    return api && api.registerCustomConfigurationProvider && api.didChangeCustomConfiguration;
}
/**
 * Helper function to get the CppToolsApi from the cpptools extension.
 * @param version The desired API version
 * @example
```
    import {CppToolsApi, Version, CustomConfigurationProvider, getCppToolsApi} from 'vscode-cpptools';

    let api: CppToolsApi|undefined = await getCppToolsApi(Version.v1);
    if (api) {
        // Inform cpptools that a custom config provider
        // will be able to service the current workspace.
        api.registerCustomConfigurationProvider(provider);

        // Do any required setup that the provider needs.

        // Notify cpptools that the provider is ready to
        // provide IntelliSense configurations.
        api.notifyReady(provider);
    }
    // Dispose of the 'api' in your extension's
    // deactivate() method, or whenever you want to
    // unregister the provider.
```
 */
function getCppToolsApi(version) {
    return __awaiter(this, void 0, void 0, function* () {
        let cpptools = vscode.extensions.getExtension("ms-vscode.cpptools");
        let extension = undefined;
        let api = undefined;
        if (cpptools) {
            if (!cpptools.isActive) {
                extension = yield cpptools.activate();
            }
            else {
                extension = cpptools.exports;
            }
            if (isCppToolsExtension(extension)) {
                // ms-vscode.cpptools > 0.17.5
                try {
                    api = extension.getApi(version);
                }
                catch (err) {
                    // Unfortunately, ms-vscode.cpptools [0.17.6, 0.18.1] throws a RangeError if you specify a version greater than v1.
                    // These versions of the extension will not be able to act on the newer interface and v2 is a superset of v1, so we can safely fall back to v1.
                    let e = err;
                    if (e && e.message && e.message.startsWith("Invalid version")) {
                        api = extension.getApi(Version.v1);
                    }
                }
                if (version !== Version.v1) {
                    if (!api.getVersion) {
                        console.warn(`[vscode-cpptools-api] version ${version} requested, but is not available in the current version of the cpptools extension. Using version 1 instead.`);
                    }
                    else if (version !== api.getVersion()) {
                        console.warn(`[vscode-cpptools-api] version ${version} requested, but is not available in the current version of the cpptools extension. Using version ${api.getVersion()} instead.`);
                    }
                }
            }
            else if (isLegacyCppToolsApi(extension)) {
                // ms-vscode.cpptools version 0.17.5
                api = extension;
                if (version !== Version.v0) {
                    console.warn(`[vscode-cpptools-api] version ${version} requested, but is not available in version 0.17.5 of the cpptools extension. Using version 0 instead.`);
                }
            }
            else {
                console.warn('[vscode-cpptools-api] No cpptools API was found.');
            }
        }
        else {
            console.warn('[vscode-cpptools-api] C/C++ extension is not installed');
        }
        return api;
    });
}
exports.getCppToolsApi = getCppToolsApi;


/***/ }),

/***/ 7373:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT license.
 * ------------------------------------------------------------------------------------------ */

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCppToolsTestApi = exports.Status = void 0;
const api_1 = __webpack_require__(3286);
const vscode = __webpack_require__(7549);
/**
 * Tag Parser or IntelliSense status codes.
 */
var Status;
(function (Status) {
    Status[Status["TagParsingBegun"] = 1] = "TagParsingBegun";
    Status[Status["TagParsingDone"] = 2] = "TagParsingDone";
    Status[Status["IntelliSenseCompiling"] = 3] = "IntelliSenseCompiling";
    Status[Status["IntelliSenseReady"] = 4] = "IntelliSenseReady";
})(Status = exports.Status || (exports.Status = {}));
function isCppToolsTestExtension(extension) {
    return extension.getTestApi !== undefined;
}
function getCppToolsTestApi(version) {
    return __awaiter(this, void 0, void 0, function* () {
        let cpptools = vscode.extensions.getExtension("ms-vscode.cpptools");
        let extension;
        let api;
        if (cpptools) {
            if (!cpptools.isActive) {
                extension = yield cpptools.activate();
            }
            else {
                extension = cpptools.exports;
            }
            if (isCppToolsTestExtension(extension)) {
                // ms-vscode.cpptools > 0.17.5
                try {
                    api = extension.getTestApi(version);
                }
                catch (err) {
                    // Unfortunately, ms-vscode.cpptools [0.17.6, 0.18.1] throws a RangeError if you specify a version greater than v1.
                    // These versions of the extension will not be able to act on the newer interface and v2 is a superset of v1, so we can safely fall back to v1.
                    let e = err;
                    if (e.message && e.message.startsWith("Invalid version")) {
                        api = extension.getTestApi(api_1.Version.v1);
                    }
                }
                if (version !== api_1.Version.v1) {
                    if (!api.getVersion) {
                        console.warn(`vscode-cpptools-api version ${version} requested, but is not available in the current version of the cpptools extension. Using version 1 instead.`);
                    }
                    else if (version !== api.getVersion()) {
                        console.warn(`vscode-cpptools-api version ${version} requested, but is not available in the current version of the cpptools extension. Using version ${api.getVersion()} instead.`);
                    }
                }
            }
            else {
                // ms-vscode.cpptools version 0.17.5
                api = extension;
                if (version !== api_1.Version.v0) {
                    console.warn(`vscode-cpptools-api version ${version} requested, but is not available in version 0.17.5 of the cpptools extension. Using version 0 instead.`);
                }
            }
        }
        else {
            console.warn("C/C++ extension is not installed");
        }
        return api;
    });
}
exports.getCppToolsTestApi = getCppToolsTestApi;


/***/ }),

/***/ 5719:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var oS=Object.create;var Si=Object.defineProperty;var uS=Object.getOwnPropertyDescriptor;var cS=Object.getOwnPropertyNames,pf=Object.getOwnPropertySymbols,lS=Object.getPrototypeOf,ff=Object.prototype.hasOwnProperty,pS=Object.prototype.propertyIsEnumerable;var df=(e,t,r)=>t in e?Si(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,It=(e,t)=>{for(var r in t||(t={}))ff.call(t,r)&&df(e,r,t[r]);if(pf)for(var r of pf(t))pS.call(t,r)&&df(e,r,t[r]);return e};var hf=e=>Si(e,"__esModule",{value:!0});var l=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),fS=(e,t)=>{hf(e);for(var r in t)Si(e,r,{get:t[r],enumerable:!0})},dS=(e,t,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of cS(t))!ff.call(e,n)&&n!=="default"&&Si(e,n,{get:()=>t[n],enumerable:!(r=uS(t,n))||r.enumerable});return e},Ai=e=>dS(hf(Si(e!=null?oS(lS(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var ve=l((Kx,_f)=>{"use strict";var hS=function(){function e(){}return e.info=function(t){for(var r=[],n=1;n<arguments.length;n++)r[n-1]=arguments[n];e.enableDebug&&console.info(e.TAG+t,r)},e.warn=function(t){for(var r=[],n=1;n<arguments.length;n++)r[n-1]=arguments[n];e.disableWarnings||console.warn(e.TAG+t,r)},e.enableDebug=!1,e.disableWarnings=!1,e.disableErrors=!1,e.TAG="ApplicationInsights:",e}();_f.exports=hS});var Eu=l(Ft=>{"use strict";var an=Ft&&Ft.__assign||function(){return an=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++){t=arguments[r];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},an.apply(this,arguments)};Object.defineProperty(Ft,"__esModule",{value:!0});Ft.AsyncScopeManager=Ft.OpenTelemetryScopeManagerWrapper=void 0;var vr=gr(),_S=__webpack_require__(8614),vf=function(){function e(){}return e.prototype.active=function(){var t=this,r=vr.CorrelationContextManager.getCurrentContext();return an(an({},r),{getValue:function(n){return t._activeSymbol?n===t._activeSymbol?r:!1:(t._activeSymbol=n,r)},setValue:function(){}})},e.prototype.with=function(t,r){var n=t.parentSpanId,i=t.name,a=e._spanToContext(t,n,i);return vr.CorrelationContextManager.runWithContext(a,r)()},e.prototype.bind=function(t){return typeof t=="function"?vr.CorrelationContextManager.wrapCallback(t):(t instanceof _S.EventEmitter&&vr.CorrelationContextManager.wrapEmitter(t),t)},e.prototype.enable=function(){return vr.CorrelationContextManager.enable(),this},e.prototype.disable=function(){return vr.CorrelationContextManager.disable(),this},e._spanToContext=function(t,r,n){var i=r?"|"+t.spanContext().traceId+"."+r+".":t.spanContext().traceId,a=an(an({},t.spanContext()),{traceFlags:t.spanContext().traceFlags}),s=vr.CorrelationContextManager.spanToContextObject(a,i,n);return s},e}();Ft.OpenTelemetryScopeManagerWrapper=vf;Ft.AsyncScopeManager=new vf});var xf=l((I,wf)=>{I=wf.exports=N;var k;typeof process=="object"&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?k=function(){var e=Array.prototype.slice.call(arguments,0);e.unshift("SEMVER"),console.log.apply(console,e)}:k=function(){};I.SEMVER_SPEC_VERSION="2.0.0";var mu=256,Ma=Number.MAX_SAFE_INTEGER||9007199254740991,yu=16,B=I.re=[],_=I.src=[],O=0,sn=O++;_[sn]="0|[1-9]\\d*";var on=O++;_[on]="[0-9]+";var Tu=O++;_[Tu]="\\d*[a-zA-Z-][a-zA-Z0-9-]*";var gf=O++;_[gf]="("+_[sn]+")\\.("+_[sn]+")\\.("+_[sn]+")";var Ef=O++;_[Ef]="("+_[on]+")\\.("+_[on]+")\\.("+_[on]+")";var Su=O++;_[Su]="(?:"+_[sn]+"|"+_[Tu]+")";var Au=O++;_[Au]="(?:"+_[on]+"|"+_[Tu]+")";var Iu=O++;_[Iu]="(?:-("+_[Su]+"(?:\\."+_[Su]+")*))";var bu=O++;_[bu]="(?:-?("+_[Au]+"(?:\\."+_[Au]+")*))";var Cu=O++;_[Cu]="[0-9A-Za-z-]+";var bi=O++;_[bi]="(?:\\+("+_[Cu]+"(?:\\."+_[Cu]+")*))";var Ou=O++,mf="v?"+_[gf]+_[Iu]+"?"+_[bi]+"?";_[Ou]="^"+mf+"$";var Pu="[v=\\s]*"+_[Ef]+_[bu]+"?"+_[bi]+"?",Ru=O++;_[Ru]="^"+Pu+"$";var un=O++;_[un]="((?:<|>)?=?)";var La=O++;_[La]=_[on]+"|x|X|\\*";var qa=O++;_[qa]=_[sn]+"|x|X|\\*";var Er=O++;_[Er]="[v=\\s]*("+_[qa]+")(?:\\.("+_[qa]+")(?:\\.("+_[qa]+")(?:"+_[Iu]+")?"+_[bi]+"?)?)?";var cn=O++;_[cn]="[v=\\s]*("+_[La]+")(?:\\.("+_[La]+")(?:\\.("+_[La]+")(?:"+_[bu]+")?"+_[bi]+"?)?)?";var yf=O++;_[yf]="^"+_[un]+"\\s*"+_[Er]+"$";var Tf=O++;_[Tf]="^"+_[un]+"\\s*"+_[cn]+"$";var Sf=O++;_[Sf]="(?:^|[^\\d])(\\d{1,"+yu+"})(?:\\.(\\d{1,"+yu+"}))?(?:\\.(\\d{1,"+yu+"}))?(?:$|[^\\d])";var ja=O++;_[ja]="(?:~>?)";var ka=O++;_[ka]="(\\s*)"+_[ja]+"\\s+";B[ka]=new RegExp(_[ka],"g");var vS="$1~",Af=O++;_[Af]="^"+_[ja]+_[Er]+"$";var If=O++;_[If]="^"+_[ja]+_[cn]+"$";var Ha=O++;_[Ha]="(?:\\^)";var Ua=O++;_[Ua]="(\\s*)"+_[Ha]+"\\s+";B[Ua]=new RegExp(_[Ua],"g");var gS="$1^",bf=O++;_[bf]="^"+_[Ha]+_[Er]+"$";var Cf=O++;_[Cf]="^"+_[Ha]+_[cn]+"$";var Nu=O++;_[Nu]="^"+_[un]+"\\s*("+Pu+")$|^$";var Du=O++;_[Du]="^"+_[un]+"\\s*("+mf+")$|^$";var Ci=O++;_[Ci]="(\\s*)"+_[un]+"\\s*("+Pu+"|"+_[Er]+")";B[Ci]=new RegExp(_[Ci],"g");var ES="$1$2$3",Of=O++;_[Of]="^\\s*("+_[Er]+")\\s+-\\s+("+_[Er]+")\\s*$";var Pf=O++;_[Pf]="^\\s*("+_[cn]+")\\s+-\\s+("+_[cn]+")\\s*$";var Rf=O++;_[Rf]="(<|>)?=?\\s*\\*";for(Vt=0;Vt<O;Vt++)k(Vt,_[Vt]),B[Vt]||(B[Vt]=new RegExp(_[Vt]));var Vt;I.parse=mr;function mr(e,t){if((!t||typeof t!="object")&&(t={loose:!!t,includePrerelease:!1}),e instanceof N)return e;if(typeof e!="string"||e.length>mu)return null;var r=t.loose?B[Ru]:B[Ou];if(!r.test(e))return null;try{return new N(e,t)}catch(n){return null}}I.valid=mS;function mS(e,t){var r=mr(e,t);return r?r.version:null}I.clean=yS;function yS(e,t){var r=mr(e.trim().replace(/^[=v]+/,""),t);return r?r.version:null}I.SemVer=N;function N(e,t){if((!t||typeof t!="object")&&(t={loose:!!t,includePrerelease:!1}),e instanceof N){if(e.loose===t.loose)return e;e=e.version}else if(typeof e!="string")throw new TypeError("Invalid Version: "+e);if(e.length>mu)throw new TypeError("version is longer than "+mu+" characters");if(!(this instanceof N))return new N(e,t);k("SemVer",e,t),this.options=t,this.loose=!!t.loose;var r=e.trim().match(t.loose?B[Ru]:B[Ou]);if(!r)throw new TypeError("Invalid Version: "+e);if(this.raw=e,this.major=+r[1],this.minor=+r[2],this.patch=+r[3],this.major>Ma||this.major<0)throw new TypeError("Invalid major version");if(this.minor>Ma||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>Ma||this.patch<0)throw new TypeError("Invalid patch version");r[4]?this.prerelease=r[4].split(".").map(function(n){if(/^[0-9]+$/.test(n)){var i=+n;if(i>=0&&i<Ma)return i}return n}):this.prerelease=[],this.build=r[5]?r[5].split("."):[],this.format()}N.prototype.format=function(){return this.version=this.major+"."+this.minor+"."+this.patch,this.prerelease.length&&(this.version+="-"+this.prerelease.join(".")),this.version};N.prototype.toString=function(){return this.version};N.prototype.compare=function(e){return k("SemVer.compare",this.version,this.options,e),e instanceof N||(e=new N(e,this.options)),this.compareMain(e)||this.comparePre(e)};N.prototype.compareMain=function(e){return e instanceof N||(e=new N(e,this.options)),ln(this.major,e.major)||ln(this.minor,e.minor)||ln(this.patch,e.patch)};N.prototype.comparePre=function(e){if(e instanceof N||(e=new N(e,this.options)),this.prerelease.length&&!e.prerelease.length)return-1;if(!this.prerelease.length&&e.prerelease.length)return 1;if(!this.prerelease.length&&!e.prerelease.length)return 0;var t=0;do{var r=this.prerelease[t],n=e.prerelease[t];if(k("prerelease compare",t,r,n),r===void 0&&n===void 0)return 0;if(n===void 0)return 1;if(r===void 0)return-1;if(r===n)continue;return ln(r,n)}while(++t)};N.prototype.inc=function(e,t){switch(e){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",t);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",t);break;case"prepatch":this.prerelease.length=0,this.inc("patch",t),this.inc("pre",t);break;case"prerelease":this.prerelease.length===0&&this.inc("patch",t),this.inc("pre",t);break;case"major":(this.minor!==0||this.patch!==0||this.prerelease.length===0)&&this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":(this.patch!==0||this.prerelease.length===0)&&this.minor++,this.patch=0,this.prerelease=[];break;case"patch":this.prerelease.length===0&&this.patch++,this.prerelease=[];break;case"pre":if(this.prerelease.length===0)this.prerelease=[0];else{for(var r=this.prerelease.length;--r>=0;)typeof this.prerelease[r]=="number"&&(this.prerelease[r]++,r=-2);r===-1&&this.prerelease.push(0)}t&&(this.prerelease[0]===t?isNaN(this.prerelease[1])&&(this.prerelease=[t,0]):this.prerelease=[t,0]);break;default:throw new Error("invalid increment argument: "+e)}return this.format(),this.raw=this.version,this};I.inc=TS;function TS(e,t,r,n){typeof r=="string"&&(n=r,r=void 0);try{return new N(e,r).inc(t,n).version}catch(i){return null}}I.diff=SS;function SS(e,t){if(wu(e,t))return null;var r=mr(e),n=mr(t),i="";if(r.prerelease.length||n.prerelease.length){i="pre";var a="prerelease"}for(var s in r)if((s==="major"||s==="minor"||s==="patch")&&r[s]!==n[s])return i+s;return a}I.compareIdentifiers=ln;var Nf=/^[0-9]+$/;function ln(e,t){var r=Nf.test(e),n=Nf.test(t);return r&&n&&(e=+e,t=+t),e===t?0:r&&!n?-1:n&&!r?1:e<t?-1:1}I.rcompareIdentifiers=AS;function AS(e,t){return ln(t,e)}I.major=IS;function IS(e,t){return new N(e,t).major}I.minor=bS;function bS(e,t){return new N(e,t).minor}I.patch=CS;function CS(e,t){return new N(e,t).patch}I.compare=bt;function bt(e,t,r){return new N(e,r).compare(new N(t,r))}I.compareLoose=OS;function OS(e,t){return bt(e,t,!0)}I.rcompare=PS;function PS(e,t,r){return bt(t,e,r)}I.sort=RS;function RS(e,t){return e.sort(function(r,n){return I.compare(r,n,t)})}I.rsort=NS;function NS(e,t){return e.sort(function(r,n){return I.rcompare(r,n,t)})}I.gt=Oi;function Oi(e,t,r){return bt(e,t,r)>0}I.lt=Ba;function Ba(e,t,r){return bt(e,t,r)<0}I.eq=wu;function wu(e,t,r){return bt(e,t,r)===0}I.neq=Df;function Df(e,t,r){return bt(e,t,r)!==0}I.gte=xu;function xu(e,t,r){return bt(e,t,r)>=0}I.lte=Mu;function Mu(e,t,r){return bt(e,t,r)<=0}I.cmp=Ga;function Ga(e,t,r,n){switch(t){case"===":return typeof e=="object"&&(e=e.version),typeof r=="object"&&(r=r.version),e===r;case"!==":return typeof e=="object"&&(e=e.version),typeof r=="object"&&(r=r.version),e!==r;case"":case"=":case"==":return wu(e,r,n);case"!=":return Df(e,r,n);case">":return Oi(e,r,n);case">=":return xu(e,r,n);case"<":return Ba(e,r,n);case"<=":return Mu(e,r,n);default:throw new TypeError("Invalid operator: "+t)}}I.Comparator=$e;function $e(e,t){if((!t||typeof t!="object")&&(t={loose:!!t,includePrerelease:!1}),e instanceof $e){if(e.loose===!!t.loose)return e;e=e.value}if(!(this instanceof $e))return new $e(e,t);k("comparator",e,t),this.options=t,this.loose=!!t.loose,this.parse(e),this.semver===Pi?this.value="":this.value=this.operator+this.semver.version,k("comp",this)}var Pi={};$e.prototype.parse=function(e){var t=this.options.loose?B[Nu]:B[Du],r=e.match(t);if(!r)throw new TypeError("Invalid comparator: "+e);this.operator=r[1],this.operator==="="&&(this.operator=""),r[2]?this.semver=new N(r[2],this.options.loose):this.semver=Pi};$e.prototype.toString=function(){return this.value};$e.prototype.test=function(e){return k("Comparator.test",e,this.options.loose),this.semver===Pi?!0:(typeof e=="string"&&(e=new N(e,this.options)),Ga(e,this.operator,this.semver,this.options))};$e.prototype.intersects=function(e,t){if(!(e instanceof $e))throw new TypeError("a Comparator is required");(!t||typeof t!="object")&&(t={loose:!!t,includePrerelease:!1});var r;if(this.operator==="")return r=new Z(e.value,t),Fa(this.value,r,t);if(e.operator==="")return r=new Z(this.value,t),Fa(e.semver,r,t);var n=(this.operator===">="||this.operator===">")&&(e.operator===">="||e.operator===">"),i=(this.operator==="<="||this.operator==="<")&&(e.operator==="<="||e.operator==="<"),a=this.semver.version===e.semver.version,s=(this.operator===">="||this.operator==="<=")&&(e.operator===">="||e.operator==="<="),o=Ga(this.semver,"<",e.semver,t)&&(this.operator===">="||this.operator===">")&&(e.operator==="<="||e.operator==="<"),u=Ga(this.semver,">",e.semver,t)&&(this.operator==="<="||this.operator==="<")&&(e.operator===">="||e.operator===">");return n||i||a&&s||o||u};I.Range=Z;function Z(e,t){if((!t||typeof t!="object")&&(t={loose:!!t,includePrerelease:!1}),e instanceof Z)return e.loose===!!t.loose&&e.includePrerelease===!!t.includePrerelease?e:new Z(e.raw,t);if(e instanceof $e)return new Z(e.value,t);if(!(this instanceof Z))return new Z(e,t);if(this.options=t,this.loose=!!t.loose,this.includePrerelease=!!t.includePrerelease,this.raw=e,this.set=e.split(/\s*\|\|\s*/).map(function(r){return this.parseRange(r.trim())},this).filter(function(r){return r.length}),!this.set.length)throw new TypeError("Invalid SemVer Range: "+e);this.format()}Z.prototype.format=function(){return this.range=this.set.map(function(e){return e.join(" ").trim()}).join("||").trim(),this.range};Z.prototype.toString=function(){return this.range};Z.prototype.parseRange=function(e){var t=this.options.loose;e=e.trim();var r=t?B[Pf]:B[Of];e=e.replace(r,US),k("hyphen replace",e),e=e.replace(B[Ci],ES),k("comparator trim",e,B[Ci]),e=e.replace(B[ka],vS),e=e.replace(B[Ua],gS),e=e.split(/\s+/).join(" ");var n=t?B[Nu]:B[Du],i=e.split(" ").map(function(a){return wS(a,this.options)},this).join(" ").split(/\s+/);return this.options.loose&&(i=i.filter(function(a){return!!a.match(n)})),i=i.map(function(a){return new $e(a,this.options)},this),i};Z.prototype.intersects=function(e,t){if(!(e instanceof Z))throw new TypeError("a Range is required");return this.set.some(function(r){return r.every(function(n){return e.set.some(function(i){return i.every(function(a){return n.intersects(a,t)})})})})};I.toComparators=DS;function DS(e,t){return new Z(e,t).set.map(function(r){return r.map(function(n){return n.value}).join(" ").trim().split(" ")})}function wS(e,t){return k("comp",e,t),e=LS(e,t),k("caret",e),e=xS(e,t),k("tildes",e),e=jS(e,t),k("xrange",e),e=HS(e,t),k("stars",e),e}function Re(e){return!e||e.toLowerCase()==="x"||e==="*"}function xS(e,t){return e.trim().split(/\s+/).map(function(r){return MS(r,t)}).join(" ")}function MS(e,t){var r=t.loose?B[If]:B[Af];return e.replace(r,function(n,i,a,s,o){k("tilde",e,n,i,a,s,o);var u;return Re(i)?u="":Re(a)?u=">="+i+".0.0 <"+(+i+1)+".0.0":Re(s)?u=">="+i+"."+a+".0 <"+i+"."+(+a+1)+".0":o?(k("replaceTilde pr",o),u=">="+i+"."+a+"."+s+"-"+o+" <"+i+"."+(+a+1)+".0"):u=">="+i+"."+a+"."+s+" <"+i+"."+(+a+1)+".0",k("tilde return",u),u})}function LS(e,t){return e.trim().split(/\s+/).map(function(r){return qS(r,t)}).join(" ")}function qS(e,t){k("caret",e,t);var r=t.loose?B[Cf]:B[bf];return e.replace(r,function(n,i,a,s,o){k("caret",e,n,i,a,s,o);var u;return Re(i)?u="":Re(a)?u=">="+i+".0.0 <"+(+i+1)+".0.0":Re(s)?i==="0"?u=">="+i+"."+a+".0 <"+i+"."+(+a+1)+".0":u=">="+i+"."+a+".0 <"+(+i+1)+".0.0":o?(k("replaceCaret pr",o),i==="0"?a==="0"?u=">="+i+"."+a+"."+s+"-"+o+" <"+i+"."+a+"."+(+s+1):u=">="+i+"."+a+"."+s+"-"+o+" <"+i+"."+(+a+1)+".0":u=">="+i+"."+a+"."+s+"-"+o+" <"+(+i+1)+".0.0"):(k("no pr"),i==="0"?a==="0"?u=">="+i+"."+a+"."+s+" <"+i+"."+a+"."+(+s+1):u=">="+i+"."+a+"."+s+" <"+i+"."+(+a+1)+".0":u=">="+i+"."+a+"."+s+" <"+(+i+1)+".0.0"),k("caret return",u),u})}function jS(e,t){return k("replaceXRanges",e,t),e.split(/\s+/).map(function(r){return kS(r,t)}).join(" ")}function kS(e,t){e=e.trim();var r=t.loose?B[Tf]:B[yf];return e.replace(r,function(n,i,a,s,o,u){k("xRange",e,n,i,a,s,o,u);var c=Re(a),p=c||Re(s),f=p||Re(o),d=f;return i==="="&&d&&(i=""),c?i===">"||i==="<"?n="<0.0.0":n="*":i&&d?(p&&(s=0),o=0,i===">"?(i=">=",p?(a=+a+1,s=0,o=0):(s=+s+1,o=0)):i==="<="&&(i="<",p?a=+a+1:s=+s+1),n=i+a+"."+s+"."+o):p?n=">="+a+".0.0 <"+(+a+1)+".0.0":f&&(n=">="+a+"."+s+".0 <"+a+"."+(+s+1)+".0"),k("xRange return",n),n})}function HS(e,t){return k("replaceStars",e,t),e.trim().replace(B[Rf],"")}function US(e,t,r,n,i,a,s,o,u,c,p,f,d){return Re(r)?t="":Re(n)?t=">="+r+".0.0":Re(i)?t=">="+r+"."+n+".0":t=">="+t,Re(u)?o="":Re(c)?o="<"+(+u+1)+".0.0":Re(p)?o="<"+u+"."+(+c+1)+".0":f?o="<="+u+"."+c+"."+p+"-"+f:o="<="+o,(t+" "+o).trim()}Z.prototype.test=function(e){if(!e)return!1;typeof e=="string"&&(e=new N(e,this.options));for(var t=0;t<this.set.length;t++)if(BS(this.set[t],e,this.options))return!0;return!1};function BS(e,t,r){for(var n=0;n<e.length;n++)if(!e[n].test(t))return!1;if(t.prerelease.length&&!r.includePrerelease){for(n=0;n<e.length;n++)if(k(e[n].semver),e[n].semver!==Pi&&e[n].semver.prerelease.length>0){var i=e[n].semver;if(i.major===t.major&&i.minor===t.minor&&i.patch===t.patch)return!0}return!1}return!0}I.satisfies=Fa;function Fa(e,t,r){try{t=new Z(t,r)}catch(n){return!1}return t.test(e)}I.maxSatisfying=GS;function GS(e,t,r){var n=null,i=null;try{var a=new Z(t,r)}catch(s){return null}return e.forEach(function(s){a.test(s)&&(!n||i.compare(s)===-1)&&(n=s,i=new N(n,r))}),n}I.minSatisfying=FS;function FS(e,t,r){var n=null,i=null;try{var a=new Z(t,r)}catch(s){return null}return e.forEach(function(s){a.test(s)&&(!n||i.compare(s)===1)&&(n=s,i=new N(n,r))}),n}I.minVersion=VS;function VS(e,t){e=new Z(e,t);var r=new N("0.0.0");if(e.test(r)||(r=new N("0.0.0-0"),e.test(r)))return r;r=null;for(var n=0;n<e.set.length;++n){var i=e.set[n];i.forEach(function(a){var s=new N(a.semver.version);switch(a.operator){case">":s.prerelease.length===0?s.patch++:s.prerelease.push(0),s.raw=s.format();case"":case">=":(!r||Oi(r,s))&&(r=s);break;case"<":case"<=":break;default:throw new Error("Unexpected operation: "+a.operator)}})}return r&&e.test(r)?r:null}I.validRange=$S;function $S(e,t){try{return new Z(e,t).range||"*"}catch(r){return null}}I.ltr=zS;function zS(e,t,r){return Lu(e,t,"<",r)}I.gtr=KS;function KS(e,t,r){return Lu(e,t,">",r)}I.outside=Lu;function Lu(e,t,r,n){e=new N(e,n),t=new Z(t,n);var i,a,s,o,u;switch(r){case">":i=Oi,a=Mu,s=Ba,o=">",u=">=";break;case"<":i=Ba,a=xu,s=Oi,o="<",u="<=";break;default:throw new TypeError('Must provide a hilo val of "<" or ">"')}if(Fa(e,t,n))return!1;for(var c=0;c<t.set.length;++c){var p=t.set[c],f=null,d=null;if(p.forEach(function(h){h.semver===Pi&&(h=new $e(">=0.0.0")),f=f||h,d=d||h,i(h.semver,f.semver,n)?f=h:s(h.semver,d.semver,n)&&(d=h)}),f.operator===o||f.operator===u||(!d.operator||d.operator===o)&&a(e,d.semver))return!1;if(d.operator===u&&s(e,d.semver))return!1}return!0}I.prerelease=XS;function XS(e,t){var r=mr(e,t);return r&&r.prerelease.length?r.prerelease:null}I.intersects=YS;function YS(e,t,r){return e=new Z(e,r),t=new Z(t,r),e.intersects(t)}I.coerce=QS;function QS(e){if(e instanceof N)return e;if(typeof e!="string")return null;var t=e.match(B[Sf]);return t==null?null:mr(t[1]+"."+(t[2]||"0")+"."+(t[3]||"0"))}});var qu=l(Va=>{"use strict";Object.defineProperty(Va,"__esModule",{value:!0});Va.makePatchingRequire=void 0;var WS=__webpack_require__(5622),ZS=xf(),Mf=__webpack_require__(2282),JS=Object.keys(process.binding("natives")),Lf=Mf.prototype.require;function eA(e){var t={};return function(n){var i=Lf.apply(this,arguments);if(e[n]){var a=Mf._resolveFilename(n,this);if(t.hasOwnProperty(a))return t[a];var s=void 0;if(JS.indexOf(n)<0)try{s=Lf.call(this,WS.join(n,"package.json")).version}catch(d){return i}else s=process.version.substring(1);var o=s.indexOf("-");o>=0&&(s=s.substring(0,o));for(var u=i,c=0,p=e[n];c<p.length;c++){var f=p[c];ZS.satisfies(s,f.versionSpecifier)&&(u=f.patch(u,a))}return t[a]=u}return i}}Va.makePatchingRequire=eA});var qf=l((Qx,tA)=>{tA.exports={name:"diagnostic-channel",version:"1.0.0",main:"./dist/src/channel.js",types:"./dist/src/channel.d.ts",scripts:{build:"tsc",lint:"tslint -c tslint.json -p tsconfig.json",clean:"rimraf ./dist",test:"mocha ./dist/tests/**/*.js"},homepage:"https://github.com/Microsoft/node-diagnostic-channel",bugs:{url:"https://github.com/Microsoft/node-diagnostic-channel/issues"},repository:{type:"git",url:"https://github.com/Microsoft/node-diagnostic-channel.git"},description:"Provides a context-saving pub/sub channel to connect diagnostic event publishers and subscribers",dependencies:{semver:"^5.3.0"},devDependencies:{"@types/mocha":"^2.2.40","@types/node":"~8.0.0",mocha:"^3.2.0",rimraf:"^2.6.1",tslint:"^5.0.0",typescript:"4.1.2"},files:["dist/src/**/*.d.ts","dist/src/**/*.js","LICENSE","README.md","package.json"],license:"MIT"}});var ue=l(pn=>{"use strict";Object.defineProperty(pn,"__esModule",{value:!0});pn.channel=pn.makePatchingRequire=void 0;var rA=qu(),nA=qu();Object.defineProperty(pn,"makePatchingRequire",{enumerable:!0,get:function(){return nA.makePatchingRequire}});var jf=function(e){return!0},iA=function(){function e(){this.version=qf().version,this.subscribers={},this.contextPreservationFunction=function(t){return t},this.knownPatches={},this.currentlyPublishing=!1}return e.prototype.shouldPublish=function(t){var r=this.subscribers[t];return r?r.some(function(n){var i=n.filter;return!i||i(!1)}):!1},e.prototype.publish=function(t,r){if(!this.currentlyPublishing){var n=this.subscribers[t];if(n){var i={timestamp:Date.now(),data:r};this.currentlyPublishing=!0,n.forEach(function(a){var s=a.listener,o=a.filter;try{o&&o(!0)&&s(i)}catch(u){}}),this.currentlyPublishing=!1}}},e.prototype.subscribe=function(t,r,n){n===void 0&&(n=jf),this.subscribers[t]||(this.subscribers[t]=[]),this.subscribers[t].push({listener:r,filter:n})},e.prototype.unsubscribe=function(t,r,n){n===void 0&&(n=jf);var i=this.subscribers[t];if(i){for(var a=0;a<i.length;++a)if(i[a].listener===r&&i[a].filter===n)return i.splice(a,1),!0}return!1},e.prototype.reset=function(){var t=this;this.subscribers={},this.contextPreservationFunction=function(r){return r},Object.getOwnPropertyNames(this.knownPatches).forEach(function(r){return delete t.knownPatches[r]})},e.prototype.bindToContext=function(t){return this.contextPreservationFunction(t)},e.prototype.addContextPreservation=function(t){var r=this.contextPreservationFunction;this.contextPreservationFunction=function(n){return t(r(n))}},e.prototype.registerMonkeyPatch=function(t,r){this.knownPatches[t]||(this.knownPatches[t]=[]),this.knownPatches[t].push(r)},e.prototype.getPatchesObject=function(){return this.knownPatches},e}();global.diagnosticsSource||(global.diagnosticsSource=new iA,kf=__webpack_require__(2282),kf.prototype.require=rA.makePatchingRequire(global.diagnosticsSource.getPatchesObject()));var kf;pn.channel=global.diagnosticsSource});var Uf=l(Hf=>{"use strict";Object.defineProperty(Hf,"__esModule",{value:!0})});var Bf=l($a=>{"use strict";Object.defineProperty($a,"__esModule",{value:!0});$a._globalThis=void 0;$a._globalThis=typeof globalThis=="object"?globalThis:global});var Gf=l(yr=>{"use strict";var aA=yr&&yr.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),sA=yr&&yr.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&aA(t,e,r)};Object.defineProperty(yr,"__esModule",{value:!0});sA(Bf(),yr)});var Ff=l(Tr=>{"use strict";var oA=Tr&&Tr.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),uA=Tr&&Tr.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&oA(t,e,r)};Object.defineProperty(Tr,"__esModule",{value:!0});uA(Gf(),Tr)});var ju=l(za=>{"use strict";Object.defineProperty(za,"__esModule",{value:!0});za.VERSION=void 0;za.VERSION="1.0.3"});var zf=l(fn=>{"use strict";Object.defineProperty(fn,"__esModule",{value:!0});fn.isCompatible=fn._makeCompatibilityCheck=void 0;var cA=ju(),Vf=/^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;function $f(e){var t=new Set([e]),r=new Set,n=e.match(Vf);if(!n)return function(){return!1};var i={major:+n[1],minor:+n[2],patch:+n[3],prerelease:n[4]};if(i.prerelease!=null)return function(u){return u===e};function a(o){return r.add(o),!1}function s(o){return t.add(o),!0}return function(u){if(t.has(u))return!0;if(r.has(u))return!1;var c=u.match(Vf);if(!c)return a(u);var p={major:+c[1],minor:+c[2],patch:+c[3],prerelease:c[4]};return p.prerelease!=null||i.major!==p.major?a(u):i.major===0?i.minor===p.minor&&i.patch<=p.patch?s(u):a(u):i.minor<=p.minor?s(u):a(u)}}fn._makeCompatibilityCheck=$f;fn.isCompatible=$f(cA.VERSION)});var dn=l($t=>{"use strict";Object.defineProperty($t,"__esModule",{value:!0});$t.unregisterGlobal=$t.getGlobal=$t.registerGlobal=void 0;var lA=Ff(),Ri=ju(),pA=zf(),fA=Ri.VERSION.split(".")[0],Ni=Symbol.for("opentelemetry.js.api."+fA),Di=lA._globalThis;function dA(e,t,r,n){var i;n===void 0&&(n=!1);var a=Di[Ni]=(i=Di[Ni])!==null&&i!==void 0?i:{version:Ri.VERSION};if(!n&&a[e]){var s=new Error("@opentelemetry/api: Attempted duplicate registration of API: "+e);return r.error(s.stack||s.message),!1}if(a.version!==Ri.VERSION){var s=new Error("@opentelemetry/api: All API registration versions must match");return r.error(s.stack||s.message),!1}return a[e]=t,r.debug("@opentelemetry/api: Registered a global for "+e+" v"+Ri.VERSION+"."),!0}$t.registerGlobal=dA;function hA(e){var t,r,n=(t=Di[Ni])===null||t===void 0?void 0:t.version;if(!(!n||!pA.isCompatible(n)))return(r=Di[Ni])===null||r===void 0?void 0:r[e]}$t.getGlobal=hA;function _A(e,t){t.debug("@opentelemetry/api: Unregistering a global for "+e+" v"+Ri.VERSION+".");var r=Di[Ni];r&&delete r[e]}$t.unregisterGlobal=_A});var Kf=l(Ka=>{"use strict";Object.defineProperty(Ka,"__esModule",{value:!0});Ka.DiagComponentLogger=void 0;var vA=dn(),gA=function(){function e(t){this._namespace=t.namespace||"DiagComponentLogger"}return e.prototype.debug=function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];return wi("debug",this._namespace,t)},e.prototype.error=function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];return wi("error",this._namespace,t)},e.prototype.info=function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];return wi("info",this._namespace,t)},e.prototype.warn=function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];return wi("warn",this._namespace,t)},e.prototype.verbose=function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];return wi("verbose",this._namespace,t)},e}();Ka.DiagComponentLogger=gA;function wi(e,t,r){var n=vA.getGlobal("diag");if(!!n)return r.unshift(t),n[e].apply(n,r)}});var Xa=l(xi=>{"use strict";Object.defineProperty(xi,"__esModule",{value:!0});xi.DiagLogLevel=void 0;var EA;(function(e){e[e.NONE=0]="NONE",e[e.ERROR=30]="ERROR",e[e.WARN=50]="WARN",e[e.INFO=60]="INFO",e[e.DEBUG=70]="DEBUG",e[e.VERBOSE=80]="VERBOSE",e[e.ALL=9999]="ALL"})(EA=xi.DiagLogLevel||(xi.DiagLogLevel={}))});var Xf=l(Ya=>{"use strict";Object.defineProperty(Ya,"__esModule",{value:!0});Ya.createLogLevelDiagLogger=void 0;var Ct=Xa();function mA(e,t){e<Ct.DiagLogLevel.NONE?e=Ct.DiagLogLevel.NONE:e>Ct.DiagLogLevel.ALL&&(e=Ct.DiagLogLevel.ALL),t=t||{};function r(n,i){var a=t[n];return typeof a=="function"&&e>=i?a.bind(t):function(){}}return{error:r("error",Ct.DiagLogLevel.ERROR),warn:r("warn",Ct.DiagLogLevel.WARN),info:r("info",Ct.DiagLogLevel.INFO),debug:r("debug",Ct.DiagLogLevel.DEBUG),verbose:r("verbose",Ct.DiagLogLevel.VERBOSE)}}Ya.createLogLevelDiagLogger=mA});var hn=l(Wa=>{"use strict";Object.defineProperty(Wa,"__esModule",{value:!0});Wa.DiagAPI=void 0;var yA=Kf(),TA=Xf(),SA=Xa(),Qa=dn(),AA="diag",IA=function(){function e(){function t(n){return function(){var i=Qa.getGlobal("diag");if(!!i)return i[n].apply(i,arguments)}}var r=this;r.setLogger=function(n,i){var a,s;if(i===void 0&&(i=SA.DiagLogLevel.INFO),n===r){var o=new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");return r.error((a=o.stack)!==null&&a!==void 0?a:o.message),!1}var u=Qa.getGlobal("diag"),c=TA.createLogLevelDiagLogger(i,n);if(u){var p=(s=new Error().stack)!==null&&s!==void 0?s:"<failed to generate stacktrace>";u.warn("Current logger will be overwritten from "+p),c.warn("Current logger will overwrite one already registered from "+p)}return Qa.registerGlobal("diag",c,r,!0)},r.disable=function(){Qa.unregisterGlobal(AA,r)},r.createComponentLogger=function(n){return new yA.DiagComponentLogger(n)},r.verbose=t("verbose"),r.debug=t("debug"),r.info=t("info"),r.warn=t("warn"),r.error=t("error")}return e.instance=function(){return this._instance||(this._instance=new e),this._instance},e}();Wa.DiagAPI=IA});var Yf=l(Za=>{"use strict";Object.defineProperty(Za,"__esModule",{value:!0});Za.BaggageImpl=void 0;var bA=function(){function e(t){this._entries=t?new Map(t):new Map}return e.prototype.getEntry=function(t){var r=this._entries.get(t);if(!!r)return Object.assign({},r)},e.prototype.getAllEntries=function(){return Array.from(this._entries.entries()).map(function(t){var r=t[0],n=t[1];return[r,n]})},e.prototype.setEntry=function(t,r){var n=new e(this._entries);return n._entries.set(t,r),n},e.prototype.removeEntry=function(t){var r=new e(this._entries);return r._entries.delete(t),r},e.prototype.removeEntries=function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];for(var n=new e(this._entries),i=0,a=t;i<a.length;i++){var s=a[i];n._entries.delete(s)}return n},e.prototype.clear=function(){return new e},e}();Za.BaggageImpl=bA});var Qf=l(Ja=>{"use strict";Object.defineProperty(Ja,"__esModule",{value:!0});Ja.baggageEntryMetadataSymbol=void 0;Ja.baggageEntryMetadataSymbol=Symbol("BaggageEntryMetadata")});var ku=l(_n=>{"use strict";Object.defineProperty(_n,"__esModule",{value:!0});_n.baggageEntryMetadataFromString=_n.createBaggage=void 0;var CA=hn(),OA=Yf(),PA=Qf(),RA=CA.DiagAPI.instance();function NA(e){return e===void 0&&(e={}),new OA.BaggageImpl(new Map(Object.entries(e)))}_n.createBaggage=NA;function DA(e){return typeof e!="string"&&(RA.error("Cannot create baggage metadata from unknown type: "+typeof e),e=""),{__TYPE__:PA.baggageEntryMetadataSymbol,toString:function(){return e}}}_n.baggageEntryMetadataFromString=DA});var Zf=l(Wf=>{"use strict";Object.defineProperty(Wf,"__esModule",{value:!0})});var ed=l(Jf=>{"use strict";Object.defineProperty(Jf,"__esModule",{value:!0})});var td=l(es=>{"use strict";Object.defineProperty(es,"__esModule",{value:!0});es.DiagConsoleLogger=void 0;var Hu=[{n:"error",c:"error"},{n:"warn",c:"warn"},{n:"info",c:"info"},{n:"debug",c:"debug"},{n:"verbose",c:"trace"}],wA=function(){function e(){function t(n){return function(){var i=arguments;if(console){var a=console[n];if(typeof a!="function"&&(a=console.log),typeof a=="function")return a.apply(console,i)}}}for(var r=0;r<Hu.length;r++)this[Hu[r].n]=t(Hu[r].c)}return e}();es.DiagConsoleLogger=wA});var nd=l(zt=>{"use strict";var xA=zt&&zt.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),rd=zt&&zt.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&xA(t,e,r)};Object.defineProperty(zt,"__esModule",{value:!0});rd(td(),zt);rd(Xa(),zt)});var Uu=l(vn=>{"use strict";Object.defineProperty(vn,"__esModule",{value:!0});vn.defaultTextMapSetter=vn.defaultTextMapGetter=void 0;vn.defaultTextMapGetter={get:function(e,t){if(e!=null)return e[t]},keys:function(e){return e==null?[]:Object.keys(e)}};vn.defaultTextMapSetter={set:function(e,t,r){e!=null&&(e[t]=r)}}});var ad=l(id=>{"use strict";Object.defineProperty(id,"__esModule",{value:!0})});var od=l(sd=>{"use strict";Object.defineProperty(sd,"__esModule",{value:!0})});var Mi=l(gn=>{"use strict";Object.defineProperty(gn,"__esModule",{value:!0});gn.ROOT_CONTEXT=gn.createContextKey=void 0;function MA(e){return Symbol.for(e)}gn.createContextKey=MA;var LA=function(){function e(t){var r=this;r._currentContext=t?new Map(t):new Map,r.getValue=function(n){return r._currentContext.get(n)},r.setValue=function(n,i){var a=new e(r._currentContext);return a._currentContext.set(n,i),a},r.deleteValue=function(n){var i=new e(r._currentContext);return i._currentContext.delete(n),i}}return e}();gn.ROOT_CONTEXT=new LA});var ud=l(En=>{"use strict";var qA=En&&En.__spreadArray||function(e,t){for(var r=0,n=t.length,i=e.length;r<n;r++,i++)e[i]=t[r];return e};Object.defineProperty(En,"__esModule",{value:!0});En.NoopContextManager=void 0;var jA=Mi(),kA=function(){function e(){}return e.prototype.active=function(){return jA.ROOT_CONTEXT},e.prototype.with=function(t,r,n){for(var i=[],a=3;a<arguments.length;a++)i[a-3]=arguments[a];return r.call.apply(r,qA([n],i))},e.prototype.bind=function(t,r){return r},e.prototype.enable=function(){return this},e.prototype.disable=function(){return this},e}();En.NoopContextManager=kA});var Fu=l(mn=>{"use strict";var HA=mn&&mn.__spreadArray||function(e,t){for(var r=0,n=t.length,i=e.length;r<n;r++,i++)e[i]=t[r];return e};Object.defineProperty(mn,"__esModule",{value:!0});mn.ContextAPI=void 0;var UA=ud(),Bu=dn(),cd=hn(),Gu="context",BA=new UA.NoopContextManager,GA=function(){function e(){}return e.getInstance=function(){return this._instance||(this._instance=new e),this._instance},e.prototype.setGlobalContextManager=function(t){return Bu.registerGlobal(Gu,t,cd.DiagAPI.instance())},e.prototype.active=function(){return this._getContextManager().active()},e.prototype.with=function(t,r,n){for(var i,a=[],s=3;s<arguments.length;s++)a[s-3]=arguments[s];return(i=this._getContextManager()).with.apply(i,HA([t,r,n],a))},e.prototype.bind=function(t,r){return this._getContextManager().bind(t,r)},e.prototype._getContextManager=function(){return Bu.getGlobal(Gu)||BA},e.prototype.disable=function(){this._getContextManager().disable(),Bu.unregisterGlobal(Gu,cd.DiagAPI.instance())},e}();mn.ContextAPI=GA});var Vu=l(Li=>{"use strict";Object.defineProperty(Li,"__esModule",{value:!0});Li.TraceFlags=void 0;var FA;(function(e){e[e.NONE=0]="NONE",e[e.SAMPLED=1]="SAMPLED"})(FA=Li.TraceFlags||(Li.TraceFlags={}))});var ts=l(lt=>{"use strict";Object.defineProperty(lt,"__esModule",{value:!0});lt.INVALID_SPAN_CONTEXT=lt.INVALID_TRACEID=lt.INVALID_SPANID=void 0;var VA=Vu();lt.INVALID_SPANID="0000000000000000";lt.INVALID_TRACEID="00000000000000000000000000000000";lt.INVALID_SPAN_CONTEXT={traceId:lt.INVALID_TRACEID,spanId:lt.INVALID_SPANID,traceFlags:VA.TraceFlags.NONE}});var ns=l(rs=>{"use strict";Object.defineProperty(rs,"__esModule",{value:!0});rs.NonRecordingSpan=void 0;var $A=ts(),zA=function(){function e(t){t===void 0&&(t=$A.INVALID_SPAN_CONTEXT),this._spanContext=t}return e.prototype.spanContext=function(){return this._spanContext},e.prototype.setAttribute=function(t,r){return this},e.prototype.setAttributes=function(t){return this},e.prototype.addEvent=function(t,r){return this},e.prototype.setStatus=function(t){return this},e.prototype.updateName=function(t){return this},e.prototype.end=function(t){},e.prototype.isRecording=function(){return!1},e.prototype.recordException=function(t,r){},e}();rs.NonRecordingSpan=zA});var zu=l(ze=>{"use strict";Object.defineProperty(ze,"__esModule",{value:!0});ze.getSpanContext=ze.setSpanContext=ze.deleteSpan=ze.setSpan=ze.getSpan=void 0;var KA=Mi(),XA=ns(),$u=KA.createContextKey("OpenTelemetry Context Key SPAN");function ld(e){return e.getValue($u)||void 0}ze.getSpan=ld;function pd(e,t){return e.setValue($u,t)}ze.setSpan=pd;function YA(e){return e.deleteValue($u)}ze.deleteSpan=YA;function QA(e,t){return pd(e,new XA.NonRecordingSpan(t))}ze.setSpanContext=QA;function WA(e){var t;return(t=ld(e))===null||t===void 0?void 0:t.spanContext()}ze.getSpanContext=WA});var is=l(pt=>{"use strict";Object.defineProperty(pt,"__esModule",{value:!0});pt.wrapSpanContext=pt.isSpanContextValid=pt.isValidSpanId=pt.isValidTraceId=void 0;var fd=ts(),ZA=ns(),JA=/^([0-9a-f]{32})$/i,eI=/^[0-9a-f]{16}$/i;function dd(e){return JA.test(e)&&e!==fd.INVALID_TRACEID}pt.isValidTraceId=dd;function hd(e){return eI.test(e)&&e!==fd.INVALID_SPANID}pt.isValidSpanId=hd;function tI(e){return dd(e.traceId)&&hd(e.spanId)}pt.isSpanContextValid=tI;function rI(e){return new ZA.NonRecordingSpan(e)}pt.wrapSpanContext=rI});var Xu=l(as=>{"use strict";Object.defineProperty(as,"__esModule",{value:!0});as.NoopTracer=void 0;var nI=Fu(),_d=zu(),Ku=ns(),iI=is(),vd=nI.ContextAPI.getInstance(),aI=function(){function e(){}return e.prototype.startSpan=function(t,r,n){var i=Boolean(r==null?void 0:r.root);if(i)return new Ku.NonRecordingSpan;var a=n&&_d.getSpanContext(n);return sI(a)&&iI.isSpanContextValid(a)?new Ku.NonRecordingSpan(a):new Ku.NonRecordingSpan},e.prototype.startActiveSpan=function(t,r,n,i){var a,s,o;if(!(arguments.length<2)){arguments.length===2?o=r:arguments.length===3?(a=r,o=n):(a=r,s=n,o=i);var u=s!=null?s:vd.active(),c=this.startSpan(t,a,u),p=_d.setSpan(u,c);return vd.with(p,o,void 0,c)}},e}();as.NoopTracer=aI;function sI(e){return typeof e=="object"&&typeof e.spanId=="string"&&typeof e.traceId=="string"&&typeof e.traceFlags=="number"}});var Yu=l(ss=>{"use strict";Object.defineProperty(ss,"__esModule",{value:!0});ss.ProxyTracer=void 0;var oI=Xu(),uI=new oI.NoopTracer,cI=function(){function e(t,r,n){this._provider=t,this.name=r,this.version=n}return e.prototype.startSpan=function(t,r,n){return this._getTracer().startSpan(t,r,n)},e.prototype.startActiveSpan=function(t,r,n,i){var a=this._getTracer();return Reflect.apply(a.startActiveSpan,a,arguments)},e.prototype._getTracer=function(){if(this._delegate)return this._delegate;var t=this._provider.getDelegateTracer(this.name,this.version);return t?(this._delegate=t,this._delegate):uI},e}();ss.ProxyTracer=cI});var gd=l(os=>{"use strict";Object.defineProperty(os,"__esModule",{value:!0});os.NoopTracerProvider=void 0;var lI=Xu(),pI=function(){function e(){}return e.prototype.getTracer=function(t,r){return new lI.NoopTracer},e}();os.NoopTracerProvider=pI});var Qu=l(us=>{"use strict";Object.defineProperty(us,"__esModule",{value:!0});us.ProxyTracerProvider=void 0;var fI=Yu(),dI=gd(),hI=new dI.NoopTracerProvider,_I=function(){function e(){}return e.prototype.getTracer=function(t,r){var n;return(n=this.getDelegateTracer(t,r))!==null&&n!==void 0?n:new fI.ProxyTracer(this,t,r)},e.prototype.getDelegate=function(){var t;return(t=this._delegate)!==null&&t!==void 0?t:hI},e.prototype.setDelegate=function(t){this._delegate=t},e.prototype.getDelegateTracer=function(t,r){var n;return(n=this._delegate)===null||n===void 0?void 0:n.getTracer(t,r)},e}();us.ProxyTracerProvider=_I});var md=l(Ed=>{"use strict";Object.defineProperty(Ed,"__esModule",{value:!0})});var yd=l(qi=>{"use strict";Object.defineProperty(qi,"__esModule",{value:!0});qi.SamplingDecision=void 0;var vI;(function(e){e[e.NOT_RECORD=0]="NOT_RECORD",e[e.RECORD=1]="RECORD",e[e.RECORD_AND_SAMPLED=2]="RECORD_AND_SAMPLED"})(vI=qi.SamplingDecision||(qi.SamplingDecision={}))});var Sd=l(Td=>{"use strict";Object.defineProperty(Td,"__esModule",{value:!0})});var Ad=l(ji=>{"use strict";Object.defineProperty(ji,"__esModule",{value:!0});ji.SpanKind=void 0;var gI;(function(e){e[e.INTERNAL=0]="INTERNAL",e[e.SERVER=1]="SERVER",e[e.CLIENT=2]="CLIENT",e[e.PRODUCER=3]="PRODUCER",e[e.CONSUMER=4]="CONSUMER"})(gI=ji.SpanKind||(ji.SpanKind={}))});var bd=l(Id=>{"use strict";Object.defineProperty(Id,"__esModule",{value:!0})});var Od=l(Cd=>{"use strict";Object.defineProperty(Cd,"__esModule",{value:!0})});var Pd=l(ki=>{"use strict";Object.defineProperty(ki,"__esModule",{value:!0});ki.SpanStatusCode=void 0;var EI;(function(e){e[e.UNSET=0]="UNSET",e[e.OK=1]="OK",e[e.ERROR=2]="ERROR"})(EI=ki.SpanStatusCode||(ki.SpanStatusCode={}))});var Nd=l(Rd=>{"use strict";Object.defineProperty(Rd,"__esModule",{value:!0})});var wd=l(Dd=>{"use strict";Object.defineProperty(Dd,"__esModule",{value:!0})});var Md=l(xd=>{"use strict";Object.defineProperty(xd,"__esModule",{value:!0})});var qd=l(Ld=>{"use strict";Object.defineProperty(Ld,"__esModule",{value:!0})});var Ud=l(cs=>{"use strict";Object.defineProperty(cs,"__esModule",{value:!0});cs.TraceAPI=void 0;var Wu=dn(),jd=Qu(),kd=is(),Hi=zu(),Hd=hn(),Zu="trace",mI=function(){function e(){this._proxyTracerProvider=new jd.ProxyTracerProvider,this.wrapSpanContext=kd.wrapSpanContext,this.isSpanContextValid=kd.isSpanContextValid,this.deleteSpan=Hi.deleteSpan,this.getSpan=Hi.getSpan,this.getSpanContext=Hi.getSpanContext,this.setSpan=Hi.setSpan,this.setSpanContext=Hi.setSpanContext}return e.getInstance=function(){return this._instance||(this._instance=new e),this._instance},e.prototype.setGlobalTracerProvider=function(t){var r=Wu.registerGlobal(Zu,this._proxyTracerProvider,Hd.DiagAPI.instance());return r&&this._proxyTracerProvider.setDelegate(t),r},e.prototype.getTracerProvider=function(){return Wu.getGlobal(Zu)||this._proxyTracerProvider},e.prototype.getTracer=function(t,r){return this.getTracerProvider().getTracer(t,r)},e.prototype.disable=function(){Wu.unregisterGlobal(Zu,Hd.DiagAPI.instance()),this._proxyTracerProvider=new jd.ProxyTracerProvider},e}();cs.TraceAPI=mI});var Bd=l(ls=>{"use strict";Object.defineProperty(ls,"__esModule",{value:!0});ls.NoopTextMapPropagator=void 0;var yI=function(){function e(){}return e.prototype.inject=function(t,r){},e.prototype.extract=function(t,r){return t},e.prototype.fields=function(){return[]},e}();ls.NoopTextMapPropagator=yI});var Gd=l(Kt=>{"use strict";Object.defineProperty(Kt,"__esModule",{value:!0});Kt.deleteBaggage=Kt.setBaggage=Kt.getBaggage=void 0;var TI=Mi(),Ju=TI.createContextKey("OpenTelemetry Baggage Key");function SI(e){return e.getValue(Ju)||void 0}Kt.getBaggage=SI;function AI(e,t){return e.setValue(Ju,t)}Kt.setBaggage=AI;function II(e){return e.deleteValue(Ju)}Kt.deleteBaggage=II});var $d=l(ps=>{"use strict";Object.defineProperty(ps,"__esModule",{value:!0});ps.PropagationAPI=void 0;var ec=dn(),bI=Bd(),Fd=Uu(),tc=Gd(),CI=ku(),Vd=hn(),rc="propagation",OI=new bI.NoopTextMapPropagator,PI=function(){function e(){this.createBaggage=CI.createBaggage,this.getBaggage=tc.getBaggage,this.setBaggage=tc.setBaggage,this.deleteBaggage=tc.deleteBaggage}return e.getInstance=function(){return this._instance||(this._instance=new e),this._instance},e.prototype.setGlobalPropagator=function(t){return ec.registerGlobal(rc,t,Vd.DiagAPI.instance())},e.prototype.inject=function(t,r,n){return n===void 0&&(n=Fd.defaultTextMapSetter),this._getGlobalPropagator().inject(t,r,n)},e.prototype.extract=function(t,r,n){return n===void 0&&(n=Fd.defaultTextMapGetter),this._getGlobalPropagator().extract(t,r,n)},e.prototype.fields=function(){return this._getGlobalPropagator().fields()},e.prototype.disable=function(){ec.unregisterGlobal(rc,Vd.DiagAPI.instance())},e.prototype._getGlobalPropagator=function(){return ec.getGlobal(rc)||OI},e}();ps.PropagationAPI=PI});var z=l(y=>{"use strict";var RI=y&&y.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),ne=y&&y.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&RI(t,e,r)};Object.defineProperty(y,"__esModule",{value:!0});y.diag=y.propagation=y.trace=y.context=y.INVALID_SPAN_CONTEXT=y.INVALID_TRACEID=y.INVALID_SPANID=y.isValidSpanId=y.isValidTraceId=y.isSpanContextValid=y.baggageEntryMetadataFromString=void 0;ne(Uf(),y);var NI=ku();Object.defineProperty(y,"baggageEntryMetadataFromString",{enumerable:!0,get:function(){return NI.baggageEntryMetadataFromString}});ne(Zf(),y);ne(ed(),y);ne(nd(),y);ne(Uu(),y);ne(ad(),y);ne(od(),y);ne(Yu(),y);ne(Qu(),y);ne(md(),y);ne(yd(),y);ne(Sd(),y);ne(Ad(),y);ne(bd(),y);ne(Od(),y);ne(Pd(),y);ne(Vu(),y);ne(Nd(),y);ne(wd(),y);ne(Md(),y);var nc=is();Object.defineProperty(y,"isSpanContextValid",{enumerable:!0,get:function(){return nc.isSpanContextValid}});Object.defineProperty(y,"isValidTraceId",{enumerable:!0,get:function(){return nc.isValidTraceId}});Object.defineProperty(y,"isValidSpanId",{enumerable:!0,get:function(){return nc.isValidSpanId}});var ic=ts();Object.defineProperty(y,"INVALID_SPANID",{enumerable:!0,get:function(){return ic.INVALID_SPANID}});Object.defineProperty(y,"INVALID_TRACEID",{enumerable:!0,get:function(){return ic.INVALID_TRACEID}});Object.defineProperty(y,"INVALID_SPAN_CONTEXT",{enumerable:!0,get:function(){return ic.INVALID_SPAN_CONTEXT}});ne(Mi(),y);ne(qd(),y);var DI=Fu();y.context=DI.ContextAPI.getInstance();var wI=Ud();y.trace=wI.TraceAPI.getInstance();var xI=$d();y.propagation=xI.PropagationAPI.getInstance();var MI=hn();y.diag=MI.DiagAPI.instance();y.default={trace:y.trace,context:y.context,propagation:y.propagation,diag:y.diag}});var fs=l(Xt=>{"use strict";Object.defineProperty(Xt,"__esModule",{value:!0});Xt.isTracingSuppressed=Xt.unsuppressTracing=Xt.suppressTracing=void 0;var LI=z(),ac=LI.createContextKey("OpenTelemetry SDK Context Key SUPPRESS_TRACING");function qI(e){return e.setValue(ac,!0)}Xt.suppressTracing=qI;function jI(e){return e.deleteValue(ac)}Xt.unsuppressTracing=jI;function kI(e){return e.getValue(ac)===!0}Xt.isTracingSuppressed=kI});var sc=l(Ie=>{"use strict";Object.defineProperty(Ie,"__esModule",{value:!0});Ie.BAGGAGE_MAX_TOTAL_LENGTH=Ie.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS=Ie.BAGGAGE_MAX_NAME_VALUE_PAIRS=Ie.BAGGAGE_HEADER=Ie.BAGGAGE_ITEMS_SEPARATOR=Ie.BAGGAGE_PROPERTIES_SEPARATOR=Ie.BAGGAGE_KEY_PAIR_SEPARATOR=void 0;Ie.BAGGAGE_KEY_PAIR_SEPARATOR="=";Ie.BAGGAGE_PROPERTIES_SEPARATOR=";";Ie.BAGGAGE_ITEMS_SEPARATOR=",";Ie.BAGGAGE_HEADER="baggage";Ie.BAGGAGE_MAX_NAME_VALUE_PAIRS=180;Ie.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS=4096;Ie.BAGGAGE_MAX_TOTAL_LENGTH=8192});var oc=l(nt=>{"use strict";Object.defineProperty(nt,"__esModule",{value:!0});nt.parseKeyPairsIntoRecord=nt.parsePairKeyValue=nt.getKeyPairs=nt.serializeKeyPairs=void 0;var HI=z(),yn=sc(),UI=e=>e.reduce((t,r)=>{let n=`${t}${t!==""?yn.BAGGAGE_ITEMS_SEPARATOR:""}${r}`;return n.length>yn.BAGGAGE_MAX_TOTAL_LENGTH?t:n},"");nt.serializeKeyPairs=UI;var BI=e=>e.getAllEntries().map(([t,r])=>`${encodeURIComponent(t)}=${encodeURIComponent(r.value)}`);nt.getKeyPairs=BI;var GI=e=>{let t=e.split(yn.BAGGAGE_PROPERTIES_SEPARATOR);if(t.length<=0)return;let r=t.shift();if(!r)return;let n=r.split(yn.BAGGAGE_KEY_PAIR_SEPARATOR);if(n.length!==2)return;let i=decodeURIComponent(n[0].trim()),a=decodeURIComponent(n[1].trim()),s;return t.length>0&&(s=HI.baggageEntryMetadataFromString(t.join(yn.BAGGAGE_PROPERTIES_SEPARATOR))),{key:i,value:a,metadata:s}};nt.parsePairKeyValue=GI;var FI=e=>typeof e!="string"||e.length===0?{}:e.split(yn.BAGGAGE_ITEMS_SEPARATOR).map(t=>nt.parsePairKeyValue(t)).filter(t=>t!==void 0&&t.value.length>0).reduce((t,r)=>(t[r.key]=r.value,t),{});nt.parseKeyPairsIntoRecord=FI});var Kd=l(ds=>{"use strict";Object.defineProperty(ds,"__esModule",{value:!0});ds.HttpBaggagePropagator=void 0;var uc=z(),VI=fs(),Tn=sc(),cc=oc(),zd=class{inject(t,r,n){let i=uc.propagation.getBaggage(t);if(!i||VI.isTracingSuppressed(t))return;let a=cc.getKeyPairs(i).filter(o=>o.length<=Tn.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS).slice(0,Tn.BAGGAGE_MAX_NAME_VALUE_PAIRS),s=cc.serializeKeyPairs(a);s.length>0&&n.set(r,Tn.BAGGAGE_HEADER,s)}extract(t,r,n){let i=n.get(r,Tn.BAGGAGE_HEADER);if(!i)return t;let a={};return i.length===0||(i.split(Tn.BAGGAGE_ITEMS_SEPARATOR).forEach(o=>{let u=cc.parsePairKeyValue(o);if(u){let c={value:u.value};u.metadata&&(c.metadata=u.metadata),a[u.key]=c}}),Object.entries(a).length===0)?t:uc.propagation.setBaggage(t,uc.propagation.createBaggage(a))}fields(){return[Tn.BAGGAGE_HEADER]}};ds.HttpBaggagePropagator=zd});var Qd=l(Sn=>{"use strict";Object.defineProperty(Sn,"__esModule",{value:!0});Sn.isAttributeValue=Sn.sanitizeAttributes=void 0;function $I(e){let t={};if(e==null||typeof e!="object")return t;for(let[r,n]of Object.entries(e))Xd(n)&&(Array.isArray(n)?t[r]=n.slice():t[r]=n);return t}Sn.sanitizeAttributes=$I;function Xd(e){return e==null?!0:Array.isArray(e)?zI(e):Yd(e)}Sn.isAttributeValue=Xd;function zI(e){let t;for(let r of e)if(r!=null){if(!t){if(Yd(r)){t=typeof r;continue}return!1}if(typeof r!==t)return!1}return!0}function Yd(e){switch(typeof e){case"number":return!0;case"boolean":return!0;case"string":return!0}return!1}});var lc=l(hs=>{"use strict";Object.defineProperty(hs,"__esModule",{value:!0});hs.loggingErrorHandler=void 0;var KI=z();function XI(){return e=>{KI.diag.error(YI(e))}}hs.loggingErrorHandler=XI;function YI(e){return typeof e=="string"?e:JSON.stringify(QI(e))}function QI(e){let t={},r=e;for(;r!==null;)Object.getOwnPropertyNames(r).forEach(n=>{if(t[n])return;let i=r[n];i&&(t[n]=String(i))}),r=Object.getPrototypeOf(r);return t}});var pc=l(An=>{"use strict";Object.defineProperty(An,"__esModule",{value:!0});An.globalErrorHandler=An.setGlobalErrorHandler=void 0;var WI=lc(),Wd=WI.loggingErrorHandler();function ZI(e){Wd=e}An.setGlobalErrorHandler=ZI;var JI=e=>{try{Wd(e)}catch(t){}};An.globalErrorHandler=JI});var fc=l(Ui=>{"use strict";Object.defineProperty(Ui,"__esModule",{value:!0});Ui.TracesSamplerValues=void 0;var eb;(function(e){e.AlwaysOff="always_off",e.AlwaysOn="always_on",e.ParentBasedAlwaysOff="parentbased_always_off",e.ParentBasedAlwaysOn="parentbased_always_on",e.ParentBasedTraceIdRatio="parentbased_traceidratio",e.TraceIdRatio="traceidratio"})(eb=Ui.TracesSamplerValues||(Ui.TracesSamplerValues={}))});var dc=l(Sr=>{"use strict";Object.defineProperty(Sr,"__esModule",{value:!0});Sr.parseEnvironment=Sr.DEFAULT_ENVIRONMENT=void 0;var Yt=z(),tb=fc(),rb=",",nb=["OTEL_BSP_EXPORT_TIMEOUT","OTEL_BSP_MAX_EXPORT_BATCH_SIZE","OTEL_BSP_MAX_QUEUE_SIZE","OTEL_BSP_SCHEDULE_DELAY","OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT","OTEL_SPAN_EVENT_COUNT_LIMIT","OTEL_SPAN_LINK_COUNT_LIMIT"];function ib(e){return nb.indexOf(e)>-1}var ab=["OTEL_NO_PATCH_MODULES","OTEL_PROPAGATORS"];function sb(e){return ab.indexOf(e)>-1}Sr.DEFAULT_ENVIRONMENT={CONTAINER_NAME:"",ECS_CONTAINER_METADATA_URI_V4:"",ECS_CONTAINER_METADATA_URI:"",HOSTNAME:"",KUBERNETES_SERVICE_HOST:"",NAMESPACE:"",OTEL_BSP_EXPORT_TIMEOUT:3e4,OTEL_BSP_MAX_EXPORT_BATCH_SIZE:512,OTEL_BSP_MAX_QUEUE_SIZE:2048,OTEL_BSP_SCHEDULE_DELAY:5e3,OTEL_EXPORTER_JAEGER_AGENT_HOST:"",OTEL_EXPORTER_JAEGER_ENDPOINT:"",OTEL_EXPORTER_JAEGER_PASSWORD:"",OTEL_EXPORTER_JAEGER_USER:"",OTEL_EXPORTER_OTLP_ENDPOINT:"",OTEL_EXPORTER_OTLP_TRACES_ENDPOINT:"",OTEL_EXPORTER_OTLP_METRICS_ENDPOINT:"",OTEL_EXPORTER_OTLP_HEADERS:"",OTEL_EXPORTER_OTLP_TRACES_HEADERS:"",OTEL_EXPORTER_OTLP_METRICS_HEADERS:"",OTEL_EXPORTER_ZIPKIN_ENDPOINT:"http://localhost:9411/api/v2/spans",OTEL_LOG_LEVEL:Yt.DiagLogLevel.INFO,OTEL_NO_PATCH_MODULES:[],OTEL_PROPAGATORS:["tracecontext","baggage"],OTEL_RESOURCE_ATTRIBUTES:"",OTEL_SERVICE_NAME:"",OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT:128,OTEL_SPAN_EVENT_COUNT_LIMIT:128,OTEL_SPAN_LINK_COUNT_LIMIT:128,OTEL_TRACES_EXPORTER:"none",OTEL_TRACES_SAMPLER:tb.TracesSamplerValues.ParentBasedAlwaysOn,OTEL_TRACES_SAMPLER_ARG:""};function ob(e,t,r,n=-1/0,i=1/0){if(typeof r[e]!="undefined"){let a=Number(r[e]);isNaN(a)||(a<n?t[e]=n:a>i?t[e]=i:t[e]=a)}}function ub(e,t,r,n=rb){let i=r[e];typeof i=="string"&&(t[e]=i.split(n).map(a=>a.trim()))}var cb={ALL:Yt.DiagLogLevel.ALL,VERBOSE:Yt.DiagLogLevel.VERBOSE,DEBUG:Yt.DiagLogLevel.DEBUG,INFO:Yt.DiagLogLevel.INFO,WARN:Yt.DiagLogLevel.WARN,ERROR:Yt.DiagLogLevel.ERROR,NONE:Yt.DiagLogLevel.NONE};function lb(e,t,r){let n=r[e];if(typeof n=="string"){let i=cb[n.toUpperCase()];i!=null&&(t[e]=i)}}function pb(e){let t={};for(let r in Sr.DEFAULT_ENVIRONMENT){let n=r;switch(n){case"OTEL_LOG_LEVEL":lb(n,t,e);break;default:if(ib(n))ob(n,t,e);else if(sb(n))ub(n,t,e);else{let i=e[n];typeof i!="undefined"&&i!==null&&(t[n]=String(i))}}}return t}Sr.parseEnvironment=pb});var Jd=l(_s=>{"use strict";Object.defineProperty(_s,"__esModule",{value:!0});_s.getEnv=void 0;var fb=__webpack_require__(2087),Zd=dc();function db(){let e=Zd.parseEnvironment(process.env);return Object.assign({HOSTNAME:fb.hostname()},Zd.DEFAULT_ENVIRONMENT,e)}_s.getEnv=db});var eh=l(vs=>{"use strict";Object.defineProperty(vs,"__esModule",{value:!0});vs.hexToBase64=void 0;function hb(e){let t=e.length,r="";for(let n=0;n<t;n+=2){let i=e.substring(n,n+2),a=parseInt(i,16);r+=String.fromCharCode(a)}return Buffer.from(r,"ascii").toString("base64")}vs.hexToBase64=hb});var ih=l(Es=>{"use strict";Object.defineProperty(Es,"__esModule",{value:!0});Es.RandomIdGenerator=void 0;var _b=8,th=16,rh=class{constructor(){this.generateTraceId=nh(th),this.generateSpanId=nh(_b)}};Es.RandomIdGenerator=rh;var gs=Buffer.allocUnsafe(th);function nh(e){return function(){for(let r=0;r<e/4;r++)gs.writeUInt32BE(Math.random()*2**32>>>0,r*4);for(let r=0;r<e&&!(gs[r]>0);r++)r===e-1&&(gs[e-1]=1);return gs.toString("hex",0,e)}}});var ah=l(ms=>{"use strict";Object.defineProperty(ms,"__esModule",{value:!0});ms.otperformance=void 0;var vb=__webpack_require__(630);ms.otperformance=vb.performance});var Ts=l(ys=>{"use strict";Object.defineProperty(ys,"__esModule",{value:!0});ys.VERSION=void 0;ys.VERSION="0.23.0"});var sh=l(x=>{"use strict";Object.defineProperty(x,"__esModule",{value:!0});x.RpcGrpcStatusCodeValues=x.MessagingOperationValues=x.MessagingDestinationKindValues=x.HttpFlavorValues=x.NetTransportValues=x.FaasInvokedProviderValues=x.FaasDocumentOperationValues=x.FaasTriggerValues=x.DbCassandraConsistencyLevelValues=x.DbSystemValues=x.SemanticAttributes=void 0;x.SemanticAttributes={DB_SYSTEM:"db.system",DB_CONNECTION_STRING:"db.connection_string",DB_USER:"db.user",DB_JDBC_DRIVER_CLASSNAME:"db.jdbc.driver_classname",DB_NAME:"db.name",DB_STATEMENT:"db.statement",DB_OPERATION:"db.operation",DB_MSSQL_INSTANCE_NAME:"db.mssql.instance_name",DB_CASSANDRA_KEYSPACE:"db.cassandra.keyspace",DB_CASSANDRA_PAGE_SIZE:"db.cassandra.page_size",DB_CASSANDRA_CONSISTENCY_LEVEL:"db.cassandra.consistency_level",DB_CASSANDRA_TABLE:"db.cassandra.table",DB_CASSANDRA_IDEMPOTENCE:"db.cassandra.idempotence",DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT:"db.cassandra.speculative_execution_count",DB_CASSANDRA_COORDINATOR_ID:"db.cassandra.coordinator.id",DB_CASSANDRA_COORDINATOR_DC:"db.cassandra.coordinator.dc",DB_HBASE_NAMESPACE:"db.hbase.namespace",DB_REDIS_DATABASE_INDEX:"db.redis.database_index",DB_MONGODB_COLLECTION:"db.mongodb.collection",DB_SQL_TABLE:"db.sql.table",EXCEPTION_TYPE:"exception.type",EXCEPTION_MESSAGE:"exception.message",EXCEPTION_STACKTRACE:"exception.stacktrace",EXCEPTION_ESCAPED:"exception.escaped",FAAS_TRIGGER:"faas.trigger",FAAS_EXECUTION:"faas.execution",FAAS_DOCUMENT_COLLECTION:"faas.document.collection",FAAS_DOCUMENT_OPERATION:"faas.document.operation",FAAS_DOCUMENT_TIME:"faas.document.time",FAAS_DOCUMENT_NAME:"faas.document.name",FAAS_TIME:"faas.time",FAAS_CRON:"faas.cron",FAAS_COLDSTART:"faas.coldstart",FAAS_INVOKED_NAME:"faas.invoked_name",FAAS_INVOKED_PROVIDER:"faas.invoked_provider",FAAS_INVOKED_REGION:"faas.invoked_region",NET_TRANSPORT:"net.transport",NET_PEER_IP:"net.peer.ip",NET_PEER_PORT:"net.peer.port",NET_PEER_NAME:"net.peer.name",NET_HOST_IP:"net.host.ip",NET_HOST_PORT:"net.host.port",NET_HOST_NAME:"net.host.name",PEER_SERVICE:"peer.service",ENDUSER_ID:"enduser.id",ENDUSER_ROLE:"enduser.role",ENDUSER_SCOPE:"enduser.scope",THREAD_ID:"thread.id",THREAD_NAME:"thread.name",CODE_FUNCTION:"code.function",CODE_NAMESPACE:"code.namespace",CODE_FILEPATH:"code.filepath",CODE_LINENO:"code.lineno",HTTP_METHOD:"http.method",HTTP_URL:"http.url",HTTP_TARGET:"http.target",HTTP_HOST:"http.host",HTTP_SCHEME:"http.scheme",HTTP_STATUS_CODE:"http.status_code",HTTP_FLAVOR:"http.flavor",HTTP_USER_AGENT:"http.user_agent",HTTP_REQUEST_CONTENT_LENGTH:"http.request_content_length",HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED:"http.request_content_length_uncompressed",HTTP_RESPONSE_CONTENT_LENGTH:"http.response_content_length",HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED:"http.response_content_length_uncompressed",HTTP_SERVER_NAME:"http.server_name",HTTP_ROUTE:"http.route",HTTP_CLIENT_IP:"http.client_ip",AWS_DYNAMODB_TABLE_NAMES:"aws.dynamodb.table_names",AWS_DYNAMODB_CONSUMED_CAPACITY:"aws.dynamodb.consumed_capacity",AWS_DYNAMODB_ITEM_COLLECTION_METRICS:"aws.dynamodb.item_collection_metrics",AWS_DYNAMODB_PROVISIONED_READ_CAPACITY:"aws.dynamodb.provisioned_read_capacity",AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY:"aws.dynamodb.provisioned_write_capacity",AWS_DYNAMODB_CONSISTENT_READ:"aws.dynamodb.consistent_read",AWS_DYNAMODB_PROJECTION:"aws.dynamodb.projection",AWS_DYNAMODB_LIMIT:"aws.dynamodb.limit",AWS_DYNAMODB_ATTRIBUTES_TO_GET:"aws.dynamodb.attributes_to_get",AWS_DYNAMODB_INDEX_NAME:"aws.dynamodb.index_name",AWS_DYNAMODB_SELECT:"aws.dynamodb.select",AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES:"aws.dynamodb.global_secondary_indexes",AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES:"aws.dynamodb.local_secondary_indexes",AWS_DYNAMODB_EXCLUSIVE_START_TABLE:"aws.dynamodb.exclusive_start_table",AWS_DYNAMODB_TABLE_COUNT:"aws.dynamodb.table_count",AWS_DYNAMODB_SCAN_FORWARD:"aws.dynamodb.scan_forward",AWS_DYNAMODB_SEGMENT:"aws.dynamodb.segment",AWS_DYNAMODB_TOTAL_SEGMENTS:"aws.dynamodb.total_segments",AWS_DYNAMODB_COUNT:"aws.dynamodb.count",AWS_DYNAMODB_SCANNED_COUNT:"aws.dynamodb.scanned_count",AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS:"aws.dynamodb.attribute_definitions",AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES:"aws.dynamodb.global_secondary_index_updates",MESSAGING_SYSTEM:"messaging.system",MESSAGING_DESTINATION:"messaging.destination",MESSAGING_DESTINATION_KIND:"messaging.destination_kind",MESSAGING_TEMP_DESTINATION:"messaging.temp_destination",MESSAGING_PROTOCOL:"messaging.protocol",MESSAGING_PROTOCOL_VERSION:"messaging.protocol_version",MESSAGING_URL:"messaging.url",MESSAGING_MESSAGE_ID:"messaging.message_id",MESSAGING_CONVERSATION_ID:"messaging.conversation_id",MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES:"messaging.message_payload_size_bytes",MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES:"messaging.message_payload_compressed_size_bytes",MESSAGING_OPERATION:"messaging.operation",MESSAGING_RABBITMQ_ROUTING_KEY:"messaging.rabbitmq.routing_key",MESSAGING_KAFKA_MESSAGE_KEY:"messaging.kafka.message_key",MESSAGING_KAFKA_CONSUMER_GROUP:"messaging.kafka.consumer_group",MESSAGING_KAFKA_CLIENT_ID:"messaging.kafka.client_id",MESSAGING_KAFKA_PARTITION:"messaging.kafka.partition",MESSAGING_KAFKA_TOMBSTONE:"messaging.kafka.tombstone",RPC_SYSTEM:"rpc.system",RPC_SERVICE:"rpc.service",RPC_METHOD:"rpc.method",RPC_GRPC_STATUS_CODE:"rpc.grpc.status_code",RPC_JSONRPC_VERSION:"rpc.jsonrpc.version",RPC_JSONRPC_METHOD:"rpc.jsonrpc.method",RPC_JSONRPC_REQUEST_ID:"rpc.jsonrpc.request_id",RPC_JSONRPC_ERROR_CODE:"rpc.jsonrpc.error_code",RPC_JSONRPC_ERROR_MESSAGE:"rpc.jsonrpc.error_message"};var gb;(function(e){e.OTHER_SQL="other_sql",e.MSSQL="mssql",e.MYSQL="mysql",e.ORACLE="oracle",e.DB2="db2",e.POSTGRESQL="postgresql",e.REDSHIFT="redshift",e.HIVE="hive",e.CLOUDSCAPE="cloudscape",e.HSQLDB="hsqldb",e.PROGRESS="progress",e.MAXDB="maxdb",e.HANADB="hanadb",e.INGRES="ingres",e.FIRSTSQL="firstsql",e.EDB="edb",e.CACHE="cache",e.ADABAS="adabas",e.FIREBIRD="firebird",e.DERBY="derby",e.FILEMAKER="filemaker",e.INFORMIX="informix",e.INSTANTDB="instantdb",e.INTERBASE="interbase",e.MARIADB="mariadb",e.NETEZZA="netezza",e.PERVASIVE="pervasive",e.POINTBASE="pointbase",e.SQLITE="sqlite",e.SYBASE="sybase",e.TERADATA="teradata",e.VERTICA="vertica",e.H2="h2",e.COLDFUSION="coldfusion",e.CASSANDRA="cassandra",e.HBASE="hbase",e.MONGODB="mongodb",e.REDIS="redis",e.COUCHBASE="couchbase",e.COUCHDB="couchdb",e.COSMOSDB="cosmosdb",e.DYNAMODB="dynamodb",e.NEO4J="neo4j",e.GEODE="geode",e.ELASTICSEARCH="elasticsearch",e.MEMCACHED="memcached",e.COCKROACHDB="cockroachdb"})(gb=x.DbSystemValues||(x.DbSystemValues={}));var Eb;(function(e){e.ALL="all",e.EACH_QUORUM="each_quorum",e.QUORUM="quorum",e.LOCAL_QUORUM="local_quorum",e.ONE="one",e.TWO="two",e.THREE="three",e.LOCAL_ONE="local_one",e.ANY="any",e.SERIAL="serial",e.LOCAL_SERIAL="local_serial"})(Eb=x.DbCassandraConsistencyLevelValues||(x.DbCassandraConsistencyLevelValues={}));var mb;(function(e){e.DATASOURCE="datasource",e.HTTP="http",e.PUBSUB="pubsub",e.TIMER="timer",e.OTHER="other"})(mb=x.FaasTriggerValues||(x.FaasTriggerValues={}));var yb;(function(e){e.INSERT="insert",e.EDIT="edit",e.DELETE="delete"})(yb=x.FaasDocumentOperationValues||(x.FaasDocumentOperationValues={}));var Tb;(function(e){e.AWS="aws",e.AZURE="azure",e.GCP="gcp"})(Tb=x.FaasInvokedProviderValues||(x.FaasInvokedProviderValues={}));var Sb;(function(e){e.IP_TCP="ip_tcp",e.IP_UDP="ip_udp",e.IP="ip",e.UNIX="unix",e.PIPE="pipe",e.INPROC="inproc",e.OTHER="other"})(Sb=x.NetTransportValues||(x.NetTransportValues={}));var Ab;(function(e){e.HTTP_1_0="1.0",e.HTTP_1_1="1.1",e.HTTP_2_0="2.0",e.SPDY="SPDY",e.QUIC="QUIC"})(Ab=x.HttpFlavorValues||(x.HttpFlavorValues={}));var Ib;(function(e){e.QUEUE="queue",e.TOPIC="topic"})(Ib=x.MessagingDestinationKindValues||(x.MessagingDestinationKindValues={}));var bb;(function(e){e.RECEIVE="receive",e.PROCESS="process"})(bb=x.MessagingOperationValues||(x.MessagingOperationValues={}));var Cb;(function(e){e[e.OK=0]="OK",e[e.CANCELLED=1]="CANCELLED",e[e.UNKNOWN=2]="UNKNOWN",e[e.INVALID_ARGUMENT=3]="INVALID_ARGUMENT",e[e.DEADLINE_EXCEEDED=4]="DEADLINE_EXCEEDED",e[e.NOT_FOUND=5]="NOT_FOUND",e[e.ALREADY_EXISTS=6]="ALREADY_EXISTS",e[e.PERMISSION_DENIED=7]="PERMISSION_DENIED",e[e.RESOURCE_EXHAUSTED=8]="RESOURCE_EXHAUSTED",e[e.FAILED_PRECONDITION=9]="FAILED_PRECONDITION",e[e.ABORTED=10]="ABORTED",e[e.OUT_OF_RANGE=11]="OUT_OF_RANGE",e[e.UNIMPLEMENTED=12]="UNIMPLEMENTED",e[e.INTERNAL=13]="INTERNAL",e[e.UNAVAILABLE=14]="UNAVAILABLE",e[e.DATA_LOSS=15]="DATA_LOSS",e[e.UNAUTHENTICATED=16]="UNAUTHENTICATED"})(Cb=x.RpcGrpcStatusCodeValues||(x.RpcGrpcStatusCodeValues={}))});var oh=l(Ar=>{"use strict";var Ob=Ar&&Ar.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),Pb=Ar&&Ar.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&Ob(t,e,r)};Object.defineProperty(Ar,"__esModule",{value:!0});Pb(sh(),Ar)});var uh=l(ie=>{"use strict";Object.defineProperty(ie,"__esModule",{value:!0});ie.TelemetrySdkLanguageValues=ie.OsTypeValues=ie.HostArchValues=ie.AwsEcsLaunchtypeValues=ie.CloudPlatformValues=ie.CloudProviderValues=ie.ResourceAttributes=void 0;ie.ResourceAttributes={CLOUD_PROVIDER:"cloud.provider",CLOUD_ACCOUNT_ID:"cloud.account.id",CLOUD_REGION:"cloud.region",CLOUD_AVAILABILITY_ZONE:"cloud.availability_zone",CLOUD_PLATFORM:"cloud.platform",AWS_ECS_CONTAINER_ARN:"aws.ecs.container.arn",AWS_ECS_CLUSTER_ARN:"aws.ecs.cluster.arn",AWS_ECS_LAUNCHTYPE:"aws.ecs.launchtype",AWS_ECS_TASK_ARN:"aws.ecs.task.arn",AWS_ECS_TASK_FAMILY:"aws.ecs.task.family",AWS_ECS_TASK_REVISION:"aws.ecs.task.revision",AWS_EKS_CLUSTER_ARN:"aws.eks.cluster.arn",AWS_LOG_GROUP_NAMES:"aws.log.group.names",AWS_LOG_GROUP_ARNS:"aws.log.group.arns",AWS_LOG_STREAM_NAMES:"aws.log.stream.names",AWS_LOG_STREAM_ARNS:"aws.log.stream.arns",CONTAINER_NAME:"container.name",CONTAINER_ID:"container.id",CONTAINER_RUNTIME:"container.runtime",CONTAINER_IMAGE_NAME:"container.image.name",CONTAINER_IMAGE_TAG:"container.image.tag",DEPLOYMENT_ENVIRONMENT:"deployment.environment",DEVICE_ID:"device.id",DEVICE_MODEL_IDENTIFIER:"device.model.identifier",DEVICE_MODEL_NAME:"device.model.name",FAAS_NAME:"faas.name",FAAS_ID:"faas.id",FAAS_VERSION:"faas.version",FAAS_INSTANCE:"faas.instance",FAAS_MAX_MEMORY:"faas.max_memory",HOST_ID:"host.id",HOST_NAME:"host.name",HOST_TYPE:"host.type",HOST_ARCH:"host.arch",HOST_IMAGE_NAME:"host.image.name",HOST_IMAGE_ID:"host.image.id",HOST_IMAGE_VERSION:"host.image.version",K8S_CLUSTER_NAME:"k8s.cluster.name",K8S_NODE_NAME:"k8s.node.name",K8S_NODE_UID:"k8s.node.uid",K8S_NAMESPACE_NAME:"k8s.namespace.name",K8S_POD_UID:"k8s.pod.uid",K8S_POD_NAME:"k8s.pod.name",K8S_CONTAINER_NAME:"k8s.container.name",K8S_REPLICASET_UID:"k8s.replicaset.uid",K8S_REPLICASET_NAME:"k8s.replicaset.name",K8S_DEPLOYMENT_UID:"k8s.deployment.uid",K8S_DEPLOYMENT_NAME:"k8s.deployment.name",K8S_STATEFULSET_UID:"k8s.statefulset.uid",K8S_STATEFULSET_NAME:"k8s.statefulset.name",K8S_DAEMONSET_UID:"k8s.daemonset.uid",K8S_DAEMONSET_NAME:"k8s.daemonset.name",K8S_JOB_UID:"k8s.job.uid",K8S_JOB_NAME:"k8s.job.name",K8S_CRONJOB_UID:"k8s.cronjob.uid",K8S_CRONJOB_NAME:"k8s.cronjob.name",OS_TYPE:"os.type",OS_DESCRIPTION:"os.description",OS_NAME:"os.name",OS_VERSION:"os.version",PROCESS_PID:"process.pid",PROCESS_EXECUTABLE_NAME:"process.executable.name",PROCESS_EXECUTABLE_PATH:"process.executable.path",PROCESS_COMMAND:"process.command",PROCESS_COMMAND_LINE:"process.command_line",PROCESS_COMMAND_ARGS:"process.command_args",PROCESS_OWNER:"process.owner",PROCESS_RUNTIME_NAME:"process.runtime.name",PROCESS_RUNTIME_VERSION:"process.runtime.version",PROCESS_RUNTIME_DESCRIPTION:"process.runtime.description",SERVICE_NAME:"service.name",SERVICE_NAMESPACE:"service.namespace",SERVICE_INSTANCE_ID:"service.instance.id",SERVICE_VERSION:"service.version",TELEMETRY_SDK_NAME:"telemetry.sdk.name",TELEMETRY_SDK_LANGUAGE:"telemetry.sdk.language",TELEMETRY_SDK_VERSION:"telemetry.sdk.version",TELEMETRY_AUTO_VERSION:"telemetry.auto.version",WEBENGINE_NAME:"webengine.name",WEBENGINE_VERSION:"webengine.version",WEBENGINE_DESCRIPTION:"webengine.description"};var Rb;(function(e){e.AWS="aws",e.AZURE="azure",e.GCP="gcp"})(Rb=ie.CloudProviderValues||(ie.CloudProviderValues={}));var Nb;(function(e){e.AWS_EC2="aws_ec2",e.AWS_ECS="aws_ecs",e.AWS_EKS="aws_eks",e.AWS_LAMBDA="aws_lambda",e.AWS_ELASTIC_BEANSTALK="aws_elastic_beanstalk",e.AZURE_VM="azure_vm",e.AZURE_CONTAINER_INSTANCES="azure_container_instances",e.AZURE_AKS="azure_aks",e.AZURE_FUNCTIONS="azure_functions",e.AZURE_APP_SERVICE="azure_app_service",e.GCP_COMPUTE_ENGINE="gcp_compute_engine",e.GCP_CLOUD_RUN="gcp_cloud_run",e.GCP_KUBERNETES_ENGINE="gcp_kubernetes_engine",e.GCP_CLOUD_FUNCTIONS="gcp_cloud_functions",e.GCP_APP_ENGINE="gcp_app_engine"})(Nb=ie.CloudPlatformValues||(ie.CloudPlatformValues={}));var Db;(function(e){e.EC2="ec2",e.FARGATE="fargate"})(Db=ie.AwsEcsLaunchtypeValues||(ie.AwsEcsLaunchtypeValues={}));var wb;(function(e){e.AMD64="amd64",e.ARM32="arm32",e.ARM64="arm64",e.IA64="ia64",e.PPC32="ppc32",e.PPC64="ppc64",e.X86="x86"})(wb=ie.HostArchValues||(ie.HostArchValues={}));var xb;(function(e){e.WINDOWS="windows",e.LINUX="linux",e.DARWIN="darwin",e.FREEBSD="freebsd",e.NETBSD="netbsd",e.OPENBSD="openbsd",e.DRAGONFLYBSD="dragonflybsd",e.HPUX="hpux",e.AIX="aix",e.SOLARIS="solaris",e.Z_OS="z_os"})(xb=ie.OsTypeValues||(ie.OsTypeValues={}));var Mb;(function(e){e.CPP="cpp",e.DOTNET="dotnet",e.ERLANG="erlang",e.GO="go",e.JAVA="java",e.NODEJS="nodejs",e.PHP="php",e.PYTHON="python",e.RUBY="ruby",e.WEBJS="webjs"})(Mb=ie.TelemetrySdkLanguageValues||(ie.TelemetrySdkLanguageValues={}))});var ch=l(Ir=>{"use strict";var Lb=Ir&&Ir.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),qb=Ir&&Ir.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&Lb(t,e,r)};Object.defineProperty(Ir,"__esModule",{value:!0});qb(uh(),Ir)});var In=l(Qt=>{"use strict";var jb=Qt&&Qt.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),lh=Qt&&Qt.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&jb(t,e,r)};Object.defineProperty(Qt,"__esModule",{value:!0});lh(oh(),Qt);lh(ch(),Qt)});var ph=l(Ss=>{"use strict";Object.defineProperty(Ss,"__esModule",{value:!0});Ss.SDK_INFO=void 0;var kb=Ts(),Bi=In();Ss.SDK_INFO={[Bi.ResourceAttributes.TELEMETRY_SDK_NAME]:"opentelemetry",[Bi.ResourceAttributes.PROCESS_RUNTIME_NAME]:"node",[Bi.ResourceAttributes.TELEMETRY_SDK_LANGUAGE]:Bi.TelemetrySdkLanguageValues.NODEJS,[Bi.ResourceAttributes.TELEMETRY_SDK_VERSION]:kb.VERSION}});var fh=l(As=>{"use strict";Object.defineProperty(As,"__esModule",{value:!0});As.unrefTimer=void 0;function Hb(e){e.unref()}As.unrefTimer=Hb});var dh=l(Ke=>{"use strict";var Ub=Ke&&Ke.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),bn=Ke&&Ke.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&Ub(t,e,r)};Object.defineProperty(Ke,"__esModule",{value:!0});bn(Jd(),Ke);bn(eh(),Ke);bn(ih(),Ke);bn(ah(),Ke);bn(ph(),Ke);bn(fh(),Ke)});var hc=l(br=>{"use strict";var Bb=br&&br.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),Gb=br&&br.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&Bb(t,e,r)};Object.defineProperty(br,"__esModule",{value:!0});Gb(dh(),br)});var vh=l(pe=>{"use strict";Object.defineProperty(pe,"__esModule",{value:!0});pe.isTimeInput=pe.isTimeInputHrTime=pe.hrTimeToMicroseconds=pe.hrTimeToMilliseconds=pe.hrTimeToNanoseconds=pe.hrTimeToTimeStamp=pe.hrTimeDuration=pe.timeInputToHrTime=pe.hrTime=void 0;var _c=hc(),vc=9,Gi=Math.pow(10,vc);function Is(e){let t=e/1e3,r=Math.trunc(t),n=Number((t-r).toFixed(vc))*Gi;return[r,n]}function hh(){let e=_c.otperformance.timeOrigin;if(typeof e!="number"){let t=_c.otperformance;e=t.timing&&t.timing.fetchStart}return e}function _h(e){let t=Is(hh()),r=Is(typeof e=="number"?e:_c.otperformance.now()),n=t[0]+r[0],i=t[1]+r[1];return i>Gi&&(i-=Gi,n+=1),[n,i]}pe.hrTime=_h;function Fb(e){if(gc(e))return e;if(typeof e=="number")return e<hh()?_h(e):Is(e);if(e instanceof Date)return Is(e.getTime());throw TypeError("Invalid input type")}pe.timeInputToHrTime=Fb;function Vb(e,t){let r=t[0]-e[0],n=t[1]-e[1];return n<0&&(r-=1,n+=Gi),[r,n]}pe.hrTimeDuration=Vb;function $b(e){let t=vc,r=`${"0".repeat(t)}${e[1]}Z`,n=r.substr(r.length-t-1);return new Date(e[0]*1e3).toISOString().replace("000Z",n)}pe.hrTimeToTimeStamp=$b;function zb(e){return e[0]*Gi+e[1]}pe.hrTimeToNanoseconds=zb;function Kb(e){return Math.round(e[0]*1e3+e[1]/1e6)}pe.hrTimeToMilliseconds=Kb;function Xb(e){return Math.round(e[0]*1e6+e[1]/1e3)}pe.hrTimeToMicroseconds=Xb;function gc(e){return Array.isArray(e)&&e.length===2&&typeof e[0]=="number"&&typeof e[1]=="number"}pe.isTimeInputHrTime=gc;function Yb(e){return gc(e)||typeof e=="number"||e instanceof Date}pe.isTimeInput=Yb});var Eh=l(gh=>{"use strict";Object.defineProperty(gh,"__esModule",{value:!0})});var mh=l(Fi=>{"use strict";Object.defineProperty(Fi,"__esModule",{value:!0});Fi.ExportResultCode=void 0;var Qb;(function(e){e[e.SUCCESS=0]="SUCCESS",e[e.FAILED=1]="FAILED"})(Qb=Fi.ExportResultCode||(Fi.ExportResultCode={}))});var Sh=l(bs=>{"use strict";Object.defineProperty(bs,"__esModule",{value:!0});bs.CompositePropagator=void 0;var yh=z(),Th=class{constructor(t={}){var r;this._propagators=(r=t.propagators)!==null&&r!==void 0?r:[],this._fields=Array.from(new Set(this._propagators.map(n=>typeof n.fields=="function"?n.fields():[]).reduce((n,i)=>n.concat(i),[])))}inject(t,r,n){for(let i of this._propagators)try{i.inject(t,r,n)}catch(a){yh.diag.warn(`Failed to inject with ${i.constructor.name}. Err: ${a.message}`)}}extract(t,r,n){return this._propagators.reduce((i,a)=>{try{return a.extract(i,r,n)}catch(s){yh.diag.warn(`Failed to inject with ${a.constructor.name}. Err: ${s.message}`)}return i},t)}fields(){return this._fields.slice()}};bs.CompositePropagator=Th});var Ah=l(Cn=>{"use strict";Object.defineProperty(Cn,"__esModule",{value:!0});Cn.validateValue=Cn.validateKey=void 0;var Ec="[_0-9a-z-*/]",Wb=`[a-z]${Ec}{0,255}`,Zb=`[a-z0-9]${Ec}{0,240}@[a-z]${Ec}{0,13}`,Jb=new RegExp(`^(?:${Wb}|${Zb})$`),eC=/^[ -~]{0,255}[!-~]$/,tC=/,|=/;function rC(e){return Jb.test(e)}Cn.validateKey=rC;function nC(e){return eC.test(e)&&!tC.test(e)}Cn.validateValue=nC});var mc=l(Os=>{"use strict";Object.defineProperty(Os,"__esModule",{value:!0});Os.TraceState=void 0;var Ih=Ah(),bh=32,iC=512,Ch=",",Oh="=",Cs=class{constructor(t){this._internalState=new Map,t&&this._parse(t)}set(t,r){let n=this._clone();return n._internalState.has(t)&&n._internalState.delete(t),n._internalState.set(t,r),n}unset(t){let r=this._clone();return r._internalState.delete(t),r}get(t){return this._internalState.get(t)}serialize(){return this._keys().reduce((t,r)=>(t.push(r+Oh+this.get(r)),t),[]).join(Ch)}_parse(t){t.length>iC||(this._internalState=t.split(Ch).reverse().reduce((r,n)=>{let i=n.trim(),a=i.indexOf(Oh);if(a!==-1){let s=i.slice(0,a),o=i.slice(a+1,n.length);Ih.validateKey(s)&&Ih.validateValue(o)&&r.set(s,o)}return r},new Map),this._internalState.size>bh&&(this._internalState=new Map(Array.from(this._internalState.entries()).reverse().slice(0,bh))))}_keys(){return Array.from(this._internalState.keys()).reverse()}_clone(){let t=new Cs;return t._internalState=new Map(this._internalState),t}};Os.TraceState=Cs});var Nh=l(be=>{"use strict";Object.defineProperty(be,"__esModule",{value:!0});be.HttpTraceContextPropagator=be.parseTraceParent=be.TRACE_STATE_HEADER=be.TRACE_PARENT_HEADER=void 0;var Ps=z(),aC=fs(),sC=mc();be.TRACE_PARENT_HEADER="traceparent";be.TRACE_STATE_HEADER="tracestate";var oC="00",uC="(?!ff)[\\da-f]{2}",cC="(?![0]{32})[\\da-f]{32}",lC="(?![0]{16})[\\da-f]{16}",pC="[\\da-f]{2}",fC=new RegExp(`^\\s?(${uC})-(${cC})-(${lC})-(${pC})(-.*)?\\s?$`);function Ph(e){let t=fC.exec(e);return!t||t[1]==="00"&&t[5]?null:{traceId:t[2],spanId:t[3],traceFlags:parseInt(t[4],16)}}be.parseTraceParent=Ph;var Rh=class{inject(t,r,n){let i=Ps.trace.getSpanContext(t);if(!i||aC.isTracingSuppressed(t)||!Ps.isSpanContextValid(i))return;let a=`${oC}-${i.traceId}-${i.spanId}-0${Number(i.traceFlags||Ps.TraceFlags.NONE).toString(16)}`;n.set(r,be.TRACE_PARENT_HEADER,a),i.traceState&&n.set(r,be.TRACE_STATE_HEADER,i.traceState.serialize())}extract(t,r,n){let i=n.get(r,be.TRACE_PARENT_HEADER);if(!i)return t;let a=Array.isArray(i)?i[0]:i;if(typeof a!="string")return t;let s=Ph(a);if(!s)return t;s.isRemote=!0;let o=n.get(r,be.TRACE_STATE_HEADER);if(o){let u=Array.isArray(o)?o.join(","):o;s.traceState=new sC.TraceState(typeof u=="string"?u:void 0)}return Ps.trace.setSpanContext(t,s)}fields(){return[be.TRACE_PARENT_HEADER,be.TRACE_STATE_HEADER]}};be.HttpTraceContextPropagator=Rh});var wh=l(Dh=>{"use strict";Object.defineProperty(Dh,"__esModule",{value:!0})});var xh=l(it=>{"use strict";Object.defineProperty(it,"__esModule",{value:!0});it.getRPCMetadata=it.deleteRPCMetadata=it.setRPCMetadata=it.RPCType=void 0;var dC=z(),yc=dC.createContextKey("OpenTelemetry SDK Context Key RPC_METADATA"),hC;(function(e){e.HTTP="http"})(hC=it.RPCType||(it.RPCType={}));function _C(e,t){return e.setValue(yc,t)}it.setRPCMetadata=_C;function vC(e){return e.deleteValue(yc)}it.deleteRPCMetadata=vC;function gC(e){return e.getValue(yc)}it.getRPCMetadata=gC});var Tc=l(Rs=>{"use strict";Object.defineProperty(Rs,"__esModule",{value:!0});Rs.AlwaysOffSampler=void 0;var EC=z(),Mh=class{shouldSample(){return{decision:EC.SamplingDecision.NOT_RECORD}}toString(){return"AlwaysOffSampler"}};Rs.AlwaysOffSampler=Mh});var Sc=l(Ns=>{"use strict";Object.defineProperty(Ns,"__esModule",{value:!0});Ns.AlwaysOnSampler=void 0;var mC=z(),Lh=class{shouldSample(){return{decision:mC.SamplingDecision.RECORD_AND_SAMPLED}}toString(){return"AlwaysOnSampler"}};Ns.AlwaysOnSampler=Lh});var kh=l(ws=>{"use strict";Object.defineProperty(ws,"__esModule",{value:!0});ws.ParentBasedSampler=void 0;var Ds=z(),yC=pc(),qh=Tc(),Ac=Sc(),jh=class{constructor(t){var r,n,i,a;this._root=t.root,this._root||(yC.globalErrorHandler(new Error("ParentBasedSampler must have a root sampler configured")),this._root=new Ac.AlwaysOnSampler),this._remoteParentSampled=(r=t.remoteParentSampled)!==null&&r!==void 0?r:new Ac.AlwaysOnSampler,this._remoteParentNotSampled=(n=t.remoteParentNotSampled)!==null&&n!==void 0?n:new qh.AlwaysOffSampler,this._localParentSampled=(i=t.localParentSampled)!==null&&i!==void 0?i:new Ac.AlwaysOnSampler,this._localParentNotSampled=(a=t.localParentNotSampled)!==null&&a!==void 0?a:new qh.AlwaysOffSampler}shouldSample(t,r,n,i,a,s){let o=Ds.trace.getSpanContext(t);return!o||!Ds.isSpanContextValid(o)?this._root.shouldSample(t,r,n,i,a,s):o.isRemote?o.traceFlags&Ds.TraceFlags.SAMPLED?this._remoteParentSampled.shouldSample(t,r,n,i,a,s):this._remoteParentNotSampled.shouldSample(t,r,n,i,a,s):o.traceFlags&Ds.TraceFlags.SAMPLED?this._localParentSampled.shouldSample(t,r,n,i,a,s):this._localParentNotSampled.shouldSample(t,r,n,i,a,s)}toString(){return`ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`}};ws.ParentBasedSampler=jh});var Uh=l(xs=>{"use strict";Object.defineProperty(xs,"__esModule",{value:!0});xs.TraceIdRatioBasedSampler=void 0;var Ic=z(),Hh=class{constructor(t=0){this._ratio=t,this._ratio=this._normalize(t),this._upperBound=Math.floor(this._ratio*4294967295)}shouldSample(t,r){return{decision:Ic.isValidTraceId(r)&&this._accumulate(r)<this._upperBound?Ic.SamplingDecision.RECORD_AND_SAMPLED:Ic.SamplingDecision.NOT_RECORD}}toString(){return`TraceIdRatioBased{${this._ratio}}`}_normalize(t){return typeof t!="number"||isNaN(t)?0:t>=1?1:t<=0?0:t}_accumulate(t){let r=0;for(let n=0;n<t.length/8;n++){let i=n*8,a=parseInt(t.slice(i,i+8),16);r=(r^a)>>>0}return r}};xs.TraceIdRatioBasedSampler=Hh});var Gh=l(On=>{"use strict";Object.defineProperty(On,"__esModule",{value:!0});On.isUrlIgnored=On.urlMatches=void 0;function Bh(e,t){return typeof t=="string"?e===t:t.test(e)}On.urlMatches=Bh;function TC(e,t){if(!t)return!1;for(let r of t)if(Bh(e,r))return!0;return!1}On.isUrlIgnored=TC});var Fh=l(Ms=>{"use strict";Object.defineProperty(Ms,"__esModule",{value:!0});Ms.isWrapped=void 0;function SC(e){return typeof e=="function"&&typeof e.__original=="function"&&typeof e.__unwrap=="function"&&e.__wrapped===!0}Ms.isWrapped=SC});var Xe=l(M=>{"use strict";var AC=M&&M.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),Y=M&&M.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&AC(t,e,r)};Object.defineProperty(M,"__esModule",{value:!0});M.baggageUtils=void 0;Y(Kd(),M);Y(Qd(),M);Y(pc(),M);Y(lc(),M);Y(vh(),M);Y(Eh(),M);Y(mh(),M);Y(Ts(),M);M.baggageUtils=oc();Y(hc(),M);Y(Sh(),M);Y(Nh(),M);Y(wh(),M);Y(xh(),M);Y(Tc(),M);Y(Sc(),M);Y(kh(),M);Y(Uh(),M);Y(fs(),M);Y(mc(),M);Y(dc(),M);Y(fc(),M);Y(Gh(),M);Y(Fh(),M);Y(Ts(),M)});var Vh=l(Ls=>{"use strict";Object.defineProperty(Ls,"__esModule",{value:!0});Ls.ExceptionEventName=void 0;Ls.ExceptionEventName="exception"});var bc=l(qs=>{"use strict";Object.defineProperty(qs,"__esModule",{value:!0});qs.Span=void 0;var Wt=z(),ft=Xe(),Cr=In(),IC=Vh(),$h=class{constructor(t,r,n,i,a,s,o=[],u=ft.hrTime()){this.attributes={},this.links=[],this.events=[],this.status={code:Wt.SpanStatusCode.UNSET},this.endTime=[0,0],this._ended=!1,this._duration=[-1,-1],this.name=n,this._spanContext=i,this.parentSpanId=s,this.kind=a,this.links=o,this.startTime=ft.timeInputToHrTime(u),this.resource=t.resource,this.instrumentationLibrary=t.instrumentationLibrary,this._spanLimits=t.getSpanLimits(),this._spanProcessor=t.getActiveSpanProcessor(),this._spanProcessor.onStart(this,r)}spanContext(){return this._spanContext}setAttribute(t,r){return r==null||this._isSpanEnded()?this:t.length===0?(Wt.diag.warn(`Invalid attribute key: ${t}`),this):ft.isAttributeValue(r)?Object.keys(this.attributes).length>=this._spanLimits.attributeCountLimit&&!Object.prototype.hasOwnProperty.call(this.attributes,t)?this:(this.attributes[t]=r,this):(Wt.diag.warn(`Invalid attribute value set for key: ${t}`),this)}setAttributes(t){for(let[r,n]of Object.entries(t))this.setAttribute(r,n);return this}addEvent(t,r,n){return this._isSpanEnded()?this:(this.events.length>=this._spanLimits.eventCountLimit&&(Wt.diag.warn("Dropping extra events."),this.events.shift()),ft.isTimeInput(r)&&(typeof n=="undefined"&&(n=r),r=void 0),typeof n=="undefined"&&(n=ft.hrTime()),this.events.push({name:t,attributes:r,time:ft.timeInputToHrTime(n)}),this)}setStatus(t){return this._isSpanEnded()?this:(this.status=t,this)}updateName(t){return this._isSpanEnded()?this:(this.name=t,this)}end(t=ft.hrTime()){if(this._isSpanEnded()){Wt.diag.error("You can only call end() on a span once.");return}this._ended=!0,this.endTime=ft.timeInputToHrTime(t),this._duration=ft.hrTimeDuration(this.startTime,this.endTime),this._duration[0]<0&&Wt.diag.warn("Inconsistent start and end time, startTime > endTime",this.startTime,this.endTime),this._spanProcessor.onEnd(this)}isRecording(){return this._ended===!1}recordException(t,r=ft.hrTime()){let n={};typeof t=="string"?n[Cr.SemanticAttributes.EXCEPTION_MESSAGE]=t:t&&(t.code?n[Cr.SemanticAttributes.EXCEPTION_TYPE]=t.code.toString():t.name&&(n[Cr.SemanticAttributes.EXCEPTION_TYPE]=t.name),t.message&&(n[Cr.SemanticAttributes.EXCEPTION_MESSAGE]=t.message),t.stack&&(n[Cr.SemanticAttributes.EXCEPTION_STACKTRACE]=t.stack)),n[Cr.SemanticAttributes.EXCEPTION_TYPE]||n[Cr.SemanticAttributes.EXCEPTION_MESSAGE]?this.addEvent(IC.ExceptionEventName,n,r):Wt.diag.warn(`Failed to record an exception ${t}`)}get duration(){return this._duration}get ended(){return this._ended}_isSpanEnded(){return this._ended&&Wt.diag.warn("Can not execute the operation on ended Span {traceId: %s, spanId: %s}",this._spanContext.traceId,this._spanContext.spanId),this._ended}};qs.Span=$h});var Cc=l(Rn=>{"use strict";Object.defineProperty(Rn,"__esModule",{value:!0});Rn.buildSamplerFromEnv=Rn.DEFAULT_CONFIG=void 0;var js=z(),ae=Xe(),bC=ae.getEnv(),CC=ae.TracesSamplerValues.AlwaysOn;Rn.DEFAULT_CONFIG={sampler:zh(bC),forceFlushTimeoutMillis:3e4,spanLimits:{attributeCountLimit:ae.getEnv().OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,linkCountLimit:ae.getEnv().OTEL_SPAN_LINK_COUNT_LIMIT,eventCountLimit:ae.getEnv().OTEL_SPAN_EVENT_COUNT_LIMIT}};function zh(e=ae.getEnv()){switch(e.OTEL_TRACES_SAMPLER){case ae.TracesSamplerValues.AlwaysOn:return new ae.AlwaysOnSampler;case ae.TracesSamplerValues.AlwaysOff:return new ae.AlwaysOffSampler;case ae.TracesSamplerValues.ParentBasedAlwaysOn:return new ae.ParentBasedSampler({root:new ae.AlwaysOnSampler});case ae.TracesSamplerValues.ParentBasedAlwaysOff:return new ae.ParentBasedSampler({root:new ae.AlwaysOffSampler});case ae.TracesSamplerValues.TraceIdRatio:return new ae.TraceIdRatioBasedSampler(Kh(e));case ae.TracesSamplerValues.ParentBasedTraceIdRatio:return new ae.ParentBasedSampler({root:new ae.TraceIdRatioBasedSampler(Kh(e))});default:return js.diag.error(`OTEL_TRACES_SAMPLER value "${e.OTEL_TRACES_SAMPLER} invalid, defaulting to ${CC}".`),new ae.AlwaysOnSampler}}Rn.buildSamplerFromEnv=zh;var Pn=1;function Kh(e){if(e.OTEL_TRACES_SAMPLER_ARG===void 0||e.OTEL_TRACES_SAMPLER_ARG==="")return js.diag.error(`OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${Pn}.`),Pn;let t=Number(e.OTEL_TRACES_SAMPLER_ARG);return isNaN(t)?(js.diag.error(`OTEL_TRACES_SAMPLER_ARG=${e.OTEL_TRACES_SAMPLER_ARG} was given, but it is invalid, defaulting to ${Pn}.`),Pn):t<0||t>1?(js.diag.error(`OTEL_TRACES_SAMPLER_ARG=${e.OTEL_TRACES_SAMPLER_ARG} was given, but it is out of range ([0..1]), defaulting to ${Pn}.`),Pn):t}});var Xh=l(ks=>{"use strict";Object.defineProperty(ks,"__esModule",{value:!0});ks.mergeConfig=void 0;var Oc=Cc();function OC(e){let t={sampler:Oc.buildSamplerFromEnv()},r=Object.assign({},Oc.DEFAULT_CONFIG,t,e);return r.spanLimits=Object.assign({},Oc.DEFAULT_CONFIG.spanLimits,e.spanLimits||{}),r}ks.mergeConfig=OC});var Qh=l(Hs=>{"use strict";Object.defineProperty(Hs,"__esModule",{value:!0});Hs.Tracer=void 0;var ge=z(),Pc=Xe(),PC=bc(),RC=Xh(),Yh=class{constructor(t,r,n){this._tracerProvider=n;let i=RC.mergeConfig(r);this._sampler=i.sampler,this._spanLimits=i.spanLimits,this._idGenerator=r.idGenerator||new Pc.RandomIdGenerator,this.resource=n.resource,this.instrumentationLibrary=t}startSpan(t,r={},n=ge.context.active()){var i,a;if(Pc.isTracingSuppressed(n))return ge.diag.debug("Instrumentation suppressed, returning Noop Span"),ge.trace.wrapSpanContext(ge.INVALID_SPAN_CONTEXT);let s=NC(r,n),o=this._idGenerator.generateSpanId(),u,c,p;!s||!ge.trace.isSpanContextValid(s)?u=this._idGenerator.generateTraceId():(u=s.traceId,c=s.traceState,p=s.spanId);let f=(i=r.kind)!==null&&i!==void 0?i:ge.SpanKind.INTERNAL,d=(a=r.links)!==null&&a!==void 0?a:[],h=Pc.sanitizeAttributes(r.attributes),E=this._sampler.shouldSample(r.root?ge.trace.setSpanContext(n,ge.INVALID_SPAN_CONTEXT):n,u,t,f,h,d),S=E.decision===ge.SamplingDecision.RECORD_AND_SAMPLED?ge.TraceFlags.SAMPLED:ge.TraceFlags.NONE,j={traceId:u,spanId:o,traceFlags:S,traceState:c};if(E.decision===ge.SamplingDecision.NOT_RECORD)return ge.diag.debug("Recording is off, propagating context in a non-recording span"),ge.trace.wrapSpanContext(j);let oe=new PC.Span(this,n,t,j,f,p,d,r.startTime);return oe.setAttributes(Object.assign(h,E.attributes)),oe}startActiveSpan(t,r,n,i){let a,s,o;if(arguments.length<2)return;arguments.length===2?o=r:arguments.length===3?(a=r,o=n):(a=r,s=n,o=i);let u=s!=null?s:ge.context.active(),c=this.startSpan(t,a,u),p=ge.trace.setSpan(u,c);return ge.context.with(p,o,void 0,c)}getSpanLimits(){return this._spanLimits}getActiveSpanProcessor(){return this._tracerProvider.getActiveSpanProcessor()}};Hs.Tracer=Yh;function NC(e,t){if(!e.root)return ge.trace.getSpanContext(t)}});var Wh=l(Us=>{"use strict";Object.defineProperty(Us,"__esModule",{value:!0});Us.defaultServiceName=void 0;function DC(){return`unknown_service:${process.argv0}`}Us.defaultServiceName=DC});var Jh=l(Bs=>{"use strict";Object.defineProperty(Bs,"__esModule",{value:!0});Bs.detectResources=void 0;var Zh=Nc(),Rc=z(),wC=__webpack_require__(1669),xC=async(e={})=>{let t=Object.assign(e),r=await Promise.all((t.detectors||[]).map(async n=>{try{let i=await n.detect(t);return Rc.diag.debug(`${n.constructor.name} found resource.`,i),i}catch(i){return Rc.diag.debug(`${n.constructor.name} failed: ${i.message}`),Zh.Resource.empty()}}));return MC(r),r.reduce((n,i)=>n.merge(i),Zh.Resource.empty())};Bs.detectResources=xC;var MC=e=>{e.forEach(t=>{if(Object.keys(t.attributes).length>0){let r=wC.inspect(t.attributes,{depth:2,breakLength:1/0,sorted:!0,compact:!1});Rc.diag.verbose(r)}})}});var t_=l(Gs=>{"use strict";Object.defineProperty(Gs,"__esModule",{value:!0});Gs.envDetector=void 0;var LC=z(),qC=Xe(),jC=In(),kC=Fs(),e_=class{constructor(){this._MAX_LENGTH=255,this._COMMA_SEPARATOR=",",this._LABEL_KEY_VALUE_SPLITTER="=",this._ERROR_MESSAGE_INVALID_CHARS="should be a ASCII string with a length greater than 0 and not exceed "+this._MAX_LENGTH+" characters.",this._ERROR_MESSAGE_INVALID_VALUE="should be a ASCII string with a length not exceed "+this._MAX_LENGTH+" characters."}async detect(t){let r={},n=qC.getEnv(),i=n.OTEL_RESOURCE_ATTRIBUTES,a=n.OTEL_SERVICE_NAME;if(i)try{let s=this._parseResourceAttributes(i);Object.assign(r,s)}catch(s){LC.diag.debug(`EnvDetector failed: ${s.message}`)}return a&&(r[jC.ResourceAttributes.SERVICE_NAME]=a),new kC.Resource(r)}_parseResourceAttributes(t){if(!t)return{};let r={},n=t.split(this._COMMA_SEPARATOR,-1);for(let i of n){let a=i.split(this._LABEL_KEY_VALUE_SPLITTER,-1);if(a.length!==2)continue;let[s,o]=a;if(s=s.trim(),o=o.trim().split('^"|"$').join(""),!this._isValidAndNotEmpty(s))throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);if(!this._isValid(o))throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);r[s]=o}return r}_isValid(t){return t.length<=this._MAX_LENGTH&&this._isPrintableString(t)}_isPrintableString(t){for(let r=0;r<t.length;r++){let n=t.charAt(r);if(n<=" "||n>="~")return!1}return!0}_isValidAndNotEmpty(t){return t.length>0&&this._isValid(t)}};Gs.envDetector=new e_});var i_=l(Vs=>{"use strict";Object.defineProperty(Vs,"__esModule",{value:!0});Vs.processDetector=void 0;var HC=z(),Zt=In(),r_=Fs(),n_=class{async detect(t){let r={[Zt.ResourceAttributes.PROCESS_PID]:process.pid,[Zt.ResourceAttributes.PROCESS_EXECUTABLE_NAME]:process.title||"",[Zt.ResourceAttributes.PROCESS_COMMAND]:process.argv[1]||"",[Zt.ResourceAttributes.PROCESS_COMMAND_LINE]:process.argv.join(" ")||""};return this._getResourceAttributes(r,t)}_getResourceAttributes(t,r){return t[Zt.ResourceAttributes.PROCESS_EXECUTABLE_NAME]===""||t[Zt.ResourceAttributes.PROCESS_EXECUTABLE_PATH]===""||t[Zt.ResourceAttributes.PROCESS_COMMAND]===""||t[Zt.ResourceAttributes.PROCESS_COMMAND_LINE]===""?(HC.diag.debug("ProcessDetector failed: Unable to find required process resources. "),r_.Resource.empty()):new r_.Resource(Object.assign({},t))}};Vs.processDetector=new n_});var s_=l(Jt=>{"use strict";var UC=Jt&&Jt.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),a_=Jt&&Jt.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&UC(t,e,r)};Object.defineProperty(Jt,"__esModule",{value:!0});a_(t_(),Jt);a_(i_(),Jt)});var o_=l(Ot=>{"use strict";var BC=Ot&&Ot.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),Dc=Ot&&Ot.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&BC(t,e,r)};Object.defineProperty(Ot,"__esModule",{value:!0});Dc(Wh(),Ot);Dc(Jh(),Ot);Dc(s_(),Ot)});var wc=l(Or=>{"use strict";var GC=Or&&Or.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),FC=Or&&Or.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&GC(t,e,r)};Object.defineProperty(Or,"__esModule",{value:!0});FC(o_(),Or)});var Nc=l($s=>{"use strict";Object.defineProperty($s,"__esModule",{value:!0});$s.Resource=void 0;var Pr=In(),xc=Xe(),VC=wc(),er=class{constructor(t){this.attributes=t}static empty(){return er.EMPTY}static default(){return new er({[Pr.ResourceAttributes.SERVICE_NAME]:VC.defaultServiceName(),[Pr.ResourceAttributes.TELEMETRY_SDK_LANGUAGE]:xc.SDK_INFO[Pr.ResourceAttributes.TELEMETRY_SDK_LANGUAGE],[Pr.ResourceAttributes.TELEMETRY_SDK_NAME]:xc.SDK_INFO[Pr.ResourceAttributes.TELEMETRY_SDK_NAME],[Pr.ResourceAttributes.TELEMETRY_SDK_VERSION]:xc.SDK_INFO[Pr.ResourceAttributes.TELEMETRY_SDK_VERSION]})}merge(t){if(!t||!Object.keys(t.attributes).length)return this;let r=Object.assign({},this.attributes,t.attributes);return new er(r)}};$s.Resource=er;er.EMPTY=new er({})});var c_=l(u_=>{"use strict";Object.defineProperty(u_,"__esModule",{value:!0})});var p_=l(l_=>{"use strict";Object.defineProperty(l_,"__esModule",{value:!0})});var Fs=l(dt=>{"use strict";var $C=dt&&dt.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),zs=dt&&dt.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&$C(t,e,r)};Object.defineProperty(dt,"__esModule",{value:!0});zs(Nc(),dt);zs(wc(),dt);zs(c_(),dt);zs(p_(),dt)});var d_=l(Ks=>{"use strict";Object.defineProperty(Ks,"__esModule",{value:!0});Ks.MultiSpanProcessor=void 0;var zC=Xe(),f_=class{constructor(t){this._spanProcessors=t}forceFlush(){let t=[];for(let r of this._spanProcessors)t.push(r.forceFlush());return new Promise(r=>{Promise.all(t).then(()=>{r()}).catch(n=>{zC.globalErrorHandler(n||new Error("MultiSpanProcessor: forceFlush failed")),r()})})}onStart(t,r){for(let n of this._spanProcessors)n.onStart(t,r)}onEnd(t){for(let r of this._spanProcessors)r.onEnd(t)}shutdown(){let t=[];for(let r of this._spanProcessors)t.push(r.shutdown());return new Promise((r,n)=>{Promise.all(t).then(()=>{r()},n)})}};Ks.MultiSpanProcessor=f_});var Mc=l(Xs=>{"use strict";Object.defineProperty(Xs,"__esModule",{value:!0});Xs.NoopSpanProcessor=void 0;var h_=class{onStart(t,r){}onEnd(t){}shutdown(){return Promise.resolve()}forceFlush(){return Promise.resolve()}};Xs.NoopSpanProcessor=h_});var F_=l((Xi,wn)=>{var KC=200,__="__lodash_hash_undefined__",XC=800,YC=16,v_=9007199254740991,g_="[object Arguments]",QC="[object Array]",WC="[object AsyncFunction]",ZC="[object Boolean]",JC="[object Date]",eO="[object Error]",E_="[object Function]",tO="[object GeneratorFunction]",rO="[object Map]",nO="[object Number]",iO="[object Null]",m_="[object Object]",aO="[object Proxy]",sO="[object RegExp]",oO="[object Set]",uO="[object String]",cO="[object Undefined]",lO="[object WeakMap]",pO="[object ArrayBuffer]",fO="[object DataView]",dO="[object Float32Array]",hO="[object Float64Array]",_O="[object Int8Array]",vO="[object Int16Array]",gO="[object Int32Array]",EO="[object Uint8Array]",mO="[object Uint8ClampedArray]",yO="[object Uint16Array]",TO="[object Uint32Array]",SO=/[\\^$.*+?()[\]{}|]/g,AO=/^\[object .+?Constructor\]$/,IO=/^(?:0|[1-9]\d*)$/,K={};K[dO]=K[hO]=K[_O]=K[vO]=K[gO]=K[EO]=K[mO]=K[yO]=K[TO]=!0;K[g_]=K[QC]=K[pO]=K[ZC]=K[fO]=K[JC]=K[eO]=K[E_]=K[rO]=K[nO]=K[m_]=K[sO]=K[oO]=K[uO]=K[lO]=!1;var y_=typeof global=="object"&&global&&global.Object===Object&&global,bO=typeof self=="object"&&self&&self.Object===Object&&self,Vi=y_||bO||Function("return this")(),T_=typeof Xi=="object"&&Xi&&!Xi.nodeType&&Xi,$i=T_&&typeof wn=="object"&&wn&&!wn.nodeType&&wn,S_=$i&&$i.exports===T_,Lc=S_&&y_.process,A_=function(){try{var e=$i&&$i.require&&$i.require("util").types;return e||Lc&&Lc.binding&&Lc.binding("util")}catch(t){}}(),I_=A_&&A_.isTypedArray;function CO(e,t,r){switch(r.length){case 0:return e.call(t);case 1:return e.call(t,r[0]);case 2:return e.call(t,r[0],r[1]);case 3:return e.call(t,r[0],r[1],r[2])}return e.apply(t,r)}function OO(e,t){for(var r=-1,n=Array(e);++r<e;)n[r]=t(r);return n}function PO(e){return function(t){return e(t)}}function RO(e,t){return e==null?void 0:e[t]}function NO(e,t){return function(r){return e(t(r))}}var DO=Array.prototype,wO=Function.prototype,Ys=Object.prototype,qc=Vi["__core-js_shared__"],Qs=wO.toString,Pt=Ys.hasOwnProperty,b_=function(){var e=/[^.]+$/.exec(qc&&qc.keys&&qc.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}(),C_=Ys.toString,xO=Qs.call(Object),MO=RegExp("^"+Qs.call(Pt).replace(SO,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Ws=S_?Vi.Buffer:void 0,O_=Vi.Symbol,P_=Vi.Uint8Array,R_=Ws?Ws.allocUnsafe:void 0,N_=NO(Object.getPrototypeOf,Object),D_=Object.create,LO=Ys.propertyIsEnumerable,qO=DO.splice,Rr=O_?O_.toStringTag:void 0,Zs=function(){try{var e=Hc(Object,"defineProperty");return e({},"",{}),e}catch(t){}}(),jO=Ws?Ws.isBuffer:void 0,w_=Math.max,kO=Date.now,x_=Hc(Vi,"Map"),zi=Hc(Object,"create"),HO=function(){function e(){}return function(t){if(!Dr(t))return{};if(D_)return D_(t);e.prototype=t;var r=new e;return e.prototype=void 0,r}}();function Nr(e){var t=-1,r=e==null?0:e.length;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}function UO(){this.__data__=zi?zi(null):{},this.size=0}function BO(e){var t=this.has(e)&&delete this.__data__[e];return this.size-=t?1:0,t}function GO(e){var t=this.__data__;if(zi){var r=t[e];return r===__?void 0:r}return Pt.call(t,e)?t[e]:void 0}function FO(e){var t=this.__data__;return zi?t[e]!==void 0:Pt.call(t,e)}function VO(e,t){var r=this.__data__;return this.size+=this.has(e)?0:1,r[e]=zi&&t===void 0?__:t,this}Nr.prototype.clear=UO;Nr.prototype.delete=BO;Nr.prototype.get=GO;Nr.prototype.has=FO;Nr.prototype.set=VO;function Rt(e){var t=-1,r=e==null?0:e.length;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}function $O(){this.__data__=[],this.size=0}function zO(e){var t=this.__data__,r=Js(t,e);if(r<0)return!1;var n=t.length-1;return r==n?t.pop():qO.call(t,r,1),--this.size,!0}function KO(e){var t=this.__data__,r=Js(t,e);return r<0?void 0:t[r][1]}function XO(e){return Js(this.__data__,e)>-1}function YO(e,t){var r=this.__data__,n=Js(r,e);return n<0?(++this.size,r.push([e,t])):r[n][1]=t,this}Rt.prototype.clear=$O;Rt.prototype.delete=zO;Rt.prototype.get=KO;Rt.prototype.has=XO;Rt.prototype.set=YO;function Nn(e){var t=-1,r=e==null?0:e.length;for(this.clear();++t<r;){var n=e[t];this.set(n[0],n[1])}}function QO(){this.size=0,this.__data__={hash:new Nr,map:new(x_||Rt),string:new Nr}}function WO(e){var t=to(this,e).delete(e);return this.size-=t?1:0,t}function ZO(e){return to(this,e).get(e)}function JO(e){return to(this,e).has(e)}function eP(e,t){var r=to(this,e),n=r.size;return r.set(e,t),this.size+=r.size==n?0:1,this}Nn.prototype.clear=QO;Nn.prototype.delete=WO;Nn.prototype.get=ZO;Nn.prototype.has=JO;Nn.prototype.set=eP;function Dn(e){var t=this.__data__=new Rt(e);this.size=t.size}function tP(){this.__data__=new Rt,this.size=0}function rP(e){var t=this.__data__,r=t.delete(e);return this.size=t.size,r}function nP(e){return this.__data__.get(e)}function iP(e){return this.__data__.has(e)}function aP(e,t){var r=this.__data__;if(r instanceof Rt){var n=r.__data__;if(!x_||n.length<KC-1)return n.push([e,t]),this.size=++r.size,this;r=this.__data__=new Nn(n)}return r.set(e,t),this.size=r.size,this}Dn.prototype.clear=tP;Dn.prototype.delete=rP;Dn.prototype.get=nP;Dn.prototype.has=iP;Dn.prototype.set=aP;function sP(e,t){var r=Gc(e),n=!r&&Bc(e),i=!r&&!n&&k_(e),a=!r&&!n&&!i&&U_(e),s=r||n||i||a,o=s?OO(e.length,String):[],u=o.length;for(var c in e)(t||Pt.call(e,c))&&!(s&&(c=="length"||i&&(c=="offset"||c=="parent")||a&&(c=="buffer"||c=="byteLength"||c=="byteOffset")||q_(c,u)))&&o.push(c);return o}function jc(e,t,r){(r!==void 0&&!ro(e[t],r)||r===void 0&&!(t in e))&&kc(e,t,r)}function oP(e,t,r){var n=e[t];(!(Pt.call(e,t)&&ro(n,r))||r===void 0&&!(t in e))&&kc(e,t,r)}function Js(e,t){for(var r=e.length;r--;)if(ro(e[r][0],t))return r;return-1}function kc(e,t,r){t=="__proto__"&&Zs?Zs(e,t,{configurable:!0,enumerable:!0,value:r,writable:!0}):e[t]=r}var uP=TP();function eo(e){return e==null?e===void 0?cO:iO:Rr&&Rr in Object(e)?SP(e):PP(e)}function M_(e){return Ki(e)&&eo(e)==g_}function cP(e){if(!Dr(e)||CP(e))return!1;var t=Vc(e)?MO:AO;return t.test(wP(e))}function lP(e){return Ki(e)&&H_(e.length)&&!!K[eo(e)]}function pP(e){if(!Dr(e))return OP(e);var t=j_(e),r=[];for(var n in e)n=="constructor"&&(t||!Pt.call(e,n))||r.push(n);return r}function L_(e,t,r,n,i){e!==t&&uP(t,function(a,s){if(i||(i=new Dn),Dr(a))fP(e,t,s,r,L_,n,i);else{var o=n?n(Uc(e,s),a,s+"",e,t,i):void 0;o===void 0&&(o=a),jc(e,s,o)}},B_)}function fP(e,t,r,n,i,a,s){var o=Uc(e,r),u=Uc(t,r),c=s.get(u);if(c){jc(e,r,c);return}var p=a?a(o,u,r+"",e,t,s):void 0,f=p===void 0;if(f){var d=Gc(u),h=!d&&k_(u),E=!d&&!h&&U_(u);p=u,d||h||E?Gc(o)?p=o:xP(o)?p=EP(o):h?(f=!1,p=_P(u,!0)):E?(f=!1,p=gP(u,!0)):p=[]:MP(u)||Bc(u)?(p=o,Bc(o)?p=LP(o):(!Dr(o)||Vc(o))&&(p=AP(u))):f=!1}f&&(s.set(u,p),i(p,u,n,a,s),s.delete(u)),jc(e,r,p)}function dP(e,t){return NP(RP(e,t,G_),e+"")}var hP=Zs?function(e,t){return Zs(e,"toString",{configurable:!0,enumerable:!1,value:jP(t),writable:!0})}:G_;function _P(e,t){if(t)return e.slice();var r=e.length,n=R_?R_(r):new e.constructor(r);return e.copy(n),n}function vP(e){var t=new e.constructor(e.byteLength);return new P_(t).set(new P_(e)),t}function gP(e,t){var r=t?vP(e.buffer):e.buffer;return new e.constructor(r,e.byteOffset,e.length)}function EP(e,t){var r=-1,n=e.length;for(t||(t=Array(n));++r<n;)t[r]=e[r];return t}function mP(e,t,r,n){var i=!r;r||(r={});for(var a=-1,s=t.length;++a<s;){var o=t[a],u=n?n(r[o],e[o],o,r,e):void 0;u===void 0&&(u=e[o]),i?kc(r,o,u):oP(r,o,u)}return r}function yP(e){return dP(function(t,r){var n=-1,i=r.length,a=i>1?r[i-1]:void 0,s=i>2?r[2]:void 0;for(a=e.length>3&&typeof a=="function"?(i--,a):void 0,s&&IP(r[0],r[1],s)&&(a=i<3?void 0:a,i=1),t=Object(t);++n<i;){var o=r[n];o&&e(t,o,n,a)}return t})}function TP(e){return function(t,r,n){for(var i=-1,a=Object(t),s=n(t),o=s.length;o--;){var u=s[e?o:++i];if(r(a[u],u,a)===!1)break}return t}}function to(e,t){var r=e.__data__;return bP(t)?r[typeof t=="string"?"string":"hash"]:r.map}function Hc(e,t){var r=RO(e,t);return cP(r)?r:void 0}function SP(e){var t=Pt.call(e,Rr),r=e[Rr];try{e[Rr]=void 0;var n=!0}catch(a){}var i=C_.call(e);return n&&(t?e[Rr]=r:delete e[Rr]),i}function AP(e){return typeof e.constructor=="function"&&!j_(e)?HO(N_(e)):{}}function q_(e,t){var r=typeof e;return t=t==null?v_:t,!!t&&(r=="number"||r!="symbol"&&IO.test(e))&&e>-1&&e%1==0&&e<t}function IP(e,t,r){if(!Dr(r))return!1;var n=typeof t;return(n=="number"?Fc(r)&&q_(t,r.length):n=="string"&&t in r)?ro(r[t],e):!1}function bP(e){var t=typeof e;return t=="string"||t=="number"||t=="symbol"||t=="boolean"?e!=="__proto__":e===null}function CP(e){return!!b_&&b_ in e}function j_(e){var t=e&&e.constructor,r=typeof t=="function"&&t.prototype||Ys;return e===r}function OP(e){var t=[];if(e!=null)for(var r in Object(e))t.push(r);return t}function PP(e){return C_.call(e)}function RP(e,t,r){return t=w_(t===void 0?e.length-1:t,0),function(){for(var n=arguments,i=-1,a=w_(n.length-t,0),s=Array(a);++i<a;)s[i]=n[t+i];i=-1;for(var o=Array(t+1);++i<t;)o[i]=n[i];return o[t]=r(s),CO(e,this,o)}}function Uc(e,t){if(!(t==="constructor"&&typeof e[t]=="function")&&t!="__proto__")return e[t]}var NP=DP(hP);function DP(e){var t=0,r=0;return function(){var n=kO(),i=YC-(n-r);if(r=n,i>0){if(++t>=XC)return arguments[0]}else t=0;return e.apply(void 0,arguments)}}function wP(e){if(e!=null){try{return Qs.call(e)}catch(t){}try{return e+""}catch(t){}}return""}function ro(e,t){return e===t||e!==e&&t!==t}var Bc=M_(function(){return arguments}())?M_:function(e){return Ki(e)&&Pt.call(e,"callee")&&!LO.call(e,"callee")},Gc=Array.isArray;function Fc(e){return e!=null&&H_(e.length)&&!Vc(e)}function xP(e){return Ki(e)&&Fc(e)}var k_=jO||kP;function Vc(e){if(!Dr(e))return!1;var t=eo(e);return t==E_||t==tO||t==WC||t==aO}function H_(e){return typeof e=="number"&&e>-1&&e%1==0&&e<=v_}function Dr(e){var t=typeof e;return e!=null&&(t=="object"||t=="function")}function Ki(e){return e!=null&&typeof e=="object"}function MP(e){if(!Ki(e)||eo(e)!=m_)return!1;var t=N_(e);if(t===null)return!0;var r=Pt.call(t,"constructor")&&t.constructor;return typeof r=="function"&&r instanceof r&&Qs.call(r)==xO}var U_=I_?PO(I_):lP;function LP(e){return mP(e,B_(e))}function B_(e){return Fc(e)?sP(e,!0):pP(e)}var qP=yP(function(e,t,r){L_(e,t,r)});function jP(e){return function(){return e}}function G_(e){return e}function kP(){return!1}wn.exports=qP});var z_=l(no=>{"use strict";Object.defineProperty(no,"__esModule",{value:!0});no.BatchSpanProcessorBase=void 0;var V_=z(),Yi=Xe(),$_=class{constructor(t,r){this._exporter=t,this._finishedSpans=[],this._isShutdown=!1,this._shuttingDownPromise=Promise.resolve();let n=Yi.getEnv();this._maxExportBatchSize=typeof(r==null?void 0:r.maxExportBatchSize)=="number"?r.maxExportBatchSize:n.OTEL_BSP_MAX_EXPORT_BATCH_SIZE,this._maxQueueSize=typeof(r==null?void 0:r.maxQueueSize)=="number"?r.maxQueueSize:n.OTEL_BSP_MAX_QUEUE_SIZE,this._scheduledDelayMillis=typeof(r==null?void 0:r.scheduledDelayMillis)=="number"?r.scheduledDelayMillis:n.OTEL_BSP_SCHEDULE_DELAY,this._exportTimeoutMillis=typeof(r==null?void 0:r.exportTimeoutMillis)=="number"?r.exportTimeoutMillis:n.OTEL_BSP_EXPORT_TIMEOUT}forceFlush(){return this._isShutdown?this._shuttingDownPromise:this._flushAll()}onStart(t){}onEnd(t){this._isShutdown||this._addToBuffer(t)}shutdown(){return this._isShutdown?this._shuttingDownPromise:(this._isShutdown=!0,this._shuttingDownPromise=new Promise((t,r)=>{Promise.resolve().then(()=>this.onShutdown()).then(()=>this._flushAll()).then(()=>this._exporter.shutdown()).then(t).catch(n=>{r(n)})}),this._shuttingDownPromise)}_addToBuffer(t){this._finishedSpans.length>=this._maxQueueSize||(this._finishedSpans.push(t),this._maybeStartTimer())}_flushAll(){return new Promise((t,r)=>{let n=[],i=Math.ceil(this._finishedSpans.length/this._maxExportBatchSize);for(let a=0,s=i;a<s;a++)n.push(this._flushOneBatch());Promise.all(n).then(()=>{t()}).catch(r)})}_flushOneBatch(){return this._clearTimer(),this._finishedSpans.length===0?Promise.resolve():new Promise((t,r)=>{let n=setTimeout(()=>{r(new Error("Timeout"))},this._exportTimeoutMillis);V_.context.with(Yi.suppressTracing(V_.context.active()),()=>{this._exporter.export(this._finishedSpans.splice(0,this._maxExportBatchSize),i=>{var a;clearTimeout(n),i.code===Yi.ExportResultCode.SUCCESS?t():r((a=i.error)!==null&&a!==void 0?a:new Error("BatchSpanProcessor: span export failed"))})})})}_maybeStartTimer(){this._timer===void 0&&(this._timer=setTimeout(()=>{this._flushOneBatch().then(()=>{this._finishedSpans.length>0&&(this._clearTimer(),this._maybeStartTimer())}).catch(t=>{Yi.globalErrorHandler(t)})},this._scheduledDelayMillis),Yi.unrefTimer(this._timer))}_clearTimer(){this._timer!==void 0&&(clearTimeout(this._timer),this._timer=void 0)}};no.BatchSpanProcessorBase=$_});var X_=l(io=>{"use strict";Object.defineProperty(io,"__esModule",{value:!0});io.BatchSpanProcessor=void 0;var HP=z_(),K_=class extends HP.BatchSpanProcessorBase{onShutdown(){}};io.BatchSpanProcessor=K_});var Y_=l(wr=>{"use strict";var UP=wr&&wr.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),BP=wr&&wr.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&UP(t,e,r)};Object.defineProperty(wr,"__esModule",{value:!0});BP(X_(),wr)});var $c=l(xr=>{"use strict";var GP=xr&&xr.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),FP=xr&&xr.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&GP(t,e,r)};Object.defineProperty(xr,"__esModule",{value:!0});FP(Y_(),xr)});var W_=l(Lr=>{"use strict";Object.defineProperty(Lr,"__esModule",{value:!0});Lr.BasicTracerProvider=Lr.ForceFlushState=void 0;var xn=z(),Qi=Xe(),Q_=Fs(),VP=zc(),$P=Cc(),zP=d_(),KP=Mc(),XP=F_(),YP=$c(),Mn;(function(e){e[e.resolved=0]="resolved",e[e.timeout=1]="timeout",e[e.error=2]="error",e[e.unresolved=3]="unresolved"})(Mn=Lr.ForceFlushState||(Lr.ForceFlushState={}));var Mr=class{constructor(t={}){var r;this._registeredSpanProcessors=[],this._tracers=new Map;let n=XP({},$P.DEFAULT_CONFIG,t);this.resource=(r=n.resource)!==null&&r!==void 0?r:Q_.Resource.empty(),this.resource=Q_.Resource.default().merge(this.resource),this._config=Object.assign({},n,{resource:this.resource});let i=this._buildExporterFromEnv();if(i!==void 0){let a=new YP.BatchSpanProcessor(i);this.activeSpanProcessor=a}else this.activeSpanProcessor=new KP.NoopSpanProcessor}getTracer(t,r){let n=`${t}@${r||""}`;return this._tracers.has(n)||this._tracers.set(n,new VP.Tracer({name:t,version:r},this._config,this)),this._tracers.get(n)}addSpanProcessor(t){this._registeredSpanProcessors.length===0&&this.activeSpanProcessor.shutdown().catch(r=>xn.diag.error("Error while trying to shutdown current span processor",r)),this._registeredSpanProcessors.push(t),this.activeSpanProcessor=new zP.MultiSpanProcessor(this._registeredSpanProcessors)}getActiveSpanProcessor(){return this.activeSpanProcessor}register(t={}){xn.trace.setGlobalTracerProvider(this),t.propagator===void 0&&(t.propagator=this._buildPropagatorFromEnv()),t.contextManager&&xn.context.setGlobalContextManager(t.contextManager),t.propagator&&xn.propagation.setGlobalPropagator(t.propagator)}forceFlush(){let t=this._config.forceFlushTimeoutMillis,r=this._registeredSpanProcessors.map(n=>new Promise(i=>{let a,s=setTimeout(()=>{i(new Error(`Span processor did not completed within timeout period of ${t} ms`)),a=Mn.timeout},t);n.forceFlush().then(()=>{clearTimeout(s),a!==Mn.timeout&&(a=Mn.resolved,i(a))}).catch(o=>{clearTimeout(s),a=Mn.error,i(o)})}));return new Promise((n,i)=>{Promise.all(r).then(a=>{let s=a.filter(o=>o!==Mn.resolved);s.length>0?i(s):n()}).catch(a=>i([a]))})}shutdown(){return this.activeSpanProcessor.shutdown()}_getPropagator(t){var r;return(r=Mr._registeredPropagators.get(t))===null||r===void 0?void 0:r()}_getSpanExporter(t){var r;return(r=Mr._registeredExporters.get(t))===null||r===void 0?void 0:r()}_buildPropagatorFromEnv(){let t=Array.from(new Set(Qi.getEnv().OTEL_PROPAGATORS)),n=t.map(i=>{let a=this._getPropagator(i);return a||xn.diag.warn(`Propagator "${i}" requested through environment variable is unavailable.`),a}).reduce((i,a)=>(a&&i.push(a),i),[]);if(n.length!==0)return t.length===1?n[0]:new Qi.CompositePropagator({propagators:n})}_buildExporterFromEnv(){let t=Qi.getEnv().OTEL_TRACES_EXPORTER;if(t==="none")return;let r=this._getSpanExporter(t);return r||xn.diag.error(`Exporter "${t}" requested through environment variable is unavailable.`),r}};Lr.BasicTracerProvider=Mr;Mr._registeredPropagators=new Map([["tracecontext",()=>new Qi.HttpTraceContextPropagator],["baggage",()=>new Qi.HttpBaggagePropagator]]);Mr._registeredExporters=new Map});var J_=l(ao=>{"use strict";Object.defineProperty(ao,"__esModule",{value:!0});ao.ConsoleSpanExporter=void 0;var Kc=Xe(),Z_=class{export(t,r){return this._sendSpans(t,r)}shutdown(){return this._sendSpans([]),Promise.resolve()}_exportInfo(t){return{traceId:t.spanContext().traceId,parentId:t.parentSpanId,name:t.name,id:t.spanContext().spanId,kind:t.kind,timestamp:Kc.hrTimeToMicroseconds(t.startTime),duration:Kc.hrTimeToMicroseconds(t.duration),attributes:t.attributes,status:t.status,events:t.events}}_sendSpans(t,r){for(let n of t)console.log(this._exportInfo(n));if(r)return r({code:Kc.ExportResultCode.SUCCESS})}};ao.ConsoleSpanExporter=Z_});var rv=l(so=>{"use strict";Object.defineProperty(so,"__esModule",{value:!0});so.InMemorySpanExporter=void 0;var ev=Xe(),tv=class{constructor(){this._finishedSpans=[],this._stopped=!1}export(t,r){if(this._stopped)return r({code:ev.ExportResultCode.FAILED,error:new Error("Exporter has been stopped")});this._finishedSpans.push(...t),setTimeout(()=>r({code:ev.ExportResultCode.SUCCESS}),0)}shutdown(){return this._stopped=!0,this._finishedSpans=[],Promise.resolve()}reset(){this._finishedSpans=[]}getFinishedSpans(){return this._finishedSpans}};so.InMemorySpanExporter=tv});var iv=l(nv=>{"use strict";Object.defineProperty(nv,"__esModule",{value:!0})});var ov=l(oo=>{"use strict";Object.defineProperty(oo,"__esModule",{value:!0});oo.SimpleSpanProcessor=void 0;var av=z(),Xc=Xe(),sv=class{constructor(t){this._exporter=t,this._isShutdown=!1,this._shuttingDownPromise=Promise.resolve()}forceFlush(){return Promise.resolve()}onStart(t){}onEnd(t){this._isShutdown||av.context.with(Xc.suppressTracing(av.context.active()),()=>{this._exporter.export([t],r=>{var n;r.code!==Xc.ExportResultCode.SUCCESS&&Xc.globalErrorHandler((n=r.error)!==null&&n!==void 0?n:new Error(`SimpleSpanProcessor: span export failed (status ${r})`))})})}shutdown(){return this._isShutdown?this._shuttingDownPromise:(this._isShutdown=!0,this._shuttingDownPromise=new Promise((t,r)=>{Promise.resolve().then(()=>this._exporter.shutdown()).then(t).catch(n=>{r(n)})}),this._shuttingDownPromise)}};oo.SimpleSpanProcessor=sv});var cv=l(uv=>{"use strict";Object.defineProperty(uv,"__esModule",{value:!0})});var pv=l(lv=>{"use strict";Object.defineProperty(lv,"__esModule",{value:!0})});var dv=l(fv=>{"use strict";Object.defineProperty(fv,"__esModule",{value:!0})});var _v=l(hv=>{"use strict";Object.defineProperty(hv,"__esModule",{value:!0})});var zc=l(he=>{"use strict";var QP=he&&he.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),Ue=he&&he.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&QP(t,e,r)};Object.defineProperty(he,"__esModule",{value:!0});Ue(Qh(),he);Ue(W_(),he);Ue($c(),he);Ue(J_(),he);Ue(rv(),he);Ue(iv(),he);Ue(ov(),he);Ue(cv(),he);Ue(Mc(),he);Ue(bc(),he);Ue(pv(),he);Ue(dv(),he);Ue(_v(),he)});var Ev=l(ht=>{"use strict";Object.defineProperty(ht,"__esModule",{value:!0});ht.enable=ht.azureCoreTracing=ht.AzureMonitorSymbol=void 0;var vv=ue();ht.AzureMonitorSymbol="Azure_Monitor_Tracer";var gv=!1,WP=function(e){if(gv)return e;try{var t=zc(),r=z(),n=new t.BasicTracerProvider,i=n.getTracer("applicationinsights tracer"),a=e.setTracer;e.setTracer=function(s){var o=s.startSpan;s.startSpan=function(u,c,p){var f=o.call(this,u,c,p),d=f.end;return f.end=function(){var h=d.apply(this,arguments);return vv.channel.publish("azure-coretracing",f),h},f},s[ht.AzureMonitorSymbol]=!0,a.call(this,s)},r.trace.getSpan(r.context.active()),e.setTracer(i),gv=!0}catch(s){}return e};ht.azureCoreTracing={versionSpecifier:">= 1.0.0 < 2.0.0",patch:WP};function ZP(){vv.channel.registerMonkeyPatch("@azure/core-tracing",ht.azureCoreTracing)}ht.enable=ZP});var yv=l(qr=>{"use strict";Object.defineProperty(qr,"__esModule",{value:!0});qr.enable=qr.bunyan=void 0;var mv=ue(),JP=function(e){var t=e.prototype._emit;return e.prototype._emit=function(r,n){var i=t.apply(this,arguments);if(!n){var a=i;a||(a=t.call(this,r,!0)),mv.channel.publish("bunyan",{level:r.level,result:a})}return i},e};qr.bunyan={versionSpecifier:">= 1.0.0 < 2.0.0",patch:JP};function eR(){mv.channel.registerMonkeyPatch("bunyan",qr.bunyan)}qr.enable=eR});var Sv=l(jr=>{"use strict";Object.defineProperty(jr,"__esModule",{value:!0});jr.enable=jr.console=void 0;var Yc=ue(),Tv=__webpack_require__(2413),tR=function(e){var t=new Tv.Writable,r=new Tv.Writable;t.write=function(c){if(!c)return!0;var p=c.toString();return Yc.channel.publish("console",{message:p}),!0},r.write=function(c){if(!c)return!0;var p=c.toString();return Yc.channel.publish("console",{message:p,stderr:!0}),!0};for(var n=new e.Console(t,r),i=["log","info","warn","error","dir","time","timeEnd","trace","assert"],a=function(c){var p=e[c];p&&(e[c]=function(){if(n[c])try{n[c].apply(n,arguments)}catch(f){}return p.apply(e,arguments)})},s=0,o=i;s<o.length;s++){var u=o[s];a(u)}return e};jr.console={versionSpecifier:">= 4.0.0",patch:tR};function rR(){Yc.channel.registerMonkeyPatch("console",jr.console),__webpack_require__(7082)}jr.enable=rR});var Av=l(kr=>{"use strict";Object.defineProperty(kr,"__esModule",{value:!0});kr.enable=kr.mongoCore=void 0;var Qc=ue(),nR=function(e){var t=e.Server.prototype.connect;return e.Server.prototype.connect=function(){var n=t.apply(this,arguments),i=this.s.pool.write;this.s.pool.write=function(){var o=typeof arguments[1]=="function"?1:2;return typeof arguments[o]=="function"&&(arguments[o]=Qc.channel.bindToContext(arguments[o])),i.apply(this,arguments)};var a=this.s.pool.logout;return this.s.pool.logout=function(){return typeof arguments[1]=="function"&&(arguments[1]=Qc.channel.bindToContext(arguments[1])),a.apply(this,arguments)},n},e};kr.mongoCore={versionSpecifier:">= 2.0.0 < 4.0.0",patch:nR};function iR(){Qc.channel.registerMonkeyPatch("mongodb-core",kr.mongoCore)}kr.enable=iR});var Iv=l(Ne=>{"use strict";var Ln=Ne&&Ne.__assign||function(){return Ln=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++){t=arguments[r];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},Ln.apply(this,arguments)};Object.defineProperty(Ne,"__esModule",{value:!0});Ne.enable=Ne.mongo330=Ne.mongo3=Ne.mongo2=void 0;var Ce=ue(),aR=function(e){var t=e.instrument({operationIdGenerator:{next:function(){return Ce.channel.bindToContext(function(n){return n()})}}}),r={};return t.on("started",function(n){r[n.requestId]||(r[n.requestId]=Ln(Ln({},n),{time:new Date}))}),t.on("succeeded",function(n){var i=r[n.requestId];i&&delete r[n.requestId],typeof n.operationId=="function"?n.operationId(function(){return Ce.channel.publish("mongodb",{startedData:i,event:n,succeeded:!0})}):Ce.channel.publish("mongodb",{startedData:i,event:n,succeeded:!0})}),t.on("failed",function(n){var i=r[n.requestId];i&&delete r[n.requestId],typeof n.operationId=="function"?n.operationId(function(){return Ce.channel.publish("mongodb",{startedData:i,event:n,succeeded:!1})}):Ce.channel.publish("mongodb",{startedData:i,event:n,succeeded:!1})}),e},sR=function(e){var t=e.instrument(),r={},n={};return t.on("started",function(i){r[i.requestId]||(n[i.requestId]=Ce.channel.bindToContext(function(a){return a()}),r[i.requestId]=Ln(Ln({},i),{time:new Date}))}),t.on("succeeded",function(i){var a=r[i.requestId];a&&delete r[i.requestId],typeof i=="object"&&typeof n[i.requestId]=="function"&&(n[i.requestId](function(){return Ce.channel.publish("mongodb",{startedData:a,event:i,succeeded:!0})}),delete n[i.requestId])}),t.on("failed",function(i){var a=r[i.requestId];a&&delete r[i.requestId],typeof i=="object"&&typeof n[i.requestId]=="function"&&(n[i.requestId](function(){return Ce.channel.publish("mongodb",{startedData:a,event:i,succeeded:!1})}),delete n[i.requestId])}),e},oR=function(e){var t=e.Server.prototype.connect;return e.Server.prototype.connect=function(){var n=t.apply(this,arguments),i=this.s.coreTopology.s.pool.write;this.s.coreTopology.s.pool.write=function(){var o=typeof arguments[1]=="function"?1:2;return typeof arguments[o]=="function"&&(arguments[o]=Ce.channel.bindToContext(arguments[o])),i.apply(this,arguments)};var a=this.s.coreTopology.s.pool.logout;return this.s.coreTopology.s.pool.logout=function(){return typeof arguments[1]=="function"&&(arguments[1]=Ce.channel.bindToContext(arguments[1])),a.apply(this,arguments)},n},e},uR=function(e){oR(e);var t=e.instrument(),r={},n={};return t.on("started",function(i){r[i.requestId]||(n[i.requestId]=Ce.channel.bindToContext(function(a){return a()}),r[i.requestId]=i)}),t.on("succeeded",function(i){var a=r[i.requestId];a&&delete r[i.requestId],typeof i=="object"&&typeof n[i.requestId]=="function"&&(n[i.requestId](function(){return Ce.channel.publish("mongodb",{startedData:a,event:i,succeeded:!0})}),delete n[i.requestId])}),t.on("failed",function(i){var a=r[i.requestId];a&&delete r[i.requestId],typeof i=="object"&&typeof n[i.requestId]=="function"&&(n[i.requestId](function(){return Ce.channel.publish("mongodb",{startedData:a,event:i,succeeded:!1})}),delete n[i.requestId])}),e};Ne.mongo2={versionSpecifier:">= 2.0.0 <= 3.0.5",patch:aR};Ne.mongo3={versionSpecifier:"> 3.0.5 < 3.3.0",patch:sR};Ne.mongo330={versionSpecifier:">= 3.3.0 < 4.0.0",patch:uR};function cR(){Ce.channel.registerMonkeyPatch("mongodb",Ne.mongo2),Ce.channel.registerMonkeyPatch("mongodb",Ne.mongo3),Ce.channel.registerMonkeyPatch("mongodb",Ne.mongo330)}Ne.enable=cR});var Cv=l(Hr=>{"use strict";Object.defineProperty(Hr,"__esModule",{value:!0});Hr.enable=Hr.mysql=void 0;var uo=ue(),bv=__webpack_require__(5622),lR=function(e,t){var r=function(u,c){return function(p,f){var d=u[p];d&&(u[p]=function(){for(var E=arguments.length-1,S=arguments.length-1;S>=0;--S)if(typeof arguments[S]=="function"){E=S;break}else if(typeof arguments[S]!="undefined")break;var j=arguments[E],oe={result:null,startTime:null,startDate:null};typeof j=="function"&&(f?(oe.startTime=process.hrtime(),oe.startDate=new Date,arguments[E]=uo.channel.bindToContext(f(oe,j))):arguments[E]=uo.channel.bindToContext(j));var Ae=d.apply(this,arguments);return oe.result=Ae,Ae})}},n=function(u,c){return r(u.prototype,c+".prototype")},i=["connect","changeUser","ping","statistics","end"],a=__webpack_require__(3255)(bv.dirname(t)+"/lib/Connection");i.forEach(function(u){return n(a,"Connection")(u)}),r(a,"Connection")("createQuery",function(u,c){return function(p){var f=process.hrtime(u.startTime),d=f[0]*1e3+f[1]/1e6|0;uo.channel.publish("mysql",{query:u.result,callbackArgs:arguments,err:p,duration:d,time:u.startDate}),c.apply(this,arguments)}});var s=["_enqueueCallback"],o=__webpack_require__(9118)(bv.dirname(t)+"/lib/Pool");return s.forEach(function(u){return n(o,"Pool")(u)}),e};Hr.mysql={versionSpecifier:">= 2.0.0 < 3.0.0",patch:lR};function pR(){uo.channel.registerMonkeyPatch("mysql",Hr.mysql)}Hr.enable=pR});var Pv=l(Ur=>{"use strict";Object.defineProperty(Ur,"__esModule",{value:!0});Ur.enable=Ur.postgresPool1=void 0;var Ov=ue();function fR(e){var t=e.prototype.connect;return e.prototype.connect=function(n){return n&&(arguments[0]=Ov.channel.bindToContext(n)),t.apply(this,arguments)},e}Ur.postgresPool1={versionSpecifier:">= 1.0.0 < 3.0.0",patch:fR};function dR(){Ov.channel.registerMonkeyPatch("pg-pool",Ur.postgresPool1)}Ur.enable=dR});var Nv=l(_t=>{"use strict";Object.defineProperty(_t,"__esModule",{value:!0});_t.enable=_t.postgres7=_t.postgres6=void 0;var qn=ue(),Rv=__webpack_require__(8614);function hR(e,t){var r=e.Client.prototype.query,n="__diagnosticOriginalFunc";return e.Client.prototype.query=function(a,s,o){var u={query:{},database:{host:this.connectionParameters.host,port:this.connectionParameters.port},result:null,error:null,duration:0,time:new Date},c=process.hrtime(),p;function f(d){d&&d[n]&&(d=d[n]);var h=qn.channel.bindToContext(function(E,S){var j=process.hrtime(c);if(u.result=S&&{rowCount:S.rowCount,command:S.command},u.error=E,u.duration=Math.ceil(j[0]*1e3+j[1]/1e6),qn.channel.publish("postgres",u),E){if(d)return d.apply(this,arguments);p&&p instanceof Rv.EventEmitter&&p.emit("error",E)}else d&&d.apply(this,arguments)});try{return Object.defineProperty(h,n,{value:d}),h}catch(E){return d}}try{typeof a=="string"?s instanceof Array?(u.query.preparable={text:a,args:s},o=f(o)):(u.query.text=a,o?o=f(o):s=f(s)):(typeof a.name=="string"?u.query.plan=a.name:a.values instanceof Array?u.query.preparable={text:a.text,args:a.values}:u.query.text=a.text,o?o=f(o):s?s=f(s):a.callback=f(a.callback))}catch(d){return r.apply(this,arguments)}return arguments[0]=a,arguments[1]=s,arguments[2]=o,arguments.length=arguments.length>3?arguments.length:3,p=r.apply(this,arguments),p},e}function _R(e,t){var r=e.Client.prototype.query,n="__diagnosticOriginalFunc";return e.Client.prototype.query=function(a,s,o){var u=this,c=!!o,p={query:{},database:{host:this.connectionParameters.host,port:this.connectionParameters.port},result:null,error:null,duration:0,time:new Date},f=process.hrtime(),d;function h(E){E&&E[n]&&(E=E[n]);var S=qn.channel.bindToContext(function(j,oe){var Ae=process.hrtime(f);if(p.result=oe&&{rowCount:oe.rowCount,command:oe.command},p.error=j,p.duration=Math.ceil(Ae[0]*1e3+Ae[1]/1e6),qn.channel.publish("postgres",p),j){if(E)return E.apply(this,arguments);d&&d instanceof Rv.EventEmitter&&d.emit("error",j)}else E&&E.apply(this,arguments)});try{return Object.defineProperty(S,n,{value:E}),S}catch(j){return E}}try{typeof a=="string"?s instanceof Array?(p.query.preparable={text:a,args:s},c=typeof o=="function",o=c?h(o):o):(p.query.text=a,o?(c=typeof o=="function",o=c?h(o):o):(c=typeof s=="function",s=c?h(s):s)):(typeof a.name=="string"?p.query.plan=a.name:a.values instanceof Array?p.query.preparable={text:a.text,args:a.values}:p.query.text=a.text,o?(c=typeof o=="function",o=h(o)):s?(c=typeof s=="function",s=c?h(s):s):(c=typeof a.callback=="function",a.callback=c?h(a.callback):a.callback))}catch(E){return r.apply(this,arguments)}return arguments[0]=a,arguments[1]=s,arguments[2]=o,arguments.length=arguments.length>3?arguments.length:3,d=r.apply(this,arguments),c?d:d.then(function(E){return h()(void 0,E),new u._Promise(function(S,j){S(E)})}).catch(function(E){return h()(E,void 0),new u._Promise(function(S,j){j(E)})})},e}_t.postgres6={versionSpecifier:"6.*",patch:hR};_t.postgres7={versionSpecifier:">=7.* <=8.*",patch:_R};function vR(){qn.channel.registerMonkeyPatch("pg",_t.postgres6),qn.channel.registerMonkeyPatch("pg",_t.postgres7)}_t.enable=vR});var Dv=l(Br=>{"use strict";Object.defineProperty(Br,"__esModule",{value:!0});Br.enable=Br.redis=void 0;var Wc=ue(),gR=function(e){var t=e.RedisClient.prototype.internal_send_command;return e.RedisClient.prototype.internal_send_command=function(r){if(r){var n=r.callback;if(!n||!n.pubsubBound){var i=this.address,a=process.hrtime(),s=new Date;r.callback=Wc.channel.bindToContext(function(o,u){var c=process.hrtime(a),p=c[0]*1e3+c[1]/1e6|0;Wc.channel.publish("redis",{duration:p,address:i,commandObj:r,err:o,result:u,time:s}),typeof n=="function"&&n.apply(this,arguments)}),r.callback.pubsubBound=!0}}return t.call(this,r)},e};Br.redis={versionSpecifier:">= 2.0.0 < 4.0.0",patch:gR};function ER(){Wc.channel.registerMonkeyPatch("redis",Br.redis)}Br.enable=ER});var wv=l(Nt=>{"use strict";var co=Nt&&Nt.__assign||function(){return co=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++){t=arguments[r];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},co.apply(this,arguments)};Object.defineProperty(Nt,"__esModule",{value:!0});Nt.enable=Nt.tedious=void 0;var Zc=ue(),mR=function(e){var t=e.Connection.prototype.makeRequest;return e.Connection.prototype.makeRequest=function(){function n(a){var s=process.hrtime(),o={query:{},database:{host:null,port:null},result:null,error:null,duration:0};return Zc.channel.bindToContext(function(u,c,p){var f=process.hrtime(s);o=co(co({},o),{database:{host:this.connection.config.server,port:this.connection.config.options.port},result:!u&&{rowCount:c,rows:p},query:{text:this.parametersByName.statement.value},error:u,duration:Math.ceil(f[0]*1e3+f[1]/1e6)}),Zc.channel.publish("tedious",o),a.call(this,u,c,p)})}var i=arguments[0];arguments[0].callback=n(i.callback),t.apply(this,arguments)},e};Nt.tedious={versionSpecifier:">= 6.0.0 < 9.0.0",patch:mR};function yR(){Zc.channel.registerMonkeyPatch("tedious",Nt.tedious)}Nt.enable=yR});var xv=l(Le=>{"use strict";var TR=Le&&Le.__extends||function(){var e=function(t,r){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},e(t,r)};return function(t,r){e(t,r);function n(){this.constructor=t}t.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}(),SR=Le&&Le.__rest||function(e,t){var r={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,n=Object.getOwnPropertySymbols(e);i<n.length;i++)t.indexOf(n[i])<0&&Object.prototype.propertyIsEnumerable.call(e,n[i])&&(r[n[i]]=e[n[i]]);return r};Object.defineProperty(Le,"__esModule",{value:!0});Le.enable=Le.winston2=Le.winston3=void 0;var lo=ue(),AR=function(e){var t=e.Logger.prototype.log,r,n=function(i,a,s){var o;return r===e.config.npm.levels?o="npm":r===e.config.syslog.levels?o="syslog":o="unknown",lo.channel.publish("winston",{level:i,message:a,meta:s,levelKind:o}),a};return e.Logger.prototype.log=function(){return r=this.levels,!this.filters||this.filters.length===0?this.filters=[n]:this.filters[this.filters.length-1]!==n&&(this.filters=this.filters.filter(function(a){return a!==n}),this.filters.push(n)),t.apply(this,arguments)},e},IR=function(e){var t=function(s,o){var u;return s.config.npm.levels[o]!=null?u="npm":s.config.syslog.levels[o]!=null?u="syslog":u="unknown",u},r=function(s){TR(o,s);function o(u,c){var p=s.call(this,c)||this;return p.winston=u,p}return o.prototype.log=function(u,c){var p=u.message,f=u.level,d=u.meta,h=SR(u,["message","level","meta"]);f=typeof Symbol.for=="function"?u[Symbol.for("level")]:f,p=u instanceof Error?u:p;var E=t(this.winston,f);d=d||{};for(var S in h)h.hasOwnProperty(S)&&(d[S]=h[S]);lo.channel.publish("winston",{message:p,level:f,levelKind:E,meta:d}),c()},o}(e.Transport);function n(){var s=arguments[0].levels||e.config.npm.levels,o;for(var u in s)s.hasOwnProperty(u)&&(o=o===void 0||s[u]>s[o]?u:o);this.add(new r(e,{level:o}))}var i=e.createLogger;e.createLogger=function(){var o=arguments[0].levels||e.config.npm.levels,u;for(var c in o)o.hasOwnProperty(c)&&(u=u===void 0||o[c]>o[u]?c:u);var p=i.apply(this,arguments);p.add(new r(e,{level:u}));var f=p.configure;return p.configure=function(){f.apply(this,arguments),n.apply(this,arguments)},p};var a=e.configure;return e.configure=function(){a.apply(this,arguments),n.apply(this,arguments)},e.add(new r(e)),e};Le.winston3={versionSpecifier:"3.x",patch:IR};Le.winston2={versionSpecifier:"2.x",patch:AR};function bR(){lo.channel.registerMonkeyPatch("winston",Le.winston2),lo.channel.registerMonkeyPatch("winston",Le.winston3)}Le.enable=bR});var $v=l($=>{"use strict";Object.defineProperty($,"__esModule",{value:!0});$.enable=$.tedious=$.pgPool=$.pg=$.winston=$.redis=$.mysql=$.mongodb=$.mongodbCore=$.console=$.bunyan=$.azuresdk=void 0;var Mv=Ev();$.azuresdk=Mv;var Lv=yv();$.bunyan=Lv;var qv=Sv();$.console=qv;var jv=Av();$.mongodbCore=jv;var kv=Iv();$.mongodb=kv;var Hv=Cv();$.mysql=Hv;var Uv=Pv();$.pgPool=Uv;var Bv=Nv();$.pg=Bv;var Gv=Dv();$.redis=Gv;var Fv=wv();$.tedious=Fv;var Vv=xv();$.winston=Vv;function CR(){Lv.enable(),qv.enable(),jv.enable(),kv.enable(),Hv.enable(),Bv.enable(),Uv.enable(),Gv.enable(),Vv.enable(),Mv.enable(),Fv.enable()}$.enable=CR});var ho=l(tr=>{"use strict";Object.defineProperty(tr,"__esModule",{value:!0});tr.registerContextPreservation=tr.IsInitialized=void 0;var OR=Eu(),Jc=ve();tr.IsInitialized=!process.env.APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL;var el="DiagnosticChannel";if(tr.IsInitialized){at=$v(),zv=process.env.APPLICATION_INSIGHTS_NO_PATCH_MODULES||"",po=zv.split(","),tl={bunyan:at.bunyan,console:at.console,mongodb:at.mongodb,mongodbCore:at.mongodbCore,mysql:at.mysql,redis:at.redis,pg:at.pg,pgPool:at.pgPool,winston:at.winston,azuresdk:at.azuresdk};for(fo in tl)po.indexOf(fo)===-1&&(tl[fo].enable(),Jc.info(el,"Subscribed to "+fo+" events"));po.length>0&&Jc.info(el,"Some modules will not be patched",po)}else Jc.info(el,"Not subscribing to dependency autocollection because APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL was set");var at,zv,po,tl,fo;function PR(e){if(!!tr.IsInitialized){var t=ue();t.channel.addContextPreservation(e),t.channel.spanContextPropagator=OR.AsyncScopeManager}}tr.registerContextPreservation=PR});var jn=l((Aq,Kv)=>{"use strict";Kv.exports={requestContextHeader:"request-context",requestContextSourceKey:"appId",requestContextTargetKey:"appId",requestIdHeader:"request-id",parentIdHeader:"x-ms-request-id",rootIdHeader:"x-ms-request-root-id",correlationContextHeader:"correlation-context",traceparentHeader:"traceparent",traceStateHeader:"tracestate"}});var Be=l((nl,Yv)=>{"use strict";var rr=nl&&nl.__assign||function(){return rr=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++){t=arguments[r];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},rr.apply(this,arguments)},RR=__webpack_require__(8605),Xv=__webpack_require__(7211),rl=__webpack_require__(8835),_o=__webpack_require__(7619),Wi=ve(),kn=jn(),NR=function(){function e(){}return e.getCookie=function(t,r){var n="";if(t&&t.length&&typeof r=="string")for(var i=t+"=",a=r.split(";"),s=0;s<a.length;s++){var r=a[s];if(r=e.trim(r),r&&r.indexOf(i)===0){n=r.substring(i.length,a[s].length);break}}return n},e.trim=function(t){return typeof t=="string"?t.replace(/^\s+|\s+$/g,""):""},e.int32ArrayToBase64=function(t){var r=function(o,u){return String.fromCharCode(o>>u&255)},n=function(o){return r(o,24)+r(o,16)+r(o,8)+r(o,0)},i=t.map(n).join(""),a=Buffer.from?Buffer.from(i,"binary"):new Buffer(i,"binary"),s=a.toString("base64");return s.substr(0,s.indexOf("="))},e.random32=function(){return 4294967296*Math.random()|0},e.randomu32=function(){return e.random32()+2147483648},e.w3cTraceId=function(){for(var t=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"],r="",n,i=0;i<4;i++)n=e.random32(),r+=t[n&15]+t[n>>4&15]+t[n>>8&15]+t[n>>12&15]+t[n>>16&15]+t[n>>20&15]+t[n>>24&15]+t[n>>28&15];var a=t[8+Math.random()*4|0];return r.substr(0,8)+r.substr(9,4)+"4"+r.substr(13,3)+a+r.substr(16,3)+r.substr(19,12)},e.w3cSpanId=function(){return e.w3cTraceId().substring(16)},e.isValidW3CId=function(t){return t.length===32&&t!=="00000000000000000000000000000000"},e.isArray=function(t){return Object.prototype.toString.call(t)==="[object Array]"},e.isError=function(t){return t instanceof Error},e.isPrimitive=function(t){var r=typeof t;return r==="string"||r==="number"||r==="boolean"},e.isDate=function(t){return Object.prototype.toString.call(t)==="[object Date]"},e.msToTimeSpan=function(t){(isNaN(t)||t<0)&&(t=0);var r=(t/1e3%60).toFixed(7).replace(/0{0,4}$/,""),n=""+Math.floor(t/(1e3*60))%60,i=""+Math.floor(t/(1e3*60*60))%24,a=Math.floor(t/(1e3*60*60*24));r=r.indexOf(".")<2?"0"+r:r,n=n.length<2?"0"+n:n,i=i.length<2?"0"+i:i;var s=a>0?a+".":"";return s+i+":"+n+":"+r},e.extractError=function(t){var r=t;return{message:t.message,code:r.code||r.id||""}},e.extractObject=function(t){return t instanceof Error?e.extractError(t):typeof t.toJSON=="function"?t.toJSON():t},e.validateStringMap=function(t){if(typeof t!="object"){Wi.info("Invalid properties dropped from payload");return}var r={};for(var n in t){var i="",a=t[n],s=typeof a;if(e.isPrimitive(a))i=a.toString();else if(a===null||s==="undefined")i="";else if(s==="function"){Wi.info("key: "+n+" was function; will not serialize");continue}else{var o=e.isArray(a)?a:e.extractObject(a);try{e.isPrimitive(o)?i=o:i=JSON.stringify(o)}catch(u){i=a.constructor.name.toString()+" (Error: "+u.message+")",Wi.info("key: "+n+", could not be serialized")}}r[n]=i.substring(0,e.MAX_PROPERTY_LENGTH)}return r},e.canIncludeCorrelationHeader=function(t,r){var n=t&&t.config&&t.config.correlationHeaderExcludedDomains;if(!n||n.length==0||!r)return!0;for(var i=0;i<n.length;i++){var a=new RegExp(n[i].replace(/\./g,".").replace(/\*/g,".*"));if(a.test(rl.parse(r).hostname))return!1}return!0},e.getCorrelationContextTarget=function(t,r){var n=t.headers&&t.headers[kn.requestContextHeader];if(n)for(var i=n.split(","),a=0;a<i.length;++a){var s=i[a].split("=");if(s.length==2&&s[0]==r)return s[1]}},e.makeRequest=function(t,r,n,i){r&&r.indexOf("//")===0&&(r="https:"+r);var a=rl.parse(r),s=rr(rr({},n),{host:a.hostname,port:a.port,path:a.pathname}),o=void 0;if(a.protocol==="https:"&&(o=t.proxyHttpsUrl||void 0),a.protocol==="http:"&&(o=t.proxyHttpUrl||void 0),o){o.indexOf("//")===0&&(o="http:"+o);var u=rl.parse(o);u.protocol==="https:"?(Wi.info("Proxies that use HTTPS are not supported"),o=void 0):s=rr(rr({},s),{host:u.hostname,port:u.port||"80",path:r,headers:rr(rr({},s.headers),{Host:a.hostname})})}var c=a.protocol==="https:"&&!o;return c&&t.httpsAgent!==void 0?s.agent=t.httpsAgent:!c&&t.httpAgent!==void 0?s.agent=t.httpAgent:c&&(s.agent=e.tlsRestrictedAgent),c?Xv.request(s,i):RR.request(s,i)},e.safeIncludeCorrelationHeader=function(t,r,n){var i;if(typeof n=="string")i=n;else if(n instanceof Array)i=n.join(",");else if(n&&typeof n.toString=="function")try{i=n.toString()}catch(a){Wi.warn("Outgoing request-context header could not be read. Correlation of requests may be lost.",a,n)}i?e.addCorrelationIdHeaderFromString(t,r,i):r.setHeader(kn.requestContextHeader,kn.requestContextSourceKey+"="+t.config.correlationId)},e.dumpObj=function(t){var r=Object.prototype.toString.call(t),n="";return r==="[object Error]"?n="{ stack: '"+t.stack+"', message: '"+t.message+"', name: '"+t.name+"'":n=JSON.stringify(t),r+n},e.addCorrelationIdHeaderFromString=function(t,r,n){var i=n.split(","),a=kn.requestContextSourceKey+"=",s=i.some(function(o){return o.substring(0,a.length)===a});s||r.setHeader(kn.requestContextHeader,n+","+kn.requestContextSourceKey+"="+t.config.correlationId)},e.MAX_PROPERTY_LENGTH=8192,e.tlsRestrictedAgent=new Xv.Agent({keepAlive:!0,maxSockets:25,secureOptions:_o.SSL_OP_NO_SSLv2|_o.SSL_OP_NO_SSLv3|_o.SSL_OP_NO_TLSv1|_o.SSL_OP_NO_TLSv1_1}),e}();Yv.exports=NR});var Gr=l((Iq,Qv)=>{"use strict";var vo=Be(),il=ve(),DR=function(){function e(){}return e.queryCorrelationId=function(t,r){var n=t.profileQueryEndpoint+"/api/profiles/"+t.instrumentationKey+"/appId";if(e.completedLookups.hasOwnProperty(n)){r(e.completedLookups[n]);return}else if(e.pendingLookups[n]){e.pendingLookups[n].push(r);return}e.pendingLookups[n]=[r];var i=function(){if(!!e.pendingLookups[n]){var a={method:"GET",disableAppInsightsAutoCollection:!0};il.info(e.TAG,a);var s=vo.makeRequest(t,n,a,function(o){if(o.statusCode===200){var u="";o.setEncoding("utf-8"),o.on("data",function(c){u+=c}),o.on("end",function(){il.info(e.TAG,u);var c=e.correlationIdPrefix+u;e.completedLookups[n]=c,e.pendingLookups[n]&&e.pendingLookups[n].forEach(function(p){return p(c)}),delete e.pendingLookups[n]})}else o.statusCode>=400&&o.statusCode<500?(e.completedLookups[n]=void 0,delete e.pendingLookups[n]):setTimeout(i,t.correlationIdRetryIntervalMs)});s&&(s.on("error",function(o){il.warn(e.TAG,o)}),s.end())}};setTimeout(i,0)},e.cancelCorrelationIdQuery=function(t,r){var n=t.profileQueryEndpoint+"/api/profiles/"+t.instrumentationKey+"/appId",i=e.pendingLookups[n];i&&(e.pendingLookups[n]=i.filter(function(a){return a!=r}),e.pendingLookups[n].length==0&&delete e.pendingLookups[n])},e.generateRequestId=function(t){if(t){t=t[0]=="|"?t:"|"+t,t[t.length-1]!=="."&&(t+=".");var r=(e.currentRootId++).toString(16);return e.appendSuffix(t,r,"_")}else return e.generateRootId()},e.getRootId=function(t){var r=t.indexOf(".");r<0&&(r=t.length);var n=t[0]==="|"?1:0;return t.substring(n,r)},e.generateRootId=function(){return"|"+vo.w3cTraceId()+"."},e.appendSuffix=function(t,r,n){if(t.length+r.length<e.requestIdMaxLength)return t+r+n;var i=e.requestIdMaxLength-9;if(t.length>i)for(;i>1;--i){var a=t[i-1];if(a==="."||a==="_")break}if(i<=1)return e.generateRootId();for(r=vo.randomu32().toString(16);r.length<8;)r="0"+r;return t.substring(0,i)+r+"#"},e.TAG="CorrelationIdManager",e.correlationIdPrefix="cid-v1:",e.w3cEnabled=!0,e.pendingLookups={},e.completedLookups={},e.requestIdMaxLength=1024,e.currentRootId=vo.randomu32(),e}();Qv.exports=DR});var Zi=l((bq,Wv)=>{"use strict";var ye=Be(),wR=Gr(),xR=function(){function e(t,r){if(this.traceFlag=e.DEFAULT_TRACE_FLAG,this.version=e.DEFAULT_VERSION,t&&typeof t=="string")if(t.split(",").length>1)this.traceId=ye.w3cTraceId(),this.spanId=ye.w3cTraceId().substr(0,16);else{var n=t.trim().split("-"),i=n.length;i>=4?(this.version=n[0],this.traceId=n[1],this.spanId=n[2],this.traceFlag=n[3]):(this.traceId=ye.w3cTraceId(),this.spanId=ye.w3cTraceId().substr(0,16)),this.version.match(/^[0-9a-f]{2}$/g)||(this.version=e.DEFAULT_VERSION,this.traceId=ye.w3cTraceId()),this.version==="00"&&i!==4&&(this.traceId=ye.w3cTraceId(),this.spanId=ye.w3cTraceId().substr(0,16)),this.version==="ff"&&(this.version=e.DEFAULT_VERSION,this.traceId=ye.w3cTraceId(),this.spanId=ye.w3cTraceId().substr(0,16)),this.version.match(/^0[0-9a-f]$/g)||(this.version=e.DEFAULT_VERSION),this.traceFlag.match(/^[0-9a-f]{2}$/g)||(this.traceFlag=e.DEFAULT_TRACE_FLAG,this.traceId=ye.w3cTraceId()),e.isValidTraceId(this.traceId)||(this.traceId=ye.w3cTraceId()),e.isValidSpanId(this.spanId)||(this.spanId=ye.w3cTraceId().substr(0,16),this.traceId=ye.w3cTraceId()),this.parentId=this.getBackCompatRequestId()}else if(r){this.parentId=r.slice();var a=wR.getRootId(r);e.isValidTraceId(a)||(this.legacyRootId=a,a=ye.w3cTraceId()),r.indexOf("|")!==-1&&(r=r.substring(1+r.substring(0,r.length-1).lastIndexOf("."),r.length-1)),this.traceId=a,this.spanId=r}else this.traceId=ye.w3cTraceId(),this.spanId=ye.w3cTraceId().substr(0,16)}return e.isValidTraceId=function(t){return t.match(/^[0-9a-f]{32}$/)&&t!=="00000000000000000000000000000000"},e.isValidSpanId=function(t){return t.match(/^[0-9a-f]{16}$/)&&t!=="0000000000000000"},e.formatOpenTelemetryTraceFlags=function(t){var r="0"+t.toString(16);return r.substring(r.length-2)},e.prototype.getBackCompatRequestId=function(){return"|"+this.traceId+"."+this.spanId+"."},e.prototype.toString=function(){return this.version+"-"+this.traceId+"-"+this.spanId+"-"+this.traceFlag},e.prototype.updateSpanId=function(){this.spanId=ye.w3cTraceId().substr(0,16)},e.DEFAULT_TRACE_FLAG="01",e.DEFAULT_VERSION="00",e}();Wv.exports=xR});var al=l((Cq,Zv)=>{"use strict";var MR=function(){function e(t){this.fieldmap=[],!!t&&(this.fieldmap=this.parseHeader(t))}return e.prototype.toString=function(){var t=this.fieldmap;return!t||t.length==0?null:t.join(", ")},e.validateKeyChars=function(t){var r=t.split("@");if(r.length==2){var n=r[0].trim(),i=r[1].trim(),a=Boolean(n.match(/^[\ ]?[a-z0-9\*\-\_/]{1,241}$/)),s=Boolean(i.match(/^[\ ]?[a-z0-9\*\-\_/]{1,14}$/));return a&&s}else if(r.length==1)return Boolean(t.match(/^[\ ]?[a-z0-9\*\-\_/]{1,256}$/));return!1},e.prototype.parseHeader=function(t){var r=[],n={},i=t.split(",");if(i.length>32)return null;for(var a=0,s=i;a<s.length;a++){var o=s[a],u=o.trim();if(u.length!==0){var c=u.split("=");if(c.length!==2||!e.validateKeyChars(c[0])||n[c[0]])return null;n[c[0]]=!0,r.push(u)}}return r},e.strict=!0,e}();Zv.exports=MR});var Dt=l((Oq,Jv)=>{"use strict";var LR=function(){function e(){}return e}();Jv.exports=LR});var tg=l((sl,eg)=>{"use strict";var qR=sl&&sl.__extends||function(){var e=function(t,r){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},e(t,r)};return function(t,r){e(t,r);function n(){this.constructor=t}t.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}(),jR=Dt(),kR=function(e){qR(t,e);function t(){var r=e.call(this)||this;return r.ver=2,r.properties={},r.measurements={},r}return t}(jR);eg.exports=kR});var ol=l((Pq,rg)=>{"use strict";var HR=function(){function e(){}return e}();rg.exports=HR});var ig=l((Rq,ng)=>{"use strict";var UR=function(){function e(){this.applicationVersion="ai.application.ver",this.deviceId="ai.device.id",this.deviceLocale="ai.device.locale",this.deviceModel="ai.device.model",this.deviceOEMName="ai.device.oemName",this.deviceOSVersion="ai.device.osVersion",this.deviceType="ai.device.type",this.locationIp="ai.location.ip",this.operationId="ai.operation.id",this.operationName="ai.operation.name",this.operationParentId="ai.operation.parentId",this.operationSyntheticSource="ai.operation.syntheticSource",this.operationCorrelationVector="ai.operation.correlationVector",this.sessionId="ai.session.id",this.sessionIsFirst="ai.session.isFirst",this.userAccountId="ai.user.accountId",this.userId="ai.user.id",this.userAuthUserId="ai.user.authUserId",this.cloudRole="ai.cloud.role",this.cloudRoleInstance="ai.cloud.roleInstance",this.internalSdkVersion="ai.internal.sdkVersion",this.internalAgentVersion="ai.internal.agentVersion",this.internalNodeName="ai.internal.nodeName"}return e}();ng.exports=UR});var sg=l((ul,ag)=>{"use strict";var BR=ul&&ul.__extends||function(){var e=function(t,r){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},e(t,r)};return function(t,r){e(t,r);function n(){this.constructor=t}t.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}(),GR=ol(),FR=function(e){BR(t,e);function t(){return e.call(this)||this}return t}(GR);ag.exports=FR});var ll=l((Nq,og)=>{"use strict";var cl;(function(e){e[e.Measurement=0]="Measurement",e[e.Aggregation=1]="Aggregation"})(cl||(cl={}));og.exports=cl});var cg=l((Dq,ug)=>{"use strict";var VR=ll(),$R=function(){function e(){this.kind=VR.Measurement}return e}();ug.exports=$R});var pg=l((wq,lg)=>{"use strict";var zR=function(){function e(){this.ver=1,this.sampleRate=100,this.tags={}}return e}();lg.exports=zR});var fl=l((pl,fg)=>{"use strict";var KR=pl&&pl.__extends||function(){var e=function(t,r){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},e(t,r)};return function(t,r){e(t,r);function n(){this.constructor=t}t.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}(),XR=Dt(),YR=function(e){KR(t,e);function t(){var r=e.call(this)||this;return r.ver=2,r.properties={},r.measurements={},r}return t}(XR);fg.exports=YR});var hg=l((dl,dg)=>{"use strict";var QR=dl&&dl.__extends||function(){var e=function(t,r){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},e(t,r)};return function(t,r){e(t,r);function n(){this.constructor=t}t.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}(),WR=Dt(),ZR=function(e){QR(t,e);function t(){var r=e.call(this)||this;return r.ver=2,r.exceptions=[],r.properties={},r.measurements={},r}return t}(WR);dg.exports=ZR});var vg=l((xq,_g)=>{"use strict";var JR=function(){function e(){this.hasFullStack=!0,this.parsedStack=[]}return e}();_g.exports=JR});var Eg=l((hl,gg)=>{"use strict";var e0=hl&&hl.__extends||function(){var e=function(t,r){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},e(t,r)};return function(t,r){e(t,r);function n(){this.constructor=t}t.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}(),t0=Dt(),r0=function(e){e0(t,e);function t(){var r=e.call(this)||this;return r.ver=2,r.properties={},r}return t}(t0);gg.exports=r0});var yg=l((_l,mg)=>{"use strict";var n0=_l&&_l.__extends||function(){var e=function(t,r){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},e(t,r)};return function(t,r){e(t,r);function n(){this.constructor=t}t.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}(),i0=Dt(),a0=function(e){n0(t,e);function t(){var r=e.call(this)||this;return r.ver=2,r.metrics=[],r.properties={},r}return t}(i0);mg.exports=a0});var Sg=l((vl,Tg)=>{"use strict";var s0=vl&&vl.__extends||function(){var e=function(t,r){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},e(t,r)};return function(t,r){e(t,r);function n(){this.constructor=t}t.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}(),o0=fl(),u0=function(e){s0(t,e);function t(){var r=e.call(this)||this;return r.ver=2,r.properties={},r.measurements={},r}return t}(o0);Tg.exports=u0});var Ig=l((gl,Ag)=>{"use strict";var c0=gl&&gl.__extends||function(){var e=function(t,r){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},e(t,r)};return function(t,r){e(t,r);function n(){this.constructor=t}t.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}(),l0=Dt(),p0=function(e){c0(t,e);function t(){var r=e.call(this)||this;return r.ver=2,r.success=!0,r.properties={},r.measurements={},r}return t}(l0);Ag.exports=p0});var Cg=l((El,bg)=>{"use strict";var f0=El&&El.__extends||function(){var e=function(t,r){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},e(t,r)};return function(t,r){e(t,r);function n(){this.constructor=t}t.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}(),d0=Dt(),h0=function(e){f0(t,e);function t(){var r=e.call(this)||this;return r.ver=2,r.properties={},r.measurements={},r}return t}(d0);bg.exports=h0});var Pg=l((Mq,Og)=>{"use strict";var ml;(function(e){e[e.Verbose=0]="Verbose",e[e.Information=1]="Information",e[e.Warning=2]="Warning",e[e.Error=3]="Error",e[e.Critical=4]="Critical"})(ml||(ml={}));Og.exports=ml});var Ng=l((Lq,Rg)=>{"use strict";var _0=function(){function e(){}return e}();Rg.exports=_0});var yl=l(fe=>{"use strict";Object.defineProperty(fe,"__esModule",{value:!0});fe.AvailabilityData=tg();fe.Base=ol();fe.ContextTagKeys=ig();fe.Data=sg();fe.DataPoint=cg();fe.DataPointType=ll();fe.Domain=Dt();fe.Envelope=pg();fe.EventData=fl();fe.ExceptionData=hg();fe.ExceptionDetails=vg();fe.MessageData=Eg();fe.MetricData=yg();fe.PageViewData=Sg();fe.RemoteDependencyData=Ig();fe.RequestData=Cg();fe.SeverityLevel=Pg();fe.StackFrame=Ng()});var Dg=l(Hn=>{"use strict";Object.defineProperty(Hn,"__esModule",{value:!0});Hn.domainSupportsProperties=Hn.RemoteDependencyDataConstants=void 0;var Fr=yl(),v0=function(){function e(){}return e.TYPE_HTTP="Http",e.TYPE_AI="Http (tracked component)",e}();Hn.RemoteDependencyDataConstants=v0;function g0(e){return"properties"in e||e instanceof Fr.EventData||e instanceof Fr.ExceptionData||e instanceof Fr.MessageData||e instanceof Fr.MetricData||e instanceof Fr.PageViewData||e instanceof Fr.RemoteDependencyData||e instanceof Fr.RequestData}Hn.domainSupportsProperties=g0});var xg=l(wg=>{"use strict";Object.defineProperty(wg,"__esModule",{value:!0})});var Lg=l(Mg=>{"use strict";Object.defineProperty(Mg,"__esModule",{value:!0})});var jg=l(qg=>{"use strict";Object.defineProperty(qg,"__esModule",{value:!0})});var Hg=l(kg=>{"use strict";Object.defineProperty(kg,"__esModule",{value:!0})});var Bg=l(Ug=>{"use strict";Object.defineProperty(Ug,"__esModule",{value:!0})});var Fg=l(Gg=>{"use strict";Object.defineProperty(Gg,"__esModule",{value:!0})});var $g=l(Vg=>{"use strict";Object.defineProperty(Vg,"__esModule",{value:!0})});var Kg=l(zg=>{"use strict";Object.defineProperty(zg,"__esModule",{value:!0})});var Yg=l(Xg=>{"use strict";Object.defineProperty(Xg,"__esModule",{value:!0})});var Wg=l(Qg=>{"use strict";Object.defineProperty(Qg,"__esModule",{value:!0})});var Jg=l(Zg=>{"use strict";Object.defineProperty(Zg,"__esModule",{value:!0})});var tE=l(eE=>{"use strict";Object.defineProperty(eE,"__esModule",{value:!0})});var rE=l(st=>{"use strict";Object.defineProperty(st,"__esModule",{value:!0});st.TelemetryType=st.TelemetryTypeString=st.baseTypeToTelemetryType=st.telemetryTypeToBaseType=void 0;function E0(e){switch(e){case Te.Event:return"EventData";case Te.Exception:return"ExceptionData";case Te.Trace:return"MessageData";case Te.Metric:return"MetricData";case Te.Request:return"RequestData";case Te.Dependency:return"RemoteDependencyData";case Te.Availability:return"AvailabilityData";case Te.PageView:return"PageViewData"}}st.telemetryTypeToBaseType=E0;function m0(e){switch(e){case"EventData":return Te.Event;case"ExceptionData":return Te.Exception;case"MessageData":return Te.Trace;case"MetricData":return Te.Metric;case"RequestData":return Te.Request;case"RemoteDependencyData":return Te.Dependency;case"AvailabilityData":return Te.Availability;case"PageViewData":return Te.PageView}}st.baseTypeToTelemetryType=m0;st.TelemetryTypeString={Event:"EventData",Exception:"ExceptionData",Trace:"MessageData",Metric:"MetricData",Request:"RequestData",Dependency:"RemoteDependencyData",Availability:"AvailabilityData",PageView:"PageViewData"};var Te;(function(e){e[e.Event=0]="Event",e[e.Exception=1]="Exception",e[e.Trace=2]="Trace",e[e.Metric=3]="Metric",e[e.Request=4]="Request",e[e.Dependency=5]="Dependency",e[e.Availability=6]="Availability",e[e.PageView=7]="PageView"})(Te=st.TelemetryType||(st.TelemetryType={}))});var nE=l(_e=>{"use strict";var y0=_e&&_e.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),Ge=_e&&_e.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&y0(t,e,r)};Object.defineProperty(_e,"__esModule",{value:!0});Ge(xg(),_e);Ge(Lg(),_e);Ge(jg(),_e);Ge(Hg(),_e);Ge(Bg(),_e);Ge(Fg(),_e);Ge($g(),_e);Ge(Kg(),_e);Ge(Yg(),_e);Ge(Wg(),_e);Ge(Jg(),_e);Ge(tE(),_e);Ge(rE(),_e)});var aE=l(iE=>{"use strict";Object.defineProperty(iE,"__esModule",{value:!0})});var oE=l(sE=>{"use strict";Object.defineProperty(sE,"__esModule",{value:!0})});var cE=l(uE=>{"use strict";Object.defineProperty(uE,"__esModule",{value:!0})});var pE=l(lE=>{"use strict";Object.defineProperty(lE,"__esModule",{value:!0})});var dE=l(fE=>{"use strict";Object.defineProperty(fE,"__esModule",{value:!0})});var _E=l(hE=>{"use strict";Object.defineProperty(hE,"__esModule",{value:!0})});var gE=l(vE=>{"use strict";Object.defineProperty(vE,"__esModule",{value:!0})});var mE=l(EE=>{"use strict";Object.defineProperty(EE,"__esModule",{value:!0})});var yE=l(qe=>{"use strict";var T0=qe&&qe.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),nr=qe&&qe.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&T0(t,e,r)};Object.defineProperty(qe,"__esModule",{value:!0});nr(aE(),qe);nr(oE(),qe);nr(cE(),qe);nr(pE(),qe);nr(dE(),qe);nr(_E(),qe);nr(gE(),qe);nr(mE(),qe)});var De=l(vt=>{"use strict";var S0=vt&&vt.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),go=vt&&vt.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&S0(t,e,r)};Object.defineProperty(vt,"__esModule",{value:!0});go(Dg(),vt);go(yl(),vt);go(nE(),vt);go(yE(),vt)});var Tl=l((u1,TE)=>{"use strict";var A0=function(){function e(){}return e.prototype.getUrl=function(){return this.url},e.prototype.RequestParser=function(){this.startTime=+new Date},e.prototype._setStatus=function(t,r){var n=+new Date;this.duration=n-this.startTime,this.statusCode=t;var i=this.properties||{};if(r){if(typeof r=="string")i.error=r;else if(r instanceof Error)i.error=r.message;else if(typeof r=="object")for(var a in r)i[a]=r[a]&&r[a].toString&&r[a].toString()}this.properties=i},e.prototype._isSuccess=function(){return 0<this.statusCode&&this.statusCode<400},e}();TE.exports=A0});var Il=l((Al,AE)=>{"use strict";var I0=Al&&Al.__extends||function(){var e=function(t,r){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},e(t,r)};return function(t,r){e(t,r);function n(){this.constructor=t}t.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}(),Eo=__webpack_require__(8835),b0=De(),SE=Be(),Fe=jn(),C0=Tl(),ir=Gr(),O0=al(),Sl=Zi(),P0=function(e){I0(t,e);function t(r,n){var i=e.call(this)||this;return r&&(i.method=r.method,i.url=i._getAbsoluteUrl(r),i.startTime=+new Date,i.socketRemoteAddress=r.socket&&r.socket.remoteAddress,i.parseHeaders(r,n),r.connection&&(i.connectionRemoteAddress=r.connection.remoteAddress,i.legacySocketRemoteAddress=r.connection.socket&&r.connection.socket.remoteAddress)),i}return t.prototype.onError=function(r,n){this._setStatus(void 0,r),n&&(this.duration=n)},t.prototype.onResponse=function(r,n){this._setStatus(r.statusCode,void 0),n&&(this.duration=n)},t.prototype.getRequestTelemetry=function(r){var n={id:this.requestId,name:this.method+" "+Eo.parse(this.url).pathname,url:this.url,source:this.sourceCorrelationId,duration:this.duration,resultCode:this.statusCode?this.statusCode.toString():null,success:this._isSuccess(),properties:this.properties};if(r&&r.time?n.time=r.time:this.startTime&&(n.time=new Date(this.startTime)),r){for(var i in r)n[i]||(n[i]=r[i]);if(r.properties)for(var i in r.properties)n.properties[i]=r.properties[i]}return n},t.prototype.getRequestTags=function(r){var n={};for(var i in r)n[i]=r[i];return n[t.keys.locationIp]=r[t.keys.locationIp]||this._getIp(),n[t.keys.sessionId]=r[t.keys.sessionId]||this._getId("ai_session"),n[t.keys.userId]=r[t.keys.userId]||this._getId("ai_user"),n[t.keys.userAuthUserId]=r[t.keys.userAuthUserId]||this._getId("ai_authUser"),n[t.keys.operationName]=this.getOperationName(r),n[t.keys.operationParentId]=this.getOperationParentId(r),n[t.keys.operationId]=this.getOperationId(r),n},t.prototype.getOperationId=function(r){return r[t.keys.operationId]||this.operationId},t.prototype.getOperationParentId=function(r){return r[t.keys.operationParentId]||this.parentId||this.getOperationId(r)},t.prototype.getOperationName=function(r){return r[t.keys.operationName]||this.method+" "+Eo.parse(this.url).pathname},t.prototype.getRequestId=function(){return this.requestId},t.prototype.getCorrelationContextHeader=function(){return this.correlationContextHeader},t.prototype.getTraceparent=function(){return this.traceparent},t.prototype.getTracestate=function(){return this.tracestate},t.prototype.getLegacyRootId=function(){return this.legacyRootId},t.prototype._getAbsoluteUrl=function(r){if(!r.headers)return r.url;var n=r.connection?r.connection.encrypted:null,i=Eo.parse(r.url),a=i.pathname,s=i.search,o=n||r.headers["x-forwarded-proto"]=="https"?"https":"http",u=Eo.format({protocol:o,host:r.headers.host,pathname:a,search:s});return u},t.prototype._getIp=function(){var r=/[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/,n=function(a){var s=r.exec(a);if(s)return s[0]},i=n(this.rawHeaders["x-forwarded-for"])||n(this.rawHeaders["x-client-ip"])||n(this.rawHeaders["x-real-ip"])||n(this.connectionRemoteAddress)||n(this.socketRemoteAddress)||n(this.legacySocketRemoteAddress);return!i&&this.connectionRemoteAddress&&this.connectionRemoteAddress.substr&&this.connectionRemoteAddress.substr(0,2)==="::"&&(i="127.0.0.1"),i},t.prototype._getId=function(r){var n=this.rawHeaders&&this.rawHeaders.cookie&&typeof this.rawHeaders.cookie=="string"&&this.rawHeaders.cookie||"",i=t.parseId(SE.getCookie(r,n));return i},t.prototype.setBackCompatFromThisTraceContext=function(){this.operationId=this.traceparent.traceId,this.traceparent.legacyRootId&&(this.legacyRootId=this.traceparent.legacyRootId),this.parentId=this.traceparent.parentId,this.traceparent.updateSpanId(),this.requestId=this.traceparent.getBackCompatRequestId()},t.prototype.parseHeaders=function(r,n){if(this.rawHeaders=r.headers||r.rawHeaders,this.userAgent=r.headers&&r.headers["user-agent"],this.sourceCorrelationId=SE.getCorrelationContextTarget(r,Fe.requestContextSourceKey),r.headers){var i=r.headers[Fe.traceStateHeader]?r.headers[Fe.traceStateHeader].toString():null,a=r.headers[Fe.traceparentHeader]?r.headers[Fe.traceparentHeader].toString():null,s=r.headers[Fe.requestIdHeader]?r.headers[Fe.requestIdHeader].toString():null,o=r.headers[Fe.parentIdHeader]?r.headers[Fe.parentIdHeader].toString():null,u=r.headers[Fe.rootIdHeader]?r.headers[Fe.rootIdHeader].toString():null;this.correlationContextHeader=r.headers[Fe.correlationContextHeader]?r.headers[Fe.correlationContextHeader].toString():null,ir.w3cEnabled&&(a||i)?(this.traceparent=new Sl(a?a.toString():null),this.tracestate=a&&i&&new O0(i?i.toString():null),this.setBackCompatFromThisTraceContext()):s?ir.w3cEnabled?(this.traceparent=new Sl(null,s),this.setBackCompatFromThisTraceContext()):(this.parentId=s,this.requestId=ir.generateRequestId(this.parentId),this.operationId=ir.getRootId(this.requestId)):ir.w3cEnabled?(this.traceparent=new Sl,this.traceparent.parentId=o,this.traceparent.legacyRootId=u||o,this.setBackCompatFromThisTraceContext()):(this.parentId=o,this.requestId=ir.generateRequestId(u||this.parentId),this.correlationContextHeader=null,this.operationId=ir.getRootId(this.requestId)),n&&(this.requestId=n,this.operationId=ir.getRootId(this.requestId))}},t.parseId=function(r){var n=r.split("|");return n.length>0?n[0]:""},t.keys=new b0.ContextTagKeys,t}(C0);AE.exports=P0});var UE=l((b,HE)=>{b=HE.exports=D;var H;typeof process=="object"&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?H=function(){var e=Array.prototype.slice.call(arguments,0);e.unshift("SEMVER"),console.log.apply(console,e)}:H=function(){};b.SEMVER_SPEC_VERSION="2.0.0";var bl=256,mo=Number.MAX_SAFE_INTEGER||9007199254740991,Cl=16,G=b.re=[],v=b.src=[],P=0,Un=P++;v[Un]="0|[1-9]\\d*";var Bn=P++;v[Bn]="[0-9]+";var Ol=P++;v[Ol]="\\d*[a-zA-Z-][a-zA-Z0-9-]*";var IE=P++;v[IE]="("+v[Un]+")\\.("+v[Un]+")\\.("+v[Un]+")";var bE=P++;v[bE]="("+v[Bn]+")\\.("+v[Bn]+")\\.("+v[Bn]+")";var Pl=P++;v[Pl]="(?:"+v[Un]+"|"+v[Ol]+")";var Rl=P++;v[Rl]="(?:"+v[Bn]+"|"+v[Ol]+")";var Nl=P++;v[Nl]="(?:-("+v[Pl]+"(?:\\."+v[Pl]+")*))";var Dl=P++;v[Dl]="(?:-?("+v[Rl]+"(?:\\."+v[Rl]+")*))";var wl=P++;v[wl]="[0-9A-Za-z-]+";var Ji=P++;v[Ji]="(?:\\+("+v[wl]+"(?:\\."+v[wl]+")*))";var xl=P++,CE="v?"+v[IE]+v[Nl]+"?"+v[Ji]+"?";v[xl]="^"+CE+"$";var Ml="[v=\\s]*"+v[bE]+v[Dl]+"?"+v[Ji]+"?",Ll=P++;v[Ll]="^"+Ml+"$";var Gn=P++;v[Gn]="((?:<|>)?=?)";var yo=P++;v[yo]=v[Bn]+"|x|X|\\*";var To=P++;v[To]=v[Un]+"|x|X|\\*";var Vr=P++;v[Vr]="[v=\\s]*("+v[To]+")(?:\\.("+v[To]+")(?:\\.("+v[To]+")(?:"+v[Nl]+")?"+v[Ji]+"?)?)?";var Fn=P++;v[Fn]="[v=\\s]*("+v[yo]+")(?:\\.("+v[yo]+")(?:\\.("+v[yo]+")(?:"+v[Dl]+")?"+v[Ji]+"?)?)?";var OE=P++;v[OE]="^"+v[Gn]+"\\s*"+v[Vr]+"$";var PE=P++;v[PE]="^"+v[Gn]+"\\s*"+v[Fn]+"$";var RE=P++;v[RE]="(?:^|[^\\d])(\\d{1,"+Cl+"})(?:\\.(\\d{1,"+Cl+"}))?(?:\\.(\\d{1,"+Cl+"}))?(?:$|[^\\d])";var So=P++;v[So]="(?:~>?)";var Ao=P++;v[Ao]="(\\s*)"+v[So]+"\\s+";G[Ao]=new RegExp(v[Ao],"g");var R0="$1~",NE=P++;v[NE]="^"+v[So]+v[Vr]+"$";var DE=P++;v[DE]="^"+v[So]+v[Fn]+"$";var Io=P++;v[Io]="(?:\\^)";var bo=P++;v[bo]="(\\s*)"+v[Io]+"\\s+";G[bo]=new RegExp(v[bo],"g");var N0="$1^",wE=P++;v[wE]="^"+v[Io]+v[Vr]+"$";var xE=P++;v[xE]="^"+v[Io]+v[Fn]+"$";var ql=P++;v[ql]="^"+v[Gn]+"\\s*("+Ml+")$|^$";var jl=P++;v[jl]="^"+v[Gn]+"\\s*("+CE+")$|^$";var ea=P++;v[ea]="(\\s*)"+v[Gn]+"\\s*("+Ml+"|"+v[Vr]+")";G[ea]=new RegExp(v[ea],"g");var D0="$1$2$3",ME=P++;v[ME]="^\\s*("+v[Vr]+")\\s+-\\s+("+v[Vr]+")\\s*$";var LE=P++;v[LE]="^\\s*("+v[Fn]+")\\s+-\\s+("+v[Fn]+")\\s*$";var qE=P++;v[qE]="(<|>)?=?\\s*\\*";for(ar=0;ar<P;ar++)H(ar,v[ar]),G[ar]||(G[ar]=new RegExp(v[ar]));var ar;b.parse=$r;function $r(e,t){if((!t||typeof t!="object")&&(t={loose:!!t,includePrerelease:!1}),e instanceof D)return e;if(typeof e!="string"||e.length>bl)return null;var r=t.loose?G[Ll]:G[xl];if(!r.test(e))return null;try{return new D(e,t)}catch(n){return null}}b.valid=w0;function w0(e,t){var r=$r(e,t);return r?r.version:null}b.clean=x0;function x0(e,t){var r=$r(e.trim().replace(/^[=v]+/,""),t);return r?r.version:null}b.SemVer=D;function D(e,t){if((!t||typeof t!="object")&&(t={loose:!!t,includePrerelease:!1}),e instanceof D){if(e.loose===t.loose)return e;e=e.version}else if(typeof e!="string")throw new TypeError("Invalid Version: "+e);if(e.length>bl)throw new TypeError("version is longer than "+bl+" characters");if(!(this instanceof D))return new D(e,t);H("SemVer",e,t),this.options=t,this.loose=!!t.loose;var r=e.trim().match(t.loose?G[Ll]:G[xl]);if(!r)throw new TypeError("Invalid Version: "+e);if(this.raw=e,this.major=+r[1],this.minor=+r[2],this.patch=+r[3],this.major>mo||this.major<0)throw new TypeError("Invalid major version");if(this.minor>mo||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>mo||this.patch<0)throw new TypeError("Invalid patch version");r[4]?this.prerelease=r[4].split(".").map(function(n){if(/^[0-9]+$/.test(n)){var i=+n;if(i>=0&&i<mo)return i}return n}):this.prerelease=[],this.build=r[5]?r[5].split("."):[],this.format()}D.prototype.format=function(){return this.version=this.major+"."+this.minor+"."+this.patch,this.prerelease.length&&(this.version+="-"+this.prerelease.join(".")),this.version};D.prototype.toString=function(){return this.version};D.prototype.compare=function(e){return H("SemVer.compare",this.version,this.options,e),e instanceof D||(e=new D(e,this.options)),this.compareMain(e)||this.comparePre(e)};D.prototype.compareMain=function(e){return e instanceof D||(e=new D(e,this.options)),Vn(this.major,e.major)||Vn(this.minor,e.minor)||Vn(this.patch,e.patch)};D.prototype.comparePre=function(e){if(e instanceof D||(e=new D(e,this.options)),this.prerelease.length&&!e.prerelease.length)return-1;if(!this.prerelease.length&&e.prerelease.length)return 1;if(!this.prerelease.length&&!e.prerelease.length)return 0;var t=0;do{var r=this.prerelease[t],n=e.prerelease[t];if(H("prerelease compare",t,r,n),r===void 0&&n===void 0)return 0;if(n===void 0)return 1;if(r===void 0)return-1;if(r===n)continue;return Vn(r,n)}while(++t)};D.prototype.inc=function(e,t){switch(e){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",t);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",t);break;case"prepatch":this.prerelease.length=0,this.inc("patch",t),this.inc("pre",t);break;case"prerelease":this.prerelease.length===0&&this.inc("patch",t),this.inc("pre",t);break;case"major":(this.minor!==0||this.patch!==0||this.prerelease.length===0)&&this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":(this.patch!==0||this.prerelease.length===0)&&this.minor++,this.patch=0,this.prerelease=[];break;case"patch":this.prerelease.length===0&&this.patch++,this.prerelease=[];break;case"pre":if(this.prerelease.length===0)this.prerelease=[0];else{for(var r=this.prerelease.length;--r>=0;)typeof this.prerelease[r]=="number"&&(this.prerelease[r]++,r=-2);r===-1&&this.prerelease.push(0)}t&&(this.prerelease[0]===t?isNaN(this.prerelease[1])&&(this.prerelease=[t,0]):this.prerelease=[t,0]);break;default:throw new Error("invalid increment argument: "+e)}return this.format(),this.raw=this.version,this};b.inc=M0;function M0(e,t,r,n){typeof r=="string"&&(n=r,r=void 0);try{return new D(e,r).inc(t,n).version}catch(i){return null}}b.diff=L0;function L0(e,t){if(kl(e,t))return null;var r=$r(e),n=$r(t),i="";if(r.prerelease.length||n.prerelease.length){i="pre";var a="prerelease"}for(var s in r)if((s==="major"||s==="minor"||s==="patch")&&r[s]!==n[s])return i+s;return a}b.compareIdentifiers=Vn;var jE=/^[0-9]+$/;function Vn(e,t){var r=jE.test(e),n=jE.test(t);return r&&n&&(e=+e,t=+t),e===t?0:r&&!n?-1:n&&!r?1:e<t?-1:1}b.rcompareIdentifiers=q0;function q0(e,t){return Vn(t,e)}b.major=j0;function j0(e,t){return new D(e,t).major}b.minor=k0;function k0(e,t){return new D(e,t).minor}b.patch=H0;function H0(e,t){return new D(e,t).patch}b.compare=wt;function wt(e,t,r){return new D(e,r).compare(new D(t,r))}b.compareLoose=U0;function U0(e,t){return wt(e,t,!0)}b.rcompare=B0;function B0(e,t,r){return wt(t,e,r)}b.sort=G0;function G0(e,t){return e.sort(function(r,n){return b.compare(r,n,t)})}b.rsort=F0;function F0(e,t){return e.sort(function(r,n){return b.rcompare(r,n,t)})}b.gt=ta;function ta(e,t,r){return wt(e,t,r)>0}b.lt=Co;function Co(e,t,r){return wt(e,t,r)<0}b.eq=kl;function kl(e,t,r){return wt(e,t,r)===0}b.neq=kE;function kE(e,t,r){return wt(e,t,r)!==0}b.gte=Hl;function Hl(e,t,r){return wt(e,t,r)>=0}b.lte=Ul;function Ul(e,t,r){return wt(e,t,r)<=0}b.cmp=Oo;function Oo(e,t,r,n){switch(t){case"===":return typeof e=="object"&&(e=e.version),typeof r=="object"&&(r=r.version),e===r;case"!==":return typeof e=="object"&&(e=e.version),typeof r=="object"&&(r=r.version),e!==r;case"":case"=":case"==":return kl(e,r,n);case"!=":return kE(e,r,n);case">":return ta(e,r,n);case">=":return Hl(e,r,n);case"<":return Co(e,r,n);case"<=":return Ul(e,r,n);default:throw new TypeError("Invalid operator: "+t)}}b.Comparator=Ye;function Ye(e,t){if((!t||typeof t!="object")&&(t={loose:!!t,includePrerelease:!1}),e instanceof Ye){if(e.loose===!!t.loose)return e;e=e.value}if(!(this instanceof Ye))return new Ye(e,t);H("comparator",e,t),this.options=t,this.loose=!!t.loose,this.parse(e),this.semver===ra?this.value="":this.value=this.operator+this.semver.version,H("comp",this)}var ra={};Ye.prototype.parse=function(e){var t=this.options.loose?G[ql]:G[jl],r=e.match(t);if(!r)throw new TypeError("Invalid comparator: "+e);this.operator=r[1],this.operator==="="&&(this.operator=""),r[2]?this.semver=new D(r[2],this.options.loose):this.semver=ra};Ye.prototype.toString=function(){return this.value};Ye.prototype.test=function(e){return H("Comparator.test",e,this.options.loose),this.semver===ra?!0:(typeof e=="string"&&(e=new D(e,this.options)),Oo(e,this.operator,this.semver,this.options))};Ye.prototype.intersects=function(e,t){if(!(e instanceof Ye))throw new TypeError("a Comparator is required");(!t||typeof t!="object")&&(t={loose:!!t,includePrerelease:!1});var r;if(this.operator==="")return r=new J(e.value,t),Po(this.value,r,t);if(e.operator==="")return r=new J(this.value,t),Po(e.semver,r,t);var n=(this.operator===">="||this.operator===">")&&(e.operator===">="||e.operator===">"),i=(this.operator==="<="||this.operator==="<")&&(e.operator==="<="||e.operator==="<"),a=this.semver.version===e.semver.version,s=(this.operator===">="||this.operator==="<=")&&(e.operator===">="||e.operator==="<="),o=Oo(this.semver,"<",e.semver,t)&&(this.operator===">="||this.operator===">")&&(e.operator==="<="||e.operator==="<"),u=Oo(this.semver,">",e.semver,t)&&(this.operator==="<="||this.operator==="<")&&(e.operator===">="||e.operator===">");return n||i||a&&s||o||u};b.Range=J;function J(e,t){if((!t||typeof t!="object")&&(t={loose:!!t,includePrerelease:!1}),e instanceof J)return e.loose===!!t.loose&&e.includePrerelease===!!t.includePrerelease?e:new J(e.raw,t);if(e instanceof Ye)return new J(e.value,t);if(!(this instanceof J))return new J(e,t);if(this.options=t,this.loose=!!t.loose,this.includePrerelease=!!t.includePrerelease,this.raw=e,this.set=e.split(/\s*\|\|\s*/).map(function(r){return this.parseRange(r.trim())},this).filter(function(r){return r.length}),!this.set.length)throw new TypeError("Invalid SemVer Range: "+e);this.format()}J.prototype.format=function(){return this.range=this.set.map(function(e){return e.join(" ").trim()}).join("||").trim(),this.range};J.prototype.toString=function(){return this.range};J.prototype.parseRange=function(e){var t=this.options.loose;e=e.trim();var r=t?G[LE]:G[ME];e=e.replace(r,J0),H("hyphen replace",e),e=e.replace(G[ea],D0),H("comparator trim",e,G[ea]),e=e.replace(G[Ao],R0),e=e.replace(G[bo],N0),e=e.split(/\s+/).join(" ");var n=t?G[ql]:G[jl],i=e.split(" ").map(function(a){return $0(a,this.options)},this).join(" ").split(/\s+/);return this.options.loose&&(i=i.filter(function(a){return!!a.match(n)})),i=i.map(function(a){return new Ye(a,this.options)},this),i};J.prototype.intersects=function(e,t){if(!(e instanceof J))throw new TypeError("a Range is required");return this.set.some(function(r){return r.every(function(n){return e.set.some(function(i){return i.every(function(a){return n.intersects(a,t)})})})})};b.toComparators=V0;function V0(e,t){return new J(e,t).set.map(function(r){return r.map(function(n){return n.value}).join(" ").trim().split(" ")})}function $0(e,t){return H("comp",e,t),e=X0(e,t),H("caret",e),e=z0(e,t),H("tildes",e),e=Q0(e,t),H("xrange",e),e=Z0(e,t),H("stars",e),e}function we(e){return!e||e.toLowerCase()==="x"||e==="*"}function z0(e,t){return e.trim().split(/\s+/).map(function(r){return K0(r,t)}).join(" ")}function K0(e,t){var r=t.loose?G[DE]:G[NE];return e.replace(r,function(n,i,a,s,o){H("tilde",e,n,i,a,s,o);var u;return we(i)?u="":we(a)?u=">="+i+".0.0 <"+(+i+1)+".0.0":we(s)?u=">="+i+"."+a+".0 <"+i+"."+(+a+1)+".0":o?(H("replaceTilde pr",o),u=">="+i+"."+a+"."+s+"-"+o+" <"+i+"."+(+a+1)+".0"):u=">="+i+"."+a+"."+s+" <"+i+"."+(+a+1)+".0",H("tilde return",u),u})}function X0(e,t){return e.trim().split(/\s+/).map(function(r){return Y0(r,t)}).join(" ")}function Y0(e,t){H("caret",e,t);var r=t.loose?G[xE]:G[wE];return e.replace(r,function(n,i,a,s,o){H("caret",e,n,i,a,s,o);var u;return we(i)?u="":we(a)?u=">="+i+".0.0 <"+(+i+1)+".0.0":we(s)?i==="0"?u=">="+i+"."+a+".0 <"+i+"."+(+a+1)+".0":u=">="+i+"."+a+".0 <"+(+i+1)+".0.0":o?(H("replaceCaret pr",o),i==="0"?a==="0"?u=">="+i+"."+a+"."+s+"-"+o+" <"+i+"."+a+"."+(+s+1):u=">="+i+"."+a+"."+s+"-"+o+" <"+i+"."+(+a+1)+".0":u=">="+i+"."+a+"."+s+"-"+o+" <"+(+i+1)+".0.0"):(H("no pr"),i==="0"?a==="0"?u=">="+i+"."+a+"."+s+" <"+i+"."+a+"."+(+s+1):u=">="+i+"."+a+"."+s+" <"+i+"."+(+a+1)+".0":u=">="+i+"."+a+"."+s+" <"+(+i+1)+".0.0"),H("caret return",u),u})}function Q0(e,t){return H("replaceXRanges",e,t),e.split(/\s+/).map(function(r){return W0(r,t)}).join(" ")}function W0(e,t){e=e.trim();var r=t.loose?G[PE]:G[OE];return e.replace(r,function(n,i,a,s,o,u){H("xRange",e,n,i,a,s,o,u);var c=we(a),p=c||we(s),f=p||we(o),d=f;return i==="="&&d&&(i=""),c?i===">"||i==="<"?n="<0.0.0":n="*":i&&d?(p&&(s=0),o=0,i===">"?(i=">=",p?(a=+a+1,s=0,o=0):(s=+s+1,o=0)):i==="<="&&(i="<",p?a=+a+1:s=+s+1),n=i+a+"."+s+"."+o):p?n=">="+a+".0.0 <"+(+a+1)+".0.0":f&&(n=">="+a+"."+s+".0 <"+a+"."+(+s+1)+".0"),H("xRange return",n),n})}function Z0(e,t){return H("replaceStars",e,t),e.trim().replace(G[qE],"")}function J0(e,t,r,n,i,a,s,o,u,c,p,f,d){return we(r)?t="":we(n)?t=">="+r+".0.0":we(i)?t=">="+r+"."+n+".0":t=">="+t,we(u)?o="":we(c)?o="<"+(+u+1)+".0.0":we(p)?o="<"+u+"."+(+c+1)+".0":f?o="<="+u+"."+c+"."+p+"-"+f:o="<="+o,(t+" "+o).trim()}J.prototype.test=function(e){if(!e)return!1;typeof e=="string"&&(e=new D(e,this.options));for(var t=0;t<this.set.length;t++)if(eN(this.set[t],e,this.options))return!0;return!1};function eN(e,t,r){for(var n=0;n<e.length;n++)if(!e[n].test(t))return!1;if(t.prerelease.length&&!r.includePrerelease){for(n=0;n<e.length;n++)if(H(e[n].semver),e[n].semver!==ra&&e[n].semver.prerelease.length>0){var i=e[n].semver;if(i.major===t.major&&i.minor===t.minor&&i.patch===t.patch)return!0}return!1}return!0}b.satisfies=Po;function Po(e,t,r){try{t=new J(t,r)}catch(n){return!1}return t.test(e)}b.maxSatisfying=tN;function tN(e,t,r){var n=null,i=null;try{var a=new J(t,r)}catch(s){return null}return e.forEach(function(s){a.test(s)&&(!n||i.compare(s)===-1)&&(n=s,i=new D(n,r))}),n}b.minSatisfying=rN;function rN(e,t,r){var n=null,i=null;try{var a=new J(t,r)}catch(s){return null}return e.forEach(function(s){a.test(s)&&(!n||i.compare(s)===1)&&(n=s,i=new D(n,r))}),n}b.minVersion=nN;function nN(e,t){e=new J(e,t);var r=new D("0.0.0");if(e.test(r)||(r=new D("0.0.0-0"),e.test(r)))return r;r=null;for(var n=0;n<e.set.length;++n){var i=e.set[n];i.forEach(function(a){var s=new D(a.semver.version);switch(a.operator){case">":s.prerelease.length===0?s.patch++:s.prerelease.push(0),s.raw=s.format();case"":case">=":(!r||ta(r,s))&&(r=s);break;case"<":case"<=":break;default:throw new Error("Unexpected operation: "+a.operator)}})}return r&&e.test(r)?r:null}b.validRange=iN;function iN(e,t){try{return new J(e,t).range||"*"}catch(r){return null}}b.ltr=aN;function aN(e,t,r){return Bl(e,t,"<",r)}b.gtr=sN;function sN(e,t,r){return Bl(e,t,">",r)}b.outside=Bl;function Bl(e,t,r,n){e=new D(e,n),t=new J(t,n);var i,a,s,o,u;switch(r){case">":i=ta,a=Ul,s=Co,o=">",u=">=";break;case"<":i=Co,a=Hl,s=ta,o="<",u="<=";break;default:throw new TypeError('Must provide a hilo val of "<" or ">"')}if(Po(e,t,n))return!1;for(var c=0;c<t.set.length;++c){var p=t.set[c],f=null,d=null;if(p.forEach(function(h){h.semver===ra&&(h=new Ye(">=0.0.0")),f=f||h,d=d||h,i(h.semver,f.semver,n)?f=h:s(h.semver,d.semver,n)&&(d=h)}),f.operator===o||f.operator===u||(!d.operator||d.operator===o)&&a(e,d.semver))return!1;if(d.operator===u&&s(e,d.semver))return!1}return!0}b.prerelease=oN;function oN(e,t){var r=$r(e,t);return r&&r.prerelease.length?r.prerelease:null}b.intersects=uN;function uN(e,t,r){return e=new J(e,r),t=new J(t,r),e.intersects(t)}b.coerce=cN;function cN(e){if(e instanceof D)return e;if(typeof e!="string")return null;var t=e.match(G[RE]);return t==null?null:$r(t[1]+"."+(t[2]||"0")+"."+(t[3]||"0"))}});var Ro=l((c1,FE)=>{"use strict";function Gl(e){return typeof e=="function"}var xe=console.error.bind(console);function na(e,t,r){var n=!!e[t]&&e.propertyIsEnumerable(t);Object.defineProperty(e,t,{configurable:!0,enumerable:n,writable:!0,value:r})}function ia(e){e&&e.logger&&(Gl(e.logger)?xe=e.logger:xe("new logger isn't a function, not replacing"))}function BE(e,t,r){if(!e||!e[t]){xe("no original function "+t+" to wrap");return}if(!r){xe("no wrapper function"),xe(new Error().stack);return}if(!Gl(e[t])||!Gl(r)){xe("original object and wrapper must be functions");return}var n=e[t],i=r(n,t);return na(i,"__original",n),na(i,"__unwrap",function(){e[t]===i&&na(e,t,n)}),na(i,"__wrapped",!0),na(e,t,i),i}function lN(e,t,r){if(e)Array.isArray(e)||(e=[e]);else{xe("must provide one or more modules to patch"),xe(new Error().stack);return}if(!(t&&Array.isArray(t))){xe("must provide one or more functions to wrap on modules");return}e.forEach(function(n){t.forEach(function(i){BE(n,i,r)})})}function GE(e,t){if(!e||!e[t]){xe("no function to unwrap."),xe(new Error().stack);return}if(!e[t].__unwrap)xe("no original to unwrap to -- has "+t+" already been unwrapped?");else return e[t].__unwrap()}function pN(e,t){if(e)Array.isArray(e)||(e=[e]);else{xe("must provide one or more modules to patch"),xe(new Error().stack);return}if(!(t&&Array.isArray(t))){xe("must provide one or more functions to unwrap on modules");return}e.forEach(function(r){t.forEach(function(n){GE(r,n)})})}ia.wrap=BE;ia.massWrap=lN;ia.unwrap=GE;ia.massUnwrap=pN;FE.exports=ia});var wo=l((l1,KE)=>{"use strict";var VE=Ro(),$n=VE.wrap,No=VE.unwrap,xt="wrap@before";function Do(e,t,r){var n=!!e[t]&&e.propertyIsEnumerable(t);Object.defineProperty(e,t,{configurable:!0,enumerable:n,writable:!0,value:r})}function fN(e,t){for(var r=t.length,n=0;n<r;n++){var i=t[n],a=e[xt];if(typeof a=="function")a(i);else if(Array.isArray(a))for(var s=a.length,o=0;o<s;o++)a[o](i)}}function $E(e,t){var r;return r=e._events&&e._events[t],Array.isArray(r)||(r?r=[r]:r=[]),r}function dN(e,t,r){var n=$E(e,t),i=n.filter(function(a){return r.indexOf(a)===-1});i.length>0&&fN(e,i)}function zE(e,t){if(!!e){var r=e;if(typeof e=="function")r=t(e);else if(Array.isArray(e)){r=[];for(var n=0;n<e.length;n++)r[n]=t(e[n])}return r}}KE.exports=function(t,r,n){if(!t||!t.on||!t.addListener||!t.removeListener||!t.emit)throw new Error("can only wrap real EEs");if(!r)throw new Error("must have function to run on listener addition");if(!n)throw new Error("must have function to wrap listeners when emitting");function i(s){return function(u,c){var p=$E(this,u).slice();try{var f=s.call(this,u,c);return dN(this,u,p),f}finally{this.on.__wrapped||$n(this,"on",i),this.addListener.__wrapped||$n(this,"addListener",i)}}}function a(s){return function(u){if(!this._events||!this._events[u])return s.apply(this,arguments);var c=this._events[u];function p(f){return function(){this._events[u]=c;try{return f.apply(this,arguments)}finally{c=this._events[u],this._events[u]=zE(c,n)}}}$n(this,"removeListener",p);try{return this._events[u]=zE(c,n),s.apply(this,arguments)}finally{No(this,"removeListener"),this._events[u]=c}}}t[xt]?typeof t[xt]=="function"?Do(t,xt,[t[xt],r]):Array.isArray(t[xt])&&t[xt].push(r):Do(t,xt,r),t.__wrapped||($n(t,"addListener",i),$n(t,"on",i),$n(t,"emit",a),Do(t,"__unwrap",function(){No(t,"addListener"),No(t,"on"),No(t,"emit"),delete t[xt],delete t.__wrapped}),Do(t,"__wrapped",!0))}});var WE=l((p1,QE)=>{"use strict";var L=__webpack_require__(1669),Mt=__webpack_require__(2357),hN=wo(),X=__webpack_require__(7303),aa="cls@contexts",sa="error@context",ee=process.env.DEBUG_CLS_HOOKED,q=-1;QE.exports={getNamespace:XE,createNamespace:_N,destroyNamespace:YE,reset:vN,ERROR_SYMBOL:sa};function Qe(e){this.name=e,this.active=null,this._set=[],this.id=null,this._contexts=new Map,this._indent=0}Qe.prototype.set=function(t,r){if(!this.active)throw new Error("No context available. ns.run() or ns.bind() must be called first.");if(this.active[t]=r,ee){let n=" ".repeat(this._indent<0?0:this._indent);Q(n+"CONTEXT-SET KEY:"+t+"="+r+" in ns:"+this.name+" currentUid:"+q+" active:"+L.inspect(this.active,{showHidden:!0,depth:2,colors:!0}))}return r};Qe.prototype.get=function(t){if(!this.active){if(ee){let r=X.currentId(),n=X.triggerAsyncId(),i=" ".repeat(this._indent<0?0:this._indent);Q(`${i}CONTEXT-GETTING KEY NO ACTIVE NS: (${this.name}) ${t}=undefined currentUid:${q} asyncHooksCurrentId:${r} triggerId:${n} len:${this._set.length}`)}return}if(ee){let r=X.executionAsyncId(),n=X.triggerAsyncId(),i=" ".repeat(this._indent<0?0:this._indent);Q(i+"CONTEXT-GETTING KEY:"+t+"="+this.active[t]+" ("+this.name+") currentUid:"+q+" active:"+L.inspect(this.active,{showHidden:!0,depth:2,colors:!0})),Q(`${i}CONTEXT-GETTING KEY: (${this.name}) ${t}=${this.active[t]} currentUid:${q} asyncHooksCurrentId:${r} triggerId:${n} len:${this._set.length} active:${L.inspect(this.active)}`)}return this.active[t]};Qe.prototype.createContext=function(){let t=Object.create(this.active?this.active:Object.prototype);if(t._ns_name=this.name,t.id=q,ee){let r=X.executionAsyncId(),n=X.triggerAsyncId(),i=" ".repeat(this._indent<0?0:this._indent);Q(`${i}CONTEXT-CREATED Context: (${this.name}) currentUid:${q} asyncHooksCurrentId:${r} triggerId:${n} len:${this._set.length} context:${L.inspect(t,{showHidden:!0,depth:2,colors:!0})}`)}return t};Qe.prototype.run=function(t){let r=this.createContext();this.enter(r);try{if(ee){let n=X.triggerAsyncId(),i=X.executionAsyncId(),a=" ".repeat(this._indent<0?0:this._indent);Q(`${a}CONTEXT-RUN BEGIN: (${this.name}) currentUid:${q} triggerId:${n} asyncHooksCurrentId:${i} len:${this._set.length} context:${L.inspect(r)}`)}return t(r),r}catch(n){throw n&&(n[sa]=r),n}finally{if(ee){let n=X.triggerAsyncId(),i=X.executionAsyncId(),a=" ".repeat(this._indent<0?0:this._indent);Q(`${a}CONTEXT-RUN END: (${this.name}) currentUid:${q} triggerId:${n} asyncHooksCurrentId:${i} len:${this._set.length} ${L.inspect(r)}`)}this.exit(r)}};Qe.prototype.runAndReturn=function(t){let r;return this.run(function(n){r=t(n)}),r};Qe.prototype.runPromise=function(t){let r=this.createContext();this.enter(r);let n=t(r);if(!n||!n.then||!n.catch)throw new Error("fn must return a promise.");return ee&&Q("CONTEXT-runPromise BEFORE: ("+this.name+") currentUid:"+q+" len:"+this._set.length+" "+L.inspect(r)),n.then(i=>(ee&&Q("CONTEXT-runPromise AFTER then: ("+this.name+") currentUid:"+q+" len:"+this._set.length+" "+L.inspect(r)),this.exit(r),i)).catch(i=>{throw i[sa]=r,ee&&Q("CONTEXT-runPromise AFTER catch: ("+this.name+") currentUid:"+q+" len:"+this._set.length+" "+L.inspect(r)),this.exit(r),i})};Qe.prototype.bind=function(t,r){r||(this.active?r=this.active:r=this.createContext());let n=this;return function(){n.enter(r);try{return t.apply(this,arguments)}catch(a){throw a&&(a[sa]=r),a}finally{n.exit(r)}}};Qe.prototype.enter=function(t){if(Mt.ok(t,"context must be provided for entering"),ee){let r=X.executionAsyncId(),n=X.triggerAsyncId(),i=" ".repeat(this._indent<0?0:this._indent);Q(`${i}CONTEXT-ENTER: (${this.name}) currentUid:${q} triggerId:${n} asyncHooksCurrentId:${r} len:${this._set.length} ${L.inspect(t)}`)}this._set.push(this.active),this.active=t};Qe.prototype.exit=function(t){if(Mt.ok(t,"context must be provided for exiting"),ee){let n=X.executionAsyncId(),i=X.triggerAsyncId(),a=" ".repeat(this._indent<0?0:this._indent);Q(`${a}CONTEXT-EXIT: (${this.name}) currentUid:${q} triggerId:${i} asyncHooksCurrentId:${n} len:${this._set.length} ${L.inspect(t)}`)}if(this.active===t){Mt.ok(this._set.length,"can't remove top context"),this.active=this._set.pop();return}let r=this._set.lastIndexOf(t);r<0?(ee&&Q("??ERROR?? context exiting but not entered - ignoring: "+L.inspect(t)),Mt.ok(r>=0,`context not currently entered; can't exit. 
`+L.inspect(this)+`
`+L.inspect(t))):(Mt.ok(r,"can't remove top context"),this._set.splice(r,1))};Qe.prototype.bindEmitter=function(t){Mt.ok(t.on&&t.addListener&&t.emit,"can only bind real EEs");let r=this,n="context@"+this.name;function i(s){!s||(s[aa]||(s[aa]=Object.create(null)),s[aa][n]={namespace:r,context:r.active})}function a(s){if(!(s&&s[aa]))return s;let o=s,u=s[aa];return Object.keys(u).forEach(function(c){let p=u[c];o=p.namespace.bind(o,p.context)}),o}hN(t,i,a)};Qe.prototype.fromException=function(t){return t[sa]};function XE(e){return process.namespaces[e]}function _N(e){Mt.ok(e,"namespace must be given a name."),ee&&Q(`NS-CREATING NAMESPACE (${e})`);let t=new Qe(e);return t.id=q,X.createHook({init(n,i,a,s){if(q=X.executionAsyncId(),t.active){if(t._contexts.set(n,t.active),ee){let o=" ".repeat(t._indent<0?0:t._indent);Q(`${o}INIT [${i}] (${e}) asyncId:${n} currentUid:${q} triggerId:${a} active:${L.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} resource:${s}`)}}else if(q===0){let o=X.triggerAsyncId(),u=t._contexts.get(o);if(u){if(t._contexts.set(n,u),ee){let c=" ".repeat(t._indent<0?0:t._indent);Q(`${c}INIT USING CONTEXT FROM TRIGGERID [${i}] (${e}) asyncId:${n} currentUid:${q} triggerId:${o} active:${L.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} resource:${s}`)}}else if(ee){let c=" ".repeat(t._indent<0?0:t._indent);Q(`${c}INIT MISSING CONTEXT [${i}] (${e}) asyncId:${n} currentUid:${q} triggerId:${o} active:${L.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} resource:${s}`)}}if(ee&&i==="PROMISE"){Q(L.inspect(s,{showHidden:!0}));let o=s.parentId,u=" ".repeat(t._indent<0?0:t._indent);Q(`${u}INIT RESOURCE-PROMISE [${i}] (${e}) parentId:${o} asyncId:${n} currentUid:${q} triggerId:${a} active:${L.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} resource:${s}`)}},before(n){q=X.executionAsyncId();let i;if(i=t._contexts.get(n)||t._contexts.get(q),i){if(ee){let a=X.triggerAsyncId(),s=" ".repeat(t._indent<0?0:t._indent);Q(`${s}BEFORE (${e}) asyncId:${n} currentUid:${q} triggerId:${a} active:${L.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} context:${L.inspect(i)}`),t._indent+=2}t.enter(i)}else if(ee){let a=X.triggerAsyncId(),s=" ".repeat(t._indent<0?0:t._indent);Q(`${s}BEFORE MISSING CONTEXT (${e}) asyncId:${n} currentUid:${q} triggerId:${a} active:${L.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} namespace._contexts:${L.inspect(t._contexts,{showHidden:!0,depth:2,colors:!0})}`),t._indent+=2}},after(n){q=X.executionAsyncId();let i;if(i=t._contexts.get(n)||t._contexts.get(q),i){if(ee){let a=X.triggerAsyncId();t._indent-=2;let s=" ".repeat(t._indent<0?0:t._indent);Q(`${s}AFTER (${e}) asyncId:${n} currentUid:${q} triggerId:${a} active:${L.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} context:${L.inspect(i)}`)}t.exit(i)}else if(ee){let a=X.triggerAsyncId();t._indent-=2;let s=" ".repeat(t._indent<0?0:t._indent);Q(`${s}AFTER MISSING CONTEXT (${e}) asyncId:${n} currentUid:${q} triggerId:${a} active:${L.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} context:${L.inspect(i)}`)}},destroy(n){if(q=X.executionAsyncId(),ee){let i=X.triggerAsyncId(),a=" ".repeat(t._indent<0?0:t._indent);Q(`${a}DESTROY (${e}) currentUid:${q} asyncId:${n} triggerId:${i} active:${L.inspect(t.active,{showHidden:!0,depth:2,colors:!0})} context:${L.inspect(t._contexts.get(q))}`)}t._contexts.delete(n)}}).enable(),process.namespaces[e]=t,t}function YE(e){let t=XE(e);Mt.ok(t,`can't delete nonexistent namespace! "`+e+'"'),Mt.ok(t.id,"don't assign to process.namespaces directly! "+L.inspect(t)),process.namespaces[e]=null}function vN(){process.namespaces&&Object.keys(process.namespaces).forEach(function(e){YE(e)}),process.namespaces=Object.create(null)}process.namespaces={};function Q(...e){ee&&process._rawDebug(`${L.format(...e)}`)}});var JE=l((f1,ZE)=>{"use strict";function gN(){}ZE.exports=function(){let t=this._hooks,r=this._state,n=process.nextTick;process.nextTick=function(){if(!r.enabled)return n.apply(process,arguments);let i=new Array(arguments.length);for(let u=0;u<arguments.length;u++)i[u]=arguments[u];let a=i[0];if(typeof a!="function")throw new TypeError("callback is not a function");let s=new gN,o=--r.counter;return t.init.call(s,o,0,null,null),i[0]=function(){t.pre.call(s,o);let u=!0;try{a.apply(this,arguments),u=!1}finally{u&&process.listenerCount("uncaughtException")>0&&process.once("uncaughtException",function(){t.post.call(s,o,!0),t.destroy.call(null,o)})}t.post.call(s,o,!1),t.destroy.call(null,o)},n.apply(process,i)}}});var tm=l((d1,em)=>{"use strict";function EN(){}em.exports=function(){let t=this._hooks,r=this._state,n=global.Promise,i=n.prototype.then;n.prototype.then=u;function a(c,p,f,d){return typeof c!="function"?d?s(f):o(f):function(){t.pre.call(p,f);try{return c.apply(this,arguments)}finally{t.post.call(p,f,!1),t.destroy.call(null,f)}}}function s(c){return function(f){return t.destroy.call(null,c),f}}function o(c){return function(f){throw t.destroy.call(null,c),f}}function u(c,p){if(!r.enabled)return i.call(this,c,p);let f=new EN,d=--r.counter;return t.init.call(f,d,0,null,null),i.call(this,a(c,f,d,!0),a(p,f,d,!1))}}});var nm=l((h1,rm)=>{"use strict";var Ve=__webpack_require__(8213);function mN(){}function yN(){}function TN(){}var SN=new Map,AN=new Map,IN=new Map,Fl=null,Vl=!1;rm.exports=function(){$l(this._hooks,this._state,"setTimeout","clearTimeout",mN,SN,!0),$l(this._hooks,this._state,"setInterval","clearInterval",yN,AN,!1),$l(this._hooks,this._state,"setImmediate","clearImmediate",TN,IN,!0),global.setTimeout=Ve.setTimeout,global.setInterval=Ve.setInterval,global.setImmediate=Ve.setImmediate,global.clearTimeout=Ve.clearTimeout,global.clearInterval=Ve.clearInterval,global.clearImmediate=Ve.clearImmediate};function $l(e,t,r,n,i,a,s){let o=Ve[r],u=Ve[n];Ve[r]=function(){if(!t.enabled)return o.apply(Ve,arguments);let c=new Array(arguments.length);for(let E=0;E<arguments.length;E++)c[E]=arguments[E];let p=c[0];if(typeof p!="function")throw new TypeError('"callback" argument must be a function');let f=new i,d=--t.counter,h;return e.init.call(f,d,0,null,null),c[0]=function(){Fl=h,e.pre.call(f,d);let E=!0;try{p.apply(this,arguments),E=!1}finally{E&&process.listenerCount("uncaughtException")>0&&process.once("uncaughtException",function(){e.post.call(f,d,!0),a.delete(h),e.destroy.call(null,d)})}e.post.call(f,d,!1),Fl=null,(s||Vl)&&(Vl=!1,a.delete(h),e.destroy.call(null,d))},h=o.apply(Ve,c),a.set(h,d),h},Ve[n]=function(c){if(Fl===c&&c!==null)Vl=!0;else if(a.has(c)){let p=a.get(c);a.delete(c),e.destroy.call(null,p)}u.apply(Ve,arguments)}}});var zl=l((_1,bN)=>{bN.exports={name:"async-hook-jl",description:"Inspect the life of handle objects in node",version:"1.7.6",author:"Andreas Madsen <amwebdk@gmail.com>",main:"./index.js",scripts:{test:"node ./test/runner.js && eslint ."},repository:{type:"git",url:"git://github.com/jeff-lewis/async-hook-jl.git"},keywords:["async","async hooks","inspect","async wrap"],license:"MIT",dependencies:{"stack-chain":"^1.3.7"},devDependencies:{async:"1.5.x","cli-color":"1.1.x",eslint:"^3.4.0",endpoint:"0.4.x"},engines:{node:"^4.7 || >=6.9 || >=7.3"}}});var sm=l((v1,am)=>{"use strict";var oa=process.binding("async_wrap"),CN=oa.Providers.TIMERWRAP,im={nextTick:JE(),promise:tm(),timers:nm()},ua=new Set;function ON(){this.enabled=!1,this.counter=0}function Kl(){let e=this.initFns=[],t=this.preFns=[],r=this.postFns=[],n=this.destroyFns=[];this.init=function(i,a,s,o){if(a===CN){ua.add(i);return}for(let u of e)u(i,this,a,s,o)},this.pre=function(i){if(!ua.has(i))for(let a of t)a(i,this)},this.post=function(i,a){if(!ua.has(i))for(let s of r)s(i,this,a)},this.destroy=function(i){if(ua.has(i)){ua.delete(i);return}for(let a of n)a(i)}}Kl.prototype.add=function(e){e.init&&this.initFns.push(e.init),e.pre&&this.preFns.push(e.pre),e.post&&this.postFns.push(e.post),e.destroy&&this.destroyFns.push(e.destroy)};function xo(e,t){let r=e.indexOf(t);r!==-1&&e.splice(r,1)}Kl.prototype.remove=function(e){e.init&&xo(this.initFns,e.init),e.pre&&xo(this.preFns,e.pre),e.post&&xo(this.postFns,e.post),e.destroy&&xo(this.destroyFns,e.destroy)};function ca(){this._state=new ON,this._hooks=new Kl,this.version=zl().version,this.providers=oa.Providers;for(let e of Object.keys(im))im[e].call(this);process.env.hasOwnProperty("NODE_ASYNC_HOOK_WARNING")&&console.warn("warning: you are using async-hook-jl which is unstable."),oa.setupHooks({init:this._hooks.init,pre:this._hooks.pre,post:this._hooks.post,destroy:this._hooks.destroy})}am.exports=ca;ca.prototype.addHooks=function(e){this._hooks.add(e)};ca.prototype.removeHooks=function(e){this._hooks.remove(e)};ca.prototype.enable=function(){this._state.enabled=!0,oa.enable()};ca.prototype.disable=function(){this._state.enabled=!1,oa.disable()}});var Xl=l((g1,PN)=>{PN.exports={name:"stack-chain",description:"API for combining call site modifiers",version:"1.3.7",author:"Andreas Madsen <amwebdk@gmail.com>",scripts:{test:"tap ./test/simple"},repository:{type:"git",url:"git://github.com/AndreasMadsen/stack-chain.git"},keywords:["stack","chain","trace","call site","concat","format"],devDependencies:{tap:"2.x.x","uglify-js":"2.5.x"},license:"MIT"}});var um=l((E1,om)=>{function RN(e){try{return Error.prototype.toString.call(e)}catch(t){try{return"<error: "+t+">"}catch(r){return"<error>"}}}om.exports=function(t,r){var n=[];n.push(RN(t));for(var i=0;i<r.length;i++){var a=r[i],s;try{s=a.toString()}catch(o){try{s="<error: "+o+">"}catch(u){s="<error>"}}n.push("    at "+s)}return n.join(`
`)}});var fm=l((m1,pm)=>{var Mo=um();function cm(){this.extend=new la,this.filter=new la,this.format=new pa,this.version=Xl().version}var Yl=!1;cm.prototype.callSite=function e(t){t||(t={}),Yl=!0;var r={};Error.captureStackTrace(r,e);var n=r.stack;return Yl=!1,n=n.slice(t.slice||0),t.extend&&(n=this.extend._modify(r,n)),t.filter&&(n=this.filter._modify(r,n)),n};var sr=new cm;function la(){this._modifiers=[]}la.prototype._modify=function(e,t){for(var r=0,n=this._modifiers.length;r<n;r++)t=this._modifiers[r](e,t);return t};la.prototype.attach=function(e){this._modifiers.push(e)};la.prototype.deattach=function(e){var t=this._modifiers.indexOf(e);return t===-1?!1:(this._modifiers.splice(t,1),!0)};function pa(){this._formater=Mo,this._previous=void 0}pa.prototype.replace=function(e){e?this._formater=e:this.restore()};pa.prototype.restore=function(){this._formater=Mo,this._previous=void 0};pa.prototype._backup=function(){this._previous=this._formater};pa.prototype._roolback=function(){this._previous===Mo?this.replace(void 0):this.replace(this._previous),this._previous=void 0};Error.prepareStackTrace&&sr.format.replace(Error.prepareStackTrace);var Ql=!1;function lm(e,t){if(Yl)return t;if(Ql)return Mo(e,t);var r=t.concat();r=sr.extend._modify(e,r),r=sr.filter._modify(e,r),r=r.slice(0,Error.stackTraceLimit),Object.isExtensible(e)&&Object.getOwnPropertyDescriptor(e,"callSite")===void 0&&(e.callSite={original:t,mutated:r}),Ql=!0;var n=sr.format._formater(e,r);return Ql=!1,n}Object.defineProperty(Error,"prepareStackTrace",{get:function(){return lm},set:function(e){e===lm?sr.format._roolback():(sr.format._backup(),sr.format.replace(e))}});function NN(){return this.stack,this.callSite}Object.defineProperty(Error.prototype,"callSite",{get:NN,set:function(e){Object.defineProperty(this,"callSite",{value:e,writable:!0,configurable:!0})},configurable:!0});pm.exports=sr});var Zl=l((y1,Wl)=>{if(global._stackChain)if(global._stackChain.version===Xl().version)Wl.exports=global._stackChain;else throw new Error("Conflicting version of stack-chain found");else Wl.exports=global._stackChain=fm()});var dm=l((T1,Jl)=>{"use strict";var DN=sm();if(global._asyncHook)if(global._asyncHook.version===zl().version)Jl.exports=global._asyncHook;else throw new Error("Conflicting version of async-hook-jl found");else Zl().filter.attach(function(t,r){return r.filter(function(n){let i=n.getFileName();return!(i&&i.slice(0,__dirname.length)===__dirname)})}),Jl.exports=global._asyncHook=new DN});var mm=l((S1,Em)=>{"use strict";var ce=__webpack_require__(1669),Lt=__webpack_require__(2357),wN=wo(),zn=dm(),fa="cls@contexts",da="error@context",hm=[];for(let e in zn.providers)hm[zn.providers[e]]=e;var se=process.env.DEBUG_CLS_HOOKED,de=-1;Em.exports={getNamespace:_m,createNamespace:xN,destroyNamespace:vm,reset:MN,ERROR_SYMBOL:da};function We(e){this.name=e,this.active=null,this._set=[],this.id=null,this._contexts=new Map}We.prototype.set=function(t,r){if(!this.active)throw new Error("No context available. ns.run() or ns.bind() must be called first.");return se&&le("    SETTING KEY:"+t+"="+r+" in ns:"+this.name+" uid:"+de+" active:"+ce.inspect(this.active,!0)),this.active[t]=r,r};We.prototype.get=function(t){if(!this.active){se&&le("    GETTING KEY:"+t+"=undefined "+this.name+" uid:"+de+" active:"+ce.inspect(this.active,!0));return}return se&&le("    GETTING KEY:"+t+"="+this.active[t]+" "+this.name+" uid:"+de+" active:"+ce.inspect(this.active,!0)),this.active[t]};We.prototype.createContext=function(){se&&le("   CREATING Context: "+this.name+" uid:"+de+" len:"+this._set.length+"  active:"+ce.inspect(this.active,!0,2,!0));let t=Object.create(this.active?this.active:Object.prototype);return t._ns_name=this.name,t.id=de,se&&le("   CREATED Context: "+this.name+" uid:"+de+" len:"+this._set.length+"  context:"+ce.inspect(t,!0,2,!0)),t};We.prototype.run=function(t){let r=this.createContext();this.enter(r);try{return se&&le(" BEFORE RUN: "+this.name+" uid:"+de+" len:"+this._set.length+" "+ce.inspect(r)),t(r),r}catch(n){throw n&&(n[da]=r),n}finally{se&&le(" AFTER RUN: "+this.name+" uid:"+de+" len:"+this._set.length+" "+ce.inspect(r)),this.exit(r)}};We.prototype.runAndReturn=function(t){var r;return this.run(function(n){r=t(n)}),r};We.prototype.runPromise=function(t){let r=this.createContext();this.enter(r);let n=t(r);if(!n||!n.then||!n.catch)throw new Error("fn must return a promise.");return se&&le(" BEFORE runPromise: "+this.name+" uid:"+de+" len:"+this._set.length+" "+ce.inspect(r)),n.then(i=>(se&&le(" AFTER runPromise: "+this.name+" uid:"+de+" len:"+this._set.length+" "+ce.inspect(r)),this.exit(r),i)).catch(i=>{throw i[da]=r,se&&le(" AFTER runPromise: "+this.name+" uid:"+de+" len:"+this._set.length+" "+ce.inspect(r)),this.exit(r),i})};We.prototype.bind=function(t,r){r||(this.active?r=this.active:r=this.createContext());let n=this;return function(){n.enter(r);try{return t.apply(this,arguments)}catch(a){throw a&&(a[da]=r),a}finally{n.exit(r)}}};We.prototype.enter=function(t){Lt.ok(t,"context must be provided for entering"),se&&le("  ENTER "+this.name+" uid:"+de+" len:"+this._set.length+" context: "+ce.inspect(t)),this._set.push(this.active),this.active=t};We.prototype.exit=function(t){if(Lt.ok(t,"context must be provided for exiting"),se&&le("  EXIT "+this.name+" uid:"+de+" len:"+this._set.length+" context: "+ce.inspect(t)),this.active===t){Lt.ok(this._set.length,"can't remove top context"),this.active=this._set.pop();return}let r=this._set.lastIndexOf(t);r<0?(se&&le("??ERROR?? context exiting but not entered - ignoring: "+ce.inspect(t)),Lt.ok(r>=0,`context not currently entered; can't exit. 
`+ce.inspect(this)+`
`+ce.inspect(t))):(Lt.ok(r,"can't remove top context"),this._set.splice(r,1))};We.prototype.bindEmitter=function(t){Lt.ok(t.on&&t.addListener&&t.emit,"can only bind real EEs");let r=this,n="context@"+this.name;function i(s){!s||(s[fa]||(s[fa]=Object.create(null)),s[fa][n]={namespace:r,context:r.active})}function a(s){if(!(s&&s[fa]))return s;let o=s,u=s[fa];return Object.keys(u).forEach(function(c){let p=u[c];o=p.namespace.bind(o,p.context)}),o}wN(t,i,a)};We.prototype.fromException=function(t){return t[da]};function _m(e){return process.namespaces[e]}function xN(e){Lt.ok(e,"namespace must be given a name."),se&&le("CREATING NAMESPACE "+e);let t=new We(e);return t.id=de,zn.addHooks({init(r,n,i,a,s){de=r,a?(t._contexts.set(r,t._contexts.get(a)),se&&le("PARENTID: "+e+" uid:"+r+" parent:"+a+" provider:"+i)):t._contexts.set(de,t.active),se&&le("INIT "+e+" uid:"+r+" parent:"+a+" provider:"+hm[i]+" active:"+ce.inspect(t.active,!0))},pre(r,n){de=r;let i=t._contexts.get(r);i?(se&&le(" PRE "+e+" uid:"+r+" handle:"+Lo(n)+" context:"+ce.inspect(i)),t.enter(i)):se&&le(" PRE MISSING CONTEXT "+e+" uid:"+r+" handle:"+Lo(n))},post(r,n){de=r;let i=t._contexts.get(r);i?(se&&le(" POST "+e+" uid:"+r+" handle:"+Lo(n)+" context:"+ce.inspect(i)),t.exit(i)):se&&le(" POST MISSING CONTEXT "+e+" uid:"+r+" handle:"+Lo(n))},destroy(r){de=r,se&&le("DESTROY "+e+" uid:"+r+" context:"+ce.inspect(t._contexts.get(de))+" active:"+ce.inspect(t.active,!0)),t._contexts.delete(r)}}),process.namespaces[e]=t,t}function vm(e){let t=_m(e);Lt.ok(t,`can't delete nonexistent namespace! "`+e+'"'),Lt.ok(t.id,"don't assign to process.namespaces directly! "+ce.inspect(t)),process.namespaces[e]=null}function MN(){process.namespaces&&Object.keys(process.namespaces).forEach(function(e){vm(e)}),process.namespaces=Object.create(null)}process.namespaces={};zn._state&&!zn._state.enabled&&zn.enable();function le(e){process.env.DEBUG&&process._rawDebug(e)}function Lo(e){if(!e)return e;if(typeof e=="function")return e.name?e.name:(e.toString().trim().match(/^function\s*([^\s(]+)/)||[])[1];if(e.constructor&&e.constructor.name)return e.constructor.name}if(se){ep=Zl();for(gm in ep.filter._modifiers)ep.filter.deattach(gm)}var ep,gm});var ym=l((A1,tp)=>{"use strict";var LN=UE();process&&LN.gte(process.versions.node,"8.0.0")?tp.exports=WE():tp.exports=mm()});var jm=l((C,qm)=>{C=qm.exports=w;var U;typeof process=="object"&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?U=function(){var e=Array.prototype.slice.call(arguments,0);e.unshift("SEMVER"),console.log.apply(console,e)}:U=function(){};C.SEMVER_SPEC_VERSION="2.0.0";var rp=256,qo=Number.MAX_SAFE_INTEGER||9007199254740991,np=16,F=C.re=[],g=C.src=[],R=0,Kn=R++;g[Kn]="0|[1-9]\\d*";var Xn=R++;g[Xn]="[0-9]+";var ip=R++;g[ip]="\\d*[a-zA-Z-][a-zA-Z0-9-]*";var Tm=R++;g[Tm]="("+g[Kn]+")\\.("+g[Kn]+")\\.("+g[Kn]+")";var Sm=R++;g[Sm]="("+g[Xn]+")\\.("+g[Xn]+")\\.("+g[Xn]+")";var ap=R++;g[ap]="(?:"+g[Kn]+"|"+g[ip]+")";var sp=R++;g[sp]="(?:"+g[Xn]+"|"+g[ip]+")";var op=R++;g[op]="(?:-("+g[ap]+"(?:\\."+g[ap]+")*))";var up=R++;g[up]="(?:-?("+g[sp]+"(?:\\."+g[sp]+")*))";var cp=R++;g[cp]="[0-9A-Za-z-]+";var ha=R++;g[ha]="(?:\\+("+g[cp]+"(?:\\."+g[cp]+")*))";var lp=R++,Am="v?"+g[Tm]+g[op]+"?"+g[ha]+"?";g[lp]="^"+Am+"$";var pp="[v=\\s]*"+g[Sm]+g[up]+"?"+g[ha]+"?",fp=R++;g[fp]="^"+pp+"$";var Yn=R++;g[Yn]="((?:<|>)?=?)";var jo=R++;g[jo]=g[Xn]+"|x|X|\\*";var ko=R++;g[ko]=g[Kn]+"|x|X|\\*";var zr=R++;g[zr]="[v=\\s]*("+g[ko]+")(?:\\.("+g[ko]+")(?:\\.("+g[ko]+")(?:"+g[op]+")?"+g[ha]+"?)?)?";var Qn=R++;g[Qn]="[v=\\s]*("+g[jo]+")(?:\\.("+g[jo]+")(?:\\.("+g[jo]+")(?:"+g[up]+")?"+g[ha]+"?)?)?";var Im=R++;g[Im]="^"+g[Yn]+"\\s*"+g[zr]+"$";var bm=R++;g[bm]="^"+g[Yn]+"\\s*"+g[Qn]+"$";var Cm=R++;g[Cm]="(?:^|[^\\d])(\\d{1,"+np+"})(?:\\.(\\d{1,"+np+"}))?(?:\\.(\\d{1,"+np+"}))?(?:$|[^\\d])";var Ho=R++;g[Ho]="(?:~>?)";var Uo=R++;g[Uo]="(\\s*)"+g[Ho]+"\\s+";F[Uo]=new RegExp(g[Uo],"g");var qN="$1~",Om=R++;g[Om]="^"+g[Ho]+g[zr]+"$";var Pm=R++;g[Pm]="^"+g[Ho]+g[Qn]+"$";var Bo=R++;g[Bo]="(?:\\^)";var Go=R++;g[Go]="(\\s*)"+g[Bo]+"\\s+";F[Go]=new RegExp(g[Go],"g");var jN="$1^",Rm=R++;g[Rm]="^"+g[Bo]+g[zr]+"$";var Nm=R++;g[Nm]="^"+g[Bo]+g[Qn]+"$";var dp=R++;g[dp]="^"+g[Yn]+"\\s*("+pp+")$|^$";var hp=R++;g[hp]="^"+g[Yn]+"\\s*("+Am+")$|^$";var _a=R++;g[_a]="(\\s*)"+g[Yn]+"\\s*("+pp+"|"+g[zr]+")";F[_a]=new RegExp(g[_a],"g");var kN="$1$2$3",Dm=R++;g[Dm]="^\\s*("+g[zr]+")\\s+-\\s+("+g[zr]+")\\s*$";var wm=R++;g[wm]="^\\s*("+g[Qn]+")\\s+-\\s+("+g[Qn]+")\\s*$";var xm=R++;g[xm]="(<|>)?=?\\s*\\*";for(or=0;or<R;or++)U(or,g[or]),F[or]||(F[or]=new RegExp(g[or]));var or;C.parse=Kr;function Kr(e,t){if((!t||typeof t!="object")&&(t={loose:!!t,includePrerelease:!1}),e instanceof w)return e;if(typeof e!="string"||e.length>rp)return null;var r=t.loose?F[fp]:F[lp];if(!r.test(e))return null;try{return new w(e,t)}catch(n){return null}}C.valid=HN;function HN(e,t){var r=Kr(e,t);return r?r.version:null}C.clean=UN;function UN(e,t){var r=Kr(e.trim().replace(/^[=v]+/,""),t);return r?r.version:null}C.SemVer=w;function w(e,t){if((!t||typeof t!="object")&&(t={loose:!!t,includePrerelease:!1}),e instanceof w){if(e.loose===t.loose)return e;e=e.version}else if(typeof e!="string")throw new TypeError("Invalid Version: "+e);if(e.length>rp)throw new TypeError("version is longer than "+rp+" characters");if(!(this instanceof w))return new w(e,t);U("SemVer",e,t),this.options=t,this.loose=!!t.loose;var r=e.trim().match(t.loose?F[fp]:F[lp]);if(!r)throw new TypeError("Invalid Version: "+e);if(this.raw=e,this.major=+r[1],this.minor=+r[2],this.patch=+r[3],this.major>qo||this.major<0)throw new TypeError("Invalid major version");if(this.minor>qo||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>qo||this.patch<0)throw new TypeError("Invalid patch version");r[4]?this.prerelease=r[4].split(".").map(function(n){if(/^[0-9]+$/.test(n)){var i=+n;if(i>=0&&i<qo)return i}return n}):this.prerelease=[],this.build=r[5]?r[5].split("."):[],this.format()}w.prototype.format=function(){return this.version=this.major+"."+this.minor+"."+this.patch,this.prerelease.length&&(this.version+="-"+this.prerelease.join(".")),this.version};w.prototype.toString=function(){return this.version};w.prototype.compare=function(e){return U("SemVer.compare",this.version,this.options,e),e instanceof w||(e=new w(e,this.options)),this.compareMain(e)||this.comparePre(e)};w.prototype.compareMain=function(e){return e instanceof w||(e=new w(e,this.options)),Wn(this.major,e.major)||Wn(this.minor,e.minor)||Wn(this.patch,e.patch)};w.prototype.comparePre=function(e){if(e instanceof w||(e=new w(e,this.options)),this.prerelease.length&&!e.prerelease.length)return-1;if(!this.prerelease.length&&e.prerelease.length)return 1;if(!this.prerelease.length&&!e.prerelease.length)return 0;var t=0;do{var r=this.prerelease[t],n=e.prerelease[t];if(U("prerelease compare",t,r,n),r===void 0&&n===void 0)return 0;if(n===void 0)return 1;if(r===void 0)return-1;if(r===n)continue;return Wn(r,n)}while(++t)};w.prototype.inc=function(e,t){switch(e){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",t);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",t);break;case"prepatch":this.prerelease.length=0,this.inc("patch",t),this.inc("pre",t);break;case"prerelease":this.prerelease.length===0&&this.inc("patch",t),this.inc("pre",t);break;case"major":(this.minor!==0||this.patch!==0||this.prerelease.length===0)&&this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":(this.patch!==0||this.prerelease.length===0)&&this.minor++,this.patch=0,this.prerelease=[];break;case"patch":this.prerelease.length===0&&this.patch++,this.prerelease=[];break;case"pre":if(this.prerelease.length===0)this.prerelease=[0];else{for(var r=this.prerelease.length;--r>=0;)typeof this.prerelease[r]=="number"&&(this.prerelease[r]++,r=-2);r===-1&&this.prerelease.push(0)}t&&(this.prerelease[0]===t?isNaN(this.prerelease[1])&&(this.prerelease=[t,0]):this.prerelease=[t,0]);break;default:throw new Error("invalid increment argument: "+e)}return this.format(),this.raw=this.version,this};C.inc=BN;function BN(e,t,r,n){typeof r=="string"&&(n=r,r=void 0);try{return new w(e,r).inc(t,n).version}catch(i){return null}}C.diff=GN;function GN(e,t){if(_p(e,t))return null;var r=Kr(e),n=Kr(t),i="";if(r.prerelease.length||n.prerelease.length){i="pre";var a="prerelease"}for(var s in r)if((s==="major"||s==="minor"||s==="patch")&&r[s]!==n[s])return i+s;return a}C.compareIdentifiers=Wn;var Mm=/^[0-9]+$/;function Wn(e,t){var r=Mm.test(e),n=Mm.test(t);return r&&n&&(e=+e,t=+t),e===t?0:r&&!n?-1:n&&!r?1:e<t?-1:1}C.rcompareIdentifiers=FN;function FN(e,t){return Wn(t,e)}C.major=VN;function VN(e,t){return new w(e,t).major}C.minor=$N;function $N(e,t){return new w(e,t).minor}C.patch=zN;function zN(e,t){return new w(e,t).patch}C.compare=qt;function qt(e,t,r){return new w(e,r).compare(new w(t,r))}C.compareLoose=KN;function KN(e,t){return qt(e,t,!0)}C.rcompare=XN;function XN(e,t,r){return qt(t,e,r)}C.sort=YN;function YN(e,t){return e.sort(function(r,n){return C.compare(r,n,t)})}C.rsort=QN;function QN(e,t){return e.sort(function(r,n){return C.rcompare(r,n,t)})}C.gt=va;function va(e,t,r){return qt(e,t,r)>0}C.lt=Fo;function Fo(e,t,r){return qt(e,t,r)<0}C.eq=_p;function _p(e,t,r){return qt(e,t,r)===0}C.neq=Lm;function Lm(e,t,r){return qt(e,t,r)!==0}C.gte=vp;function vp(e,t,r){return qt(e,t,r)>=0}C.lte=gp;function gp(e,t,r){return qt(e,t,r)<=0}C.cmp=Vo;function Vo(e,t,r,n){switch(t){case"===":return typeof e=="object"&&(e=e.version),typeof r=="object"&&(r=r.version),e===r;case"!==":return typeof e=="object"&&(e=e.version),typeof r=="object"&&(r=r.version),e!==r;case"":case"=":case"==":return _p(e,r,n);case"!=":return Lm(e,r,n);case">":return va(e,r,n);case">=":return vp(e,r,n);case"<":return Fo(e,r,n);case"<=":return gp(e,r,n);default:throw new TypeError("Invalid operator: "+t)}}C.Comparator=Ze;function Ze(e,t){if((!t||typeof t!="object")&&(t={loose:!!t,includePrerelease:!1}),e instanceof Ze){if(e.loose===!!t.loose)return e;e=e.value}if(!(this instanceof Ze))return new Ze(e,t);U("comparator",e,t),this.options=t,this.loose=!!t.loose,this.parse(e),this.semver===ga?this.value="":this.value=this.operator+this.semver.version,U("comp",this)}var ga={};Ze.prototype.parse=function(e){var t=this.options.loose?F[dp]:F[hp],r=e.match(t);if(!r)throw new TypeError("Invalid comparator: "+e);this.operator=r[1],this.operator==="="&&(this.operator=""),r[2]?this.semver=new w(r[2],this.options.loose):this.semver=ga};Ze.prototype.toString=function(){return this.value};Ze.prototype.test=function(e){return U("Comparator.test",e,this.options.loose),this.semver===ga?!0:(typeof e=="string"&&(e=new w(e,this.options)),Vo(e,this.operator,this.semver,this.options))};Ze.prototype.intersects=function(e,t){if(!(e instanceof Ze))throw new TypeError("a Comparator is required");(!t||typeof t!="object")&&(t={loose:!!t,includePrerelease:!1});var r;if(this.operator==="")return r=new te(e.value,t),$o(this.value,r,t);if(e.operator==="")return r=new te(this.value,t),$o(e.semver,r,t);var n=(this.operator===">="||this.operator===">")&&(e.operator===">="||e.operator===">"),i=(this.operator==="<="||this.operator==="<")&&(e.operator==="<="||e.operator==="<"),a=this.semver.version===e.semver.version,s=(this.operator===">="||this.operator==="<=")&&(e.operator===">="||e.operator==="<="),o=Vo(this.semver,"<",e.semver,t)&&(this.operator===">="||this.operator===">")&&(e.operator==="<="||e.operator==="<"),u=Vo(this.semver,">",e.semver,t)&&(this.operator==="<="||this.operator==="<")&&(e.operator===">="||e.operator===">");return n||i||a&&s||o||u};C.Range=te;function te(e,t){if((!t||typeof t!="object")&&(t={loose:!!t,includePrerelease:!1}),e instanceof te)return e.loose===!!t.loose&&e.includePrerelease===!!t.includePrerelease?e:new te(e.raw,t);if(e instanceof Ze)return new te(e.value,t);if(!(this instanceof te))return new te(e,t);if(this.options=t,this.loose=!!t.loose,this.includePrerelease=!!t.includePrerelease,this.raw=e,this.set=e.split(/\s*\|\|\s*/).map(function(r){return this.parseRange(r.trim())},this).filter(function(r){return r.length}),!this.set.length)throw new TypeError("Invalid SemVer Range: "+e);this.format()}te.prototype.format=function(){return this.range=this.set.map(function(e){return e.join(" ").trim()}).join("||").trim(),this.range};te.prototype.toString=function(){return this.range};te.prototype.parseRange=function(e){var t=this.options.loose;e=e.trim();var r=t?F[wm]:F[Dm];e=e.replace(r,sD),U("hyphen replace",e),e=e.replace(F[_a],kN),U("comparator trim",e,F[_a]),e=e.replace(F[Uo],qN),e=e.replace(F[Go],jN),e=e.split(/\s+/).join(" ");var n=t?F[dp]:F[hp],i=e.split(" ").map(function(a){return ZN(a,this.options)},this).join(" ").split(/\s+/);return this.options.loose&&(i=i.filter(function(a){return!!a.match(n)})),i=i.map(function(a){return new Ze(a,this.options)},this),i};te.prototype.intersects=function(e,t){if(!(e instanceof te))throw new TypeError("a Range is required");return this.set.some(function(r){return r.every(function(n){return e.set.some(function(i){return i.every(function(a){return n.intersects(a,t)})})})})};C.toComparators=WN;function WN(e,t){return new te(e,t).set.map(function(r){return r.map(function(n){return n.value}).join(" ").trim().split(" ")})}function ZN(e,t){return U("comp",e,t),e=tD(e,t),U("caret",e),e=JN(e,t),U("tildes",e),e=nD(e,t),U("xrange",e),e=aD(e,t),U("stars",e),e}function Me(e){return!e||e.toLowerCase()==="x"||e==="*"}function JN(e,t){return e.trim().split(/\s+/).map(function(r){return eD(r,t)}).join(" ")}function eD(e,t){var r=t.loose?F[Pm]:F[Om];return e.replace(r,function(n,i,a,s,o){U("tilde",e,n,i,a,s,o);var u;return Me(i)?u="":Me(a)?u=">="+i+".0.0 <"+(+i+1)+".0.0":Me(s)?u=">="+i+"."+a+".0 <"+i+"."+(+a+1)+".0":o?(U("replaceTilde pr",o),u=">="+i+"."+a+"."+s+"-"+o+" <"+i+"."+(+a+1)+".0"):u=">="+i+"."+a+"."+s+" <"+i+"."+(+a+1)+".0",U("tilde return",u),u})}function tD(e,t){return e.trim().split(/\s+/).map(function(r){return rD(r,t)}).join(" ")}function rD(e,t){U("caret",e,t);var r=t.loose?F[Nm]:F[Rm];return e.replace(r,function(n,i,a,s,o){U("caret",e,n,i,a,s,o);var u;return Me(i)?u="":Me(a)?u=">="+i+".0.0 <"+(+i+1)+".0.0":Me(s)?i==="0"?u=">="+i+"."+a+".0 <"+i+"."+(+a+1)+".0":u=">="+i+"."+a+".0 <"+(+i+1)+".0.0":o?(U("replaceCaret pr",o),i==="0"?a==="0"?u=">="+i+"."+a+"."+s+"-"+o+" <"+i+"."+a+"."+(+s+1):u=">="+i+"."+a+"."+s+"-"+o+" <"+i+"."+(+a+1)+".0":u=">="+i+"."+a+"."+s+"-"+o+" <"+(+i+1)+".0.0"):(U("no pr"),i==="0"?a==="0"?u=">="+i+"."+a+"."+s+" <"+i+"."+a+"."+(+s+1):u=">="+i+"."+a+"."+s+" <"+i+"."+(+a+1)+".0":u=">="+i+"."+a+"."+s+" <"+(+i+1)+".0.0"),U("caret return",u),u})}function nD(e,t){return U("replaceXRanges",e,t),e.split(/\s+/).map(function(r){return iD(r,t)}).join(" ")}function iD(e,t){e=e.trim();var r=t.loose?F[bm]:F[Im];return e.replace(r,function(n,i,a,s,o,u){U("xRange",e,n,i,a,s,o,u);var c=Me(a),p=c||Me(s),f=p||Me(o),d=f;return i==="="&&d&&(i=""),c?i===">"||i==="<"?n="<0.0.0":n="*":i&&d?(p&&(s=0),o=0,i===">"?(i=">=",p?(a=+a+1,s=0,o=0):(s=+s+1,o=0)):i==="<="&&(i="<",p?a=+a+1:s=+s+1),n=i+a+"."+s+"."+o):p?n=">="+a+".0.0 <"+(+a+1)+".0.0":f&&(n=">="+a+"."+s+".0 <"+a+"."+(+s+1)+".0"),U("xRange return",n),n})}function aD(e,t){return U("replaceStars",e,t),e.trim().replace(F[xm],"")}function sD(e,t,r,n,i,a,s,o,u,c,p,f,d){return Me(r)?t="":Me(n)?t=">="+r+".0.0":Me(i)?t=">="+r+"."+n+".0":t=">="+t,Me(u)?o="":Me(c)?o="<"+(+u+1)+".0.0":Me(p)?o="<"+u+"."+(+c+1)+".0":f?o="<="+u+"."+c+"."+p+"-"+f:o="<="+o,(t+" "+o).trim()}te.prototype.test=function(e){if(!e)return!1;typeof e=="string"&&(e=new w(e,this.options));for(var t=0;t<this.set.length;t++)if(oD(this.set[t],e,this.options))return!0;return!1};function oD(e,t,r){for(var n=0;n<e.length;n++)if(!e[n].test(t))return!1;if(t.prerelease.length&&!r.includePrerelease){for(n=0;n<e.length;n++)if(U(e[n].semver),e[n].semver!==ga&&e[n].semver.prerelease.length>0){var i=e[n].semver;if(i.major===t.major&&i.minor===t.minor&&i.patch===t.patch)return!0}return!1}return!0}C.satisfies=$o;function $o(e,t,r){try{t=new te(t,r)}catch(n){return!1}return t.test(e)}C.maxSatisfying=uD;function uD(e,t,r){var n=null,i=null;try{var a=new te(t,r)}catch(s){return null}return e.forEach(function(s){a.test(s)&&(!n||i.compare(s)===-1)&&(n=s,i=new w(n,r))}),n}C.minSatisfying=cD;function cD(e,t,r){var n=null,i=null;try{var a=new te(t,r)}catch(s){return null}return e.forEach(function(s){a.test(s)&&(!n||i.compare(s)===1)&&(n=s,i=new w(n,r))}),n}C.minVersion=lD;function lD(e,t){e=new te(e,t);var r=new w("0.0.0");if(e.test(r)||(r=new w("0.0.0-0"),e.test(r)))return r;r=null;for(var n=0;n<e.set.length;++n){var i=e.set[n];i.forEach(function(a){var s=new w(a.semver.version);switch(a.operator){case">":s.prerelease.length===0?s.patch++:s.prerelease.push(0),s.raw=s.format();case"":case">=":(!r||va(r,s))&&(r=s);break;case"<":case"<=":break;default:throw new Error("Unexpected operation: "+a.operator)}})}return r&&e.test(r)?r:null}C.validRange=pD;function pD(e,t){try{return new te(e,t).range||"*"}catch(r){return null}}C.ltr=fD;function fD(e,t,r){return Ep(e,t,"<",r)}C.gtr=dD;function dD(e,t,r){return Ep(e,t,">",r)}C.outside=Ep;function Ep(e,t,r,n){e=new w(e,n),t=new te(t,n);var i,a,s,o,u;switch(r){case">":i=va,a=gp,s=Fo,o=">",u=">=";break;case"<":i=Fo,a=vp,s=va,o="<",u="<=";break;default:throw new TypeError('Must provide a hilo val of "<" or ">"')}if($o(e,t,n))return!1;for(var c=0;c<t.set.length;++c){var p=t.set[c],f=null,d=null;if(p.forEach(function(h){h.semver===ga&&(h=new Ze(">=0.0.0")),f=f||h,d=d||h,i(h.semver,f.semver,n)?f=h:s(h.semver,d.semver,n)&&(d=h)}),f.operator===o||f.operator===u||(!d.operator||d.operator===o)&&a(e,d.semver))return!1;if(d.operator===u&&s(e,d.semver))return!1}return!0}C.prerelease=hD;function hD(e,t){var r=Kr(e,t);return r&&r.prerelease.length?r.prerelease:null}C.intersects=_D;function _D(e,t,r){return e=new te(e,r),t=new te(t,r),e.intersects(t)}C.coerce=vD;function vD(e){if(e instanceof w)return e;if(typeof e!="string")return null;var t=e.match(F[Cm]);return t==null?null:Kr(t[1]+"."+(t[2]||"0")+"."+(t[3]||"0"))}});var Um=l((I1,Hm)=>{var gD=Ro().wrap,mp=1<<0,yp=1<<1,Tp=1<<2,zo=1<<3,V=[],ED=0,Oe=!1,ur=[],Zn,Sp;function Ap(e,t){var r=e.length,n=t.length,i=[];if(r===0&&n===0)return i;for(var a=0;a<r;a++)i[a]=e[a];if(n===0)return i;for(var s=0;s<n;s++){var o=!0;for(a=0;a<r;a++)if(e[a].uid===t[s].uid){o=!1;break}o&&i.push(t[s])}return i}process._fatalException?(Ko=!1,Zn=function(t){var r=V.length;if(Ko||r===0)return!1;var n=!1;Ko=!0;for(var i=0;i<r;++i){var a=V[i];if((a.flags&zo)!=0){var s=Jn&&Jn[a.uid];n=a.error(s,t)||n}}return Ko=!1,ur.length>0&&(V=ur.pop()),Jn=void 0,n&&!Oe},Sp=function(t,r,n){var i=[];Oe=!0;for(var a=0;a<n;++a){var s=r[a];if(i[s.uid]=s.data,(s.flags&mp)!=0){var o=s.create(s.data);o!==void 0&&(i[s.uid]=o)}}return Oe=!1,function(){Jn=i,ur.push(V),V=Ap(r,V),Oe=!0;for(var u=0;u<n;++u)(r[u].flags&yp)>0&&r[u].before(this,i[r[u].uid]);Oe=!1;var c=t.apply(this,arguments);for(Oe=!0,u=0;u<n;++u)(r[u].flags&Tp)>0&&r[u].after(this,i[r[u].uid]);return Oe=!1,V=ur.pop(),Jn=void 0,c}},gD(process,"_fatalException",function(e){return function(r){return Zn(r)||e(r)}})):(Ip=!1,Zn=function(t){if(Ip)throw t;for(var r=!1,n=V.length,i=0;i<n;++i){var a=V[i];(a.flags&zo)!=0&&(r=a.error(null,t)||r)}if(!r&&Oe)throw t},Sp=function(t,r,n){var i=[];Oe=!0;for(var a=0;a<n;++a){var s=r[a];if(i[s.uid]=s.data,(s.flags&mp)!=0){var o=s.create(s.data);o!==void 0&&(i[s.uid]=o)}}return Oe=!1,function(){var u=!1,c=!1;ur.push(V),V=Ap(r,V),Oe=!0;for(var p=0;p<n;++p)(r[p].flags&yp)>0&&r[p].before(this,i[r[p].uid]);Oe=!1;var f;try{f=t.apply(this,arguments)}catch(d){u=!0;for(var p=0;p<n;++p)if((V[p].flags&zo)!=0)try{c=V[p].error(i[r[p].uid],d)||c}catch(E){throw Ip=!0,E}if(!c)throw process.removeListener("uncaughtException",Zn),process._originalNextTick(function(){process.addListener("uncaughtException",Zn)}),d}finally{if(!u||c){for(Oe=!0,p=0;p<n;++p)(r[p].flags&Tp)>0&&r[p].after(this,i[r[p].uid]);Oe=!1}V=ur.pop()}return f}},process.addListener("uncaughtException",Zn));var Ko,Jn,Ip;function mD(e,t,r){Oe=!0;for(var n=0;n<r;++n){var i=t[n];i.create&&i.create(i.data)}return Oe=!1,function(){ur.push(V),V=Ap(t,V);var a=e.apply(this,arguments);return V=ur.pop(),a}}function yD(e){var t=V.length;if(t===0)return e;for(var r=V.slice(),n=0;n<t;++n)if(r[n].flags>0)return Sp(e,r,t);return mD(e,r,t)}function gt(e,t){typeof e.create=="function"&&(this.create=e.create,this.flags|=mp),typeof e.before=="function"&&(this.before=e.before,this.flags|=yp),typeof e.after=="function"&&(this.after=e.after,this.flags|=Tp),typeof e.error=="function"&&(this.error=e.error,this.flags|=zo),this.uid=++ED,this.data=t===void 0?null:t}gt.prototype.create=void 0;gt.prototype.before=void 0;gt.prototype.after=void 0;gt.prototype.error=void 0;gt.prototype.data=void 0;gt.prototype.uid=0;gt.prototype.flags=0;function km(e,t){if(typeof e!="object"||!e)throw new TypeError("callbacks argument must be an object");return e instanceof gt?e:new gt(e,t)}function TD(e,t){var r;e instanceof gt?r=e:r=km(e,t);for(var n=!1,i=0;i<V.length;i++)if(r===V[i]){n=!0;break}return n||V.push(r),r}function SD(e){for(var t=0;t<V.length;t++)if(e===V[t]){V.splice(t,1);break}}process.createAsyncListener=km;process.addAsyncListener=TD;process.removeAsyncListener=SD;Hm.exports=yD});var Gm=l((C1,Bm)=>{"use strict";Bm.exports=(e,t)=>class extends e{constructor(n){var i,a;super(o);var s=this;try{n.apply(i,a)}catch(u){a[1](u)}return s;function o(u,c){i=this,a=[p,f];function p(d){return t(s,!1),u(d)}function f(d){return t(s,!1),c(d)}}}}});var Ym=l(()=>{"use strict";if(process.addAsyncListener)throw new Error("Don't require polyfill unless needed");var Fm=Ro(),Xo=jm(),je=Fm.wrap,cr=Fm.massWrap,re=Um(),AD=__webpack_require__(1669),ID=Xo.gte(process.version,"6.0.0"),bp=Xo.gte(process.version,"7.0.0"),bD=Xo.gte(process.version,"8.0.0"),CD=Xo.gte(process.version,"11.0.0"),Et=__webpack_require__(1631);bp&&!Et._normalizeArgs?Et._normalizeArgs=function(e){if(e.length===0)return[{},null];var t=e[0],r={};typeof t=="object"&&t!==null?r=t:DD(t)?r.path=t:(r.port=t,e.length>1&&typeof e[1]=="string"&&(r.host=e[1]));var n=e[e.length-1];return typeof n!="function"?[r,null]:[r,n]}:!bp&&!Et._normalizeConnectArgs&&(Et._normalizeConnectArgs=function(e){var t={};function r(i){return(i=Number(i))>=0?i:!1}typeof e[0]=="object"&&e[0]!==null?t=e[0]:typeof e[0]=="string"&&r(e[0])===!1?t.path=e[0]:(t.port=e[0],typeof e[1]=="string"&&(t.host=e[1]));var n=e[e.length-1];return typeof n=="function"?[t,n]:[t]});"_setUpListenHandle"in Et.Server.prototype?je(Et.Server.prototype,"_setUpListenHandle",Vm):je(Et.Server.prototype,"_listen2",Vm);function Vm(e){return function(){this.on("connection",function(t){t._handle&&(t._handle.onread=re(t._handle.onread))});try{return e.apply(this,arguments)}finally{this._handle&&this._handle.onconnection&&(this._handle.onconnection=re(this._handle.onconnection))}}}function $m(e){if(e&&e._handle){var t=e._handle;t._originalOnread||(t._originalOnread=t.onread),t.onread=re(t._originalOnread)}}je(Et.Socket.prototype,"connect",function(e){return function(){var t;bD&&Array.isArray(arguments[0])&&Object.getOwnPropertySymbols(arguments[0]).length>0?t=arguments[0]:t=bp?Et._normalizeArgs(arguments):Et._normalizeConnectArgs(arguments),t[1]&&(t[1]=re(t[1]));var r=e.apply(this,t);return $m(this),r}});var OD=__webpack_require__(8605);je(OD.Agent.prototype,"addRequest",function(e){return function(t){var r=t.onSocket;return t.onSocket=re(function(n){return $m(n),r.apply(this,arguments)}),e.apply(this,arguments)}});var Cp=__webpack_require__(3129);function zm(e){Array.isArray(e.stdio)&&e.stdio.forEach(function(t){t&&t._handle&&(t._handle.onread=re(t._handle.onread),je(t._handle,"close",Qo))}),e._handle&&(e._handle.onexit=re(e._handle.onexit))}Cp.ChildProcess?je(Cp.ChildProcess.prototype,"spawn",function(e){return function(){var t=e.apply(this,arguments);return zm(this),t}}):cr(Cp,["execFile","fork","spawn"],function(e){return function(){var t=e.apply(this,arguments);return zm(t),t}});process._fatalException||(process._originalNextTick=process.nextTick);var Op=[];process._nextDomainTick&&Op.push("_nextDomainTick");process._tickDomainCallback&&Op.push("_tickDomainCallback");cr(process,Op,mt);je(process,"nextTick",Qo);var Pp=["setTimeout","setInterval"];global.setImmediate&&Pp.push("setImmediate");var Km=__webpack_require__(8213),PD=global.setTimeout===Km.setTimeout;cr(Km,Pp,Qo);PD&&cr(global,Pp,Qo);var Rp=__webpack_require__(881);cr(Rp,["lookup","resolve","resolve4","resolve6","resolveCname","resolveMx","resolveNs","resolveTxt","resolveSrv","reverse"],mt);Rp.resolveNaptr&&je(Rp,"resolveNaptr",mt);var Xr=__webpack_require__(5747);cr(Xr,["watch","rename","truncate","chown","fchown","chmod","fchmod","stat","lstat","fstat","link","symlink","readlink","realpath","unlink","rmdir","mkdir","readdir","close","open","utimes","futimes","fsync","write","read","readFile","writeFile","appendFile","watchFile","unwatchFile","exists"],mt);Xr.lchown&&je(Xr,"lchown",mt);Xr.lchmod&&je(Xr,"lchmod",mt);Xr.ftruncate&&je(Xr,"ftruncate",mt);var Ea;try{Ea=__webpack_require__(8761)}catch(e){}Ea&&Ea.Deflate&&Ea.Deflate.prototype&&(Yr=Object.getPrototypeOf(Ea.Deflate.prototype),Yr._transform?je(Yr,"_transform",mt):Yr.write&&Yr.flush&&Yr.end&&cr(Yr,["write","flush","end"],mt));var Yr,Np;try{Np=__webpack_require__(6417)}catch(e){}Np&&(Dp=["pbkdf2","randomBytes"],CD||Dp.push("pseudoRandomBytes"),cr(Np,Dp,mt));var Dp,Yo=!!global.Promise&&Promise.toString()==="function Promise() { [native code] }"&&Promise.toString.toString()==="function toString() { [native code] }";Yo&&(Xm=process.addAsyncListener({create:function(){Yo=!1}}),global.Promise.resolve(!0).then(function(){Yo=!1}),process.removeAsyncListener(Xm));var Xm;Yo&&RD();function RD(){var e=global.Promise;function t(s){if(!(this instanceof t))return e(s);if(typeof s!="function")return new e(s);var o,u,c=new e(p);c.__proto__=t.prototype;try{s.apply(o,u)}catch(f){u[1](f)}return c;function p(f,d){o=this,u=[h,E];function h(S){return n(c,!1),f(S)}function E(S){return n(c,!1),d(S)}}}if(AD.inherits(t,e),je(e.prototype,"then",a),e.prototype.chain&&je(e.prototype,"chain",a),ID)global.Promise=Gm()(e,n);else{var r=["all","race","reject","resolve","accept","defer"];r.forEach(function(s){typeof e[s]=="function"&&(t[s]=e[s])}),global.Promise=t}function n(s,o){(!s.__asl_wrapper||o)&&(s.__asl_wrapper=re(i))}function i(s,o,u,c){var p;try{return p=o.call(s,u),{returnVal:p,error:!1}}catch(f){return{errorVal:f,error:!0}}finally{p instanceof e?c.__asl_wrapper=function(){var d=p.__asl_wrapper||i;return d.apply(this,arguments)}:n(c,!0)}}function a(s){return function(){var u=this,c=s.apply(u,Array.prototype.map.call(arguments,p));return c.__asl_wrapper=function(d,h,E,S){return u.__asl_wrapper?(u.__asl_wrapper(d,function(){},null,c),c.__asl_wrapper(d,h,E,S)):i(d,h,E,S)},c;function p(f){return typeof f!="function"?f:re(function(d){var h=(u.__asl_wrapper||i)(this,f,d,c);if(h.error)throw h.errorVal;return h.returnVal})}}}}function mt(e){var t=function(){var r,n=arguments.length-1;if(typeof arguments[n]=="function"){r=Array(arguments.length);for(var i=0;i<arguments.length-1;i++)r[i]=arguments[i];r[n]=re(arguments[n])}return e.apply(this,r||arguments)};switch(e.length){case 1:return function(r){return arguments.length!==1?t.apply(this,arguments):(typeof r=="function"&&(r=re(r)),e.call(this,r))};case 2:return function(r,n){return arguments.length!==2?t.apply(this,arguments):(typeof n=="function"&&(n=re(n)),e.call(this,r,n))};case 3:return function(r,n,i){return arguments.length!==3?t.apply(this,arguments):(typeof i=="function"&&(i=re(i)),e.call(this,r,n,i))};case 4:return function(r,n,i,a){return arguments.length!==4?t.apply(this,arguments):(typeof a=="function"&&(a=re(a)),e.call(this,r,n,i,a))};case 5:return function(r,n,i,a,s){return arguments.length!==5?t.apply(this,arguments):(typeof s=="function"&&(s=re(s)),e.call(this,r,n,i,a,s))};case 6:return function(r,n,i,a,s,o){return arguments.length!==6?t.apply(this,arguments):(typeof o=="function"&&(o=re(o)),e.call(this,r,n,i,a,s,o))};default:return t}}function Qo(e){var t=function(){var r;if(typeof arguments[0]=="function"){r=Array(arguments.length),r[0]=re(arguments[0]);for(var n=1;n<arguments.length;n++)r[n]=arguments[n]}return e.apply(this,r||arguments)};switch(e.length){case 1:return function(r){return arguments.length!==1?t.apply(this,arguments):(typeof r=="function"&&(r=re(r)),e.call(this,r))};case 2:return function(r,n){return arguments.length!==2?t.apply(this,arguments):(typeof r=="function"&&(r=re(r)),e.call(this,r,n))};case 3:return function(r,n,i){return arguments.length!==3?t.apply(this,arguments):(typeof r=="function"&&(r=re(r)),e.call(this,r,n,i))};case 4:return function(r,n,i,a){return arguments.length!==4?t.apply(this,arguments):(typeof r=="function"&&(r=re(r)),e.call(this,r,n,i,a))};case 5:return function(r,n,i,a,s){return arguments.length!==5?t.apply(this,arguments):(typeof r=="function"&&(r=re(r)),e.call(this,r,n,i,a,s))};case 6:return function(r,n,i,a,s,o){return arguments.length!==6?t.apply(this,arguments):(typeof r=="function"&&(r=re(r)),e.call(this,r,n,i,a,s,o))};default:return t}}function ND(e){return(e=Number(e))>=0?e:!1}function DD(e){return typeof e=="string"&&ND(e)===!1}});var ey=l((R1,Jm)=>{"use strict";var jt=__webpack_require__(2357),wD=wo(),ma="cls@contexts",wp="error@context";process.addAsyncListener||Ym();function ot(e){this.name=e,this.active=null,this._set=[],this.id=null}ot.prototype.set=function(e,t){if(!this.active)throw new Error("No context available. ns.run() or ns.bind() must be called first.");return this.active[e]=t,t};ot.prototype.get=function(e){if(!!this.active)return this.active[e]};ot.prototype.createContext=function(){return Object.create(this.active)};ot.prototype.run=function(e){var t=this.createContext();this.enter(t);try{return e(t),t}catch(r){throw r&&(r[wp]=t),r}finally{this.exit(t)}};ot.prototype.runAndReturn=function(e){var t;return this.run(function(r){t=e(r)}),t};ot.prototype.bind=function(e,t){t||(this.active?t=this.active:t=this.createContext());var r=this;return function(){r.enter(t);try{return e.apply(this,arguments)}catch(n){throw n&&(n[wp]=t),n}finally{r.exit(t)}}};ot.prototype.enter=function(e){jt.ok(e,"context must be provided for entering"),this._set.push(this.active),this.active=e};ot.prototype.exit=function(e){if(jt.ok(e,"context must be provided for exiting"),this.active===e){jt.ok(this._set.length,"can't remove top context"),this.active=this._set.pop();return}var t=this._set.lastIndexOf(e);jt.ok(t>=0,"context not currently entered; can't exit"),jt.ok(t,"can't remove top context"),this._set.splice(t,1)};ot.prototype.bindEmitter=function(e){jt.ok(e.on&&e.addListener&&e.emit,"can only bind real EEs");var t=this,r="context@"+this.name;function n(a){!a||(a[ma]||(a[ma]=Object.create(null)),a[ma][r]={namespace:t,context:t.active})}function i(a){if(!(a&&a[ma]))return a;var s=a,o=a[ma];return Object.keys(o).forEach(function(u){var c=o[u];s=c.namespace.bind(s,c.context)}),s}wD(e,n,i)};ot.prototype.fromException=function(e){return e[wp]};function Qm(e){return process.namespaces[e]}function xD(e){jt.ok(e,"namespace must be given a name!");var t=new ot(e);return t.id=process.addAsyncListener({create:function(){return t.active},before:function(r,n){n&&t.enter(n)},after:function(r,n){n&&t.exit(n)},error:function(r){r&&t.exit(r)}}),process.namespaces[e]=t,t}function Wm(e){var t=Qm(e);jt.ok(t,"can't delete nonexistent namespace!"),jt.ok(t.id,"don't assign to process.namespaces directly!"),process.removeAsyncListener(t.id),process.namespaces[e]=null}function Zm(){process.namespaces&&Object.keys(process.namespaces).forEach(function(e){Wm(e)}),process.namespaces=Object.create(null)}process.namespaces||Zm();Jm.exports={getNamespace:Qm,createNamespace:xD,destroyNamespace:Wm,reset:Zm}});var gr=l(Wo=>{"use strict";Object.defineProperty(Wo,"__esModule",{value:!0});Wo.CorrelationContextManager=void 0;var ty=ve(),MD=ho(),ei=Zi(),xp=al(),ry=Il(),LD=function(){function e(){}return e.getCurrentContext=function(){if(!e.enabled)return null;var t=e.session.get(e.CONTEXT_NAME);return t===void 0?null:t},e.generateContextObject=function(t,r,n,i,a,s){return r=r||t,this.enabled?{operation:{name:n,id:t,parentId:r,traceparent:a,tracestate:s},customProperties:new qD(i)}:null},e.spanToContextObject=function(t,r,n){var i=new ei;return i.traceId=t.traceId,i.spanId=t.spanId,i.traceFlag=ei.formatOpenTelemetryTraceFlags(t.traceFlags)||ei.DEFAULT_TRACE_FLAG,i.parentId=r,e.generateContextObject(i.traceId,i.parentId,n,null,i)},e.runWithContext=function(t,r){var n;return e.enabled?e.session.bind(r,(n={},n[e.CONTEXT_NAME]=t,n))():r()},e.wrapEmitter=function(t){e.enabled&&e.session.bindEmitter(t)},e.wrapCallback=function(t,r){var n;return e.enabled?e.session.bind(t,r?(n={},n[e.CONTEXT_NAME]=r,n):void 0):t},e.enable=function(t){if(!this.enabled){if(!this.isNodeVersionCompatible()){this.enabled=!1;return}e.hasEverEnabled||(this.forceClsHooked=t,this.hasEverEnabled=!0,typeof this.cls=="undefined"&&(e.forceClsHooked===!0||e.forceClsHooked===void 0&&e.shouldUseClsHooked()?this.cls=ym():this.cls=ey()),e.session=this.cls.createNamespace("AI-CLS-Session"),MD.registerContextPreservation(function(r){return e.session.bind(r)})),this.enabled=!0}},e.startOperation=function(t,r){var n=t&&t.traceContext||null,i=t&&t.traceId?t:null,a=t&&t.headers;if(i){var s=new ei("00-"+i.traceId+"-"+i.spanId+"-01"),o=new xp(i.traceState?i.traceState.serialize():null),u=e.generateContextObject(i.traceId,"|"+i.traceId+"."+i.spanId+".",typeof r=="string"?r:"",void 0,s,o);return u}if(n){var s=new ei(n.traceparent),o=new xp(n.tracestate),c=typeof r=="object"?new ry(r):null,u=e.generateContextObject(s.traceId,s.parentId,typeof r=="string"?r:c.getOperationName({}),c&&c.getCorrelationContextHeader()||void 0,s,o);return u}if(a){var s=new ei(a.traceparent?a.traceparent.toString():null),o=new xp(a.tracestate?a.tracestate.toString():null),c=new ry(t),u=e.generateContextObject(s.traceId,s.parentId,c.getOperationName({}),c.getCorrelationContextHeader(),s,o);return u}return ty.warn("startOperation was called with invalid arguments",arguments),null},e.disable=function(){this.enabled=!1},e.reset=function(){e.hasEverEnabled&&(e.session=null,e.session=this.cls.createNamespace("AI-CLS-Session"))},e.isNodeVersionCompatible=function(){var t=process.versions.node.split(".");return parseInt(t[0])>3||parseInt(t[0])>2&&parseInt(t[1])>2},e.shouldUseClsHooked=function(){var t=process.versions.node.split(".");return parseInt(t[0])>8||parseInt(t[0])>=8&&parseInt(t[1])>=2},e.canUseClsHooked=function(){var t=process.versions.node.split("."),r=parseInt(t[0])>8||parseInt(t[0])>=8&&parseInt(t[1])>=0,n=parseInt(t[0])<8||parseInt(t[0])<=8&&parseInt(t[1])<2,i=parseInt(t[0])>4||parseInt(t[0])>=4&&parseInt(t[1])>=7;return!(r&&n)&&i},e.enabled=!1,e.hasEverEnabled=!1,e.forceClsHooked=void 0,e.CONTEXT_NAME="ApplicationInsights-Context",e}();Wo.CorrelationContextManager=LD;var qD=function(){function e(t){this.props=[],this.addHeaderData(t)}return e.prototype.addHeaderData=function(t){var r=t?t.split(", "):[];this.props=r.map(function(n){var i=n.split("=");return{key:i[0],value:i[1]}}).concat(this.props)},e.prototype.serializeToHeader=function(){return this.props.map(function(t){return t.key+"="+t.value}).join(", ")},e.prototype.getProperty=function(t){for(var r=0;r<this.props.length;++r){var n=this.props[r];if(n.key===t)return n.value}},e.prototype.setProperty=function(t,r){if(e.bannedCharacters.test(t)||e.bannedCharacters.test(r)){ty.warn("Correlation context property keys and values must not contain ',' or '='. setProperty was called with key: "+t+" and value: "+r);return}for(var n=0;n<this.props.length;++n){var i=this.props[n];if(i.key===t){i.value=r;return}}this.props.push({key:t,value:r})},e.bannedCharacters=/[,=]/,e}()});var iy=l(ti=>{"use strict";Object.defineProperty(ti,"__esModule",{value:!0});ti.dispose=ti.enable=void 0;var ny=De(),Mp=ue(),Qr=[],Lp=function(e){var t=e.data.message;Qr.forEach(function(r){t instanceof Error?r.trackException({exception:t}):(t.lastIndexOf(`
`)==t.length-1&&(t=t.substring(0,t.length-1)),r.trackTrace({message:t,severity:e.data.stderr?ny.SeverityLevel.Warning:ny.SeverityLevel.Information}))})};function jD(e,t){e?(Qr.length===0&&Mp.channel.subscribe("console",Lp),Qr.push(t)):(Qr=Qr.filter(function(r){return r!=t}),Qr.length===0&&Mp.channel.unsubscribe("console",Lp))}ti.enable=jD;function kD(){Mp.channel.unsubscribe("console",Lp),Qr=[]}ti.dispose=kD});var ay=l(ni=>{"use strict";Object.defineProperty(ni,"__esModule",{value:!0});ni.dispose=ni.enable=void 0;var ri=De(),qp=ue(),Wr=[],HD={10:ri.SeverityLevel.Verbose,20:ri.SeverityLevel.Verbose,30:ri.SeverityLevel.Information,40:ri.SeverityLevel.Warning,50:ri.SeverityLevel.Error,60:ri.SeverityLevel.Critical},jp=function(e){var t=e.data.result;Wr.forEach(function(r){var n=HD[e.data.level];t instanceof Error?r.trackException({exception:t}):r.trackTrace({message:t,severity:n})})};function UD(e,t){e?(Wr.length===0&&qp.channel.subscribe("bunyan",jp),Wr.push(t)):(Wr=Wr.filter(function(r){return r!=t}),Wr.length===0&&qp.channel.unsubscribe("bunyan",jp))}ni.enable=UD;function BD(){qp.channel.unsubscribe("bunyan",jp),Wr=[]}ni.dispose=BD});var sy=l(ii=>{"use strict";Object.defineProperty(ii,"__esModule",{value:!0});ii.dispose=ii.enable=void 0;var Se=De(),kp=ue(),Zr=[],GD={syslog:function(e){var t={emerg:Se.SeverityLevel.Critical,alert:Se.SeverityLevel.Critical,crit:Se.SeverityLevel.Critical,error:Se.SeverityLevel.Error,warning:Se.SeverityLevel.Warning,notice:Se.SeverityLevel.Information,info:Se.SeverityLevel.Information,debug:Se.SeverityLevel.Verbose};return t[e]===void 0?Se.SeverityLevel.Information:t[e]},npm:function(e){var t={error:Se.SeverityLevel.Error,warn:Se.SeverityLevel.Warning,info:Se.SeverityLevel.Information,verbose:Se.SeverityLevel.Verbose,debug:Se.SeverityLevel.Verbose,silly:Se.SeverityLevel.Verbose};return t[e]===void 0?Se.SeverityLevel.Information:t[e]},unknown:function(e){return Se.SeverityLevel.Information}},Hp=function(e){var t=e.data.message;Zr.forEach(function(r){if(t instanceof Error)r.trackException({exception:t,properties:e.data.meta});else{var n=GD[e.data.levelKind](e.data.level);r.trackTrace({message:t,severity:n,properties:e.data.meta})}})};function FD(e,t){e?(Zr.length===0&&kp.channel.subscribe("winston",Hp),Zr.push(t)):(Zr=Zr.filter(function(r){return r!=t}),Zr.length===0&&kp.channel.unsubscribe("winston",Hp))}ii.enable=FD;function VD(){kp.channel.unsubscribe("winston",Hp),Zr=[]}ii.dispose=VD});var uy=l((M1,oy)=>{"use strict";var $D=ho(),zD=function(){function e(t){if(e.INSTANCE)throw new Error("Console logging adapter tracking should be configured from the applicationInsights object");this._client=t,e.INSTANCE=this}return e.prototype.enable=function(t,r){$D.IsInitialized&&(iy().enable(t&&r,this._client),ay().enable(t,this._client),sy().enable(t,this._client))},e.prototype.isInitialized=function(){return this._isInitialized},e.prototype.dispose=function(){e.INSTANCE=null,this.enable(!1,!1)},e._methodNames=["debug","info","log","warn","error"],e}();oy.exports=zD});var ly=l((L1,cy)=>{"use strict";var KD=function(){function e(t){if(e.INSTANCE)throw new Error("Exception tracking should be configured from the applicationInsights object");e.INSTANCE=this,this._client=t;var r=process.versions.node.split(".");e._canUseUncaughtExceptionMonitor=parseInt(r[0])>13||parseInt(r[0])===13&&parseInt(r[1])>=7}return e.prototype.isInitialized=function(){return this._isInitialized},e.prototype.enable=function(t){var r=this;if(t){this._isInitialized=!0;var n=this;if(!this._exceptionListenerHandle){var i=function(a,s,o){o===void 0&&(o=new Error(e._FALLBACK_ERROR_MESSAGE)),r._client.trackException({exception:o}),r._client.flush({isAppCrashing:!0}),a&&s&&process.listeners(s).length===1&&(console.error(o),process.exit(1))};e._canUseUncaughtExceptionMonitor?(this._exceptionListenerHandle=i.bind(this,!1,void 0),process.on(e.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME,this._exceptionListenerHandle)):(this._exceptionListenerHandle=i.bind(this,!0,e.UNCAUGHT_EXCEPTION_HANDLER_NAME),this._rejectionListenerHandle=i.bind(this,!1,void 0),process.on(e.UNCAUGHT_EXCEPTION_HANDLER_NAME,this._exceptionListenerHandle),process.on(e.UNHANDLED_REJECTION_HANDLER_NAME,this._rejectionListenerHandle))}}else this._exceptionListenerHandle&&(e._canUseUncaughtExceptionMonitor?process.removeListener(e.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME,this._exceptionListenerHandle):(process.removeListener(e.UNCAUGHT_EXCEPTION_HANDLER_NAME,this._exceptionListenerHandle),process.removeListener(e.UNHANDLED_REJECTION_HANDLER_NAME,this._rejectionListenerHandle)),this._exceptionListenerHandle=void 0,this._rejectionListenerHandle=void 0,delete this._exceptionListenerHandle,delete this._rejectionListenerHandle)},e.prototype.dispose=function(){e.INSTANCE=null,this.enable(!1),this._isInitialized=!1},e.INSTANCE=null,e.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME="uncaughtExceptionMonitor",e.UNCAUGHT_EXCEPTION_HANDLER_NAME="uncaughtException",e.UNHANDLED_REJECTION_HANDLER_NAME="unhandledRejection",e._RETHROW_EXIT_MESSAGE="Application Insights Rethrow Exception Handler",e._FALLBACK_ERROR_MESSAGE="A promise was rejected without providing an error. Application Insights generated this error stack for you.",e._canUseUncaughtExceptionMonitor=!1,e}();cy.exports=KD});var kt=l(T=>{"use strict";var ut;Object.defineProperty(T,"__esModule",{value:!0});T.HeartBeatMetricName=T.DependencyTypeName=T.SpanAttribute=T.TelemetryTypeStringToQuickPulseDocumentType=T.TelemetryTypeStringToQuickPulseType=T.QuickPulseType=T.QuickPulseDocumentType=T.PerformanceToQuickPulseCounter=T.MetricId=T.PerformanceCounter=T.QuickPulseCounter=T.DEFAULT_LIVEMETRICS_HOST=T.DEFAULT_LIVEMETRICS_ENDPOINT=T.DEFAULT_BREEZE_ENDPOINT=void 0;T.DEFAULT_BREEZE_ENDPOINT="https://dc.services.visualstudio.com";T.DEFAULT_LIVEMETRICS_ENDPOINT="https://rt.services.visualstudio.com";T.DEFAULT_LIVEMETRICS_HOST="rt.services.visualstudio.com";var Pe;(function(e){e.COMMITTED_BYTES="\\Memory\\Committed Bytes",e.PROCESSOR_TIME="\\Processor(_Total)\\% Processor Time",e.REQUEST_RATE="\\ApplicationInsights\\Requests/Sec",e.REQUEST_FAILURE_RATE="\\ApplicationInsights\\Requests Failed/Sec",e.REQUEST_DURATION="\\ApplicationInsights\\Request Duration",e.DEPENDENCY_RATE="\\ApplicationInsights\\Dependency Calls/Sec",e.DEPENDENCY_FAILURE_RATE="\\ApplicationInsights\\Dependency Calls Failed/Sec",e.DEPENDENCY_DURATION="\\ApplicationInsights\\Dependency Call Duration",e.EXCEPTION_RATE="\\ApplicationInsights\\Exceptions/Sec"})(Pe=T.QuickPulseCounter||(T.QuickPulseCounter={}));var Zo;(function(e){e.PRIVATE_BYTES="\\Process(??APP_WIN32_PROC??)\\Private Bytes",e.AVAILABLE_BYTES="\\Memory\\Available Bytes",e.PROCESSOR_TIME="\\Processor(_Total)\\% Processor Time",e.PROCESS_TIME="\\Process(??APP_WIN32_PROC??)\\% Processor Time",e.REQUEST_RATE="\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Requests/Sec",e.REQUEST_DURATION="\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Request Execution Time"})(Zo=T.PerformanceCounter||(T.PerformanceCounter={}));var XD;(function(e){e.REQUESTS_DURATION="requests/duration",e.DEPENDENCIES_DURATION="dependencies/duration",e.EXCEPTIONS_COUNT="exceptions/count",e.TRACES_COUNT="traces/count"})(XD=T.MetricId||(T.MetricId={}));T.PerformanceToQuickPulseCounter=(ut={},ut[Zo.PROCESSOR_TIME]=Pe.PROCESSOR_TIME,ut[Zo.REQUEST_RATE]=Pe.REQUEST_RATE,ut[Zo.REQUEST_DURATION]=Pe.REQUEST_DURATION,ut[Pe.COMMITTED_BYTES]=Pe.COMMITTED_BYTES,ut[Pe.REQUEST_FAILURE_RATE]=Pe.REQUEST_FAILURE_RATE,ut[Pe.DEPENDENCY_RATE]=Pe.DEPENDENCY_RATE,ut[Pe.DEPENDENCY_FAILURE_RATE]=Pe.DEPENDENCY_FAILURE_RATE,ut[Pe.DEPENDENCY_DURATION]=Pe.DEPENDENCY_DURATION,ut[Pe.EXCEPTION_RATE]=Pe.EXCEPTION_RATE,ut);T.QuickPulseDocumentType={Event:"Event",Exception:"Exception",Trace:"Trace",Metric:"Metric",Request:"Request",Dependency:"RemoteDependency",Availability:"Availability",PageView:"PageView"};T.QuickPulseType={Event:"EventTelemetryDocument",Exception:"ExceptionTelemetryDocument",Trace:"TraceTelemetryDocument",Metric:"MetricTelemetryDocument",Request:"RequestTelemetryDocument",Dependency:"DependencyTelemetryDocument",Availability:"AvailabilityTelemetryDocument",PageView:"PageViewTelemetryDocument"};T.TelemetryTypeStringToQuickPulseType={EventData:T.QuickPulseType.Event,ExceptionData:T.QuickPulseType.Exception,MessageData:T.QuickPulseType.Trace,MetricData:T.QuickPulseType.Metric,RequestData:T.QuickPulseType.Request,RemoteDependencyData:T.QuickPulseType.Dependency,AvailabilityData:T.QuickPulseType.Availability,PageViewData:T.QuickPulseType.PageView};T.TelemetryTypeStringToQuickPulseDocumentType={EventData:T.QuickPulseDocumentType.Event,ExceptionData:T.QuickPulseDocumentType.Exception,MessageData:T.QuickPulseDocumentType.Trace,MetricData:T.QuickPulseDocumentType.Metric,RequestData:T.QuickPulseDocumentType.Request,RemoteDependencyData:T.QuickPulseDocumentType.Dependency,AvailabilityData:T.QuickPulseDocumentType.Availability,PageViewData:T.QuickPulseDocumentType.PageView};T.SpanAttribute={HttpHost:"http.host",HttpMethod:"http.method",HttpPort:"http.port",HttpStatusCode:"http.status_code",HttpUrl:"http.url",HttpUserAgent:"http.user_agent",GrpcMethod:"grpc.method",GrpcService:"rpc.service"};T.DependencyTypeName={Grpc:"GRPC",Http:"HTTP",InProc:"InProc"};T.HeartBeatMetricName="HeartBeat"});var eu=l((j1,py)=>{"use strict";var Jo=__webpack_require__(2087),Je=kt(),YD=function(){function e(t,r,n){r===void 0&&(r=6e4),n===void 0&&(n=!1),this._lastIntervalRequestExecutionTime=0,this._lastIntervalDependencyExecutionTime=0,e.INSTANCE||(e.INSTANCE=this),this._isInitialized=!1,this._client=t,this._collectionInterval=r,this._enableLiveMetricsCounters=n}return e.prototype.enable=function(t,r){var n=this;this._isEnabled=t,this._isEnabled&&!this._isInitialized&&(this._isInitialized=!0),t?this._handle||(this._lastCpus=Jo.cpus(),this._lastRequests={totalRequestCount:e._totalRequestCount,totalFailedRequestCount:e._totalFailedRequestCount,time:+new Date},this._lastDependencies={totalDependencyCount:e._totalDependencyCount,totalFailedDependencyCount:e._totalFailedDependencyCount,time:+new Date},this._lastExceptions={totalExceptionCount:e._totalExceptionCount,time:+new Date},typeof process.cpuUsage=="function"&&(this._lastAppCpuUsage=process.cpuUsage()),this._lastHrtime=process.hrtime(),this._collectionInterval=r||this._collectionInterval,this._handle=setInterval(function(){return n.trackPerformance()},this._collectionInterval),this._handle.unref()):this._handle&&(clearInterval(this._handle),this._handle=void 0)},e.countRequest=function(t,r){var n;if(!!e.isEnabled()){if(typeof t=="string")n=+new Date("1970-01-01T"+t+"Z");else if(typeof t=="number")n=t;else return;e._intervalRequestExecutionTime+=n,r===!1&&e._totalFailedRequestCount++,e._totalRequestCount++}},e.countException=function(){e._totalExceptionCount++},e.countDependency=function(t,r){var n;if(!!e.isEnabled()){if(typeof t=="string")n=+new Date("1970-01-01T"+t+"Z");else if(typeof t=="number")n=t;else return;e._intervalDependencyExecutionTime+=n,r===!1&&e._totalFailedDependencyCount++,e._totalDependencyCount++}},e.prototype.isInitialized=function(){return this._isInitialized},e.isEnabled=function(){return e.INSTANCE&&e.INSTANCE._isEnabled},e.prototype.trackPerformance=function(){this._trackCpu(),this._trackMemory(),this._trackNetwork(),this._trackDependencyRate(),this._trackExceptionRate()},e.prototype._trackCpu=function(){var t=Jo.cpus();if(t&&t.length&&this._lastCpus&&t.length===this._lastCpus.length){for(var r=0,n=0,i=0,a=0,s=0,o=0;!!t&&o<t.length;o++){var u=t[o],c=this._lastCpus[o],p="% cpu("+o+") ",f=u.model,d=u.speed,h=u.times,E=c.times,S=h.user-E.user||0;r+=S;var j=h.sys-E.sys||0;n+=j;var oe=h.nice-E.nice||0;i+=oe;var Ae=h.idle-E.idle||0;a+=Ae;var At=h.irq-E.irq||0;s+=At}var tn=void 0;if(typeof process.cpuUsage=="function"){var Ti=process.cpuUsage(),rn=process.hrtime(),aS=Ti.user-this._lastAppCpuUsage.user+(Ti.system-this._lastAppCpuUsage.system)||0;if(typeof this._lastHrtime!="undefined"&&this._lastHrtime.length===2){var sS=(rn[0]-this._lastHrtime[0])*1e6+(rn[1]-this._lastHrtime[1])/1e3||0;tn=100*aS/(sS*t.length)}this._lastAppCpuUsage=Ti,this._lastHrtime=rn}var _u=r+n+i+a+s||1;this._client.trackMetric({name:Je.PerformanceCounter.PROCESSOR_TIME,value:(_u-a)/_u*100}),this._client.trackMetric({name:Je.PerformanceCounter.PROCESS_TIME,value:tn||r/_u*100})}this._lastCpus=t},e.prototype._trackMemory=function(){var t=Jo.freemem(),r=process.memoryUsage().rss,n=Jo.totalmem()-t;this._client.trackMetric({name:Je.PerformanceCounter.PRIVATE_BYTES,value:r}),this._client.trackMetric({name:Je.PerformanceCounter.AVAILABLE_BYTES,value:t}),this._enableLiveMetricsCounters&&this._client.trackMetric({name:Je.QuickPulseCounter.COMMITTED_BYTES,value:n})},e.prototype._trackNetwork=function(){var t=this._lastRequests,r={totalRequestCount:e._totalRequestCount,totalFailedRequestCount:e._totalFailedRequestCount,time:+new Date},n=r.totalRequestCount-t.totalRequestCount||0,i=r.totalFailedRequestCount-t.totalFailedRequestCount||0,a=r.time-t.time,s=a/1e3,o=(e._intervalRequestExecutionTime-this._lastIntervalRequestExecutionTime)/n||0;if(this._lastIntervalRequestExecutionTime=e._intervalRequestExecutionTime,a>0){var u=n/s,c=i/s;this._client.trackMetric({name:Je.PerformanceCounter.REQUEST_RATE,value:u}),(!this._enableLiveMetricsCounters||n>0)&&this._client.trackMetric({name:Je.PerformanceCounter.REQUEST_DURATION,value:o}),this._enableLiveMetricsCounters&&this._client.trackMetric({name:Je.QuickPulseCounter.REQUEST_FAILURE_RATE,value:c})}this._lastRequests=r},e.prototype._trackDependencyRate=function(){if(this._enableLiveMetricsCounters){var t=this._lastDependencies,r={totalDependencyCount:e._totalDependencyCount,totalFailedDependencyCount:e._totalFailedDependencyCount,time:+new Date},n=r.totalDependencyCount-t.totalDependencyCount||0,i=r.totalFailedDependencyCount-t.totalFailedDependencyCount||0,a=r.time-t.time,s=a/1e3,o=(e._intervalDependencyExecutionTime-this._lastIntervalDependencyExecutionTime)/n||0;if(this._lastIntervalDependencyExecutionTime=e._intervalDependencyExecutionTime,a>0){var u=n/s,c=i/s;this._client.trackMetric({name:Je.QuickPulseCounter.DEPENDENCY_RATE,value:u}),this._client.trackMetric({name:Je.QuickPulseCounter.DEPENDENCY_FAILURE_RATE,value:c}),(!this._enableLiveMetricsCounters||n>0)&&this._client.trackMetric({name:Je.QuickPulseCounter.DEPENDENCY_DURATION,value:o})}this._lastDependencies=r}},e.prototype._trackExceptionRate=function(){if(this._enableLiveMetricsCounters){var t=this._lastExceptions,r={totalExceptionCount:e._totalExceptionCount,time:+new Date},n=r.totalExceptionCount-t.totalExceptionCount||0,i=r.time-t.time,a=i/1e3;if(i>0){var s=n/a;this._client.trackMetric({name:Je.QuickPulseCounter.EXCEPTION_RATE,value:s})}this._lastExceptions=r}},e.prototype.dispose=function(){e.INSTANCE=null,this.enable(!1),this._isInitialized=!1},e._totalRequestCount=0,e._totalFailedRequestCount=0,e._totalDependencyCount=0,e._totalFailedDependencyCount=0,e._totalExceptionCount=0,e._intervalDependencyExecutionTime=0,e._intervalRequestExecutionTime=0,e}();py.exports=YD});var fy=l(tu=>{"use strict";Object.defineProperty(tu,"__esModule",{value:!0});tu.AggregatedMetricCounter=void 0;var QD=function(){function e(t){this.dimensions=t,this.totalCount=0,this.lastTotalCount=0,this.intervalExecutionTime=0,this.lastTime=+new Date,this.lastIntervalExecutionTime=0}return e}();tu.AggregatedMetricCounter=QD});var dy=l(ru=>{"use strict";Object.defineProperty(ru,"__esModule",{value:!0});ru.PreaggregatedMetricPropertyNames=void 0;ru.PreaggregatedMetricPropertyNames={cloudRoleInstance:"cloud/roleInstance",cloudRoleName:"cloud/roleName",operationSynthetic:"operation/synthetic",requestSuccess:"Request.Success",requestResultCode:"request/resultCode",dependencyType:"Dependency.Type",dependencyTarget:"dependency/target",dependencySuccess:"Dependency.Success",dependencyResultCode:"dependency/resultCode",traceSeverityLevel:"trace/severityLevel"}});var Bp=l((Up,hy)=>{"use strict";var nu=Up&&Up.__assign||function(){return nu=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++){t=arguments[r];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},nu.apply(this,arguments)},iu=kt(),WD=fy(),ZD=dy(),JD=function(){function e(t,r){r===void 0&&(r=6e4),e.INSTANCE||(e.INSTANCE=this),this._isInitialized=!1,e._dependencyCountersCollection=[],e._requestCountersCollection=[],e._exceptionCountersCollection=[],e._traceCountersCollection=[],this._client=t,this._collectionInterval=r}return e.prototype.enable=function(t,r){var n=this;this._isEnabled=t,this._isEnabled&&!this._isInitialized&&(this._isInitialized=!0),t?this._handle||(this._collectionInterval=r||this._collectionInterval,this._handle=setInterval(function(){return n.trackPreAggregatedMetrics()},this._collectionInterval),this._handle.unref()):this._handle&&(clearInterval(this._handle),this._handle=void 0)},e.countException=function(t){if(!!e.isEnabled()){var r=e._getAggregatedCounter(t,this._exceptionCountersCollection);r.totalCount++}},e.countTrace=function(t){if(!!e.isEnabled()){var r=e._getAggregatedCounter(t,this._traceCountersCollection);r.totalCount++}},e.countRequest=function(t,r){if(!!e.isEnabled()){var n,i=e._getAggregatedCounter(r,this._requestCountersCollection);if(typeof t=="string")n=+new Date("1970-01-01T"+t+"Z");else if(typeof t=="number")n=t;else return;i.intervalExecutionTime+=n,i.totalCount++}},e.countDependency=function(t,r){if(!!e.isEnabled()){var n=e._getAggregatedCounter(r,this._dependencyCountersCollection),i;if(typeof t=="string")i=+new Date("1970-01-01T"+t+"Z");else if(typeof t=="number")i=t;else return;n.intervalExecutionTime+=i,n.totalCount++}},e.prototype.isInitialized=function(){return this._isInitialized},e.isEnabled=function(){return e.INSTANCE&&e.INSTANCE._isEnabled},e.prototype.trackPreAggregatedMetrics=function(){this._trackRequestMetrics(),this._trackDependencyMetrics(),this._trackExceptionMetrics(),this._trackTraceMetrics()},e._getAggregatedCounter=function(t,r){for(var n=!1,i=0;i<r.length;i++){if(t===r[i].dimensions)return r[i];if(Object.keys(t).length===Object.keys(r[i].dimensions).length){for(var a in t)if(t[a]!=r[i].dimensions[a]){n=!0;break}if(!n)return r[i];n=!1}}var s=new WD.AggregatedMetricCounter(t);return r.push(s),s},e.prototype._trackRequestMetrics=function(){for(var t=0;t<e._requestCountersCollection.length;t++){var r=e._requestCountersCollection[t];r.time=+new Date;var n=r.totalCount-r.lastTotalCount||0,i=r.time-r.lastTime,a=(r.intervalExecutionTime-r.lastIntervalExecutionTime)/n||0;r.lastIntervalExecutionTime=r.intervalExecutionTime,i>0&&n>0&&this._trackPreAggregatedMetric({name:"Server response time",dimensions:r.dimensions,value:a,count:n,aggregationInterval:i,metricType:iu.MetricId.REQUESTS_DURATION}),r.lastTotalCount=r.totalCount,r.lastTime=r.time}},e.prototype._trackDependencyMetrics=function(){for(var t=0;t<e._dependencyCountersCollection.length;t++){var r=e._dependencyCountersCollection[t];r.time=+new Date;var n=r.totalCount-r.lastTotalCount||0,i=r.time-r.lastTime,a=(r.intervalExecutionTime-r.lastIntervalExecutionTime)/n||0;r.lastIntervalExecutionTime=r.intervalExecutionTime,i>0&&n>0&&this._trackPreAggregatedMetric({name:"Dependency duration",dimensions:r.dimensions,value:a,count:n,aggregationInterval:i,metricType:iu.MetricId.DEPENDENCIES_DURATION}),r.lastTotalCount=r.totalCount,r.lastTime=r.time}},e.prototype._trackExceptionMetrics=function(){for(var t=0;t<e._exceptionCountersCollection.length;t++){var r=e._exceptionCountersCollection[t],n=r.totalCount-r.lastTotalCount||0,i=r.time-r.lastTime;this._trackPreAggregatedMetric({name:"Exceptions",dimensions:r.dimensions,value:n,count:n,aggregationInterval:i,metricType:iu.MetricId.EXCEPTIONS_COUNT}),r.lastTotalCount=r.totalCount,r.lastTime=r.time}},e.prototype._trackTraceMetrics=function(){for(var t=0;t<e._traceCountersCollection.length;t++){var r=e._traceCountersCollection[t],n=r.totalCount-r.lastTotalCount||0,i=r.time-r.lastTime;this._trackPreAggregatedMetric({name:"Traces",dimensions:r.dimensions,value:n,count:n,aggregationInterval:i,metricType:iu.MetricId.TRACES_COUNT}),r.lastTotalCount=r.totalCount,r.lastTime=r.time}},e.prototype._trackPreAggregatedMetric=function(t){var r={};for(var n in t.dimensions)r[ZD.PreaggregatedMetricPropertyNames[n]]=t.dimensions[n];r=nu(nu({},r),{"_MS.MetricId":t.metricType,"_MS.AggregationIntervalMs":String(t.aggregationInterval),"_MS.IsAutocollected":"True"});var i={name:t.name,value:t.value,count:t.count,properties:r,kind:"Aggregation"};this._client.trackMetric(i)},e.prototype.dispose=function(){e.INSTANCE=null,this.enable(!1),this._isInitialized=!1},e}();hy.exports=JD});var ya=l((U1,Ey)=>{"use strict";var Ht=__webpack_require__(2087),_y=__webpack_require__(5747),vy=__webpack_require__(5622),ew=De(),gy=ve(),tw=function(){function e(t){this.keys=new ew.ContextTagKeys,this.tags={},this._loadApplicationContext(t),this._loadDeviceContext(),this._loadInternalContext()}return e.prototype._loadApplicationContext=function(t){if(t=t||vy.resolve(__dirname,"../../../../package.json"),!e.appVersion[t]){e.appVersion[t]="unknown";try{var r=JSON.parse(_y.readFileSync(t,"utf8"));r&&typeof r.version=="string"&&(e.appVersion[t]=r.version)}catch(n){gy.info("unable to read app version: ",n)}}this.tags[this.keys.applicationVersion]=e.appVersion[t]},e.prototype._loadDeviceContext=function(){this.tags[this.keys.deviceId]="",this.tags[this.keys.cloudRoleInstance]=Ht&&Ht.hostname(),this.tags[this.keys.deviceOSVersion]=Ht&&Ht.type()+" "+Ht.release(),this.tags[this.keys.cloudRole]=e.DefaultRoleName,this.tags["ai.device.osArchitecture"]=Ht&&Ht.arch(),this.tags["ai.device.osPlatform"]=Ht&&Ht.platform()},e.prototype._loadInternalContext=function(){var t=vy.resolve(__dirname,"../../package.json");if(!e.sdkVersion){e.sdkVersion="unknown";try{var r=JSON.parse(_y.readFileSync(t,"utf8"));r&&typeof r.version=="string"&&(e.sdkVersion=r.version)}catch(n){gy.info("unable to read app version: ",n)}}this.tags[this.keys.internalSdkVersion]="node:"+e.sdkVersion},e.DefaultRoleName="Web",e.appVersion={},e.sdkVersion=null,e}();Ey.exports=tw});var yy=l((Fp,my)=>{"use strict";var rw=Fp&&Fp.__extends||function(){var e=function(t,r){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},e(t,r)};return function(t,r){e(t,r);function n(){this.constructor=t}t.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}(),ct=__webpack_require__(8835),Gp=De(),nw=Be(),iw=jn(),aw=Tl(),sw=Gr(),ow=function(e){rw(t,e);function t(r,n){var i=e.call(this)||this;return n&&n.method&&r&&(i.method=n.method,i.url=t._getUrlFromRequestOptions(r,n),i.startTime=+new Date),i}return t.prototype.onError=function(r){this._setStatus(void 0,r)},t.prototype.onResponse=function(r){this._setStatus(r.statusCode,void 0),this.correlationId=nw.getCorrelationContextTarget(r,iw.requestContextTargetKey)},t.prototype.getDependencyTelemetry=function(r,n){var i=ct.parse(this.url);i.search=void 0,i.hash=void 0;var a=this.method.toUpperCase()+" "+i.pathname,s=Gp.RemoteDependencyDataConstants.TYPE_HTTP,o=i.hostname;i.port&&(o+=":"+i.port),this.correlationId?(s=Gp.RemoteDependencyDataConstants.TYPE_AI,this.correlationId!==sw.correlationIdPrefix&&(o+=" | "+this.correlationId)):s=Gp.RemoteDependencyDataConstants.TYPE_HTTP;var u={id:n,name:a,data:this.url,duration:this.duration,success:this._isSuccess(),resultCode:this.statusCode?this.statusCode.toString():null,properties:this.properties||{},dependencyTypeName:s,target:o};if(r&&r.time?u.time=r.time:this.startTime&&(u.time=new Date(this.startTime)),r){for(var c in r)u[c]||(u[c]=r[c]);if(r.properties)for(var c in r.properties)u.properties[c]=r.properties[c]}return u},t._getUrlFromRequestOptions=function(r,n){if(typeof r=="string")if(r.indexOf("http://")===0||r.indexOf("https://")===0)r=ct.parse(r);else{var i=ct.parse(r);i.host==="443"?r=ct.parse("https://"+r):r=ct.parse("http://"+r)}else{if(r&&typeof ct.URL=="function"&&r instanceof ct.URL)return ct.format(r);var a=r;r={},a&&Object.keys(a).forEach(function(u){r[u]=a[u]})}if(r.path){var s=ct.parse(r.path);r.pathname=s.pathname,r.search=s.search}if(r.host&&r.port){var o=ct.parse("http://"+r.host);!o.port&&r.port&&(r.hostname=r.host,delete r.host)}return r.protocol=r.protocol||n.agent&&n.agent.protocol||n.protocol||void 0,r.hostname=r.hostname||"localhost",ct.format(r)},t}(aw);my.exports=ow});var Ty=l(ai=>{"use strict";var Ta=ai&&ai.__assign||function(){return Ta=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++){t=arguments[r];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},Ta.apply(this,arguments)};Object.defineProperty(ai,"__esModule",{value:!0});ai.spanToTelemetryContract=void 0;var uw=z(),ke=kt();function Vp(e){var t=Ta({},e);return Object.keys(ke.SpanAttribute).forEach(function(r){delete t[r]}),t}function cw(e){var t="|"+e.spanContext().traceId+"."+e.spanContext().spanId+".",r=Math.round(e._duration[0]*1e3+e._duration[1]/1e6),n=e.attributes["peer.address"]?e.attributes["peer.address"].toString():"",i=e.attributes.component?e.attributes.component.toString():"",a=i.toUpperCase()===ke.DependencyTypeName.Http||!!e.attributes[ke.SpanAttribute.HttpUrl],s=i.toLowerCase()===ke.DependencyTypeName.Grpc;if(a){var o=e.attributes[ke.SpanAttribute.HttpMethod]||"GET",u=new URL(e.attributes[ke.SpanAttribute.HttpUrl].toString()),c=e.attributes[ke.SpanAttribute.HttpHost]||u.host,p=e.attributes[ke.SpanAttribute.HttpPort]||u.port||null,f=u.pathname||"/",d=o+" "+f,h=ke.DependencyTypeName.Http,E=p?(c+":"+p).toString():c.toString(),S=u.toString(),j=e.attributes[ke.SpanAttribute.HttpStatusCode]||e.status.code||0,oe=j<400;return{id:t,name:d,dependencyTypeName:h,target:E,data:S,success:oe,duration:r,url:S,resultCode:String(j),properties:Vp(e.attributes)}}else if(s){var o=e.attributes[ke.SpanAttribute.GrpcMethod]||"rpc",Ae=e.attributes[ke.SpanAttribute.GrpcService],At=Ae?o+" "+Ae:e.name;return{id:t,duration:r,name:At,target:Ae.toString(),data:Ae.toString()||At,url:Ae.toString()||At,dependencyTypeName:ke.DependencyTypeName.Grpc,resultCode:String(e.status.code||0),success:e.status.code===0,properties:Vp(e.attributes)}}else{var tn=e.name,Ti=e.links&&e.links.map(function(rn){return{operation_Id:rn.context.traceId,id:rn.context.spanId}});return{id:t,duration:r,name:tn,target:n,data:n||tn,url:n||tn,dependencyTypeName:e.kind===uw.SpanKind.INTERNAL?ke.DependencyTypeName.InProc:i||e.name,resultCode:String(e.status.code||0),success:e.status.code===0,properties:Ta(Ta({},Vp(e.attributes)),{"_MS.links":Ti||void 0})}}}ai.spanToTelemetryContract=cw});var Iy=l(lr=>{"use strict";Object.defineProperty(lr,"__esModule",{value:!0});lr.enable=lr.subscriber=void 0;var $p=z(),Sy=ue(),Ay=Zi(),lw=Ty(),pw=Eu(),si=[],fw=function(e){var t=e.data,r=lw.spanToTelemetryContract(t),n=t.spanContext(),i=new Ay;i.traceId=n.traceId,i.spanId=n.spanId,i.traceFlag=Ay.formatOpenTelemetryTraceFlags(n.traceFlags),i.parentId=t.parentSpanId?"|"+n.traceId+"."+t.parentSpanId+".":null,pw.AsyncScopeManager.with(t,function(){si.forEach(function(a){t.kind===$p.SpanKind.SERVER?a.trackRequest(r):(t.kind===$p.SpanKind.CLIENT||t.kind===$p.SpanKind.INTERNAL)&&a.trackDependency(r)})})};lr.subscriber=fw;function dw(e,t){e?(si.length===0&&Sy.channel.subscribe("azure-coretracing",lr.subscriber),si.push(t)):(si=si.filter(function(r){return r!=t}),si.length===0&&Sy.channel.unsubscribe("azure-coretracing",lr.subscriber))}lr.enable=dw});var Cy=l(pr=>{"use strict";Object.defineProperty(pr,"__esModule",{value:!0});pr.enable=pr.subscriber=void 0;var by=ue(),oi=[],hw=function(e){e.data.event.commandName!=="ismaster"&&oi.forEach(function(t){var r=e.data.startedData&&e.data.startedData.databaseName||"Unknown database";t.trackDependency({target:r,data:e.data.event.commandName,name:e.data.event.commandName,duration:e.data.event.duration,success:e.data.succeeded,resultCode:e.data.succeeded?"0":"1",time:e.data.startedData.time,dependencyTypeName:"mongodb"})})};pr.subscriber=hw;function _w(e,t){e?(oi.length===0&&by.channel.subscribe("mongodb",pr.subscriber),oi.push(t)):(oi=oi.filter(function(r){return r!=t}),oi.length===0&&by.channel.unsubscribe("mongodb",pr.subscriber))}pr.enable=_w});var Py=l(fr=>{"use strict";Object.defineProperty(fr,"__esModule",{value:!0});fr.enable=fr.subscriber=void 0;var Oy=ue(),ui=[],vw=function(e){ui.forEach(function(t){var r=e.data.query||{},n=r.sql||"Unknown query",i=!e.data.err,a=r._connection||{},s=a.config||{},o=s.socketPath?s.socketPath:(s.host||"localhost")+":"+s.port;t.trackDependency({target:o,data:n,name:n,duration:e.data.duration,success:i,resultCode:i?"0":"1",time:e.data.time,dependencyTypeName:"mysql"})})};fr.subscriber=vw;function gw(e,t){e?(ui.length===0&&Oy.channel.subscribe("mysql",fr.subscriber),ui.push(t)):(ui=ui.filter(function(r){return r!=t}),ui.length===0&&Oy.channel.unsubscribe("mysql",fr.subscriber))}fr.enable=gw});var Ny=l(dr=>{"use strict";Object.defineProperty(dr,"__esModule",{value:!0});dr.enable=dr.subscriber=void 0;var Ry=ue(),ci=[],Ew=function(e){ci.forEach(function(t){e.data.commandObj.command!=="info"&&t.trackDependency({target:e.data.address,name:e.data.commandObj.command,data:e.data.commandObj.command,duration:e.data.duration,success:!e.data.err,resultCode:e.data.err?"1":"0",time:e.data.time,dependencyTypeName:"redis"})})};dr.subscriber=Ew;function mw(e,t){e?(ci.length===0&&Ry.channel.subscribe("redis",dr.subscriber),ci.push(t)):(ci=ci.filter(function(r){return r!=t}),ci.length===0&&Ry.channel.unsubscribe("redis",dr.subscriber))}dr.enable=mw});var wy=l(hr=>{"use strict";Object.defineProperty(hr,"__esModule",{value:!0});hr.enable=hr.subscriber=void 0;var Dy=ue(),li=[],yw=function(e){li.forEach(function(t){var r=e.data.query,n=r.preparable&&r.preparable.text||r.plan||r.text||"unknown query",i=!e.data.error,a=e.data.database.host+":"+e.data.database.port;t.trackDependency({target:a,data:n,name:n,duration:e.data.duration,success:i,resultCode:i?"0":"1",time:e.data.time,dependencyTypeName:"postgres"})})};hr.subscriber=yw;function Tw(e,t){e?(li.length===0&&Dy.channel.subscribe("postgres",hr.subscriber),li.push(t)):(li=li.filter(function(r){return r!=t}),li.length===0&&Dy.channel.unsubscribe("postgres",hr.subscriber))}hr.enable=Tw});var di=l((Xp,qy)=>{"use strict";var au=Xp&&Xp.__spreadArrays||function(){for(var e=0,t=0,r=arguments.length;t<r;t++)e+=arguments[t].length;for(var n=Array(e),i=0,t=0;t<r;t++)for(var a=arguments[t],s=0,o=a.length;s<o;s++,i++)n[i]=a[s];return n},pi=__webpack_require__(8605),fi=__webpack_require__(7211),zp=ve(),xy=Be(),_r=jn(),Sw=yy(),My=gr(),Ly=Gr(),Kp=Zi(),Aw=ho(),Iw=function(){function e(t){if(e.INSTANCE)throw new Error("Client request tracking should be configured from the applicationInsights object");e.INSTANCE=this,this._client=t}return e.prototype.enable=function(t){this._isEnabled=t,this._isEnabled&&!this._isInitialized&&this._initialize(),Aw.IsInitialized&&(Iy().enable(!0,this._client),Cy().enable(t,this._client),Py().enable(t,this._client),Ny().enable(t,this._client),wy().enable(t,this._client))},e.prototype.isInitialized=function(){return this._isInitialized},e.prototype._initialize=function(){var t=this;this._isInitialized=!0;var r=pi.request,n=fi.request,i=function(a,s){var o=!s[e.disableCollectionRequestOption]&&!a[e.alreadyAutoCollectedFlag];s.headers&&s.headers["user-agent"]&&s.headers["user-agent"].toString().indexOf("azsdk-js")!==-1&&(o=!1),a[e.alreadyAutoCollectedFlag]=!0,a&&s&&o&&(My.CorrelationContextManager.wrapEmitter(a),e.trackRequest(t._client,{options:s,request:a}))};pi.request=function(a){for(var s=[],o=1;o<arguments.length;o++)s[o-1]=arguments[o];var u=r.call.apply(r,au([pi,a],s));return i(u,a),u},fi.request=function(a){for(var s=[],o=1;o<arguments.length;o++)s[o-1]=arguments[o];var u=n.call.apply(n,au([fi,a],s));return i(u,a),u},pi.get=function(a){for(var s,o=[],u=1;u<arguments.length;u++)o[u-1]=arguments[u];var c=(s=pi.request).call.apply(s,au([pi,a],o));return c.end(),c},fi.get=function(a){for(var s,o=[],u=1;u<arguments.length;u++)o[u-1]=arguments[u];var c=(s=fi.request).call.apply(s,au([fi,a],o));return c.end(),c}},e.trackRequest=function(t,r){if(!r.options||!r.request||!t){zp.info("AutoCollectHttpDependencies.trackRequest was called with invalid parameters: ",!r.options,!r.request,!t);return}var n=new Sw(r.options,r.request),i=My.CorrelationContextManager.getCurrentContext(),a,s;if(i&&i.operation&&i.operation.traceparent&&Kp.isValidTraceId(i.operation.traceparent.traceId))i.operation.traceparent.updateSpanId(),a=i.operation.traceparent.getBackCompatRequestId();else if(Ly.w3cEnabled){var o=new Kp;s=o.toString(),a=o.getBackCompatRequestId()}else a=i&&i.operation&&i.operation.parentId+e.requestNumber+++".";if(xy.canIncludeCorrelationHeader(t,n.getUrl())&&r.request.getHeader&&r.request.setHeader&&t.config&&t.config.correlationId){var u=r.request.getHeader(_r.requestContextHeader);try{xy.safeIncludeCorrelationHeader(t,r.request,u)}catch(f){zp.warn("Request-Context header could not be set. Correlation of requests may be lost",f)}if(i&&i.operation)try{if(r.request.setHeader(_r.requestIdHeader,a),t.config.ignoreLegacyHeaders||(r.request.setHeader(_r.parentIdHeader,i.operation.id),r.request.setHeader(_r.rootIdHeader,a)),s||i.operation.traceparent)r.request.setHeader(_r.traceparentHeader,s||i.operation.traceparent.toString());else if(Ly.w3cEnabled){var o=new Kp().toString();r.request.setHeader(_r.traceparentHeader,o)}if(i.operation.tracestate){var c=i.operation.tracestate.toString();c&&r.request.setHeader(_r.traceStateHeader,c)}var p=i.customProperties.serializeToHeader();p&&r.request.setHeader(_r.correlationContextHeader,p)}catch(f){zp.warn("Correlation headers could not be set. Correlation of requests may be lost.",f)}}r.request.on&&(r.request.on("response",function(f){n.onResponse(f);var d=n.getDependencyTelemetry(r,a);d.contextObjects=d.contextObjects||{},d.contextObjects["http.RequestOptions"]=r.options,d.contextObjects["http.ClientRequest"]=r.request,d.contextObjects["http.ClientResponse"]=f,t.trackDependency(d)}),r.request.on("error",function(f){n.onError(f);var d=n.getDependencyTelemetry(r,a);d.contextObjects=d.contextObjects||{},d.contextObjects["http.RequestOptions"]=r.options,d.contextObjects["http.ClientRequest"]=r.request,d.contextObjects.Error=f,t.trackDependency(d)}),r.request.on("abort",function(){n.onError(new Error);var f=n.getDependencyTelemetry(r,a);f.contextObjects=f.contextObjects||{},f.contextObjects["http.RequestOptions"]=r.options,f.contextObjects["http.ClientRequest"]=r.request,t.trackDependency(f)}))},e.prototype.dispose=function(){e.INSTANCE=null,this.enable(!1),this._isInitialized=!1},e.disableCollectionRequestOption="disableAppInsightsAutoCollection",e.requestNumber=1,e.alreadyAutoCollectedFlag="_appInsightsAutoCollected",e}();qy.exports=Iw});var Hy=l((K1,ky)=>{"use strict";var bw=__webpack_require__(2087),jy=kt(),Cw=Be(),Ow=ya(),Pw=di(),Rw="http://169.254.169.254/metadata/instance/compute",Nw="api-version=2017-12-01",Dw="format=json",ww="ENETUNREACH",xw=function(){function e(t){this._collectionInterval=9e5,this._vmData={},this._azInst_vmId="",this._azInst_subscriptionId="",this._azInst_osType="",e.INSTANCE||(e.INSTANCE=this),this._isInitialized=!1,this._client=t}return e.prototype.enable=function(t,r){var n=this;this._isEnabled=t,this._isEnabled&&!this._isInitialized&&(this._isInitialized=!0),t?this._handle||(this._handle=setInterval(function(){return n.trackHeartBeat(r,function(){})},this._collectionInterval),this._handle.unref()):this._handle&&(clearInterval(this._handle),this._handle=null)},e.prototype.isInitialized=function(){return this._isInitialized},e.isEnabled=function(){return e.INSTANCE&&e.INSTANCE._isEnabled},e.prototype.trackHeartBeat=function(t,r){var n=this,i=!1,a={},s=Ow.sdkVersion;a.sdk=s,a.osType=bw.type(),process.env.WEBSITE_SITE_NAME?(a.appSrv_SiteName=process.env.WEBSITE_SITE_NAME||"",a.appSrv_wsStamp=process.env.WEBSITE_HOME_STAMPNAME||"",a.appSrv_wsHost=process.env.WEBSITE_HOSTNAME||""):process.env.FUNCTIONS_WORKER_RUNTIME?a.azfunction_appId=process.env.WEBSITE_HOSTNAME:t&&(this._isVM===void 0?(i=!0,this._getAzureComputeMetadata(t,function(){n._isVM&&Object.keys(n._vmData).length>0&&(a.azInst_vmId=n._vmData.vmId||"",a.azInst_subscriptionId=n._vmData.subscriptionId||"",a.azInst_osType=n._vmData.osType||"",n._azInst_vmId=n._vmData.vmId||"",n._azInst_subscriptionId=n._vmData.subscriptionId||"",n._azInst_osType=n._vmData.osType||""),n._client.trackMetric({name:jy.HeartBeatMetricName,value:0,properties:a}),r()})):this._isVM&&(a.azInst_vmId=this._azInst_vmId,a.azInst_subscriptionId=this._azInst_subscriptionId,a.azInst_osType=this._azInst_osType)),i||(this._client.trackMetric({name:jy.HeartBeatMetricName,value:0,properties:a}),r())},e.prototype.dispose=function(){e.INSTANCE=null,this.enable(!1),this._isInitialized=!1},e.prototype._getAzureComputeMetadata=function(t,r){var n,i=this,a=Rw+"?"+Nw+"&"+Dw,s=(n={method:"GET"},n[Pw.disableCollectionRequestOption]=!0,n.headers={Metadata:"True"},n),o=Cw.makeRequest(t,a,s,function(u){if(u.statusCode===200){i._isVM=!0;var c="";u.on("data",function(p){c+=p}),u.on("end",function(){i._vmData=i._isJSON(c)?JSON.parse(c):{},r()})}else r()});o&&(o.on("error",function(u){u&&u.message&&u.message.indexOf(ww)>-1&&(i._isVM=!1),r()}),o.end())},e.prototype._isJSON=function(t){try{return JSON.parse(t)&&!!t}catch(r){return!1}},e}();ky.exports=xw});var Qp=l((X1,Vy)=>{"use strict";var Uy=__webpack_require__(8605),By=__webpack_require__(7211),Gy=ve(),Fy=Be(),Mw=jn(),Yp=Il(),Ut=gr(),Lw=eu(),qw=function(){function e(t){if(e.INSTANCE)throw new Error("Server request tracking should be configured from the applicationInsights object");e.INSTANCE=this,this._client=t}return e.prototype.enable=function(t){this._isEnabled=t,(this._isAutoCorrelating||this._isEnabled||Lw.isEnabled())&&!this._isInitialized&&(this.useAutoCorrelation(this._isAutoCorrelating),this._initialize())},e.prototype.useAutoCorrelation=function(t,r){t&&!this._isAutoCorrelating?Ut.CorrelationContextManager.enable(r):!t&&this._isAutoCorrelating&&Ut.CorrelationContextManager.disable(),this._isAutoCorrelating=t},e.prototype.isInitialized=function(){return this._isInitialized},e.prototype.isAutoCorrelating=function(){return this._isAutoCorrelating},e.prototype._generateCorrelationContext=function(t){if(!!this._isAutoCorrelating)return Ut.CorrelationContextManager.generateContextObject(t.getOperationId(this._client.context.tags),t.getRequestId(),t.getOperationName(this._client.context.tags),t.getCorrelationContextHeader(),t.getTraceparent(),t.getTracestate())},e.prototype._initialize=function(){var t=this;this._isInitialized=!0;var r=function(s){if(!!s){if(typeof s!="function")throw new Error("onRequest handler must be a function");return function(o,u){Ut.CorrelationContextManager.wrapEmitter(o),Ut.CorrelationContextManager.wrapEmitter(u);var c=o&&!o[e.alreadyAutoCollectedFlag];if(o&&c){var p=new Yp(o),f=t._generateCorrelationContext(p);Ut.CorrelationContextManager.runWithContext(f,function(){t._isEnabled&&(o[e.alreadyAutoCollectedFlag]=!0,e.trackRequest(t._client,{request:o,response:u},p)),typeof s=="function"&&s(o,u)})}else typeof s=="function"&&s(o,u)}}},n=function(s){var o=s.addListener.bind(s);s.addListener=function(u,c){switch(u){case"request":case"checkContinue":return o(u,r(c));default:return o(u,c)}},s.on=s.addListener},i=Uy.createServer;Uy.createServer=function(s,o){if(o&&typeof o=="function"){var u=i(s,r(o));return n(u),u}else{var u=i(r(s));return n(u),u}};var a=By.createServer;By.createServer=function(s,o){var u=a(s,r(o));return n(u),u}},e.trackRequestSync=function(t,r){if(!r.request||!r.response||!t){Gy.info("AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: ",!r.request,!r.response,!t);return}e.addResponseCorrelationIdHeader(t,r.response);var n=Ut.CorrelationContextManager.getCurrentContext(),i=new Yp(r.request,n&&n.operation.parentId);n&&(n.operation.id=i.getOperationId(t.context.tags)||n.operation.id,n.operation.name=i.getOperationName(t.context.tags)||n.operation.name,n.operation.parentId=i.getRequestId()||n.operation.parentId,n.customProperties.addHeaderData(i.getCorrelationContextHeader())),e.endRequest(t,i,r,r.duration,r.error)},e.trackRequest=function(t,r,n){if(!r.request||!r.response||!t){Gy.info("AutoCollectHttpRequests.trackRequest was called with invalid parameters: ",!r.request,!r.response,!t);return}var i=Ut.CorrelationContextManager.getCurrentContext(),a=n||new Yp(r.request,i&&i.operation.parentId);Fy.canIncludeCorrelationHeader(t,a.getUrl())&&e.addResponseCorrelationIdHeader(t,r.response),i&&!n&&(i.operation.id=a.getOperationId(t.context.tags)||i.operation.id,i.operation.name=a.getOperationName(t.context.tags)||i.operation.name,i.operation.parentId=a.getOperationParentId(t.context.tags)||i.operation.parentId,i.customProperties.addHeaderData(a.getCorrelationContextHeader())),r.response.once&&r.response.once("finish",function(){e.endRequest(t,a,r,null,null)}),r.request.on&&r.request.on("error",function(s){e.endRequest(t,a,r,null,s)}),r.request.on&&r.request.on("aborted",function(){var s="The request has been aborted and the network socket has closed.";e.endRequest(t,a,r,null,s)})},e.addResponseCorrelationIdHeader=function(t,r){if(t.config&&t.config.correlationId&&r.getHeader&&r.setHeader&&!r.headersSent){var n=r.getHeader(Mw.requestContextHeader);Fy.safeIncludeCorrelationHeader(t,r,n)}},e.endRequest=function(t,r,n,i,a){a?r.onError(a,i):r.onResponse(n.response,i);var s=r.getRequestTelemetry(n);if(s.tagOverrides=r.getRequestTags(t.context.tags),n.tagOverrides)for(var o in n.tagOverrides)s.tagOverrides[o]=n.tagOverrides[o];var u=r.getLegacyRootId();u&&(s.properties.ai_legacyRootId=u),s.contextObjects=s.contextObjects||{},s.contextObjects["http.ServerRequest"]=n.request,s.contextObjects["http.ServerResponse"]=n.response,t.trackRequest(s)},e.prototype.dispose=function(){e.INSTANCE=null,this.enable(!1),this._isInitialized=!1,Ut.CorrelationContextManager.disable(),this._isAutoCorrelating=!1},e.alreadyAutoCollectedFlag="_appInsightsAutoCollected",e}();Vy.exports=qw});var Ky=l((Zp,zy)=>{"use strict";var et=Zp&&Zp.__assign||function(){return et=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++){t=arguments[r];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},et.apply(this,arguments)},Wp=__webpack_require__(2087),Jr=De(),$y=kt(),jw=Be(),kw=ve(),Hw=jw.w3cTraceId(),Uw=function(){function e(){}return e.createQuickPulseEnvelope=function(t,r,n,i){var a=Wp&&typeof Wp.hostname=="function"&&Wp.hostname()||"Unknown",s=i.tags&&i.keys&&i.keys.cloudRoleInstance&&i.tags[i.keys.cloudRoleInstance]||a,o=i.tags&&i.keys&&i.keys.cloudRole&&i.tags[i.keys.cloudRole]||null,u={Documents:r.length>0?r:null,InstrumentationKey:n.instrumentationKey||"",Metrics:t.length>0?t:null,InvariantVersion:1,Timestamp:"/Date("+Date.now()+")/",Version:i.tags[i.keys.internalSdkVersion],StreamId:Hw,MachineName:a,Instance:s,RoleName:o};return u},e.createQuickPulseMetric=function(t){var r;return r={Name:t.name,Value:t.value,Weight:t.count||1},r},e.telemetryEnvelopeToQuickPulseDocument=function(t){switch(t.data.baseType){case Jr.TelemetryTypeString.Event:return e.createQuickPulseEventDocument(t);case Jr.TelemetryTypeString.Exception:return e.createQuickPulseExceptionDocument(t);case Jr.TelemetryTypeString.Trace:return e.createQuickPulseTraceDocument(t);case Jr.TelemetryTypeString.Dependency:return e.createQuickPulseDependencyDocument(t);case Jr.TelemetryTypeString.Request:return e.createQuickPulseRequestDocument(t)}return null},e.createQuickPulseEventDocument=function(t){var r=e.createQuickPulseDocument(t),n=t.data.baseData.name,i=et(et({},r),{Name:n});return i},e.createQuickPulseTraceDocument=function(t){var r=e.createQuickPulseDocument(t),n=t.data.baseData.severityLevel||0,i=et(et({},r),{Message:t.data.baseData.message,SeverityLevel:Jr.SeverityLevel[n]});return i},e.createQuickPulseExceptionDocument=function(t){var r=e.createQuickPulseDocument(t),n=t.data.baseData.exceptions,i="",a="",s="";n&&n.length>0&&(n[0].parsedStack&&n[0].parsedStack.length>0?n[0].parsedStack.forEach(function(u){i+=u.assembly+`
`}):n[0].stack&&n[0].stack.length>0&&(i=n[0].stack),a=n[0].message,s=n[0].typeName);var o=et(et({},r),{Exception:i,ExceptionMessage:a,ExceptionType:s});return o},e.createQuickPulseRequestDocument=function(t){var r=e.createQuickPulseDocument(t),n=t.data.baseData,i=et(et({},r),{Name:n.name,Success:n.success,Duration:n.duration,ResponseCode:n.responseCode,OperationName:n.name});return i},e.createQuickPulseDependencyDocument=function(t){var r=e.createQuickPulseDocument(t),n=t.data.baseData,i=et(et({},r),{Name:n.name,Target:n.target,Success:n.success,Duration:n.duration,ResultCode:n.resultCode,CommandName:n.data,OperationName:r.OperationId,DependencyTypeName:n.type});return i},e.createQuickPulseDocument=function(t){var r,n,i,a;t.data.baseType?(n=$y.TelemetryTypeStringToQuickPulseType[t.data.baseType],r=$y.TelemetryTypeStringToQuickPulseDocumentType[t.data.baseType]):kw.warn("Document type invalid; not sending live metric document",t.data.baseType),i=t.tags[e.keys.operationId],a=e.aggregateProperties(t);var s={DocumentType:r,__type:n,OperationId:i,Version:"1.0",Properties:a};return s},e.aggregateProperties=function(t){var r=[],n=t.data.baseData.measurements||{};for(var i in n)if(n.hasOwnProperty(i)){var a=n[i],s={key:i,value:a};r.push(s)}var o=t.data.baseData.properties||{};for(var i in o)if(o.hasOwnProperty(i)){var a=o[i],s={key:i,value:a};r.push(s)}return r},e.keys=new Jr.ContextTagKeys,e}();zy.exports=Uw});var Yy=l((Y1,Xy)=>{"use strict";var Bw=function(){return(Date.now()+621355968e5)*1e4};Xy.exports={getTransmissionTime:Bw}});var eT=l((Sa,Jy)=>{"use strict";var Qy=Sa&&Sa.__awaiter||function(e,t,r,n){function i(a){return a instanceof r?a:new r(function(s){s(a)})}return new(r||(r=Promise))(function(a,s){function o(p){try{c(n.next(p))}catch(f){s(f)}}function u(p){try{c(n.throw(p))}catch(f){s(f)}}function c(p){p.done?a(p.value):i(p.value).then(o,u)}c((n=n.apply(e,t||[])).next())})},Wy=Sa&&Sa.__generator||function(e,t){var r={label:0,sent:function(){if(a[0]&1)throw a[1];return a[1]},trys:[],ops:[]},n,i,a,s;return s={next:o(0),throw:o(1),return:o(2)},typeof Symbol=="function"&&(s[Symbol.iterator]=function(){return this}),s;function o(c){return function(p){return u([c,p])}}function u(c){if(n)throw new TypeError("Generator is already executing.");for(;r;)try{if(n=1,i&&(a=c[0]&2?i.return:c[0]?i.throw||((a=i.return)&&a.call(i),0):i.next)&&!(a=a.call(i,c[1])).done)return a;switch(i=0,a&&(c=[c[0]&2,a.value]),c[0]){case 0:case 1:a=c;break;case 4:return r.label++,{value:c[1],done:!1};case 5:r.label++,i=c[1],c=[0];continue;case 7:c=r.ops.pop(),r.trys.pop();continue;default:if(a=r.trys,!(a=a.length>0&&a[a.length-1])&&(c[0]===6||c[0]===2)){r=0;continue}if(c[0]===3&&(!a||c[1]>a[0]&&c[1]<a[3])){r.label=c[1];break}if(c[0]===6&&r.label<a[1]){r.label=a[1],a=c;break}if(a&&r.label<a[2]){r.label=a[2],r.ops.push(c);break}a[2]&&r.ops.pop(),r.trys.pop();continue}c=t.call(e,r)}catch(p){c=[6,p],i=0}finally{n=a=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}},Gw=__webpack_require__(7211),Fw=di(),Zy=ve(),Vw=Yy(),$w=Be(),tt={method:"POST",time:"x-ms-qps-transmission-time",pollingIntervalHint:"x-ms-qps-service-polling-interval-hint",endpointRedirect:"x-ms-qps-service-endpoint-redirect",instanceName:"x-ms-qps-instance-name",streamId:"x-ms-qps-stream-id",machineName:"x-ms-qps-machine-name",roleName:"x-ms-qps-role-name",streamid:"x-ms-qps-stream-id",invariantVersion:"x-ms-qps-invariant-version",subscribed:"x-ms-qps-subscribed"},zw=function(){function e(t){this._config=t,this._consecutiveErrors=0}return e.prototype.ping=function(t,r,n){var i=[{name:tt.streamId,value:t.StreamId},{name:tt.machineName,value:t.MachineName},{name:tt.roleName,value:t.RoleName},{name:tt.instanceName,value:t.Instance},{name:tt.invariantVersion,value:t.InvariantVersion.toString()}];this._submitData(t,r,n,"ping",i)},e.prototype.post=function(t,r,n){return Qy(this,void 0,void 0,function(){return Wy(this,function(i){switch(i.label){case 0:return[4,this._submitData([t],r,n,"post")];case 1:return i.sent(),[2]}})})},e.prototype._submitData=function(t,r,n,i,a){return Qy(this,void 0,void 0,function(){var s,o,u,c,p,f=this;return Wy(this,function(d){return s=JSON.stringify(t),o=(c={},c[Fw.disableCollectionRequestOption]=!0,c.host=r&&r.length>0?r:this._config.quickPulseHost,c.method=tt.method,c.path="/QuickPulseService.svc/"+i+"?ikey="+this._config.instrumentationKey,c.headers=(p={Expect:"100-continue"},p[tt.time]=Vw.getTransmissionTime(),p["Content-Type"]="application/json",p["Content-Length"]=Buffer.byteLength(s),p),c),a&&a.length>0&&a.forEach(function(h){return o.headers[h.name]=h.value}),this._config.httpsAgent?o.agent=this._config.httpsAgent:o.agent=$w.tlsRestrictedAgent,u=Gw.request(o,function(h){if(h.statusCode==200){var E=h.headers[tt.subscribed]==="true",S=h.headers[tt.endpointRedirect]?h.headers[tt.endpointRedirect].toString():null,j=h.headers[tt.pollingIntervalHint]?parseInt(h.headers[tt.pollingIntervalHint].toString()):null;f._consecutiveErrors=0,n(E,h,S,j)}else f._onError("StatusCode:"+h.statusCode+" StatusMessage:"+h.statusMessage),n()}),u.on("error",function(h){f._onError(h),n()}),u.write(s),u.end(),[2]})})},e.prototype._onError=function(t){this._consecutiveErrors++;var r="Transient error connecting to the Live Metrics endpoint. This packet will not appear in your Live Metrics Stream. Error:";this._consecutiveErrors%e.MAX_QPS_FAILURES_BEFORE_WARN==0?(r="Live Metrics endpoint could not be reached "+this._consecutiveErrors+" consecutive times. Most recent error:",Zy.warn(e.TAG,r,t)):Zy.info(e.TAG,r,t)},e.TAG="QuickPulseSender",e.MAX_QPS_FAILURES_BEFORE_WARN=25,e}();Jy.exports=zw});var aT=l((Aa,iT)=>{"use strict";var tT=Aa&&Aa.__awaiter||function(e,t,r,n){function i(a){return a instanceof r?a:new r(function(s){s(a)})}return new(r||(r=Promise))(function(a,s){function o(p){try{c(n.next(p))}catch(f){s(f)}}function u(p){try{c(n.throw(p))}catch(f){s(f)}}function c(p){p.done?a(p.value):i(p.value).then(o,u)}c((n=n.apply(e,t||[])).next())})},rT=Aa&&Aa.__generator||function(e,t){var r={label:0,sent:function(){if(a[0]&1)throw a[1];return a[1]},trys:[],ops:[]},n,i,a,s;return s={next:o(0),throw:o(1),return:o(2)},typeof Symbol=="function"&&(s[Symbol.iterator]=function(){return this}),s;function o(c){return function(p){return u([c,p])}}function u(c){if(n)throw new TypeError("Generator is already executing.");for(;r;)try{if(n=1,i&&(a=c[0]&2?i.return:c[0]?i.throw||((a=i.return)&&a.call(i),0):i.next)&&!(a=a.call(i,c[1])).done)return a;switch(i=0,a&&(c=[c[0]&2,a.value]),c[0]){case 0:case 1:a=c;break;case 4:return r.label++,{value:c[1],done:!1};case 5:r.label++,i=c[1],c=[0];continue;case 7:c=r.ops.pop(),r.trys.pop();continue;default:if(a=r.trys,!(a=a.length>0&&a[a.length-1])&&(c[0]===6||c[0]===2)){r=0;continue}if(c[0]===3&&(!a||c[1]>a[0]&&c[1]<a[3])){r.label=c[1];break}if(c[0]===6&&r.label<a[1]){r.label=a[1],a=c;break}if(a&&r.label<a[2]){r.label=a[2],r.ops.push(c);break}a[2]&&r.ops.pop(),r.trys.pop();continue}c=t.call(e,r)}catch(p){c=[6,p],i=0}finally{n=a=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}},nT=ve(),Jp=Ky(),Kw=eT(),Xw=kt(),Yw=ya(),Qw=function(){function e(t,r){this._isCollectingData=!1,this._lastSuccessTime=Date.now(),this._lastSendSucceeded=!0,this._metrics={},this._documents=[],this._collectors=[],this._redirectedHost=null,this._pollingIntervalHint=-1,this.config=t,this.context=r||new Yw,this._sender=new Kw(this.config),this._isEnabled=!1}return e.prototype.addCollector=function(t){this._collectors.push(t)},e.prototype.trackMetric=function(t){this._addMetric(t)},e.prototype.addDocument=function(t){var r=Jp.telemetryEnvelopeToQuickPulseDocument(t);r&&this._documents.push(r)},e.prototype.enable=function(t){t&&!this._isEnabled?(this._isEnabled=!0,this._goQuickPulse()):!t&&this._isEnabled&&(this._isEnabled=!1,clearTimeout(this._handle),this._handle=void 0)},e.prototype.enableCollectors=function(t){this._collectors.forEach(function(r){r.enable(t)})},e.prototype._addMetric=function(t){var r=t.value,n=t.count||1,i=Xw.PerformanceToQuickPulseCounter[t.name];i&&(this._metrics[i]?(this._metrics[i].Value=(this._metrics[i].Value*this._metrics[i].Weight+r*n)/(this._metrics[i].Weight+n),this._metrics[i].Weight+=n):(this._metrics[i]=Jp.createQuickPulseMetric(t),this._metrics[i].Name=i,this._metrics[i].Weight=1))},e.prototype._resetQuickPulseBuffer=function(){delete this._metrics,this._metrics={},this._documents.length=0},e.prototype._goQuickPulse=function(){return tT(this,void 0,void 0,function(){var t,r,n,i,a=this;return rT(this,function(s){switch(s.label){case 0:return t=Object.keys(this._metrics).map(function(o){return a._metrics[o]}),r=Jp.createQuickPulseEnvelope(t,this._documents.slice(),this.config,this.context),this._resetQuickPulseBuffer(),this._isCollectingData?[4,this._post(r)]:[3,2];case 1:return s.sent(),[3,3];case 2:this._ping(r),s.label=3;case 3:return n=this._pollingIntervalHint>0?this._pollingIntervalHint:e.PING_INTERVAL,i=this._isCollectingData?e.POST_INTERVAL:n,this._isCollectingData&&Date.now()-this._lastSuccessTime>=e.MAX_POST_WAIT_TIME&&!this._lastSendSucceeded?(this._isCollectingData=!1,i=e.FALLBACK_INTERVAL):!this._isCollectingData&&Date.now()-this._lastSuccessTime>=e.MAX_PING_WAIT_TIME&&!this._lastSendSucceeded&&(i=e.FALLBACK_INTERVAL),this._lastSendSucceeded=null,this._handle=setTimeout(this._goQuickPulse.bind(this),i),this._handle.unref(),[2]}})})},e.prototype._ping=function(t){this._sender.ping(t,this._redirectedHost,this._quickPulseDone.bind(this))},e.prototype._post=function(t){return tT(this,void 0,void 0,function(){return rT(this,function(r){switch(r.label){case 0:return[4,this._sender.post(t,this._redirectedHost,this._quickPulseDone.bind(this))];case 1:return r.sent(),[2]}})})},e.prototype._quickPulseDone=function(t,r,n,i){t!=null?(this._isCollectingData!==t&&(nT.info("Live Metrics sending data",t),this.enableCollectors(t)),this._isCollectingData=t,n&&n.length>0&&(this._redirectedHost=n,nT.info("Redirecting endpoint to: ",n)),i&&i>0&&(this._pollingIntervalHint=i),r&&r.statusCode<300&&r.statusCode>=200?(this._lastSuccessTime=Date.now(),this._lastSendSucceeded=!0):this._lastSendSucceeded=!1):this._lastSendSucceeded=!1},e.MAX_POST_WAIT_TIME=2e4,e.MAX_PING_WAIT_TIME=6e4,e.FALLBACK_INTERVAL=6e4,e.PING_INTERVAL=5e3,e.POST_INTERVAL=1e3,e}();iT.exports=Qw});var uT=l((Q1,oT)=>{"use strict";var sT=kt(),Ww=function(){function e(){}return e.parse=function(t){if(!t)return{};var r=t.split(e._FIELDS_SEPARATOR),n=r.reduce(function(a,s){var o=s.split(e._FIELD_KEY_VALUE_SEPARATOR);if(o.length===2){var u=o[0].toLowerCase(),c=o[1];a[u]=c}return a},{});if(Object.keys(n).length>0){if(n.endpointsuffix){var i=n.location?n.location+".":"";n.ingestionendpoint=n.ingestionendpoint||"https://"+i+"dc."+n.endpointsuffix,n.liveendpoint=n.liveendpoint||"https://"+i+"live."+n.endpointsuffix}n.ingestionendpoint=n.ingestionendpoint||sT.DEFAULT_BREEZE_ENDPOINT,n.liveendpoint=n.liveendpoint||sT.DEFAULT_LIVEMETRICS_ENDPOINT}return n},e._FIELDS_SEPARATOR=";",e._FIELD_KEY_VALUE_SEPARATOR="=",e}();oT.exports=Ww});var tf=l((Z1,pT)=>{"use strict";var ef=Gr(),cT=uT(),W1=ve(),lT=kt(),Zw=__webpack_require__(8835),Jw=function(){function e(t){var r=this;this.endpointBase=lT.DEFAULT_BREEZE_ENDPOINT;var n=process.env[e.ENV_connectionString],i=cT.parse(t),a=cT.parse(n),s=!i.instrumentationkey&&Object.keys(i).length>0?null:t;this.instrumentationKey=i.instrumentationkey||s||a.instrumentationkey||e._getInstrumentationKey(),!e._validateInstrumentationKey(this.instrumentationKey),this.endpointUrl=(i.ingestionendpoint||a.ingestionendpoint||this.endpointBase)+"/v2.1/track",this.maxBatchSize=250,this.maxBatchIntervalMs=15e3,this.disableAppInsights=!1,this.samplingPercentage=100,this.correlationIdRetryIntervalMs=30*1e3,this.correlationHeaderExcludedDomains=["*.core.windows.net","*.core.chinacloudapi.cn","*.core.cloudapi.de","*.core.usgovcloudapi.net","*.core.microsoft.scloud","*.core.eaglex.ic.gov"],this.setCorrelationId=function(o){return r.correlationId=o},this.proxyHttpUrl=process.env[e.ENV_http_proxy]||void 0,this.proxyHttpsUrl=process.env[e.ENV_https_proxy]||void 0,this.httpAgent=void 0,this.httpsAgent=void 0,this.profileQueryEndpoint=i.ingestionendpoint||a.ingestionendpoint||process.env[e.ENV_profileQueryEndpoint]||this.endpointBase,this._quickPulseHost=i.liveendpoint||a.liveendpoint||process.env[e.ENV_quickPulseHost]||lT.DEFAULT_LIVEMETRICS_HOST,this._quickPulseHost.match(/^https?:\/\//)&&(this._quickPulseHost=Zw.parse(this._quickPulseHost).host)}return Object.defineProperty(e.prototype,"profileQueryEndpoint",{get:function(){return this._profileQueryEndpoint},set:function(t){ef.cancelCorrelationIdQuery(this,this.setCorrelationId),this._profileQueryEndpoint=t,this.correlationId=ef.correlationIdPrefix,ef.queryCorrelationId(this,this.setCorrelationId)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"quickPulseHost",{get:function(){return this._quickPulseHost},set:function(t){this._quickPulseHost=t},enumerable:!1,configurable:!0}),e._getInstrumentationKey=function(){var t=process.env[e.ENV_iKey]||process.env[e.ENV_azurePrefix+e.ENV_iKey]||process.env[e.legacy_ENV_iKey]||process.env[e.ENV_azurePrefix+e.legacy_ENV_iKey];if(!t||t=="")throw new Error("Instrumentation key not found, pass the key in the config to this method or set the key in the environment variable APPINSIGHTS_INSTRUMENTATIONKEY before starting the server");return t},e._validateInstrumentationKey=function(t){var r="^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$",n=new RegExp(r);return n.test(t)},e.ENV_azurePrefix="APPSETTING_",e.ENV_iKey="APPINSIGHTS_INSTRUMENTATIONKEY",e.legacy_ENV_iKey="APPINSIGHTS_INSTRUMENTATION_KEY",e.ENV_profileQueryEndpoint="APPINSIGHTS_PROFILE_QUERY_ENDPOINT",e.ENV_quickPulseHost="APPINSIGHTS_QUICKPULSE_HOST",e.ENV_connectionString="APPLICATIONINSIGHTS_CONNECTION_STRING",e.ENV_nativeMetricsDisablers="APPLICATION_INSIGHTS_DISABLE_EXTENDED_METRIC",e.ENV_nativeMetricsDisableAll="APPLICATION_INSIGHTS_DISABLE_ALL_EXTENDED_METRICS",e.ENV_http_proxy="http_proxy",e.ENV_https_proxy="https_proxy",e}();pT.exports=Jw});var dT=l(hi=>{"use strict";var su=hi&&hi.__assign||function(){return su=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++){t=arguments[r];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},su.apply(this,arguments)};Object.defineProperty(hi,"__esModule",{value:!0});hi.AutoCollectNativePerformance=void 0;var fT=tf(),Ia=ya(),ex=ve(),tx=function(){function e(t){this._disabledMetrics={},e.INSTANCE&&e.INSTANCE.dispose(),e.INSTANCE=this,this._client=t}return e.isNodeVersionCompatible=function(){var t=process.versions.node.split(".");return parseInt(t[0])>=6},e.prototype.enable=function(t,r,n){var i=this;if(r===void 0&&(r={}),n===void 0&&(n=6e4),!!e.isNodeVersionCompatible()){if(e._metricsAvailable==null&&t&&!this._isInitialized)try{var a=__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'applicationinsights-native-metrics'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));e._emitter=new a,e._metricsAvailable=!0,ex.info("Native metrics module successfully loaded!")}catch(s){e._metricsAvailable=!1;return}this._isEnabled=t,this._disabledMetrics=r,this._isEnabled&&!this._isInitialized&&(this._isInitialized=!0),this._isEnabled&&e._emitter?(e._emitter.enable(!0,n),this._handle||(this._handle=setInterval(function(){return i._trackNativeMetrics()},n),this._handle.unref())):e._emitter&&(e._emitter.enable(!1),this._handle&&(clearInterval(this._handle),this._handle=void 0))}},e.prototype.dispose=function(){this.enable(!1)},e.parseEnabled=function(t){var r=process.env[fT.ENV_nativeMetricsDisableAll],n=process.env[fT.ENV_nativeMetricsDisablers];if(r)return{isEnabled:!1,disabledMetrics:{}};if(n){var i=n.split(","),a={};if(i.length>0)for(var s=0,o=i;s<o.length;s++){var u=o[s];a[u]=!0}return typeof t=="object"?{isEnabled:!0,disabledMetrics:su(su({},t),a)}:{isEnabled:t,disabledMetrics:a}}return typeof t=="boolean"?{isEnabled:t,disabledMetrics:{}}:{isEnabled:!0,disabledMetrics:t}},e.prototype._trackNativeMetrics=function(){var t=!0;typeof this._isEnabled!="object"&&(t=this._isEnabled),t&&(this._trackGarbageCollection(),this._trackEventLoop(),this._trackHeapUsage())},e.prototype._trackGarbageCollection=function(){var t;if(!this._disabledMetrics.gc){var r=e._emitter.getGCData();for(var n in r){var i=r[n].metrics,a=n+" Garbage Collection Duration",s=Math.sqrt(i.sumSquares/i.count-Math.pow(i.total/i.count,2))||0;this._client.trackMetric({name:a,value:i.total,count:i.count,max:i.max,min:i.min,stdDev:s,tagOverrides:(t={},t[this._client.context.keys.internalSdkVersion]="node-nativeperf:"+Ia.sdkVersion,t)})}}},e.prototype._trackEventLoop=function(){var t;if(!this._disabledMetrics.loop){var r=e._emitter.getLoopData(),n=r.loopUsage;if(n.count!=0){var i="Event Loop CPU Time",a=Math.sqrt(n.sumSquares/n.count-Math.pow(n.total/n.count,2))||0;this._client.trackMetric({name:i,value:n.total,count:n.count,min:n.min,max:n.max,stdDev:a,tagOverrides:(t={},t[this._client.context.keys.internalSdkVersion]="node-nativeperf:"+Ia.sdkVersion,t)})}}},e.prototype._trackHeapUsage=function(){var t,r,n;if(!this._disabledMetrics.heap){var i=process.memoryUsage(),a=i.heapUsed,s=i.heapTotal,o=i.rss;this._client.trackMetric({name:"Memory Usage (Heap)",value:a,count:1,tagOverrides:(t={},t[this._client.context.keys.internalSdkVersion]="node-nativeperf:"+Ia.sdkVersion,t)}),this._client.trackMetric({name:"Memory Total (Heap)",value:s,count:1,tagOverrides:(r={},r[this._client.context.keys.internalSdkVersion]="node-nativeperf:"+Ia.sdkVersion,r)}),this._client.trackMetric({name:"Memory Usage (Non-Heap)",value:o-s,count:1,tagOverrides:(n={},n[this._client.context.keys.internalSdkVersion]="node-nativeperf:"+Ia.sdkVersion,n)})}},e}();hi.AutoCollectNativePerformance=tx});var _T=l((ej,hT)=>{"use strict";var rx=ve(),nx=function(){function e(t,r,n,i){this._buffer=[],this._lastSend=0,this._isDisabled=t,this._getBatchSize=r,this._getBatchIntervalMs=n,this._sender=i}return e.prototype.setUseDiskRetryCaching=function(t,r,n){this._sender.setDiskRetryMode(t,r,n)},e.prototype.send=function(t){var r=this;if(!this._isDisabled()){if(!t){rx.warn("Cannot send null/undefined telemetry");return}if(this._buffer.push(t),this._buffer.length>=this._getBatchSize()){this.triggerSend(!1);return}!this._timeoutHandle&&this._buffer.length>0&&(this._timeoutHandle=setTimeout(function(){r._timeoutHandle=null,r.triggerSend(!1)},this._getBatchIntervalMs()))}},e.prototype.triggerSend=function(t,r){var n=this._buffer.length<1;n||(t?(this._sender.saveOnCrash(this._buffer),typeof r=="function"&&r("data saved on crash")):this._sender.send(this._buffer,r)),this._lastSend=+new Date,this._buffer=[],clearTimeout(this._timeoutHandle),this._timeoutHandle=null,n&&typeof r=="function"&&r("no data to send")},e}();hT.exports=nx});var vT=l(ou=>{"use strict";Object.defineProperty(ou,"__esModule",{value:!0});ou.azureRoleEnvironmentTelemetryProcessor=void 0;function ix(e,t){process.env.WEBSITE_SITE_NAME&&(e.tags[t.keys.cloudRole]=process.env.WEBSITE_SITE_NAME)}ou.azureRoleEnvironmentTelemetryProcessor=ix});var mT=l(_i=>{"use strict";Object.defineProperty(_i,"__esModule",{value:!0});_i.getSamplingHashCode=_i.samplingTelemetryProcessor=void 0;var gT=De();function ax(e,t){var r=e.sampleRate,n=!1;return r==null||r>=100||e.data&&gT.TelemetryType.Metric===gT.baseTypeToTelemetryType(e.data.baseType)?!0:(t.correlationContext&&t.correlationContext.operation?n=ET(t.correlationContext.operation.id)<r:n=Math.random()*100<r,n)}_i.samplingTelemetryProcessor=ax;function ET(e){var t=-2147483648,r=2147483647,n=5381;if(!e)return 0;for(;e.length<8;)e=e+e;for(var i=0;i<e.length;i++)n=((n<<5)+n|0)+e.charCodeAt(i)|0;return n=n<=t?r:Math.abs(n),n/r*100}_i.getSamplingHashCode=ET});var yT=l(uu=>{"use strict";Object.defineProperty(uu,"__esModule",{value:!0});uu.performanceMetricsTelemetryProcessor=void 0;var rf=eu(),nf=De();function sx(e,t){switch(t&&t.addDocument(e),e.data.baseType){case nf.TelemetryTypeString.Exception:rf.countException();break;case nf.TelemetryTypeString.Request:var r=e.data.baseData;rf.countRequest(r.duration,r.success);break;case nf.TelemetryTypeString.Dependency:var n=e.data.baseData;rf.countDependency(n.duration,n.success);break}return!0}uu.performanceMetricsTelemetryProcessor=sx});var TT=l(vi=>{"use strict";var yt=vi&&vi.__assign||function(){return yt=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++){t=arguments[r];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},yt.apply(this,arguments)};Object.defineProperty(vi,"__esModule",{value:!0});vi.preAggregatedMetricsTelemetryProcessor=void 0;var ox=De(),ba=Bp(),cu=De();function ux(e,t){if(ba.isEnabled())switch(e.data.baseType){case cu.TelemetryTypeString.Exception:var r=e.data.baseData;r.properties=yt(yt({},r.properties),{"_MS.ProcessedByMetricExtractors":"(Name:'Exceptions', Ver:'1.1')"});var n={cloudRoleInstance:e.tags[t.keys.cloudRoleInstance],cloudRoleName:e.tags[t.keys.cloudRole]};ba.countException(n);break;case cu.TelemetryTypeString.Trace:var i=e.data.baseData;i.properties=yt(yt({},i.properties),{"_MS.ProcessedByMetricExtractors":"(Name:'Traces', Ver:'1.1')"});var a={cloudRoleInstance:e.tags[t.keys.cloudRoleInstance],cloudRoleName:e.tags[t.keys.cloudRole],traceSeverityLevel:ox.SeverityLevel[i.severity]};ba.countTrace(a);break;case cu.TelemetryTypeString.Request:var s=e.data.baseData;s.properties=yt(yt({},s.properties),{"_MS.ProcessedByMetricExtractors":"(Name:'Requests', Ver:'1.1')"});var o={cloudRoleInstance:e.tags[t.keys.cloudRoleInstance],cloudRoleName:e.tags[t.keys.cloudRole],operationSynthetic:e.tags[t.keys.operationSyntheticSource],requestSuccess:s.success,requestResultCode:s.responseCode};ba.countRequest(s.duration,o);break;case cu.TelemetryTypeString.Dependency:var u=e.data.baseData;u.properties=yt(yt({},u.properties),{"_MS.ProcessedByMetricExtractors":"(Name:'Dependencies', Ver:'1.1')"});var c={cloudRoleInstance:e.tags[t.keys.cloudRoleInstance],cloudRoleName:e.tags[t.keys.cloudRole],operationSynthetic:e.tags[t.keys.operationSyntheticSource],dependencySuccess:u.success,dependencyType:u.type,dependencyTarget:u.target,dependencyResultCode:u.resultCode};ba.countDependency(u.duration,c);break}return!0}vi.preAggregatedMetricsTelemetryProcessor=ux});var ST=l(Tt=>{"use strict";var cx=Tt&&Tt.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),lu=Tt&&Tt.__exportStar||function(e,t){for(var r in e)r!=="default"&&!Object.prototype.hasOwnProperty.call(t,r)&&cx(t,e,r)};Object.defineProperty(Tt,"__esModule",{value:!0});lu(vT(),Tt);lu(mT(),Tt);lu(yT(),Tt);lu(TT(),Tt)});var bT=l((Ca,IT)=>{"use strict";var lx=Ca&&Ca.__awaiter||function(e,t,r,n){function i(a){return a instanceof r?a:new r(function(s){s(a)})}return new(r||(r=Promise))(function(a,s){function o(p){try{c(n.next(p))}catch(f){s(f)}}function u(p){try{c(n.throw(p))}catch(f){s(f)}}function c(p){p.done?a(p.value):i(p.value).then(o,u)}c((n=n.apply(e,t||[])).next())})},px=Ca&&Ca.__generator||function(e,t){var r={label:0,sent:function(){if(a[0]&1)throw a[1];return a[1]},trys:[],ops:[]},n,i,a,s;return s={next:o(0),throw:o(1),return:o(2)},typeof Symbol=="function"&&(s[Symbol.iterator]=function(){return this}),s;function o(c){return function(p){return u([c,p])}}function u(c){if(n)throw new TypeError("Generator is already executing.");for(;r;)try{if(n=1,i&&(a=c[0]&2?i.return:c[0]?i.throw||((a=i.return)&&a.call(i),0):i.next)&&!(a=a.call(i,c[1])).done)return a;switch(i=0,a&&(c=[c[0]&2,a.value]),c[0]){case 0:case 1:a=c;break;case 4:return r.label++,{value:c[1],done:!1};case 5:r.label++,i=c[1],c=[0];continue;case 7:c=r.ops.pop(),r.trys.pop();continue;default:if(a=r.trys,!(a=a.length>0&&a[a.length-1])&&(c[0]===6||c[0]===2)){r=0;continue}if(c[0]===3&&(!a||c[1]>a[0]&&c[1]<a[3])){r.label=c[1];break}if(c[0]===6&&r.label<a[1]){r.label=a[1],a=c;break}if(a&&r.label<a[2]){r.label=a[2],r.ops.push(c);break}a[2]&&r.ops.pop(),r.trys.pop();continue}c=t.call(e,r)}catch(p){c=[6,p],i=0}finally{n=a=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}},Ee=__webpack_require__(5747),AT=__webpack_require__(2087),Bt=__webpack_require__(5622),fx=__webpack_require__(8761),gi=__webpack_require__(3129),me=ve(),dx=di(),pu=Be(),hx=function(){function e(t,r,n){if(this._redirectedHost=null,this._config=t,this._onSuccess=r,this._onError=n,this._enableDiskRetryMode=!1,this._resendInterval=e.WAIT_BETWEEN_RESEND,this._maxBytesOnDisk=e.MAX_BYTES_ON_DISK,this._numConsecutiveFailures=0,this._numConsecutiveRedirects=0,this._resendTimer=null,this._fileCleanupTimer=null,this._tempDir=Bt.join(AT.tmpdir(),e.TEMPDIR_PREFIX+this._config.instrumentationKey),!e.OS_PROVIDES_FILE_PROTECTION)if(e.USE_ICACLS){try{e.OS_PROVIDES_FILE_PROTECTION=Ee.existsSync(e.ICACLS_PATH)}catch(i){}e.OS_PROVIDES_FILE_PROTECTION||me.warn(e.TAG,"Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.")}else e.OS_PROVIDES_FILE_PROTECTION=!0}return e.prototype.setDiskRetryMode=function(t,r,n){var i=this;this._enableDiskRetryMode=e.OS_PROVIDES_FILE_PROTECTION&&t,typeof r=="number"&&r>=0&&(this._resendInterval=Math.floor(r)),typeof n=="number"&&n>=0&&(this._maxBytesOnDisk=Math.floor(n)),t&&!e.OS_PROVIDES_FILE_PROTECTION&&(this._enableDiskRetryMode=!1,me.warn(e.TAG,"Ignoring request to enable disk retry mode. Sufficient file protection capabilities were not detected.")),this._enableDiskRetryMode?this._fileCleanupTimer||(this._fileCleanupTimer=setTimeout(function(){i._fileCleanupTask()},e.CLEANUP_TIMEOUT),this._fileCleanupTimer.unref()):this._fileCleanupTimer&&clearTimeout(this._fileCleanupTimer)},e.prototype.send=function(t,r){return lx(this,void 0,void 0,function(){var n,i,a,s,o=this;return px(this,function(u){return t&&(n=this._redirectedHost||this._config.endpointUrl,i={method:"POST",withCredentials:!1,headers:{"Content-Type":"application/x-json-stream"}},a="",t.forEach(function(c){var p=o._stringify(c);typeof p=="string"&&(a+=p+`
`)}),a.length>0&&(a=a.substring(0,a.length-1)),s=Buffer.from?Buffer.from(a):new Buffer(a),fx.gzip(s,function(c,p){var f=p;c?(me.warn(c),f=s,i.headers["Content-Length"]=s.length.toString()):(i.headers["Content-Encoding"]="gzip",i.headers["Content-Length"]=p.length.toString()),me.info(e.TAG,i),i[dx.disableCollectionRequestOption]=!0;var d=function(E){E.setEncoding("utf-8");var S="";E.on("data",function(j){S+=j}),E.on("end",function(){if(o._numConsecutiveFailures=0,o._enableDiskRetryMode){if(E.statusCode===200)o._resendTimer||(o._resendTimer=setTimeout(function(){o._resendTimer=null,o._sendFirstFileOnDisk()},o._resendInterval),o._resendTimer.unref());else if(o._isRetriable(E.statusCode))try{var j=JSON.parse(S),oe=[];j.errors.forEach(function(At){o._isRetriable(At.statusCode)&&oe.push(t[At.index])}),oe.length>0&&o._storeToDisk(oe)}catch(At){o._storeToDisk(t)}}if(E.statusCode===307||E.statusCode===308)if(o._numConsecutiveRedirects++,o._numConsecutiveRedirects<10){var Ae=E.headers.location?E.headers.location.toString():null;Ae&&(o._redirectedHost=Ae,o.send(t,r))}else typeof r=="function"&&r("Error sending telemetry because of circular redirects.");else o._numConsecutiveRedirects=0,typeof r=="function"&&r(S),me.info(e.TAG,S),typeof o._onSuccess=="function"&&o._onSuccess(S)})},h=pu.makeRequest(o._config,n,i,d);h.on("error",function(E){if(o._numConsecutiveFailures++,!o._enableDiskRetryMode||o._numConsecutiveFailures>0&&o._numConsecutiveFailures%e.MAX_CONNECTION_FAILURES_BEFORE_WARN==0){var S="Ingestion endpoint could not be reached. This batch of telemetry items has been lost. Use Disk Retry Caching to enable resending of failed telemetry. Error:";o._enableDiskRetryMode&&(S="Ingestion endpoint could not be reached "+o._numConsecutiveFailures+" consecutive times. There may be resulting telemetry loss. Most recent error:"),me.warn(e.TAG,S,pu.dumpObj(E))}else{var S="Transient failure to reach ingestion endpoint. This batch of telemetry items will be retried. Error:";me.info(e.TAG,S,pu.dumpObj(E))}o._onErrorHelper(E),typeof r=="function"&&(E&&r(pu.dumpObj(E)),r("Error sending telemetry")),o._enableDiskRetryMode&&o._storeToDisk(t)}),h.write(f),h.end()})),[2]})})},e.prototype.saveOnCrash=function(t){this._enableDiskRetryMode&&this._storeToDiskSync(this._stringify(t))},e.prototype._isRetriable=function(t){return t===206||t===408||t===429||t===439||t===500||t===503},e.prototype._runICACLS=function(t,r){var n=gi.spawn(e.ICACLS_PATH,t,{windowsHide:!0});n.on("error",function(i){return r(i)}),n.on("close",function(i,a){return r(i===0?null:new Error("Setting ACL restrictions did not succeed (ICACLS returned code "+i+")"))})},e.prototype._runICACLSSync=function(t){if(gi.spawnSync){var r=gi.spawnSync(e.ICACLS_PATH,t,{windowsHide:!0});if(r.error)throw r.error;if(r.status!==0)throw new Error("Setting ACL restrictions did not succeed (ICACLS returned code "+r.status+")")}else throw new Error("Could not synchronously call ICACLS under current version of Node.js")},e.prototype._getACLIdentity=function(t){if(e.ACL_IDENTITY)return t(null,e.ACL_IDENTITY);var r=gi.spawn(e.POWERSHELL_PATH,["-Command","[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"],{windowsHide:!0,stdio:["ignore","pipe","pipe"]}),n="";r.stdout.on("data",function(i){return n+=i}),r.on("error",function(i){return t(i,null)}),r.on("close",function(i,a){return e.ACL_IDENTITY=n&&n.trim(),t(i===0?null:new Error("Getting ACL identity did not succeed (PS returned code "+i+")"),e.ACL_IDENTITY)})},e.prototype._getACLIdentitySync=function(){if(e.ACL_IDENTITY)return e.ACL_IDENTITY;if(gi.spawnSync){var t=gi.spawnSync(e.POWERSHELL_PATH,["-Command","[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"],{windowsHide:!0,stdio:["ignore","pipe","pipe"]});if(t.error)throw t.error;if(t.status!==0)throw new Error("Getting ACL identity did not succeed (PS returned code "+t.status+")");return e.ACL_IDENTITY=t.stdout&&t.stdout.toString().trim(),e.ACL_IDENTITY}else throw new Error("Could not synchronously get ACL identity under current version of Node.js")},e.prototype._getACLArguments=function(t,r){return[t,"/grant","*S-1-5-32-544:(OI)(CI)F","/grant",r+":(OI)(CI)F","/inheritance:r"]},e.prototype._applyACLRules=function(t,r){var n=this;if(!e.USE_ICACLS)return r(null);if(e.ACLED_DIRECTORIES[t]===void 0)e.ACLED_DIRECTORIES[t]=!1,this._getACLIdentity(function(i,a){if(i)return e.ACLED_DIRECTORIES[t]=!1,r(i);n._runICACLS(n._getACLArguments(t,a),function(s){return e.ACLED_DIRECTORIES[t]=!s,r(s)})});else return r(e.ACLED_DIRECTORIES[t]?null:new Error("Setting ACL restrictions did not succeed (cached result)"))},e.prototype._applyACLRulesSync=function(t){if(e.USE_ICACLS){if(e.ACLED_DIRECTORIES[t]===void 0){this._runICACLSSync(this._getACLArguments(t,this._getACLIdentitySync())),e.ACLED_DIRECTORIES[t]=!0;return}else if(!e.ACLED_DIRECTORIES[t])throw new Error("Setting ACL restrictions did not succeed (cached result)")}},e.prototype._confirmDirExists=function(t,r){var n=this;Ee.lstat(t,function(i,a){i&&i.code==="ENOENT"?Ee.mkdir(t,function(s){s&&s.code!=="EEXIST"?r(s):n._applyACLRules(t,r)}):!i&&a.isDirectory()?n._applyACLRules(t,r):r(i||new Error("Path existed but was not a directory"))})},e.prototype._getShallowDirectorySize=function(t,r){Ee.readdir(t,function(n,i){if(n)return r(n,-1);var a=null,s=0,o=0;if(i.length===0){r(null,0);return}for(var u=0;u<i.length;u++)Ee.stat(Bt.join(t,i[u]),function(c,p){o++,c?a=c:p.isFile()&&(s+=p.size),o===i.length&&(a?r(a,-1):r(a,s))})})},e.prototype._getShallowDirectorySizeSync=function(t){for(var r=Ee.readdirSync(t),n=0,i=0;i<r.length;i++)n+=Ee.statSync(Bt.join(t,r[i])).size;return n},e.prototype._storeToDisk=function(t){var r=this;me.info(e.TAG,"Checking existence of data storage directory: "+this._tempDir),this._confirmDirExists(this._tempDir,function(n){if(n){me.warn(e.TAG,"Error while checking/creating directory: "+(n&&n.message)),r._onErrorHelper(n);return}r._getShallowDirectorySize(r._tempDir,function(i,a){if(i||a<0){me.warn(e.TAG,"Error while checking directory size: "+(i&&i.message)),r._onErrorHelper(i);return}else if(a>r._maxBytesOnDisk){me.warn(e.TAG,"Not saving data due to max size limit being met. Directory size in bytes is: "+a);return}var s=new Date().getTime()+".ai.json",o=Bt.join(r._tempDir,s);me.info(e.TAG,"saving data to disk at: "+o),Ee.writeFile(o,r._stringify(t),{mode:384},function(u){return r._onErrorHelper(u)})})})},e.prototype._storeToDiskSync=function(t){try{me.info(e.TAG,"Checking existence of data storage directory: "+this._tempDir),Ee.existsSync(this._tempDir)||Ee.mkdirSync(this._tempDir),this._applyACLRulesSync(this._tempDir);var r=this._getShallowDirectorySizeSync(this._tempDir);if(r>this._maxBytesOnDisk){me.info(e.TAG,"Not saving data due to max size limit being met. Directory size in bytes is: "+r);return}var n=new Date().getTime()+".ai.json",i=Bt.join(this._tempDir,n);me.info(e.TAG,"saving data before crash to disk at: "+i),Ee.writeFileSync(i,t,{mode:384})}catch(a){me.warn(e.TAG,"Error while saving data to disk: "+(a&&a.message)),this._onErrorHelper(a)}},e.prototype._sendFirstFileOnDisk=function(){var t=this;Ee.exists(this._tempDir,function(r){r&&Ee.readdir(t._tempDir,function(n,i){if(n)t._onErrorHelper(n);else if(i=i.filter(function(o){return Bt.basename(o).indexOf(".ai.json")>-1}),i.length>0){var a=i[0],s=Bt.join(t._tempDir,a);Ee.readFile(s,function(o,u){o?t._onErrorHelper(o):Ee.unlink(s,function(c){if(c)t._onErrorHelper(c);else try{var p=JSON.parse(u.toString());t.send(p)}catch(f){me.warn("Failed to read persisted file",f)}})})}})})},e.prototype._onErrorHelper=function(t){typeof this._onError=="function"&&this._onError(t)},e.prototype._stringify=function(t){try{return JSON.stringify(t)}catch(r){me.warn("Failed to serialize payload",r,t)}},e.prototype._fileCleanupTask=function(){var t=this;Ee.exists(this._tempDir,function(r){r&&Ee.readdir(t._tempDir,function(n,i){n?t._onErrorHelper(n):(i=i.filter(function(a){return Bt.basename(a).indexOf(".ai.json")>-1}),i.length>0&&i.forEach(function(a){var s=new Date(parseInt(a.split(".ai.json")[0])),o=new Date(+new Date-e.FILE_RETEMPTION_PERIOD)>s;if(o){var u=Bt.join(t._tempDir,a);Ee.unlink(u,function(c){c&&t._onErrorHelper(c)})}}))})})},e.TAG="Sender",e.ICACLS_PATH=process.env.systemdrive+"/windows/system32/icacls.exe",e.POWERSHELL_PATH=process.env.systemdrive+"/windows/system32/windowspowershell/v1.0/powershell.exe",e.ACLED_DIRECTORIES={},e.ACL_IDENTITY=null,e.WAIT_BETWEEN_RESEND=60*1e3,e.MAX_BYTES_ON_DISK=50*1024*1024,e.MAX_CONNECTION_FAILURES_BEFORE_WARN=5,e.CLEANUP_TIMEOUT=60*60*1e3,e.FILE_RETEMPTION_PERIOD=7*24*60*60*1e3,e.TEMPDIR_PREFIX="appInsights-node",e.OS_PROVIDES_FILE_PROTECTION=!1,e.USE_ICACLS=AT.type()==="Windows_NT",e}();IT.exports=hx});var PT=l((sj,OT)=>{"use strict";var A=De(),rt=Be(),_x=gr(),vx=function(){function e(){}return e.createEnvelope=function(t,r,n,i,a){var s=null;switch(r){case A.TelemetryType.Trace:s=e.createTraceData(t);break;case A.TelemetryType.Dependency:s=e.createDependencyData(t);break;case A.TelemetryType.Event:s=e.createEventData(t);break;case A.TelemetryType.Exception:s=e.createExceptionData(t);break;case A.TelemetryType.Request:s=e.createRequestData(t);break;case A.TelemetryType.Metric:s=e.createMetricData(t);break;case A.TelemetryType.Availability:s=e.createAvailabilityData(t);break;case A.TelemetryType.PageView:s=e.createPageViewData(t);break}if(n&&A.domainSupportsProperties(s.baseData)){if(s&&s.baseData)if(!s.baseData.properties)s.baseData.properties=n;else for(var o in n)s.baseData.properties[o]||(s.baseData.properties[o]=n[o]);s.baseData.properties=rt.validateStringMap(s.baseData.properties)}var u=a&&a.instrumentationKey||"",c=new A.Envelope;return c.data=s,c.iKey=u,c.name="Microsoft.ApplicationInsights."+u.replace(/-/g,"")+"."+s.baseType.substr(0,s.baseType.length-4),c.tags=this.getTags(i,t.tagOverrides),c.time=new Date().toISOString(),c.ver=1,c.sampleRate=a?a.samplingPercentage:100,r===A.TelemetryType.Metric&&(c.sampleRate=100),c},e.createTraceData=function(t){var r=new A.MessageData;r.message=t.message,r.properties=t.properties,isNaN(t.severity)?r.severityLevel=A.SeverityLevel.Information:r.severityLevel=t.severity;var n=new A.Data;return n.baseType=A.telemetryTypeToBaseType(A.TelemetryType.Trace),n.baseData=r,n},e.createDependencyData=function(t){var r=new A.RemoteDependencyData;typeof t.name=="string"&&(r.name=t.name.length>1024?t.name.slice(0,1021)+"...":t.name),r.data=t.data,r.target=t.target,r.duration=rt.msToTimeSpan(t.duration),r.success=t.success,r.type=t.dependencyTypeName,r.properties=t.properties,r.resultCode=t.resultCode?t.resultCode+"":"",t.id?r.id=t.id:r.id=rt.w3cTraceId();var n=new A.Data;return n.baseType=A.telemetryTypeToBaseType(A.TelemetryType.Dependency),n.baseData=r,n},e.createEventData=function(t){var r=new A.EventData;r.name=t.name,r.properties=t.properties,r.measurements=t.measurements;var n=new A.Data;return n.baseType=A.telemetryTypeToBaseType(A.TelemetryType.Event),n.baseData=r,n},e.createExceptionData=function(t){var r=new A.ExceptionData;r.properties=t.properties,isNaN(t.severity)?r.severityLevel=A.SeverityLevel.Error:r.severityLevel=t.severity,r.measurements=t.measurements,r.exceptions=[];var n=t.exception.stack,i=new A.ExceptionDetails;i.message=t.exception.message,i.typeName=t.exception.name,i.parsedStack=this.parseStack(n),i.hasFullStack=rt.isArray(i.parsedStack)&&i.parsedStack.length>0,r.exceptions.push(i);var a=new A.Data;return a.baseType=A.telemetryTypeToBaseType(A.TelemetryType.Exception),a.baseData=r,a},e.createRequestData=function(t){var r=new A.RequestData;t.id?r.id=t.id:r.id=rt.w3cTraceId(),r.name=t.name,r.url=t.url,r.source=t.source,r.duration=rt.msToTimeSpan(t.duration),r.responseCode=t.resultCode?t.resultCode+"":"",r.success=t.success,r.properties=t.properties;var n=new A.Data;return n.baseType=A.telemetryTypeToBaseType(A.TelemetryType.Request),n.baseData=r,n},e.createMetricData=function(t){var r=new A.MetricData;r.metrics=[];var n=new A.DataPoint;n.count=isNaN(t.count)?1:t.count,n.kind=A.DataPointType.Aggregation,n.max=isNaN(t.max)?t.value:t.max,n.min=isNaN(t.min)?t.value:t.min,n.name=t.name,n.stdDev=isNaN(t.stdDev)?0:t.stdDev,n.value=t.value,r.metrics.push(n),r.properties=t.properties;var i=new A.Data;return i.baseType=A.telemetryTypeToBaseType(A.TelemetryType.Metric),i.baseData=r,i},e.createAvailabilityData=function(t){var r=new A.AvailabilityData;t.id?r.id=t.id:r.id=rt.w3cTraceId(),r.name=t.name,r.duration=rt.msToTimeSpan(t.duration),r.success=t.success,r.runLocation=t.runLocation,r.message=t.message,r.measurements=t.measurements,r.properties=t.properties;var n=new A.Data;return n.baseType=A.telemetryTypeToBaseType(A.TelemetryType.Availability),n.baseData=r,n},e.createPageViewData=function(t){var r=new A.PageViewData;r.name=t.name,r.duration=rt.msToTimeSpan(t.duration),r.url=t.url,r.measurements=t.measurements,r.properties=t.properties;var n=new A.Data;return n.baseType=A.telemetryTypeToBaseType(A.TelemetryType.PageView),n.baseData=r,n},e.getTags=function(t,r){var n=_x.CorrelationContextManager.getCurrentContext(),i={};if(t&&t.tags)for(var a in t.tags)i[a]=t.tags[a];if(r)for(var a in r)i[a]=r[a];return n&&(i[t.keys.operationId]=i[t.keys.operationId]||n.operation.id,i[t.keys.operationName]=i[t.keys.operationName]||n.operation.name,i[t.keys.operationParentId]=i[t.keys.operationParentId]||n.operation.parentId),i},e.parseStack=function(t){var r=void 0;if(typeof t=="string"){var n=t.split(`
`);r=[];for(var i=0,a=0,s=0;s<=n.length;s++){var o=n[s];if(CT.regex.test(o)){var u=new CT(n[s],i++);a+=u.sizeInBytes,r.push(u)}}var c=32*1024;if(a>c)for(var p=0,f=r.length-1,d=0,h=p,E=f;p<f;){var S=r[p].sizeInBytes,j=r[f].sizeInBytes;if(d+=S+j,d>c){var oe=E-h+1;r.splice(h,oe);break}h=p,E=f,p++,f--}}return r},e}(),CT=function(){function e(t,r){this.sizeInBytes=0,this.level=r,this.method="<no_method>",this.assembly=rt.trim(t);var n=t.match(e.regex);n&&n.length>=5&&(this.method=rt.trim(n[2])||this.method,this.fileName=rt.trim(n[4])||"<no_filename>",this.line=parseInt(n[5])||0),this.sizeInBytes+=this.method.length,this.sizeInBytes+=this.fileName.length,this.sizeInBytes+=this.assembly.length,this.sizeInBytes+=e.baseSize,this.sizeInBytes+=this.level.toString().length,this.sizeInBytes+=this.line.toString().length}return e.regex=/^(\s+at)?(.*?)(\@|\s\(|\s)([^\(\n]+):(\d+):(\d+)(\)?)$/,e.baseSize=58,e}();OT.exports=vx});var wT=l((oj,DT)=>{"use strict";var gx=__webpack_require__(8835),Ex=tf(),mx=ya(),Gt=De(),yx=_T(),fu=ST(),RT=gr(),Tx=bT(),af=Be(),NT=ve(),Sx=PT(),Ax=function(){function e(t){this._telemetryProcessors=[],this._enableAzureProperties=!1;var r=new Ex(t);this.config=r,this.context=new mx,this.commonProperties={};var n=new Tx(this.config);this.channel=new yx(function(){return r.disableAppInsights},function(){return r.maxBatchSize},function(){return r.maxBatchIntervalMs},n)}return e.prototype.trackAvailability=function(t){this.track(t,Gt.TelemetryType.Availability)},e.prototype.trackPageView=function(t){this.track(t,Gt.TelemetryType.PageView)},e.prototype.trackTrace=function(t){this.track(t,Gt.TelemetryType.Trace)},e.prototype.trackMetric=function(t){this.track(t,Gt.TelemetryType.Metric)},e.prototype.trackException=function(t){t&&t.exception&&!af.isError(t.exception)&&(t.exception=new Error(t.exception.toString())),this.track(t,Gt.TelemetryType.Exception)},e.prototype.trackEvent=function(t){this.track(t,Gt.TelemetryType.Event)},e.prototype.trackRequest=function(t){this.track(t,Gt.TelemetryType.Request)},e.prototype.trackDependency=function(t){t&&!t.target&&t.data&&(t.target=gx.parse(t.data).host),this.track(t,Gt.TelemetryType.Dependency)},e.prototype.flush=function(t){this.channel.triggerSend(t?!!t.isAppCrashing:!1,t?t.callback:void 0)},e.prototype.track=function(t,r){if(t&&Gt.telemetryTypeToBaseType(r)){var n=Sx.createEnvelope(t,r,this.commonProperties,this.context,this.config);t.time&&(n.time=t.time.toISOString()),this._enableAzureProperties&&fu.azureRoleEnvironmentTelemetryProcessor(n,this.context);var i=this.runTelemetryProcessors(n,t.contextObjects);i=i&&fu.samplingTelemetryProcessor(n,{correlationContext:RT.CorrelationContextManager.getCurrentContext()}),fu.preAggregatedMetricsTelemetryProcessor(n,this.context),i&&(fu.performanceMetricsTelemetryProcessor(n,this.quickPulseClient),this.channel.send(n))}else NT.warn("track() requires telemetry object and telemetryType to be specified.")},e.prototype.setAutoPopulateAzureProperties=function(t){this._enableAzureProperties=t},e.prototype.addTelemetryProcessor=function(t){this._telemetryProcessors.push(t)},e.prototype.clearTelemetryProcessors=function(){this._telemetryProcessors=[]},e.prototype.runTelemetryProcessors=function(t,r){var n=!0,i=this._telemetryProcessors.length;if(i===0)return n;r=r||{},r.correlationContext=RT.CorrelationContextManager.getCurrentContext();for(var a=0;a<i;++a)try{var s=this._telemetryProcessors[a];if(s&&s.apply(null,[t,r])===!1){n=!1;break}}catch(o){n=!0,NT.warn("One of telemetry processors failed, telemetry item will be sent.",o,t)}return n&&(t&&t.tags&&(t.tags=af.validateStringMap(t.tags)),t&&t.data&&t.data.baseData&&t.data.baseData.properties&&(t.data.baseData.properties=af.validateStringMap(t.data.baseData.properties))),n},e}();DT.exports=Ax});var LT=l((sf,MT)=>{"use strict";var Ix=sf&&sf.__extends||function(){var e=function(t,r){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(n[a]=i[a])},e(t,r)};return function(t,r){e(t,r);function n(){this.constructor=t}t.prototype=r===null?Object.create(r):(n.prototype=r.prototype,new n)}}(),bx=wT(),xT=Qp(),Cx=di(),du=ve(),Ox=function(e){Ix(t,e);function t(){return e!==null&&e.apply(this,arguments)||this}return t.prototype.trackNodeHttpRequestSync=function(r){r&&r.request&&r.response&&r.duration?xT.trackRequestSync(this,r):du.warn("trackNodeHttpRequestSync requires NodeHttpRequestTelemetry object with request, response and duration specified.")},t.prototype.trackNodeHttpRequest=function(r){(r.duration||r.error)&&du.warn("trackNodeHttpRequest will ignore supplied duration and error parameters. These values are collected from the request and response objects."),r&&r.request&&r.response?xT.trackRequest(this,r):du.warn("trackNodeHttpRequest requires NodeHttpRequestTelemetry object with request and response specified.")},t.prototype.trackNodeHttpDependency=function(r){r&&r.request?Cx.trackRequest(this,r):du.warn("trackNodeHttpDependency requires NodeHttpDependencyTelemetry object with request specified.")},t}(bx);MT.exports=Ox});var jT=l(qT=>{"use strict";Object.defineProperty(qT,"__esModule",{value:!0})});var iS=l(m=>{"use strict";Object.defineProperty(m,"__esModule",{value:!0});m.dispose=m.Configuration=m.wrapWithCorrelationContext=m.startOperation=m.getCorrelationContext=m.start=m.setup=m.liveMetricsClient=m.defaultClient=m.DistributedTracingModes=void 0;var of=gr(),Px=uy(),Rx=ly(),kT=eu(),Nx=Bp(),Dx=Hy(),wx=di(),xx=Qp(),HT=Gr(),Oa=ve(),Mx=aT(),UT=dT();m.TelemetryClient=LT();m.Contracts=De();m.azureFunctionsTypes=jT();var BT;(function(e){e[e.AI=0]="AI",e[e.AI_AND_W3C=1]="AI_AND_W3C"})(BT=m.DistributedTracingModes||(m.DistributedTracingModes={}));var GT=!0,FT=!1,VT=!0,$T=!0,zT=!0,KT=!1,XT=!0,YT=!0,QT=!0,uf=!0,WT,hu=!1,ZT=!0,JT,eS=void 0,tS=void 0,Pa,Ra,Na,Da,wa,Ei,en,xa,St=!1,rS;function Lx(e){return m.defaultClient?Oa.info("The default client is already setup"):(m.defaultClient=new m.TelemetryClient(e),Pa=new Px(m.defaultClient),Ra=new Rx(m.defaultClient),Na=new kT(m.defaultClient),Da=new Nx(m.defaultClient),wa=new Dx(m.defaultClient),en=new xx(m.defaultClient),xa=new wx(m.defaultClient),Ei||(Ei=new UT.AutoCollectNativePerformance(m.defaultClient))),m.defaultClient&&m.defaultClient.channel&&m.defaultClient.channel.setUseDiskRetryCaching(QT,eS,tS),cf}m.setup=Lx;function nS(){return m.defaultClient?(St=!0,Pa.enable(GT,FT),Ra.enable(VT),Na.enable($T),Da.enable(zT),wa.enable(KT,m.defaultClient.config),Ei.enable(ZT,JT),en.useAutoCorrelation(uf,WT),en.enable(XT),xa.enable(YT),m.liveMetricsClient&&hu&&m.liveMetricsClient.enable(hu)):Oa.warn("Start cannot be called before setup"),cf}m.start=nS;function qx(){return uf?of.CorrelationContextManager.getCurrentContext():null}m.getCorrelationContext=qx;function jx(e,t){return of.CorrelationContextManager.startOperation(e,t)}m.startOperation=jx;function kx(e,t){return of.CorrelationContextManager.wrapCallback(e,t)}m.wrapWithCorrelationContext=kx;var cf=function(){function e(){}return e.setDistributedTracingMode=function(t){return HT.w3cEnabled=t===BT.AI_AND_W3C,e},e.setAutoCollectConsole=function(t,r){return r===void 0&&(r=!1),GT=t,FT=r,St&&Pa.enable(t,r),e},e.setAutoCollectExceptions=function(t){return VT=t,St&&Ra.enable(t),e},e.setAutoCollectPerformance=function(t,r){r===void 0&&(r=!0),$T=t;var n=UT.AutoCollectNativePerformance.parseEnabled(r);return ZT=n.isEnabled,JT=n.disabledMetrics,St&&(Na.enable(t),Ei.enable(n.isEnabled,n.disabledMetrics)),e},e.setAutoCollectPreAggregatedMetrics=function(t){return zT=t,St&&Da.enable(t),e},e.setAutoCollectHeartbeat=function(t){return KT=t,St&&wa.enable(t,m.defaultClient.config),e},e.setAutoCollectRequests=function(t){return XT=t,St&&en.enable(t),e},e.setAutoCollectDependencies=function(t){return YT=t,St&&xa.enable(t),e},e.setAutoDependencyCorrelation=function(t,r){return uf=t,WT=r,St&&en.useAutoCorrelation(t,r),e},e.setUseDiskRetryCaching=function(t,r,n){return QT=t,eS=r,tS=n,m.defaultClient&&m.defaultClient.channel&&m.defaultClient.channel.setUseDiskRetryCaching(t,r,n),e},e.setInternalLogging=function(t,r){return t===void 0&&(t=!1),r===void 0&&(r=!0),Oa.enableDebug=t,Oa.disableWarnings=!r,e},e.setSendLiveMetrics=function(t){return t===void 0&&(t=!1),m.defaultClient?(!m.liveMetricsClient&&t?(m.liveMetricsClient=new Mx(m.defaultClient.config,null),rS=new kT(m.liveMetricsClient,1e3,!0),m.liveMetricsClient.addCollector(rS),m.defaultClient.quickPulseClient=m.liveMetricsClient):m.liveMetricsClient&&m.liveMetricsClient.enable(t),hu=t,e):(Oa.warn("Live metrics client cannot be setup without the default client"),e)},e.start=nS,e}();m.Configuration=cf;function Hx(){HT.w3cEnabled=!0,m.defaultClient=null,St=!1,Pa&&Pa.dispose(),Ra&&Ra.dispose(),Na&&Na.dispose(),Da&&Da.dispose(),wa&&wa.dispose(),Ei&&Ei.dispose(),en&&en.dispose(),xa&&xa.dispose(),m.liveMetricsClient&&(m.liveMetricsClient.enable(!1),hu=!1,m.liveMetricsClient=void 0)}m.dispose=Hx});fS(exports,{default:()=>lf});var mi=Ai(__webpack_require__(2087)),yi=Ai(__webpack_require__(7549));var W=Ai(__webpack_require__(7549));var Ii=Ai(__webpack_require__(7549)),He;(function(r){r.ON="on",r.OFF="off"})(He||(He={}));function nn(){let e="telemetry",t="enableTelemetry";return Ii.env.isTelemetryEnabled!==void 0?Ii.env.isTelemetryEnabled?He.ON:He.OFF:Ii.workspace.getConfiguration(e).get(t)?He.ON:He.OFF}var vu=class{constructor(t,r,n,i,a){this.extensionId=t;this.extensionVersion=r;this.telemetryAppender=n;this.osShim=i;this.firstParty=!1;this.userOptIn=!1;this.errorOptIn=!1;this.disposables=[];this.firstParty=!!a,this.updateUserOptStatus(),W.env.onDidChangeTelemetryEnabled!==void 0?(this.disposables.push(W.env.onDidChangeTelemetryEnabled(()=>this.updateUserOptStatus())),this.disposables.push(W.workspace.onDidChangeConfiguration(()=>this.updateUserOptStatus()))):this.disposables.push(W.workspace.onDidChangeConfiguration(()=>this.updateUserOptStatus()))}updateUserOptStatus(){let t=nn();this.userOptIn=t===He.ON,this.errorOptIn=t===He.ON,(this.userOptIn||this.errorOptIn)&&this.telemetryAppender.instantiateAppender()}cleanRemoteName(t){if(!t)return"none";let r="other";return["ssh-remote","dev-container","attached-container","wsl","codespaces"].forEach(n=>{t.indexOf(`${n}+`)===0&&(r=n)}),r}get extension(){return this._extension===void 0&&(this._extension=W.extensions.getExtension(this.extensionId)),this._extension}cloneAndChange(t,r){if(t===null||typeof t!="object"||typeof r!="function")return t;let n={};for(let i in t)n[i]=r(i,t[i]);return n}shouldSendErrorTelemetry(){return this.errorOptIn===!1?!1:this.firstParty?this.cleanRemoteName(W.env.remoteName)!=="other"?!0:!(this.extension===void 0||this.extension.extensionKind===W.ExtensionKind.Workspace||W.env.uiKind===W.UIKind.Web):!0}getCommonProperties(){let t=Object.create(null);if(t["common.os"]=this.osShim.platform,t["common.nodeArch"]=this.osShim.architecture,t["common.platformversion"]=(this.osShim.release||"").replace(/^(\d+)(\.\d+)?(\.\d+)?(.*)/,"$1$2$3"),t["common.extname"]=this.extensionId,t["common.extversion"]=this.extensionVersion,W&&W.env){switch(t["common.vscodemachineid"]=W.env.machineId,t["common.vscodesessionid"]=W.env.sessionId,t["common.vscodeversion"]=W.version,t["common.isnewappinstall"]=W.env.isNewAppInstall?W.env.isNewAppInstall.toString():"false",t["common.product"]=W.env.appHost,W.env.uiKind){case W.UIKind.Web:t["common.uikind"]="web";break;case W.UIKind.Desktop:t["common.uikind"]="desktop";break;default:t["common.uikind"]="unknown"}t["common.remotename"]=this.cleanRemoteName(W.env.remoteName)}return t}anonymizeFilePaths(t,r){let n;if(t==null)return"";let i=[];W.env.appRoot!==""&&i.push(new RegExp(W.env.appRoot.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"gi")),this.extension&&i.push(new RegExp(this.extension.extensionPath.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"gi"));let a=t;if(r){let s=[];for(let p of i)for(;(n=p.exec(t))&&n;)s.push([n.index,p.lastIndex]);let o=/^[\\/]?(node_modules|node_modules\.asar)[\\/]/,u=/(file:\/\/)?([a-zA-Z]:(\\\\|\\|\/)|(\\\\|\\|\/))?([\w-._]+(\\\\|\\|\/))+[\w-._]*/g,c=0;for(a="";(n=u.exec(t))&&n;)n[0]&&!o.test(n[0])&&s.every(([p,f])=>n.index<p||n.index>=f)&&(a+=t.substring(c,n.index)+"<REDACTED: user-file-path>",c=u.lastIndex);c<t.length&&(a+=t.substr(c))}for(let s of i)a=a.replace(s,"");return a}removePropertiesWithPossibleUserInfo(t){if(typeof t!="object")return;let r=Object.create(null);for(let n of Object.keys(t)){let i=t[n];if(!i)continue;let a=/@[a-zA-Z0-9-.]+/;/(key|token|sig|signature|password|passwd|pwd)[="':\s]/.test(i.toLowerCase())?r[n]="<REDACTED: secret>":a.test(i)?r[n]="<REDACTED: email>":r[n]=i}return r}sendTelemetryEvent(t,r,n){if(this.userOptIn&&t!==""){r=It(It({},r),this.getCommonProperties());let i=this.cloneAndChange(r,(a,s)=>this.anonymizeFilePaths(s,this.firstParty));this.telemetryAppender.logEvent(`${this.extensionId}/${t}`,{properties:this.removePropertiesWithPossibleUserInfo(i),measurements:n})}}sendRawTelemetryEvent(t,r,n){this.userOptIn&&t!==""&&(r=It(It({},r),this.getCommonProperties()),this.telemetryAppender.logEvent(`${this.extensionId}/${t}`,{properties:r,measurements:n}))}sendTelemetryErrorEvent(t,r,n,i){if(this.errorOptIn&&t!==""){r=It(It({},r),this.getCommonProperties());let a=this.cloneAndChange(r,(s,o)=>this.shouldSendErrorTelemetry()?this.anonymizeFilePaths(o,this.firstParty):i===void 0||i.indexOf(s)!==-1?"REDACTED":this.anonymizeFilePaths(o,this.firstParty));this.telemetryAppender.logEvent(`${this.extensionId}/${t}`,{properties:this.removePropertiesWithPossibleUserInfo(a),measurements:n})}}sendTelemetryException(t,r,n){if(this.shouldSendErrorTelemetry()&&this.errorOptIn&&t){r=It(It({},r),this.getCommonProperties());let i=this.cloneAndChange(r,(a,s)=>this.anonymizeFilePaths(s,this.firstParty));t.stack&&(t.stack=this.anonymizeFilePaths(t.stack,this.firstParty)),this.telemetryAppender.logException(t,{properties:this.removePropertiesWithPossibleUserInfo(i),measurements:n})}}dispose(){return this.telemetryAppender.flush(),Promise.all(this.disposables.map(t=>t.dispose()))}};var gu=class{constructor(t,r){this._isInstantiated=!1;this._eventQueue=[];this._exceptionQueue=[];this._clientFactory=r,this._key=t,nn()!==He.OFF&&this.instantiateAppender()}logEvent(t,r){if(!this._telemetryClient){!this._isInstantiated&&nn()===He.ON&&this._eventQueue.push({eventName:t,data:r});return}this._telemetryClient.logEvent(t,r)}logException(t,r){if(!this._telemetryClient){!this._isInstantiated&&nn()!==He.OFF&&this._exceptionQueue.push({exception:t,data:r});return}this._telemetryClient.logException(t,r)}async flush(){this._telemetryClient&&(await this._telemetryClient.flush(),this._telemetryClient=void 0)}_flushQueues(){this._eventQueue.forEach(({eventName:t,data:r})=>this.logEvent(t,r)),this._eventQueue=[],this._exceptionQueue.forEach(({exception:t,data:r})=>this.logException(t,r)),this._exceptionQueue=[]}instantiateAppender(){this._isInstantiated||this._clientFactory(this._key).then(t=>{this._telemetryClient=t,this._isInstantiated=!0,this._flushQueues()}).catch(t=>{console.error(t)})}};var Ux=async e=>{let t;try{let n=await Promise.resolve().then(()=>Ai(iS()));n.defaultClient?(t=new n.TelemetryClient(e),t.channel.setUseDiskRetryCaching(!0)):(n.setup(e).setAutoCollectRequests(!1).setAutoCollectPerformance(!1).setAutoCollectExceptions(!1).setAutoCollectDependencies(!1).setAutoDependencyCorrelation(!1).setAutoCollectConsole(!1).setUseDiskRetryCaching(!0).start(),t=n.defaultClient),yi&&yi.env&&(t.context.tags[t.context.keys.userId]=yi.env.machineId,t.context.tags[t.context.keys.sessionId]=yi.env.sessionId,t.context.tags[t.context.keys.cloudRole]=yi.env.appName,t.context.tags[t.context.keys.cloudRoleInstance]=yi.env.appName),e&&e.indexOf("AIF-")===0&&(t.config.endpointUrl="https://vortex.data.microsoft.com/collect/v1")}catch(n){return Promise.reject(n)}return{logEvent:(n,i)=>{t==null||t.trackEvent({name:n,properties:i==null?void 0:i.properties,measurements:i==null?void 0:i.measurements})},logException:(n,i)=>{t==null||t.trackException({exception:n,properties:i==null?void 0:i.properties,measurements:i==null?void 0:i.measurements})},flush:async()=>{t==null||t.flush()}}},lf=class extends vu{constructor(t,r,n,i){let a=new gu(n,Ux);n&&n.indexOf("AIF-")===0&&(i=!0);super(t,r,a,{release:mi.release(),platform:mi.platform(),architecture:mi.arch()},i)}};0&&(0);


/***/ }),

/***/ 8528:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(2403);
const Is = __webpack_require__(1081);
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        let candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    let handle = setTimeout(callback.bind(context), 0);
    return { dispose() { clearTimeout(handle); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this._emitter = undefined;
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        this.cancel();
    }
}
exports.CancellationTokenSource = CancellationTokenSource;


/***/ }),

/***/ 2403:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable = exports.Disposable || (exports.Disposable = {}));
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event = exports.Event || (exports.Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        var foundCallbackWithDifferentContext = false;
        for (var i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (var i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                let result;
                result = {
                    dispose: () => {
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
Emitter._noop = function () { };
exports.Emitter = Emitter;


/***/ }),

/***/ 1081:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;


/***/ }),

/***/ 4461:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.Last = 2;
})(Touch = exports.Touch || (exports.Touch = {}));
class LinkedMap {
    constructor() {
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
    }
    delete(key) {
        const item = this._map.get(key);
        if (!item) {
            return false;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return true;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            current = current.next;
        }
    }
    forEachReverse(callbackfn, thisArg) {
        let current = this._tail;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            current = current.previous;
        }
    }
    values() {
        let result = [];
        let current = this._head;
        while (current) {
            result.push(current.value);
            current = current.next;
        }
        return result;
    }
    keys() {
        let result = [];
        let current = this._head;
        while (current) {
            result.push(current.key);
            current = current.next;
        }
        return result;
    }
    /* JSON RPC run on es5 which has no Symbol.iterator
    public keys(): IterableIterator<K> {
        let current = this._head;
        let iterator: IterableIterator<K> = {
            [Symbol.iterator]() {
                return iterator;
            },
            next():IteratorResult<K> {
                if (current) {
                    let result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }

    public values(): IterableIterator<V> {
        let current = this._head;
        let iterator: IterableIterator<V> = {
            [Symbol.iterator]() {
                return iterator;
            },
            next():IteratorResult<V> {
                if (current) {
                    let result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                } else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    */
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            this._head = item.next;
        }
        else if (item === this._tail) {
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
        }
    }
}
exports.LinkedMap = LinkedMap;


/***/ }),

/***/ 617:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="./thenable.ts" />

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Is = __webpack_require__(1081);
const messages_1 = __webpack_require__(3722);
exports.RequestType = messages_1.RequestType;
exports.RequestType0 = messages_1.RequestType0;
exports.RequestType1 = messages_1.RequestType1;
exports.RequestType2 = messages_1.RequestType2;
exports.RequestType3 = messages_1.RequestType3;
exports.RequestType4 = messages_1.RequestType4;
exports.RequestType5 = messages_1.RequestType5;
exports.RequestType6 = messages_1.RequestType6;
exports.RequestType7 = messages_1.RequestType7;
exports.RequestType8 = messages_1.RequestType8;
exports.RequestType9 = messages_1.RequestType9;
exports.ResponseError = messages_1.ResponseError;
exports.ErrorCodes = messages_1.ErrorCodes;
exports.NotificationType = messages_1.NotificationType;
exports.NotificationType0 = messages_1.NotificationType0;
exports.NotificationType1 = messages_1.NotificationType1;
exports.NotificationType2 = messages_1.NotificationType2;
exports.NotificationType3 = messages_1.NotificationType3;
exports.NotificationType4 = messages_1.NotificationType4;
exports.NotificationType5 = messages_1.NotificationType5;
exports.NotificationType6 = messages_1.NotificationType6;
exports.NotificationType7 = messages_1.NotificationType7;
exports.NotificationType8 = messages_1.NotificationType8;
exports.NotificationType9 = messages_1.NotificationType9;
const messageReader_1 = __webpack_require__(1160);
exports.MessageReader = messageReader_1.MessageReader;
exports.StreamMessageReader = messageReader_1.StreamMessageReader;
exports.IPCMessageReader = messageReader_1.IPCMessageReader;
exports.SocketMessageReader = messageReader_1.SocketMessageReader;
const messageWriter_1 = __webpack_require__(7636);
exports.MessageWriter = messageWriter_1.MessageWriter;
exports.StreamMessageWriter = messageWriter_1.StreamMessageWriter;
exports.IPCMessageWriter = messageWriter_1.IPCMessageWriter;
exports.SocketMessageWriter = messageWriter_1.SocketMessageWriter;
const events_1 = __webpack_require__(2403);
exports.Disposable = events_1.Disposable;
exports.Event = events_1.Event;
exports.Emitter = events_1.Emitter;
const cancellation_1 = __webpack_require__(8528);
exports.CancellationTokenSource = cancellation_1.CancellationTokenSource;
exports.CancellationToken = cancellation_1.CancellationToken;
const linkedMap_1 = __webpack_require__(4461);
__export(__webpack_require__(5362));
__export(__webpack_require__(4502));
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Verbose"] = 2] = "Verbose";
})(Trace = exports.Trace || (exports.Trace = {}));
(function (Trace) {
    function fromString(value) {
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTraceNotification');
})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTraceNotification');
})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function _createMessageConnection(messageReader, messageWriter, logger, strategy) {
    let sequenceNumber = 0;
    let notificationSquenceNumber = 0;
    let unknownResponseSquenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    let requestHandlers = Object.create(null);
    let starNotificationHandler = undefined;
    let notificationHandlers = Object.create(null);
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let requestTokens = Object.create(null);
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    let errorEmitter = new events_1.Emitter();
    let closeEmitter = new events_1.Emitter();
    let unhandledNotificationEmitter = new events_1.Emitter();
    let disposeEmitter = new events_1.Emitter();
    function createRequestQueueKey(id) {
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSquenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.isResponseMessage(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    ;
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        let message = messageQueue.shift();
        try {
            if (messages_1.isRequestMessage(message)) {
                handleRequest(message);
            }
            else if (messages_1.isNotificationMessage(message)) {
                handleNotification(message);
            }
            else if (messages_1.isResponseMessage(message)) {
                handleResponse(message);
            }
            else {
                handleInvalidMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    let callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
                let key = createRequestQueueKey(message.params.id);
                let toCancel = messageQueue.get(key);
                if (messages_1.isRequestMessage(toCancel)) {
                    let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== void 0 || response.result !== void 0)) {
                        messageQueue.delete(key);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response);
                        return;
                    }
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            let message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === void 0 ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replyError(error, method, startTime) {
            let message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === void 0) {
                result = null;
            }
            let message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        let element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        let startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            let cancellationSource = new cancellation_1.CancellationTokenSource();
            let tokenKey = String(requestMessage.id);
            requestTokens[tokenKey] = cancellationSource;
            try {
                let handlerResult;
                if (requestMessage.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {
                    handlerResult = requestHandler
                        ? requestHandler(cancellationSource.token)
                        : starRequestHandler(requestMessage.method, cancellationSource.token);
                }
                else if (Is.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {
                    handlerResult = requestHandler
                        ? requestHandler(...requestMessage.params, cancellationSource.token)
                        : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);
                }
                else {
                    handlerResult = requestHandler
                        ? requestHandler(requestMessage.params, cancellationSource.token)
                        : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                let promise = handlerResult;
                if (!handlerResult) {
                    delete requestTokens[tokenKey];
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        delete requestTokens[tokenKey];
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        delete requestTokens[tokenKey];
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    delete requestTokens[tokenKey];
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            let key = String(responseMessage.id);
            let responsePromise = responsePromises[key];
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise) {
                delete responsePromises[key];
                try {
                    if (responseMessage.error) {
                        let error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== void 0) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            notificationHandler = (params) => {
                let id = params.id;
                let source = requestTokens[String(id)];
                if (source) {
                    source.cancel();
                }
            };
        }
        else {
            let element = notificationHandlers[message.method];
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (message.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {
                    notificationHandler ? notificationHandler() : starNotificationHandler(message.method);
                }
                else if (Is.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {
                    notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);
                }
                else {
                    notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        let responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            let key = String(responseMessage.id);
            let responseHandler = responsePromises[key];
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === void 0) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === void 0) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === void 0) {
            return null;
        }
        else {
            return param;
        }
    }
    function computeMessageParams(type, params) {
        let result;
        let numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = null;
                break;
            case 1:
                result = undefinedToNull(params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    let connection = {
        sendNotification: (type, ...params) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                switch (params.length) {
                    case 0:
                        messageParams = null;
                        break;
                    case 1:
                        messageParams = params[0];
                        break;
                    default:
                        messageParams = params;
                        break;
                }
            }
            else {
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            let notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    notificationHandlers[type] = { type: undefined, handler };
                }
                else {
                    notificationHandlers[type.method] = { type, handler };
                }
            }
        },
        sendRequest: (type, ...params) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                switch (params.length) {
                    case 0:
                        messageParams = null;
                        break;
                    case 1:
                        // The cancellation token is optional so it can also be undefined.
                        if (cancellation_1.CancellationToken.is(params[0])) {
                            messageParams = null;
                            token = params[0];
                        }
                        else {
                            messageParams = undefinedToNull(params[0]);
                        }
                        break;
                    default:
                        const last = params.length - 1;
                        if (cancellation_1.CancellationToken.is(params[last])) {
                            token = params[last];
                            if (params.length === 2) {
                                messageParams = undefinedToNull(params[0]);
                            }
                            else {
                                messageParams = params.slice(0, last).map(value => undefinedToNull(value));
                            }
                        }
                        else {
                            messageParams = params.map(value => undefinedToNull(value));
                        }
                        break;
                }
            }
            else {
                method = type.method;
                messageParams = computeMessageParams(type, params);
                let numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            let id = sequenceNumber++;
            let result = new Promise((resolve, reject) => {
                let requestMessage = {
                    jsonrpc: version,
                    id: id,
                    method: method,
                    params: messageParams
                };
                let responsePromise = { method: method, timerStart: Date.now(), resolve, reject };
                traceSendingRequest(requestMessage);
                try {
                    messageWriter.write(requestMessage);
                }
                catch (e) {
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                    responsePromise = null;
                }
                if (responsePromise) {
                    responsePromises[String(id)] = responsePromise;
                }
            });
            if (token) {
                token.onCancellationRequested(() => {
                    connection.sendNotification(CancelNotification.type, { id });
                });
            }
            return result;
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            if (Is.func(type)) {
                starRequestHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    requestHandlers[type] = { type: undefined, handler };
                }
                else {
                    requestHandlers[type.method] = { type, handler };
                }
            }
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== void 0) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            let error = new Error('Connection got disposed.');
            Object.keys(responsePromises).forEach((key) => {
                responsePromises[key].reject(error);
            });
            responsePromises = Object.create(null);
            requestTokens = Object.create(null);
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            console.log("inspect");
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);
    });
    return connection;
}
function isMessageReader(value) {
    return value.listen !== void 0 && value.read === void 0;
}
function isMessageWriter(value) {
    return value.write !== void 0 && value.end === void 0;
}
function createMessageConnection(input, output, logger, strategy) {
    if (!logger) {
        logger = exports.NullLogger;
    }
    let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);
    let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);
    return _createMessageConnection(reader, writer, logger, strategy);
}
exports.createMessageConnection = createMessageConnection;


/***/ }),

/***/ 1160:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(2403);
const Is = __webpack_require__(1081);
let DefaultSize = 8192;
let CR = Buffer.from('\r', 'ascii')[0];
let LF = Buffer.from('\n', 'ascii')[0];
let CRLF = '\r\n';
class MessageBuffer {
    constructor(encoding = 'utf8') {
        this.encoding = encoding;
        this.index = 0;
        this.buffer = Buffer.allocUnsafe(DefaultSize);
    }
    append(chunk) {
        var toAppend = chunk;
        if (typeof (chunk) === 'string') {
            var str = chunk;
            var bufferLen = Buffer.byteLength(str, this.encoding);
            toAppend = Buffer.allocUnsafe(bufferLen);
            toAppend.write(str, 0, bufferLen, this.encoding);
        }
        if (this.buffer.length - this.index >= toAppend.length) {
            toAppend.copy(this.buffer, this.index, 0, toAppend.length);
        }
        else {
            var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;
            if (this.index === 0) {
                this.buffer = Buffer.allocUnsafe(newSize);
                toAppend.copy(this.buffer, 0, 0, toAppend.length);
            }
            else {
                this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
            }
        }
        this.index += toAppend.length;
    }
    tryReadHeaders() {
        let result = undefined;
        let current = 0;
        while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {
            current++;
        }
        // No header / body separator found (e.g CRLFCRLF)
        if (current + 3 >= this.index) {
            return result;
        }
        result = Object.create(null);
        let headers = this.buffer.toString('ascii', 0, current).split(CRLF);
        headers.forEach((header) => {
            let index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            let key = header.substr(0, index);
            let value = header.substr(index + 1).trim();
            result[key] = value;
        });
        let nextStart = current + 4;
        this.buffer = this.buffer.slice(nextStart);
        this.index = this.index - nextStart;
        return result;
    }
    tryReadContent(length) {
        if (this.index < length) {
            return null;
        }
        let result = this.buffer.toString(this.encoding, 0, length);
        let nextStart = length;
        this.buffer.copy(this.buffer, 0, nextStart);
        this.index = this.index - nextStart;
        return result;
    }
    get numberOfBytes() {
        return this.index;
    }
}
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader recevied error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
class StreamMessageReader extends AbstractMessageReader {
    constructor(readable, encoding = 'utf8') {
        super();
        this.readable = readable;
        this.buffer = new MessageBuffer(encoding);
        this._partialMessageTimeout = 10000;
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        this.readable.on('data', (data) => {
            this.onData(data);
        });
        this.readable.on('error', (error) => this.fireError(error));
        this.readable.on('close', () => this.fireClose());
    }
    onData(data) {
        this.buffer.append(data);
        while (true) {
            if (this.nextMessageLength === -1) {
                let headers = this.buffer.tryReadHeaders();
                if (!headers) {
                    return;
                }
                let contentLength = headers['Content-Length'];
                if (!contentLength) {
                    throw new Error('Header must provide a Content-Length property.');
                }
                let length = parseInt(contentLength);
                if (isNaN(length)) {
                    throw new Error('Content-Length value must be a number.');
                }
                this.nextMessageLength = length;
                // Take the encoding form the header. For compatibility
                // treat both utf-8 and utf8 as node utf8
            }
            var msg = this.buffer.tryReadContent(this.nextMessageLength);
            if (msg === null) {
                /** We haven't recevied the full message yet. */
                this.setPartialMessageTimer();
                return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.messageToken++;
            var json = JSON.parse(msg);
            this.callback(json);
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            clearTimeout(this.partialMessageTimer);
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class IPCMessageReader extends AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
    }
}
exports.IPCMessageReader = IPCMessageReader;
class SocketMessageReader extends StreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super(socket, encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;


/***/ }),

/***/ 7636:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(2403);
const Is = __webpack_require__(1081);
let ContentLength = 'Content-Length: ';
let CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer recevied error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
class StreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, encoding = 'utf8') {
        super();
        this.writable = writable;
        this.encoding = encoding;
        this.errorCount = 0;
        this.writable.on('error', (error) => this.fireError(error));
        this.writable.on('close', () => this.fireClose());
    }
    write(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
            ContentLength, contentLength.toString(), CRLF,
            CRLF
        ];
        try {
            // Header must be written in ASCII encoding
            this.writable.write(headers.join(''), 'ascii');
            // Now write the content. This can be written in any encoding
            this.writable.write(json, this.encoding);
            this.errorCount = 0;
        }
        catch (error) {
            this.errorCount++;
            this.fireError(error, msg, this.errorCount);
        }
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
class IPCMessageWriter extends AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        this.queue = [];
        this.sending = false;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        if (!this.sending && this.queue.length === 0) {
            // See https://github.com/nodejs/node/issues/7657
            this.doWriteMessage(msg);
        }
        else {
            this.queue.push(msg);
        }
    }
    doWriteMessage(msg) {
        try {
            if (this.process.send) {
                this.sending = true;
                this.process.send(msg, undefined, undefined, (error) => {
                    this.sending = false;
                    if (error) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    else {
                        this.errorCount = 0;
                    }
                    if (this.queue.length > 0) {
                        this.doWriteMessage(this.queue.shift());
                    }
                });
            }
        }
        catch (error) {
            this.errorCount++;
            this.fireError(error, msg, this.errorCount);
        }
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class SocketMessageWriter extends AbstractMessageWriter {
    constructor(socket, encoding = 'utf8') {
        super();
        this.socket = socket;
        this.queue = [];
        this.sending = false;
        this.encoding = encoding;
        this.errorCount = 0;
        this.socket.on('error', (error) => this.fireError(error));
        this.socket.on('close', () => this.fireClose());
    }
    write(msg) {
        if (!this.sending && this.queue.length === 0) {
            // See https://github.com/nodejs/node/issues/7657
            this.doWriteMessage(msg);
        }
        else {
            this.queue.push(msg);
        }
    }
    doWriteMessage(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
            ContentLength, contentLength.toString(), CRLF,
            CRLF
        ];
        try {
            // Header must be written in ASCII encoding
            this.sending = true;
            this.socket.write(headers.join(''), 'ascii', (error) => {
                if (error) {
                    this.handleError(error, msg);
                }
                try {
                    // Now write the content. This can be written in any encoding
                    this.socket.write(json, this.encoding, (error) => {
                        this.sending = false;
                        if (error) {
                            this.handleError(error, msg);
                        }
                        else {
                            this.errorCount = 0;
                        }
                        if (this.queue.length > 0) {
                            this.doWriteMessage(this.queue.shift());
                        }
                    });
                }
                catch (error) {
                    this.handleError(error, msg);
                }
            });
        }
        catch (error) {
            this.handleError(error, msg);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
}
exports.SocketMessageWriter = SocketMessageWriter;


/***/ }),

/***/ 3722:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const is = __webpack_require__(1081);
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    ErrorCodes.serverErrorStart = -32099;
    ErrorCodes.serverErrorEnd = -32000;
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    // Defined by the protocol.
    ErrorCodes.RequestCancelled = -32800;
    // Defined by VSCode library.
    ErrorCodes.MessageWriteError = 1;
    ErrorCodes.MessageReadError = 2;
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        return {
            code: this.code,
            message: this.message,
            data: this.data,
        };
    }
}
exports.ResponseError = ResponseError;
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageType {
    constructor(_method, _numberOfParams) {
        this._method = _method;
        this._numberOfParams = _numberOfParams;
    }
    get method() {
        return this._method;
    }
    get numberOfParams() {
        return this._numberOfParams;
    }
}
exports.AbstractMessageType = AbstractMessageType;
/**
 * Classes to type request response pairs
 */
class RequestType0 extends AbstractMessageType {
    constructor(method) {
        super(method, 0);
        this._ = undefined;
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
        this._ = undefined;
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
        this._ = undefined;
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageType {
    constructor(method) {
        super(method, 2);
        this._ = undefined;
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageType {
    constructor(method) {
        super(method, 3);
        this._ = undefined;
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageType {
    constructor(method) {
        super(method, 4);
        this._ = undefined;
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageType {
    constructor(method) {
        super(method, 5);
        this._ = undefined;
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageType {
    constructor(method) {
        super(method, 6);
        this._ = undefined;
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageType {
    constructor(method) {
        super(method, 7);
        this._ = undefined;
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageType {
    constructor(method) {
        super(method, 8);
        this._ = undefined;
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageType {
    constructor(method) {
        super(method, 9);
        this._ = undefined;
    }
}
exports.RequestType9 = RequestType9;
class NotificationType extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
        this._ = undefined;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageType {
    constructor(method) {
        super(method, 0);
        this._ = undefined;
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageType {
    constructor(method) {
        super(method, 1);
        this._ = undefined;
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageType {
    constructor(method) {
        super(method, 2);
        this._ = undefined;
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageType {
    constructor(method) {
        super(method, 3);
        this._ = undefined;
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageType {
    constructor(method) {
        super(method, 4);
        this._ = undefined;
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageType {
    constructor(method) {
        super(method, 5);
        this._ = undefined;
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageType {
    constructor(method) {
        super(method, 6);
        this._ = undefined;
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageType {
    constructor(method) {
        super(method, 7);
        this._ = undefined;
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageType {
    constructor(method) {
        super(method, 8);
        this._ = undefined;
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageType {
    constructor(method) {
        super(method, 9);
        this._ = undefined;
    }
}
exports.NotificationType9 = NotificationType9;
/**
 * Tests if the given message is a request message
 */
function isRequestMessage(message) {
    let candidate = message;
    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
}
exports.isRequestMessage = isRequestMessage;
/**
 * Tests if the given message is a notification message
 */
function isNotificationMessage(message) {
    let candidate = message;
    return candidate && is.string(candidate.method) && message.id === void 0;
}
exports.isNotificationMessage = isNotificationMessage;
/**
 * Tests if the given message is a response message
 */
function isResponseMessage(message) {
    let candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
}
exports.isResponseMessage = isResponseMessage;


/***/ }),

/***/ 5362:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path_1 = __webpack_require__(5622);
const os_1 = __webpack_require__(2087);
const crypto_1 = __webpack_require__(6417);
const net_1 = __webpack_require__(1631);
const messageReader_1 = __webpack_require__(1160);
const messageWriter_1 = __webpack_require__(7636);
function generateRandomPipeName() {
    const randomSuffix = crypto_1.randomBytes(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    else {
        // Mac/Unix: use socket file
        return path_1.join(os_1.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    let connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new messageReader_1.SocketMessageReader(socket, encoding),
                new messageWriter_1.SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = net_1.createConnection(pipeName);
    return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;


/***/ }),

/***/ 4502:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const net_1 = __webpack_require__(1631);
const messageReader_1 = __webpack_require__(1160);
const messageWriter_1 = __webpack_require__(7636);
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    let connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new messageReader_1.SocketMessageReader(socket, encoding),
                new messageWriter_1.SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = net_1.createConnection(port, '127.0.0.1');
    return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;


/***/ }),

/***/ 7014:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_1 = __webpack_require__(7549);
const vscode_languageserver_protocol_1 = __webpack_require__(5310);
const c2p = __webpack_require__(2639);
const p2c = __webpack_require__(8899);
const Is = __webpack_require__(4797);
const async_1 = __webpack_require__(4834);
const UUID = __webpack_require__(7465);
__export(__webpack_require__(5310));
class ConsoleLogger {
    error(message) {
        console.error(message);
    }
    warn(message) {
        console.warn(message);
    }
    info(message) {
        console.info(message);
    }
    log(message) {
        console.log(message);
    }
}
function createConnection(input, output, errorHandler, closeHandler) {
    let logger = new ConsoleLogger();
    let connection = vscode_languageserver_protocol_1.createProtocolConnection(input, output, logger);
    connection.onError((data) => { errorHandler(data[0], data[1], data[2]); });
    connection.onClose(closeHandler);
    let result = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(Is.string(type) ? type : type.method, handler),
        sendNotification: (type, params) => connection.sendNotification(Is.string(type) ? type : type.method, params),
        onNotification: (type, handler) => connection.onNotification(Is.string(type) ? type : type.method, handler),
        trace: (value, tracer, sendNotificationOrTraceOptions) => {
            const defaultTraceOptions = {
                sendNotification: false,
                traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text
            };
            if (sendNotificationOrTraceOptions === void 0) {
                connection.trace(value, tracer, defaultTraceOptions);
            }
            else if (Is.boolean(sendNotificationOrTraceOptions)) {
                connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
            else {
                connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
        },
        initialize: (params) => connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params),
        shutdown: () => connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, undefined),
        exit: () => connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type),
        onLogMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, handler),
        onShowMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, handler),
        onTelemetry: (handler) => connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, handler),
        didChangeConfiguration: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, params),
        didChangeWatchedFiles: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, params),
        didOpenTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, params),
        didChangeTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params),
        didCloseTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, params),
        didSaveTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, params),
        onDiagnostics: (handler) => connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, handler),
        dispose: () => connection.dispose()
    };
    return result;
}
/**
 * An action to be performed when the connection is producing errors.
 */
var ErrorAction;
(function (ErrorAction) {
    /**
     * Continue running the server.
     */
    ErrorAction[ErrorAction["Continue"] = 1] = "Continue";
    /**
     * Shutdown the server.
     */
    ErrorAction[ErrorAction["Shutdown"] = 2] = "Shutdown";
})(ErrorAction = exports.ErrorAction || (exports.ErrorAction = {}));
/**
 * An action to be performed when the connection to a server got closed.
 */
var CloseAction;
(function (CloseAction) {
    /**
     * Don't restart the server. The connection stays closed.
     */
    CloseAction[CloseAction["DoNotRestart"] = 1] = "DoNotRestart";
    /**
     * Restart the server.
     */
    CloseAction[CloseAction["Restart"] = 2] = "Restart";
})(CloseAction = exports.CloseAction || (exports.CloseAction = {}));
class DefaultErrorHandler {
    constructor(name) {
        this.name = name;
        this.restarts = [];
    }
    error(_error, _message, count) {
        if (count && count <= 3) {
            return ErrorAction.Continue;
        }
        return ErrorAction.Shutdown;
    }
    closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length < 5) {
            return CloseAction.Restart;
        }
        else {
            let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
            if (diff <= 3 * 60 * 1000) {
                vscode_1.window.showErrorMessage(`The ${this.name} server crashed 5 times in the last 3 minutes. The server will not be restarted.`);
                return CloseAction.DoNotRestart;
            }
            else {
                this.restarts.shift();
                return CloseAction.Restart;
            }
        }
    }
}
var RevealOutputChannelOn;
(function (RevealOutputChannelOn) {
    RevealOutputChannelOn[RevealOutputChannelOn["Info"] = 1] = "Info";
    RevealOutputChannelOn[RevealOutputChannelOn["Warn"] = 2] = "Warn";
    RevealOutputChannelOn[RevealOutputChannelOn["Error"] = 3] = "Error";
    RevealOutputChannelOn[RevealOutputChannelOn["Never"] = 4] = "Never";
})(RevealOutputChannelOn = exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));
var State;
(function (State) {
    State[State["Stopped"] = 1] = "Stopped";
    State[State["Starting"] = 3] = "Starting";
    State[State["Running"] = 2] = "Running";
})(State = exports.State || (exports.State = {}));
var ClientState;
(function (ClientState) {
    ClientState[ClientState["Initial"] = 0] = "Initial";
    ClientState[ClientState["Starting"] = 1] = "Starting";
    ClientState[ClientState["StartFailed"] = 2] = "StartFailed";
    ClientState[ClientState["Running"] = 3] = "Running";
    ClientState[ClientState["Stopping"] = 4] = "Stopping";
    ClientState[ClientState["Stopped"] = 5] = "Stopped";
})(ClientState || (ClientState = {}));
const SupportedSymbolKinds = [
    vscode_languageserver_protocol_1.SymbolKind.File,
    vscode_languageserver_protocol_1.SymbolKind.Module,
    vscode_languageserver_protocol_1.SymbolKind.Namespace,
    vscode_languageserver_protocol_1.SymbolKind.Package,
    vscode_languageserver_protocol_1.SymbolKind.Class,
    vscode_languageserver_protocol_1.SymbolKind.Method,
    vscode_languageserver_protocol_1.SymbolKind.Property,
    vscode_languageserver_protocol_1.SymbolKind.Field,
    vscode_languageserver_protocol_1.SymbolKind.Constructor,
    vscode_languageserver_protocol_1.SymbolKind.Enum,
    vscode_languageserver_protocol_1.SymbolKind.Interface,
    vscode_languageserver_protocol_1.SymbolKind.Function,
    vscode_languageserver_protocol_1.SymbolKind.Variable,
    vscode_languageserver_protocol_1.SymbolKind.Constant,
    vscode_languageserver_protocol_1.SymbolKind.String,
    vscode_languageserver_protocol_1.SymbolKind.Number,
    vscode_languageserver_protocol_1.SymbolKind.Boolean,
    vscode_languageserver_protocol_1.SymbolKind.Array,
    vscode_languageserver_protocol_1.SymbolKind.Object,
    vscode_languageserver_protocol_1.SymbolKind.Key,
    vscode_languageserver_protocol_1.SymbolKind.Null,
    vscode_languageserver_protocol_1.SymbolKind.EnumMember,
    vscode_languageserver_protocol_1.SymbolKind.Struct,
    vscode_languageserver_protocol_1.SymbolKind.Event,
    vscode_languageserver_protocol_1.SymbolKind.Operator,
    vscode_languageserver_protocol_1.SymbolKind.TypeParameter
];
const SupportedCompletionItemKinds = [
    vscode_languageserver_protocol_1.CompletionItemKind.Text,
    vscode_languageserver_protocol_1.CompletionItemKind.Method,
    vscode_languageserver_protocol_1.CompletionItemKind.Function,
    vscode_languageserver_protocol_1.CompletionItemKind.Constructor,
    vscode_languageserver_protocol_1.CompletionItemKind.Field,
    vscode_languageserver_protocol_1.CompletionItemKind.Variable,
    vscode_languageserver_protocol_1.CompletionItemKind.Class,
    vscode_languageserver_protocol_1.CompletionItemKind.Interface,
    vscode_languageserver_protocol_1.CompletionItemKind.Module,
    vscode_languageserver_protocol_1.CompletionItemKind.Property,
    vscode_languageserver_protocol_1.CompletionItemKind.Unit,
    vscode_languageserver_protocol_1.CompletionItemKind.Value,
    vscode_languageserver_protocol_1.CompletionItemKind.Enum,
    vscode_languageserver_protocol_1.CompletionItemKind.Keyword,
    vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
    vscode_languageserver_protocol_1.CompletionItemKind.Color,
    vscode_languageserver_protocol_1.CompletionItemKind.File,
    vscode_languageserver_protocol_1.CompletionItemKind.Reference,
    vscode_languageserver_protocol_1.CompletionItemKind.Folder,
    vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,
    vscode_languageserver_protocol_1.CompletionItemKind.Constant,
    vscode_languageserver_protocol_1.CompletionItemKind.Struct,
    vscode_languageserver_protocol_1.CompletionItemKind.Event,
    vscode_languageserver_protocol_1.CompletionItemKind.Operator,
    vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter
];
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
var DynamicFeature;
(function (DynamicFeature) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.register) && Is.func(candidate.unregister) && Is.func(candidate.dispose) && candidate.messages !== void 0;
    }
    DynamicFeature.is = is;
})(DynamicFeature || (DynamicFeature = {}));
class DocumentNotifiactions {
    constructor(_client, _event, _type, _middleware, _createParams, _selectorFilter) {
        this._client = _client;
        this._event = _event;
        this._type = _type;
        this._middleware = _middleware;
        this._createParams = _createParams;
        this._selectorFilter = _selectorFilter;
        this._selectors = new Map();
    }
    static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
            if (vscode_1.languages.match(selector, textDocument)) {
                return true;
            }
        }
        return false;
    }
    register(_message, data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = this._event(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
    }
    callback(data) {
        if (!this._selectorFilter || this._selectorFilter(this._selectors.values(), data)) {
            if (this._middleware) {
                this._middleware(data, (data) => this._client.sendNotification(this._type, this._createParams(data)));
            }
            else {
                this._client.sendNotification(this._type, this._createParams(data));
            }
            this.notificationSent(data);
        }
    }
    notificationSent(_data) {
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
}
class DidOpenTextDocumentFeature extends DocumentNotifiactions {
    constructor(client, _syncedDocuments) {
        super(client, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, client.clientOptions.middleware.didOpen, (textDocument) => client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument), DocumentNotifiactions.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register(this.messages, { id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });
        }
    }
    register(message, data) {
        super.register(message, data);
        if (!data.registerOptions.documentSelector) {
            return;
        }
        let documentSelector = data.registerOptions.documentSelector;
        vscode_1.workspace.textDocuments.forEach((textDocument) => {
            let uri = textDocument.uri.toString();
            if (this._syncedDocuments.has(uri)) {
                return;
            }
            if (vscode_1.languages.match(documentSelector, textDocument)) {
                let middleware = this._client.clientOptions.middleware;
                let didOpen = (textDocument) => {
                    this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                if (middleware.didOpen) {
                    middleware.didOpen(textDocument, didOpen);
                }
                else {
                    didOpen(textDocument);
                }
                this._syncedDocuments.set(uri, textDocument);
            }
        });
    }
    notificationSent(textDocument) {
        super.notificationSent(textDocument);
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
    }
}
class DidCloseTextDocumentFeature extends DocumentNotifiactions {
    constructor(client, _syncedDocuments) {
        super(client, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, client.clientOptions.middleware.didClose, (textDocument) => client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument), DocumentNotifiactions.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register(this.messages, { id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });
        }
    }
    notificationSent(textDocument) {
        super.notificationSent(textDocument);
        this._syncedDocuments.delete(textDocument.uri.toString());
    }
    unregister(id) {
        let selector = this._selectors.get(id);
        // The super call removed the selector from the map
        // of selectors.
        super.unregister(id);
        let selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
            if (vscode_1.languages.match(selector, textDocument) && !this._selectorFilter(selectors, textDocument)) {
                let middleware = this._client.clientOptions.middleware;
                let didClose = (textDocument) => {
                    this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                this._syncedDocuments.delete(textDocument.uri.toString());
                if (middleware.didClose) {
                    middleware.didClose(textDocument, didClose);
                }
                else {
                    didClose(textDocument);
                }
            }
        });
    }
}
class DidChangeTextDocumentFeature {
    constructor(_client) {
        this._client = _client;
        this._changeData = new Map();
        this._forcingDelivery = false;
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { syncKind: textDocumentSyncOptions.change })
            });
        }
    }
    register(_message, data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
            documentSelector: data.registerOptions.documentSelector,
            syncKind: data.registerOptions.syncKind
        });
    }
    callback(event) {
        // Text document changes are send for dirty changes as well. We don't
        // have dirty / undirty events in the LSP so we ignore content changes
        // with length zero.
        if (event.contentChanges.length === 0) {
            return;
        }
        for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, event.document)) {
                let middleware = this._client.clientOptions.middleware;
                if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
                    let params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event);
                    if (middleware.didChange) {
                        middleware.didChange(event, () => this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params));
                    }
                    else {
                        this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                    }
                }
                else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
                    let didChange = (event) => {
                        if (this._changeDelayer) {
                            if (this._changeDelayer.uri !== event.document.uri.toString()) {
                                // Use this force delivery to track boolean state. Otherwise we might call two times.
                                this.forceDelivery();
                                this._changeDelayer.uri = event.document.uri.toString();
                            }
                            this._changeDelayer.delayer.trigger(() => {
                                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, this._client.code2ProtocolConverter.asChangeTextDocumentParams(event.document));
                            });
                        }
                        else {
                            this._changeDelayer = {
                                uri: event.document.uri.toString(),
                                delayer: new async_1.Delayer(200)
                            };
                            this._changeDelayer.delayer.trigger(() => {
                                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, this._client.code2ProtocolConverter.asChangeTextDocumentParams(event.document));
                            }, -1);
                        }
                    };
                    if (middleware.didChange) {
                        middleware.didChange(event, didChange);
                    }
                    else {
                        didChange(event);
                    }
                }
            }
        }
    }
    unregister(id) {
        this._changeData.delete(id);
        if (this._changeData.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._changeDelayer = undefined;
        this._forcingDelivery = false;
        this._changeData.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    forceDelivery() {
        if (this._forcingDelivery || !this._changeDelayer) {
            return;
        }
        try {
            this._forcingDelivery = true;
            this._changeDelayer.delayer.forceDelivery();
        }
        finally {
            this._forcingDelivery = false;
        }
    }
}
class WillSaveFeature extends DocumentNotifiactions {
    constructor(client) {
        super(client, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, client.clientOptions.middleware.willSave, (willSaveEvent) => client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent), (selectors, willSaveEvent) => DocumentNotifiactions.textDocumentFilter(selectors, willSaveEvent.document));
    }
    get messages() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, 'textDocument'), 'synchronization');
        value.willSave = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
}
class WillSaveWaitUntilFeature {
    constructor(_client) {
        this._client = _client;
        this._selectors = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
    }
    fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, 'textDocument'), 'synchronization');
        value.willSaveWaitUntil = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
    register(_message, data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
    }
    callback(event) {
        if (DocumentNotifiactions.textDocumentFilter(this._selectors.values(), event.document)) {
            let middleware = this._client.clientOptions.middleware;
            let willSaveWaitUntil = (event) => {
                return this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event)).then((edits) => {
                    let vEdits = this._client.protocol2CodeConverter.asTextEdits(edits);
                    return vEdits === void 0 ? [] : vEdits;
                });
            };
            event.waitUntil(middleware.willSaveWaitUntil
                ? middleware.willSaveWaitUntil(event, willSaveWaitUntil)
                : willSaveWaitUntil(event));
        }
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
}
class DidSaveTextDocumentFeature extends DocumentNotifiactions {
    constructor(client) {
        super(client, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, client.clientOptions.middleware.didSave, (textDocument) => client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText), DocumentNotifiactions.textDocumentFilter);
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').didSave = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { includeText: !!textDocumentSyncOptions.save.includeText })
            });
        }
    }
    register(method, data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(method, data);
    }
}
class FileSystemWatcherFeature {
    constructor(_client, _notifyFileEvent) {
        this._client = _client;
        this._notifyFileEvent = _notifyFileEvent;
        this._watchers = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'didChangeWatchedFiles').dynamicRegistration = true;
    }
    initialize(_capabilities, _documentSelector) {
    }
    register(_method, data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
            return;
        }
        let disposeables = [];
        for (let watcher of data.registerOptions.watchers) {
            if (!Is.string(watcher.globPattern)) {
                continue;
            }
            let watchCreate = true, watchChange = true, watchDelete = true;
            if (watcher.kind !== void 0 && watcher.kind !== null) {
                watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;
                watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) != 0;
                watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) != 0;
            }
            let fileSystemWatcher = vscode_1.workspace.createFileSystemWatcher(watcher.globPattern, !watchCreate, !watchChange, !watchDelete);
            this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete);
            disposeables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposeables);
    }
    registerRaw(id, fileSystemWatchers) {
        let disposeables = [];
        for (let fileSystemWatcher of fileSystemWatchers) {
            this.hookListeners(fileSystemWatcher, true, true, true, disposeables);
        }
        this._watchers.set(id, disposeables);
    }
    hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        if (watchCreate) {
            fileSystemWatcher.onDidCreate((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Created
            }), null, listeners);
        }
        if (watchChange) {
            fileSystemWatcher.onDidChange((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Changed
            }), null, listeners);
        }
        if (watchDelete) {
            fileSystemWatcher.onDidDelete((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Deleted
            }), null, listeners);
        }
    }
    unregister(id) {
        let disposeables = this._watchers.get(id);
        if (disposeables) {
            for (let disposable of disposeables) {
                disposable.dispose();
            }
        }
    }
    dispose() {
        this._watchers.forEach((disposeables) => {
            for (let disposable of disposeables) {
                disposable.dispose();
            }
        });
        this._watchers.clear();
    }
}
class TextDocumentFeature {
    constructor(_client, _message) {
        this._client = _client;
        this._message = _message;
        this._providers = new Map();
    }
    get messages() {
        return this._message;
    }
    register(message, data) {
        if (message.method !== this.messages.method) {
            throw new Error(`Register called on wrong feature. Requested ${message.method} but reached feature ${this.messages.method}`);
        }
        if (!data.registerOptions.documentSelector) {
            return;
        }
        let provider = this.registerLanguageProvider(data.registerOptions);
        if (provider) {
            this._providers.set(data.id, provider);
        }
    }
    unregister(id) {
        let provider = this._providers.get(id);
        if (provider) {
            provider.dispose();
        }
    }
    dispose() {
        this._providers.forEach((value) => {
            value.dispose();
        });
        this._providers.clear();
    }
}
exports.TextDocumentFeature = TextDocumentFeature;
class WorkspaceFeature {
    constructor(_client, _message) {
        this._client = _client;
        this._message = _message;
        this._providers = new Map();
    }
    get messages() {
        return this._message;
    }
    register(message, data) {
        if (message.method !== this.messages.method) {
            throw new Error(`Register called on wron feature. Requested ${message.method} but reached feature ${this.messages.method}`);
        }
        let provider = this.registerLanguageProvider(data.registerOptions);
        if (provider) {
            this._providers.set(data.id, provider);
        }
    }
    unregister(id) {
        let provider = this._providers.get(id);
        if (provider) {
            provider.dispose();
        }
    }
    dispose() {
        this._providers.forEach((value) => {
            value.dispose();
        });
        this._providers.clear();
    }
}
class CompletionItemFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CompletionRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let completion = ensure(ensure(capabilites, 'textDocument'), 'completion');
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
            snippetSupport: true,
            commitCharactersSupport: true,
            documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
            deprecatedSupport: true,
            preselectSupport: true
        };
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.completionProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector }, capabilities.completionProvider)
        });
    }
    registerLanguageProvider(options) {
        let triggerCharacters = options.triggerCharacters || [];
        let client = this._client;
        let provideCompletionItems = (document, position, context, token) => {
            return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, client.code2ProtocolConverter.asCompletionParams(document, position, context), token).then(client.protocol2CodeConverter.asCompletionResult, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, error);
                return Promise.resolve([]);
            });
        };
        let resolveCompletionItem = (item, token) => {
            return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, client.code2ProtocolConverter.asCompletionItem(item), token).then(client.protocol2CodeConverter.asCompletionItem, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, error);
                return Promise.resolve(item);
            });
        };
        let middleware = this._client.clientOptions.middleware;
        return vscode_1.languages.registerCompletionItemProvider(options.documentSelector, {
            provideCompletionItems: (document, position, token, context) => {
                return middleware.provideCompletionItem
                    ? middleware.provideCompletionItem(document, position, context, token, provideCompletionItems)
                    : provideCompletionItems(document, position, context, token);
            },
            resolveCompletionItem: options.resolveProvider
                ? (item, token) => {
                    return middleware.resolveCompletionItem
                        ? middleware.resolveCompletionItem(item, token, resolveCompletionItem)
                        : resolveCompletionItem(item, token);
                }
                : undefined
        }, ...triggerCharacters);
    }
}
class HoverFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.HoverRequest.type);
    }
    fillClientCapabilities(capabilites) {
        const hoverCapability = (ensure(ensure(capabilites, 'textDocument'), 'hover'));
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.hoverProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector })
        });
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let provideHover = (document, position, token) => {
            return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asHover, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, error);
                return Promise.resolve(null);
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerHoverProvider(options.documentSelector, {
            provideHover: (document, position, token) => {
                return middleware.provideHover
                    ? middleware.provideHover(document, position, token, provideHover)
                    : provideHover(document, position, token);
            }
        });
    }
}
class SignatureHelpFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let config = ensure(ensure(capabilites, 'textDocument'), 'signatureHelp');
        config.dynamicRegistration = true;
        config.signatureInformation = { documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText] };
        config.signatureInformation.parameterInformation = { labelOffsetSupport: true };
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.signatureHelpProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector }, capabilities.signatureHelpProvider)
        });
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let providerSignatureHelp = (document, position, token) => {
            return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asSignatureHelp, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, error);
                return Promise.resolve(null);
            });
        };
        let middleware = client.clientOptions.middleware;
        let triggerCharacters = options.triggerCharacters || [];
        return vscode_1.languages.registerSignatureHelpProvider(options.documentSelector, {
            provideSignatureHelp: (document, position, token) => {
                return middleware.provideSignatureHelp
                    ? middleware.provideSignatureHelp(document, position, token, providerSignatureHelp)
                    : providerSignatureHelp(document, position, token);
            }
        }, ...triggerCharacters);
    }
}
class DefinitionFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DefinitionRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let definitionSupport = ensure(ensure(capabilites, 'textDocument'), 'definition');
        definitionSupport.dynamicRegistration = true;
        definitionSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.definitionProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector })
        });
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let provideDefinition = (document, position, token) => {
            return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, error);
                return Promise.resolve(null);
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerDefinitionProvider(options.documentSelector, {
            provideDefinition: (document, position, token) => {
                return middleware.provideDefinition
                    ? middleware.provideDefinition(document, position, token, provideDefinition)
                    : provideDefinition(document, position, token);
            }
        });
    }
}
class ReferencesFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.ReferencesRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'references').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.referencesProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector })
        });
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let providerReferences = (document, position, options, token) => {
            return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, client.code2ProtocolConverter.asReferenceParams(document, position, options), token).then(client.protocol2CodeConverter.asReferences, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, error);
                return Promise.resolve([]);
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerReferenceProvider(options.documentSelector, {
            provideReferences: (document, position, options, token) => {
                return middleware.provideReferences
                    ? middleware.provideReferences(document, position, options, token, providerReferences)
                    : providerReferences(document, position, options, token);
            }
        });
    }
}
class DocumentHighlightFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'documentHighlight').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.documentHighlightProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector })
        });
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let provideDocumentHighlights = (document, position, token) => {
            return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDocumentHighlights, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, error);
                return Promise.resolve([]);
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerDocumentHighlightProvider(options.documentSelector, {
            provideDocumentHighlights: (document, position, token) => {
                return middleware.provideDocumentHighlights
                    ? middleware.provideDocumentHighlights(document, position, token, provideDocumentHighlights)
                    : provideDocumentHighlights(document, position, token);
            }
        });
    }
}
class DocumentSymbolFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let symbolCapabilities = ensure(ensure(capabilites, 'textDocument'), 'documentSymbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.documentSymbolProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector })
        });
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let provideDocumentSymbols = (document, token) => {
            return client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, client.code2ProtocolConverter.asDocumentSymbolParams(document), token).then((data) => {
                if (data === null) {
                    return undefined;
                }
                if (data.length === 0) {
                    return [];
                }
                else {
                    let element = data[0];
                    if (vscode_languageserver_protocol_1.DocumentSymbol.is(element)) {
                        return client.protocol2CodeConverter.asDocumentSymbols(data);
                    }
                    else {
                        return client.protocol2CodeConverter.asSymbolInformations(data);
                    }
                }
            }, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, error);
                return Promise.resolve([]);
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerDocumentSymbolProvider(options.documentSelector, {
            provideDocumentSymbols: (document, token) => {
                return middleware.provideDocumentSymbols
                    ? middleware.provideDocumentSymbols(document, token, provideDocumentSymbols)
                    : provideDocumentSymbols(document, token);
            }
        });
    }
}
class WorkspaceSymbolFeature extends WorkspaceFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let symbolCapabilities = ensure(ensure(capabilites, 'workspace'), 'symbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: SupportedSymbolKinds
        };
    }
    initialize(capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: undefined
        });
    }
    registerLanguageProvider(_options) {
        let client = this._client;
        let provideWorkspaceSymbols = (query, token) => {
            return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query }, token).then(client.protocol2CodeConverter.asSymbolInformations, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, error);
                return Promise.resolve([]);
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerWorkspaceSymbolProvider({
            provideWorkspaceSymbols: (query, token) => {
                return middleware.provideWorkspaceSymbols
                    ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols)
                    : provideWorkspaceSymbols(query, token);
            }
        });
    }
}
class CodeActionFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeActionRequest.type);
    }
    fillClientCapabilities(capabilites) {
        const cap = ensure(ensure(capabilites, 'textDocument'), 'codeAction');
        cap.dynamicRegistration = true;
        cap.codeActionLiteralSupport = {
            codeActionKind: {
                valueSet: [
                    '',
                    vscode_languageserver_protocol_1.CodeActionKind.QuickFix,
                    vscode_languageserver_protocol_1.CodeActionKind.Refactor,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,
                    vscode_languageserver_protocol_1.CodeActionKind.Source,
                    vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports
                ]
            }
        };
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.codeActionProvider || !documentSelector) {
            return;
        }
        let codeActionKinds = undefined;
        if (!Is.boolean(capabilities.codeActionProvider)) {
            codeActionKinds = capabilities.codeActionProvider.codeActionKinds;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: { documentSelector: documentSelector, codeActionKinds }
        });
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let provideCodeActions = (document, range, context, token) => {
            let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                range: client.code2ProtocolConverter.asRange(range),
                context: client.code2ProtocolConverter.asCodeActionContext(context)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token).then((values) => {
                if (values === null) {
                    return undefined;
                }
                let result = [];
                for (let item of values) {
                    if (vscode_languageserver_protocol_1.Command.is(item)) {
                        result.push(client.protocol2CodeConverter.asCommand(item));
                    }
                    else {
                        result.push(client.protocol2CodeConverter.asCodeAction(item));
                    }
                    ;
                }
                return result;
            }, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, error);
                return Promise.resolve([]);
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerCodeActionsProvider(options.documentSelector, {
            provideCodeActions: (document, range, context, token) => {
                return middleware.provideCodeActions
                    ? middleware.provideCodeActions(document, range, context, token, provideCodeActions)
                    : provideCodeActions(document, range, context, token);
            }
        }, options.codeActionKinds
            ? { providedCodeActionKinds: client.protocol2CodeConverter.asCodeActionKinds(options.codeActionKinds) }
            : undefined);
    }
}
class CodeLensFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'codeLens').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.codeLensProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector }, capabilities.codeLensProvider)
        });
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let provideCodeLenses = (document, token) => {
            return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client.code2ProtocolConverter.asCodeLensParams(document), token).then(client.protocol2CodeConverter.asCodeLenses, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, error);
                return Promise.resolve([]);
            });
        };
        let resolveCodeLens = (codeLens, token) => {
            return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client.code2ProtocolConverter.asCodeLens(codeLens), token).then(client.protocol2CodeConverter.asCodeLens, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, error);
                return codeLens;
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerCodeLensProvider(options.documentSelector, {
            provideCodeLenses: (document, token) => {
                return middleware.provideCodeLenses
                    ? middleware.provideCodeLenses(document, token, provideCodeLenses)
                    : provideCodeLenses(document, token);
            },
            resolveCodeLens: (options.resolveProvider)
                ? (codeLens, token) => {
                    return middleware.resolveCodeLens
                        ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens)
                        : resolveCodeLens(codeLens, token);
                }
                : undefined
        });
    }
}
class DocumentFormattingFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'formatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.documentFormattingProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector })
        });
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let provideDocumentFormattingEdits = (document, options, token) => {
            let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                options: client.code2ProtocolConverter.asFormattingOptions(options)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, error);
                return Promise.resolve([]);
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerDocumentFormattingEditProvider(options.documentSelector, {
            provideDocumentFormattingEdits: (document, options, token) => {
                return middleware.provideDocumentFormattingEdits
                    ? middleware.provideDocumentFormattingEdits(document, options, token, provideDocumentFormattingEdits)
                    : provideDocumentFormattingEdits(document, options, token);
            }
        });
    }
}
class DocumentRangeFormattingFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'rangeFormatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.documentRangeFormattingProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector })
        });
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let provideDocumentRangeFormattingEdits = (document, range, options, token) => {
            let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                range: client.code2ProtocolConverter.asRange(range),
                options: client.code2ProtocolConverter.asFormattingOptions(options)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, error);
                return Promise.resolve([]);
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerDocumentRangeFormattingEditProvider(options.documentSelector, {
            provideDocumentRangeFormattingEdits: (document, range, options, token) => {
                return middleware.provideDocumentRangeFormattingEdits
                    ? middleware.provideDocumentRangeFormattingEdits(document, range, options, token, provideDocumentRangeFormattingEdits)
                    : provideDocumentRangeFormattingEdits(document, range, options, token);
            }
        });
    }
}
class DocumentOnTypeFormattingFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'onTypeFormatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.documentOnTypeFormattingProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector }, capabilities.documentOnTypeFormattingProvider)
        });
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let moreTriggerCharacter = options.moreTriggerCharacter || [];
        let provideOnTypeFormattingEdits = (document, position, ch, options, token) => {
            let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                position: client.code2ProtocolConverter.asPosition(position),
                ch: ch,
                options: client.code2ProtocolConverter.asFormattingOptions(options)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, error);
                return Promise.resolve([]);
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerOnTypeFormattingEditProvider(options.documentSelector, {
            provideOnTypeFormattingEdits: (document, position, ch, options, token) => {
                return middleware.provideOnTypeFormattingEdits
                    ? middleware.provideOnTypeFormattingEdits(document, position, ch, options, token, provideOnTypeFormattingEdits)
                    : provideOnTypeFormattingEdits(document, position, ch, options, token);
            }
        }, options.firstTriggerCharacter, ...moreTriggerCharacter);
    }
}
class RenameFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.RenameRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let rename = ensure(ensure(capabilites, 'textDocument'), 'rename');
        rename.dynamicRegistration = true;
        rename.prepareSupport = true;
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.renameProvider || !documentSelector) {
            return;
        }
        let options = Object.assign({}, { documentSelector: documentSelector });
        if (Is.boolean(capabilities.renameProvider)) {
            options.prepareProvider = false;
        }
        else {
            options.prepareProvider = capabilities.renameProvider.prepareProvider;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let provideRenameEdits = (document, position, newName, token) => {
            let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                position: client.code2ProtocolConverter.asPosition(position),
                newName: newName
            };
            return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token).then(client.protocol2CodeConverter.asWorkspaceEdit, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, error);
                return Promise.reject(new Error(error.message));
            });
        };
        let prepareRename = (document, position, token) => {
            let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                position: client.code2ProtocolConverter.asPosition(position),
            };
            return client.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token).then((result) => {
                if (vscode_languageserver_protocol_1.Range.is(result)) {
                    return client.protocol2CodeConverter.asRange(result);
                }
                else if (result && result.range) {
                    return {
                        range: client.protocol2CodeConverter.asRange(result.range),
                        placeholder: result.placeholder
                    };
                }
                return null;
            }, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, error);
                return Promise.reject(new Error(error.message));
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerRenameProvider(options.documentSelector, {
            provideRenameEdits: (document, position, newName, token) => {
                return middleware.provideRenameEdits
                    ? middleware.provideRenameEdits(document, position, newName, token, provideRenameEdits)
                    : provideRenameEdits(document, position, newName, token);
            },
            prepareRename: options.prepareProvider
                ? (document, position, token) => {
                    return middleware.prepareRename
                        ? middleware.prepareRename(document, position, token, prepareRename)
                        : prepareRename(document, position, token);
                }
                : undefined
        });
    }
}
class DocumentLinkFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentLinkRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'documentLink').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.documentLinkProvider || !documentSelector) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector: documentSelector }, capabilities.documentLinkProvider)
        });
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let provideDocumentLinks = (document, token) => {
            return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, client.code2ProtocolConverter.asDocumentLinkParams(document), token).then(client.protocol2CodeConverter.asDocumentLinks, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, error);
                Promise.resolve(new Error(error.message));
            });
        };
        let resolveDocumentLink = (link, token) => {
            return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, client.code2ProtocolConverter.asDocumentLink(link), token).then(client.protocol2CodeConverter.asDocumentLink, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, error);
                Promise.resolve(new Error(error.message));
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerDocumentLinkProvider(options.documentSelector, {
            provideDocumentLinks: (document, token) => {
                return middleware.provideDocumentLinks
                    ? middleware.provideDocumentLinks(document, token, provideDocumentLinks)
                    : provideDocumentLinks(document, token);
            },
            resolveDocumentLink: options.resolveProvider
                ? (link, token) => {
                    return middleware.resolveDocumentLink
                        ? middleware.resolveDocumentLink(link, token, resolveDocumentLink)
                        : resolveDocumentLink(link, token);
                }
                : undefined
        });
    }
}
class ConfigurationFeature {
    constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'didChangeConfiguration').dynamicRegistration = true;
    }
    initialize() {
        let section = this._client.clientOptions.synchronize.configurationSection;
        if (section !== void 0) {
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: {
                    section: section
                }
            });
        }
    }
    register(_message, data) {
        let disposable = vscode_1.workspace.onDidChangeConfiguration((event) => {
            this.onDidChangeConfiguration(data.registerOptions.section, event);
        });
        this._listeners.set(data.id, disposable);
        if (data.registerOptions.section !== void 0) {
            this.onDidChangeConfiguration(data.registerOptions.section, undefined);
        }
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
            this._listeners.delete(id);
            disposable.dispose();
        }
    }
    dispose() {
        for (let disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    onDidChangeConfiguration(configurationSection, event) {
        let sections;
        if (Is.string(configurationSection)) {
            sections = [configurationSection];
        }
        else {
            sections = configurationSection;
        }
        if (sections !== void 0 && event !== void 0) {
            let affected = sections.some((section) => event.affectsConfiguration(section));
            if (!affected) {
                return;
            }
        }
        let didChangeConfiguration = (sections) => {
            if (sections === void 0) {
                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });
                return;
            }
            this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: this.extractSettingsInformation(sections) });
        };
        let middleware = this.getMiddleware();
        middleware
            ? middleware(sections, didChangeConfiguration)
            : didChangeConfiguration(sections);
    }
    extractSettingsInformation(keys) {
        function ensurePath(config, path) {
            let current = config;
            for (let i = 0; i < path.length - 1; i++) {
                let obj = current[path[i]];
                if (!obj) {
                    obj = Object.create(null);
                    current[path[i]] = obj;
                }
                current = obj;
            }
            return current;
        }
        let resource = this._client.clientOptions.workspaceFolder
            ? this._client.clientOptions.workspaceFolder.uri
            : undefined;
        let result = Object.create(null);
        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let index = key.indexOf('.');
            let config = null;
            if (index >= 0) {
                config = vscode_1.workspace.getConfiguration(key.substr(0, index), resource).get(key.substr(index + 1));
            }
            else {
                config = vscode_1.workspace.getConfiguration(key, resource);
            }
            if (config) {
                let path = keys[i].split('.');
                ensurePath(result, path)[path[path.length - 1]] = config;
            }
        }
        return result;
    }
    getMiddleware() {
        let middleware = this._client.clientOptions.middleware;
        if (middleware.workspace && middleware.workspace.didChangeConfiguration) {
            return middleware.workspace.didChangeConfiguration;
        }
        else {
            return undefined;
        }
    }
}
class ExecuteCommandFeature {
    constructor(_client) {
        this._client = _client;
        this._commands = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'executeCommand').dynamicRegistration = true;
    }
    initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
            return;
        }
        this.register(this.messages, {
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
    }
    register(_message, data) {
        let client = this._client;
        if (data.registerOptions.commands) {
            let disposeables = [];
            for (const command of data.registerOptions.commands) {
                disposeables.push(vscode_1.commands.registerCommand(command, (...args) => {
                    let params = {
                        command,
                        arguments: args
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(undefined, (error) => {
                        client.logFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, error);
                    });
                }));
            }
            this._commands.set(data.id, disposeables);
        }
    }
    unregister(id) {
        let disposeables = this._commands.get(id);
        if (disposeables) {
            disposeables.forEach(disposable => disposable.dispose());
        }
    }
    dispose() {
        this._commands.forEach((value) => {
            value.forEach(disposable => disposable.dispose());
        });
        this._commands.clear();
    }
}
var MessageTransports;
(function (MessageTransports) {
    function is(value) {
        let candidate = value;
        return candidate && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);
    }
    MessageTransports.is = is;
})(MessageTransports = exports.MessageTransports || (exports.MessageTransports = {}));
class OnReady {
    constructor(_resolve, _reject) {
        this._resolve = _resolve;
        this._reject = _reject;
        this._used = false;
    }
    get isUsed() {
        return this._used;
    }
    resolve() {
        this._used = true;
        this._resolve();
    }
    reject(error) {
        this._used = true;
        this._reject(error);
    }
}
class BaseLanguageClient {
    constructor(id, name, clientOptions) {
        this._traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        this._features = [];
        this._method2Message = new Map();
        this._dynamicFeatures = new Map();
        this._id = id;
        this._name = name;
        clientOptions = clientOptions || {};
        this._clientOptions = {
            documentSelector: clientOptions.documentSelector || [],
            synchronize: clientOptions.synchronize || {},
            diagnosticCollectionName: clientOptions.diagnosticCollectionName,
            outputChannelName: clientOptions.outputChannelName || this._name,
            revealOutputChannelOn: clientOptions.revealOutputChannelOn || RevealOutputChannelOn.Error,
            stdioEncoding: clientOptions.stdioEncoding || 'utf8',
            initializationOptions: clientOptions.initializationOptions,
            initializationFailedHandler: clientOptions.initializationFailedHandler,
            errorHandler: clientOptions.errorHandler || new DefaultErrorHandler(this._name),
            middleware: clientOptions.middleware || {},
            uriConverters: clientOptions.uriConverters,
            workspaceFolder: clientOptions.workspaceFolder
        };
        this._clientOptions.synchronize = this._clientOptions.synchronize || {};
        this.state = ClientState.Initial;
        this._connectionPromise = undefined;
        this._resolvedConnection = undefined;
        this._initializeResult = undefined;
        if (clientOptions.outputChannel) {
            this._outputChannel = clientOptions.outputChannel;
            this._disposeOutputChannel = false;
        }
        else {
            this._outputChannel = undefined;
            this._disposeOutputChannel = true;
        }
        this._listeners = undefined;
        this._providers = undefined;
        this._diagnostics = undefined;
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onReady = new Promise((resolve, reject) => {
            this._onReadyCallbacks = new OnReady(resolve, reject);
        });
        this._onStop = undefined;
        this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._tracer = {
            log: (messageOrDataObject, data) => {
                if (Is.string(messageOrDataObject)) {
                    this.logTrace(messageOrDataObject, data);
                }
                else {
                    this.logObjectTrace(messageOrDataObject);
                }
            },
        };
        this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : undefined);
        this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : undefined);
        this._syncedDocuments = new Map();
        this.registerBuiltinFeatures();
    }
    get state() {
        return this._state;
    }
    set state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
            this._stateChangeEmitter.fire({ oldState, newState });
        }
    }
    getPublicState() {
        if (this.state === ClientState.Running) {
            return State.Running;
        }
        else if (this.state === ClientState.Starting) {
            return State.Starting;
        }
        else {
            return State.Stopped;
        }
    }
    get initializeResult() {
        return this._initializeResult;
    }
    sendRequest(type, ...params) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        this.forceDocumentSync();
        try {
            return this._resolvedConnection.sendRequest(type, ...params);
        }
        catch (error) {
            this.error(`Sending request ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onRequest(type, handler) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            this._resolvedConnection.onRequest(type, handler);
        }
        catch (error) {
            this.error(`Registering request handler ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    sendNotification(type, params) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        this.forceDocumentSync();
        try {
            this._resolvedConnection.sendNotification(type, params);
        }
        catch (error) {
            this.error(`Sending notification ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onNotification(type, handler) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet');
        }
        try {
            this._resolvedConnection.onNotification(type, handler);
        }
        catch (error) {
            this.error(`Registering notification handler ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    get clientOptions() {
        return this._clientOptions;
    }
    get protocol2CodeConverter() {
        return this._p2c;
    }
    get code2ProtocolConverter() {
        return this._c2p;
    }
    get onTelemetry() {
        return this._telemetryEmitter.event;
    }
    get onDidChangeState() {
        return this._stateChangeEmitter.event;
    }
    get outputChannel() {
        if (!this._outputChannel) {
            this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
        }
        return this._outputChannel;
    }
    get diagnostics() {
        return this._diagnostics;
    }
    createDefaultErrorHandler() {
        return new DefaultErrorHandler(this._name);
    }
    set trace(value) {
        this._trace = value;
        this.onReady().then(() => {
            this.resolveConnection().then((connection) => {
                connection.trace(this._trace, this._tracer, {
                    sendNotification: false,
                    traceFormat: this._traceFormat
                });
            });
        }, () => {
        });
    }
    data2String(data) {
        if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
            const responseError = data;
            return `  Message: ${responseError.message}\n  Code: ${responseError.code} ${responseError.data ? '\n' + responseError.data.toString() : ''}`;
        }
        if (data instanceof Error) {
            if (Is.string(data.stack)) {
                return data.stack;
            }
            return data.message;
        }
        if (Is.string(data)) {
            return data;
        }
        return data.toString();
    }
    info(message, data) {
        this.outputChannel.appendLine(`[Info  - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
            this.outputChannel.show(true);
        }
    }
    warn(message, data) {
        this.outputChannel.appendLine(`[Warn  - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
            this.outputChannel.show(true);
        }
    }
    error(message, data) {
        this.outputChannel.appendLine(`[Error - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error) {
            this.outputChannel.show(true);
        }
    }
    logTrace(message, data) {
        this.outputChannel.appendLine(`[Trace - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.outputChannel.appendLine(this.data2String(data));
        }
    }
    logObjectTrace(data) {
        if (data.isLSPMessage && data.type) {
            this.outputChannel.append(`[LSP   - ${(new Date().toLocaleTimeString())}] `);
        }
        else {
            this.outputChannel.append(`[Trace - ${(new Date().toLocaleTimeString())}] `);
        }
        if (data) {
            this.outputChannel.appendLine(`${JSON.stringify(data)}`);
        }
    }
    needsStart() {
        return this.state === ClientState.Initial || this.state === ClientState.Stopping || this.state === ClientState.Stopped;
    }
    needsStop() {
        return this.state === ClientState.Starting || this.state === ClientState.Running;
    }
    onReady() {
        return this._onReady;
    }
    isConnectionActive() {
        return this.state === ClientState.Running && !!this._resolvedConnection;
    }
    start() {
        if (this._onReadyCallbacks.isUsed) {
            this._onReady = new Promise((resolve, reject) => {
                this._onReadyCallbacks = new OnReady(resolve, reject);
            });
        }
        this._listeners = [];
        this._providers = [];
        // If we restart then the diagnostics collection is reused.
        if (!this._diagnostics) {
            this._diagnostics = this._clientOptions.diagnosticCollectionName
                ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName)
                : vscode_1.languages.createDiagnosticCollection();
        }
        this.state = ClientState.Starting;
        this.resolveConnection().then((connection) => {
            connection.onLogMessage((message) => {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        this.error(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        this.warn(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        this.info(message.message);
                        break;
                    default:
                        this.outputChannel.appendLine(message.message);
                }
            });
            connection.onShowMessage((message) => {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        vscode_1.window.showErrorMessage(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        vscode_1.window.showWarningMessage(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        vscode_1.window.showInformationMessage(message.message);
                        break;
                    default:
                        vscode_1.window.showInformationMessage(message.message);
                }
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, (params) => {
                let messageFunc;
                switch (params.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        messageFunc = vscode_1.window.showErrorMessage;
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        messageFunc = vscode_1.window.showWarningMessage;
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        messageFunc = vscode_1.window.showInformationMessage;
                        break;
                    default:
                        messageFunc = vscode_1.window.showInformationMessage;
                }
                let actions = params.actions || [];
                return messageFunc(params.message, ...actions);
            });
            connection.onTelemetry((data) => {
                this._telemetryEmitter.fire(data);
            });
            connection.listen();
            // Error is handled in the initialize call.
            return this.initialize(connection);
        }).then(undefined, (error) => {
            this.state = ClientState.StartFailed;
            this._onReadyCallbacks.reject(error);
            this.error('Starting client failed', error);
            vscode_1.window.showErrorMessage(`Couldn't start client ${this._name}`);
        });
        return new vscode_1.Disposable(() => {
            if (this.needsStop()) {
                this.stop();
            }
        });
    }
    resolveConnection() {
        if (!this._connectionPromise) {
            this._connectionPromise = this.createConnection();
        }
        return this._connectionPromise;
    }
    initialize(connection) {
        this.refreshTrace(connection, false);
        let initOption = this._clientOptions.initializationOptions;
        let rootPath = this._clientOptions.workspaceFolder
            ? this._clientOptions.workspaceFolder.uri.fsPath
            : this._clientGetRootPath();
        let initParams = {
            processId: process.pid,
            rootPath: rootPath ? rootPath : null,
            rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,
            capabilities: this.computeClientCapabilities(),
            initializationOptions: Is.func(initOption) ? initOption() : initOption,
            trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
            workspaceFolders: null
        };
        this.fillInitializeParams(initParams);
        return connection.initialize(initParams).then((result) => {
            this._resolvedConnection = connection;
            this._initializeResult = result;
            this.state = ClientState.Running;
            let textDocumentSyncOptions = undefined;
            if (Is.number(result.capabilities.textDocumentSync)) {
                if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
                    textDocumentSyncOptions = {
                        openClose: false,
                        change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,
                        save: undefined
                    };
                }
                else {
                    textDocumentSyncOptions = {
                        openClose: true,
                        change: result.capabilities.textDocumentSync,
                        save: {
                            includeText: false
                        }
                    };
                }
            }
            else if (result.capabilities.textDocumentSync !== void 0 && result.capabilities.textDocumentSync !== null) {
                textDocumentSyncOptions = result.capabilities.textDocumentSync;
            }
            this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
            connection.onDiagnostics(params => this.handleDiagnostics(params));
            connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params => this.handleRegistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/registerFeature', params => this.handleRegistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params => this.handleUnregistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/unregisterFeature', params => this.handleUnregistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params => this.handleApplyWorkspaceEdit(params));
            connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});
            this.hookFileEvents(connection);
            this.hookConfigurationChanged(connection);
            this.initializeFeatures(connection);
            this._onReadyCallbacks.resolve();
            return result;
        }).then(undefined, (error) => {
            if (this._clientOptions.initializationFailedHandler) {
                if (this._clientOptions.initializationFailedHandler(error)) {
                    this.initialize(connection);
                }
                else {
                    this.stop();
                    this._onReadyCallbacks.reject(error);
                }
            }
            else if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry) {
                vscode_1.window.showErrorMessage(error.message, { title: 'Retry', id: "retry" }).then(item => {
                    if (item && item.id === 'retry') {
                        this.initialize(connection);
                    }
                    else {
                        this.stop();
                        this._onReadyCallbacks.reject(error);
                    }
                });
            }
            else {
                if (error && error.message) {
                    vscode_1.window.showErrorMessage(error.message);
                }
                this.error('Server initialization failed.', error);
                this.stop();
                this._onReadyCallbacks.reject(error);
            }
        });
    }
    _clientGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
            return undefined;
        }
        let folder = folders[0];
        if (folder.uri.scheme === 'file') {
            return folder.uri.fsPath;
        }
        return undefined;
    }
    stop() {
        this._initializeResult = undefined;
        if (!this._connectionPromise) {
            this.state = ClientState.Stopped;
            return Promise.resolve();
        }
        if (this.state === ClientState.Stopping && this._onStop) {
            return this._onStop;
        }
        this.state = ClientState.Stopping;
        this.cleanUp();
        // unhook listeners
        return this._onStop = this.resolveConnection().then(connection => {
            return connection.shutdown().then(() => {
                connection.exit();
                connection.dispose();
                this.state = ClientState.Stopped;
                this._onStop = undefined;
                this._connectionPromise = undefined;
                this._resolvedConnection = undefined;
            });
        });
    }
    cleanUp(channel = true, diagnostics = true) {
        if (this._listeners) {
            this._listeners.forEach(listener => listener.dispose());
            this._listeners = undefined;
        }
        if (this._providers) {
            this._providers.forEach(provider => provider.dispose());
            this._providers = undefined;
        }
        if (this._syncedDocuments) {
            this._syncedDocuments.clear();
        }
        for (let handler of this._dynamicFeatures.values()) {
            handler.dispose();
        }
        if (channel && this._outputChannel && this._disposeOutputChannel) {
            this._outputChannel.dispose();
            this._outputChannel = undefined;
        }
        if (diagnostics && this._diagnostics) {
            this._diagnostics.dispose();
            this._diagnostics = undefined;
        }
    }
    notifyFileEvent(event) {
        this._fileEvents.push(event);
        this._fileEventDelayer.trigger(() => {
            this.onReady().then(() => {
                this.resolveConnection().then(connection => {
                    if (this.isConnectionActive()) {
                        connection.didChangeWatchedFiles({ changes: this._fileEvents });
                    }
                    this._fileEvents = [];
                });
            }, (error) => {
                this.error(`Notify file events failed.`, error);
            });
        });
    }
    forceDocumentSync() {
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method).forceDelivery();
    }
    handleDiagnostics(params) {
        if (!this._diagnostics) {
            return;
        }
        let uri = this._p2c.asUri(params.uri);
        let diagnostics = this._p2c.asDiagnostics(params.diagnostics);
        let middleware = this.clientOptions.middleware.handleDiagnostics;
        if (middleware) {
            middleware(uri, diagnostics, (uri, diagnostics) => this.setDiagnostics(uri, diagnostics));
        }
        else {
            this.setDiagnostics(uri, diagnostics);
        }
    }
    setDiagnostics(uri, diagnostics) {
        if (!this._diagnostics) {
            return;
        }
        this._diagnostics.set(uri, diagnostics);
    }
    createConnection() {
        let errorHandler = (error, message, count) => {
            this.handleConnectionError(error, message, count);
        };
        let closeHandler = () => {
            this.handleConnectionClosed();
        };
        return this.createMessageTransports(this._clientOptions.stdioEncoding || 'utf8').then((transports) => {
            return createConnection(transports.reader, transports.writer, errorHandler, closeHandler);
        });
    }
    handleConnectionClosed() {
        // Check whether this is a normal shutdown in progress or the client stopped normally.
        if (this.state === ClientState.Stopping || this.state === ClientState.Stopped) {
            return;
        }
        try {
            if (this._resolvedConnection) {
                this._resolvedConnection.dispose();
            }
        }
        catch (error) {
            // Disposing a connection could fail if error cases.
        }
        let action = CloseAction.DoNotRestart;
        try {
            action = this._clientOptions.errorHandler.closed();
        }
        catch (error) {
            // Ignore errors coming from the error handler.
        }
        this._connectionPromise = undefined;
        this._resolvedConnection = undefined;
        if (action === CloseAction.DoNotRestart) {
            this.error('Connection to server got closed. Server will not be restarted.');
            this.state = ClientState.Stopped;
            this.cleanUp(false, true);
        }
        else if (action === CloseAction.Restart) {
            this.info('Connection to server got closed. Server will restart.');
            this.cleanUp(false, false);
            this.state = ClientState.Initial;
            this.start();
        }
    }
    handleConnectionError(error, message, count) {
        let action = this._clientOptions.errorHandler.error(error, message, count);
        if (action === ErrorAction.Shutdown) {
            this.error('Connection to server is erroring. Shutting down server.');
            this.stop();
        }
    }
    hookConfigurationChanged(connection) {
        vscode_1.workspace.onDidChangeConfiguration(() => {
            this.refreshTrace(connection, true);
        });
    }
    refreshTrace(connection, sendNotification = false) {
        let config = vscode_1.workspace.getConfiguration(this._id);
        let trace = vscode_languageserver_protocol_1.Trace.Off;
        let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        if (config) {
            const traceConfig = config.get('trace.server', 'off');
            if (typeof traceConfig === 'string') {
                trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);
            }
            else {
                trace = vscode_languageserver_protocol_1.Trace.fromString(config.get('trace.server.verbosity', 'off'));
                traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get('trace.server.format', 'text'));
            }
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
            sendNotification,
            traceFormat: this._traceFormat
        });
    }
    hookFileEvents(_connection) {
        let fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents) {
            return;
        }
        let watchers;
        if (Is.array(fileEvents)) {
            watchers = fileEvents;
        }
        else {
            watchers = [fileEvents];
        }
        if (!watchers) {
            return;
        }
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
    }
    registerFeatures(features) {
        for (let feature of features) {
            this.registerFeature(feature);
        }
    }
    registerFeature(feature) {
        this._features.push(feature);
        if (DynamicFeature.is(feature)) {
            let messages = feature.messages;
            if (Array.isArray(messages)) {
                for (let message of messages) {
                    this._method2Message.set(message.method, message);
                    this._dynamicFeatures.set(message.method, feature);
                }
            }
            else {
                this._method2Message.set(messages.method, messages);
                this._dynamicFeatures.set(messages.method, feature);
            }
        }
    }
    registerBuiltinFeatures() {
        this.registerFeature(new ConfigurationFeature(this));
        this.registerFeature(new DidOpenTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new DidChangeTextDocumentFeature(this));
        this.registerFeature(new WillSaveFeature(this));
        this.registerFeature(new WillSaveWaitUntilFeature(this));
        this.registerFeature(new DidSaveTextDocumentFeature(this));
        this.registerFeature(new DidCloseTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
        this.registerFeature(new CompletionItemFeature(this));
        this.registerFeature(new HoverFeature(this));
        this.registerFeature(new SignatureHelpFeature(this));
        this.registerFeature(new DefinitionFeature(this));
        this.registerFeature(new ReferencesFeature(this));
        this.registerFeature(new DocumentHighlightFeature(this));
        this.registerFeature(new DocumentSymbolFeature(this));
        this.registerFeature(new WorkspaceSymbolFeature(this));
        this.registerFeature(new CodeActionFeature(this));
        this.registerFeature(new CodeLensFeature(this));
        this.registerFeature(new DocumentFormattingFeature(this));
        this.registerFeature(new DocumentRangeFormattingFeature(this));
        this.registerFeature(new DocumentOnTypeFormattingFeature(this));
        this.registerFeature(new RenameFeature(this));
        this.registerFeature(new DocumentLinkFeature(this));
        this.registerFeature(new ExecuteCommandFeature(this));
    }
    fillInitializeParams(params) {
        for (let feature of this._features) {
            if (Is.func(feature.fillInitializeParams)) {
                feature.fillInitializeParams(params);
            }
        }
    }
    computeClientCapabilities() {
        let result = {};
        ensure(result, 'workspace').applyEdit = true;
        let workspaceEdit = ensure(ensure(result, 'workspace'), 'workspaceEdit');
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;
        ensure(ensure(result, 'textDocument'), 'publishDiagnostics').relatedInformation = true;
        for (let feature of this._features) {
            feature.fillClientCapabilities(result);
        }
        return result;
    }
    initializeFeatures(_connection) {
        let documentSelector = this._clientOptions.documentSelector;
        for (let feature of this._features) {
            feature.initialize(this._capabilities, documentSelector);
        }
    }
    handleRegistrationRequest(params) {
        return new Promise((resolve, reject) => {
            for (let registration of params.registrations) {
                const feature = this._dynamicFeatures.get(registration.method);
                if (!feature) {
                    reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
                    return;
                }
                const options = registration.registerOptions || {};
                options.documentSelector = options.documentSelector || this._clientOptions.documentSelector;
                const data = {
                    id: registration.id,
                    registerOptions: options
                };
                feature.register(this._method2Message.get(registration.method), data);
            }
            resolve();
        });
    }
    handleUnregistrationRequest(params) {
        return new Promise((resolve, reject) => {
            for (let unregistration of params.unregisterations) {
                const feature = this._dynamicFeatures.get(unregistration.method);
                if (!feature) {
                    reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
                    return;
                }
                feature.unregister(unregistration.id);
            }
            ;
            resolve();
        });
    }
    handleApplyWorkspaceEdit(params) {
        // This is some sort of workaround since the version check should be done by VS Code in the Workspace.applyEdit.
        // However doing it here adds some safety since the server can lag more behind then an extension.
        let workspaceEdit = params.edit;
        let openTextDocuments = new Map();
        vscode_1.workspace.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
            for (const change of workspaceEdit.documentChanges) {
                if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                    let textDocument = openTextDocuments.get(change.textDocument.uri);
                    if (textDocument && textDocument.version !== change.textDocument.version) {
                        versionMismatch = true;
                        break;
                    }
                }
            }
        }
        if (versionMismatch) {
            return Promise.resolve({ applied: false });
        }
        return vscode_1.workspace.applyEdit(this._p2c.asWorkspaceEdit(params.edit)).then((value) => { return { applied: value }; });
    }
    ;
    logFailedRequest(type, error) {
        // If we get a request cancel don't log anything.
        if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.code === vscode_languageserver_protocol_1.ErrorCodes.RequestCancelled) {
            return;
        }
        this.error(`Request ${type.method} failed.`, error);
    }
}
exports.BaseLanguageClient = BaseLanguageClient;


/***/ }),

/***/ 2639:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(7549);
const proto = __webpack_require__(5310);
const Is = __webpack_require__(4797);
const protocolCompletionItem_1 = __webpack_require__(3810);
const protocolCodeLens_1 = __webpack_require__(3780);
const protocolDocumentLink_1 = __webpack_require__(6380);
function createConverter(uriConverter) {
    const nullConverter = (value) => value.toString();
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri)
        };
    }
    function asVersionedTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri),
            version: textDocument.version
        };
    }
    function asOpenTextDocumentParams(textDocument) {
        return {
            textDocument: {
                uri: _uriConverter(textDocument.uri),
                languageId: textDocument.languageId,
                version: textDocument.version,
                text: textDocument.getText()
            }
        };
    }
    function isTextDocumentChangeEvent(value) {
        let candidate = value;
        return !!candidate.document && !!candidate.contentChanges;
    }
    function isTextDocument(value) {
        let candidate = value;
        return !!candidate.uri && !!candidate.version;
    }
    function asChangeTextDocumentParams(arg) {
        if (isTextDocument(arg)) {
            let result = {
                textDocument: {
                    uri: _uriConverter(arg.uri),
                    version: arg.version
                },
                contentChanges: [{ text: arg.getText() }]
            };
            return result;
        }
        else if (isTextDocumentChangeEvent(arg)) {
            let document = arg.document;
            let result = {
                textDocument: {
                    uri: _uriConverter(document.uri),
                    version: document.version
                },
                contentChanges: arg.contentChanges.map((change) => {
                    let range = change.range;
                    return {
                        range: {
                            start: { line: range.start.line, character: range.start.character },
                            end: { line: range.end.line, character: range.end.character }
                        },
                        rangeLength: change.rangeLength,
                        text: change.text
                    };
                })
            };
            return result;
        }
        else {
            throw Error('Unsupported text document change parameter');
        }
    }
    function asCloseTextDocumentParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asSaveTextDocumentParams(textDocument, includeContent = false) {
        let result = {
            textDocument: asVersionedTextDocumentIdentifier(textDocument)
        };
        if (includeContent) {
            result.text = textDocument.getText();
        }
        return result;
    }
    function asTextDocumentSaveReason(reason) {
        switch (reason) {
            case code.TextDocumentSaveReason.Manual:
                return proto.TextDocumentSaveReason.Manual;
            case code.TextDocumentSaveReason.AfterDelay:
                return proto.TextDocumentSaveReason.AfterDelay;
            case code.TextDocumentSaveReason.FocusOut:
                return proto.TextDocumentSaveReason.FocusOut;
        }
        return proto.TextDocumentSaveReason.Manual;
    }
    function asWillSaveTextDocumentParams(event) {
        return {
            textDocument: asTextDocumentIdentifier(event.document),
            reason: asTextDocumentSaveReason(event.reason)
        };
    }
    function asTextDocumentPositionParams(textDocument, position) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position)
        };
    }
    function asTriggerKind(triggerKind) {
        switch (triggerKind) {
            case code.CompletionTriggerKind.TriggerCharacter:
                return proto.CompletionTriggerKind.TriggerCharacter;
            case code.CompletionTriggerKind.TriggerForIncompleteCompletions:
                return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;
            default:
                return proto.CompletionTriggerKind.Invoked;
        }
    }
    function asCompletionParams(textDocument, position, context) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
                triggerKind: asTriggerKind(context.triggerKind),
                triggerCharacter: context.triggerCharacter
            }
        };
    }
    function asWorkerPosition(position) {
        return { line: position.line, character: position.character };
    }
    function asPosition(value) {
        if (value === void 0) {
            return undefined;
        }
        else if (value === null) {
            return null;
        }
        return { line: value.line, character: value.character };
    }
    function asRange(value) {
        if (value === void 0 || value === null) {
            return value;
        }
        return { start: asPosition(value.start), end: asPosition(value.end) };
    }
    function asDiagnosticSeverity(value) {
        switch (value) {
            case code.DiagnosticSeverity.Error:
                return proto.DiagnosticSeverity.Error;
            case code.DiagnosticSeverity.Warning:
                return proto.DiagnosticSeverity.Warning;
            case code.DiagnosticSeverity.Information:
                return proto.DiagnosticSeverity.Information;
            case code.DiagnosticSeverity.Hint:
                return proto.DiagnosticSeverity.Hint;
        }
    }
    function asDiagnostic(item) {
        let result = proto.Diagnostic.create(asRange(item.range), item.message);
        if (Is.number(item.severity)) {
            result.severity = asDiagnosticSeverity(item.severity);
        }
        if (Is.number(item.code) || Is.string(item.code)) {
            result.code = item.code;
        }
        if (item.source) {
            result.source = item.source;
        }
        return result;
    }
    function asDiagnostics(items) {
        if (items === void 0 || items === null) {
            return items;
        }
        return items.map(asDiagnostic);
    }
    function asDocumentation(format, documentation) {
        switch (format) {
            case '$string':
                return documentation;
            case proto.MarkupKind.PlainText:
                return { kind: format, value: documentation };
            case proto.MarkupKind.Markdown:
                return { kind: format, value: documentation.value };
            default:
                return `Unsupported Markup content received. Kind is: ${format}`;
        }
    }
    function asCompletionItemKind(value, original) {
        if (original !== void 0) {
            return original;
        }
        return value + 1;
    }
    function asCompletionItem(item) {
        let result = { label: item.label };
        let protocolItem = item instanceof protocolCompletionItem_1.default ? item : undefined;
        if (item.detail) {
            result.detail = item.detail;
        }
        // We only send items back we created. So this can't be something else than
        // a string right now.
        if (item.documentation) {
            if (!protocolItem || protocolItem.documentationFormat === '$string') {
                result.documentation = item.documentation;
            }
            else {
                result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation);
            }
        }
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        fillPrimaryInsertText(result, item);
        if (Is.number(item.kind)) {
            result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (item.commitCharacters) {
            result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
        }
        if (protocolItem) {
            if (protocolItem.data !== void 0) {
                result.data = protocolItem.data;
            }
            if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
                result.deprecated = protocolItem.deprecated;
            }
        }
        return result;
    }
    function fillPrimaryInsertText(target, source) {
        let format = proto.InsertTextFormat.PlainText;
        let text;
        let range = undefined;
        if (source.textEdit) {
            text = source.textEdit.newText;
            range = asRange(source.textEdit.range);
        }
        else if (source.insertText instanceof code.SnippetString) {
            format = proto.InsertTextFormat.Snippet;
            text = source.insertText.value;
        }
        else {
            text = source.insertText;
        }
        if (source.range) {
            range = asRange(source.range);
        }
        target.insertTextFormat = format;
        if (source.fromEdit && text && range) {
            target.textEdit = { newText: text, range: range };
        }
        else {
            target.insertText = text;
        }
    }
    function asTextEdit(edit) {
        return { range: asRange(edit.range), newText: edit.newText };
    }
    function asTextEdits(edits) {
        if (edits === void 0 || edits === null) {
            return edits;
        }
        return edits.map(asTextEdit);
    }
    function asReferenceParams(textDocument, position, options) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: { includeDeclaration: options.includeDeclaration }
        };
    }
    function asCodeActionContext(context) {
        if (context === void 0 || context === null) {
            return context;
        }
        return proto.CodeActionContext.create(asDiagnostics(context.diagnostics), Is.string(context.only) ? [context.only] : undefined);
    }
    function asCommand(item) {
        let result = proto.Command.create(item.title, item.command);
        if (item.arguments) {
            result.arguments = item.arguments;
        }
        return result;
    }
    function asCodeLens(item) {
        let result = proto.CodeLens.create(asRange(item.range));
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item instanceof protocolCodeLens_1.default) {
            if (item.data) {
                result.data = item.data;
            }
            ;
        }
        return result;
    }
    function asFormattingOptions(item) {
        return { tabSize: item.tabSize, insertSpaces: item.insertSpaces };
    }
    function asDocumentSymbolParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asCodeLensParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asDocumentLink(item) {
        let result = proto.DocumentLink.create(asRange(item.range));
        if (item.target) {
            result.target = asUri(item.target);
        }
        let protocolItem = item instanceof protocolDocumentLink_1.default ? item : undefined;
        if (protocolItem && protocolItem.data) {
            result.data = protocolItem.data;
        }
        return result;
    }
    function asDocumentLinkParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    return {
        asUri,
        asTextDocumentIdentifier,
        asVersionedTextDocumentIdentifier,
        asOpenTextDocumentParams,
        asChangeTextDocumentParams,
        asCloseTextDocumentParams,
        asSaveTextDocumentParams,
        asWillSaveTextDocumentParams,
        asTextDocumentPositionParams,
        asCompletionParams,
        asWorkerPosition,
        asRange,
        asPosition,
        asDiagnosticSeverity,
        asDiagnostic,
        asDiagnostics,
        asCompletionItem,
        asTextEdit,
        asReferenceParams,
        asCodeActionContext,
        asCommand,
        asCodeLens,
        asFormattingOptions,
        asDocumentSymbolParams,
        asCodeLensParams,
        asDocumentLink,
        asDocumentLinkParams
    };
}
exports.createConverter = createConverter;


/***/ }),

/***/ 2014:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const UUID = __webpack_require__(7465);
const Is = __webpack_require__(4797);
const vscode_1 = __webpack_require__(7549);
const vscode_languageserver_protocol_1 = __webpack_require__(5310);
const client_1 = __webpack_require__(7014);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class ColorProviderFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentColorRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'colorProvider').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.colorProvider) {
            return;
        }
        const implCapabilities = capabilities.colorProvider;
        const id = Is.string(implCapabilities.id) && implCapabilities.id.length > 0 ? implCapabilities.id : UUID.generateUuid();
        const selector = implCapabilities.documentSelector || documentSelector;
        if (selector) {
            this.register(this.messages, {
                id,
                registerOptions: Object.assign({}, { documentSelector: selector })
            });
        }
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let provideColorPresentations = (color, context, token) => {
            const requestParams = {
                color,
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(context.document),
                range: client.code2ProtocolConverter.asRange(context.range)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token).then(this.asColorPresentations.bind(this), (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, error);
                return Promise.resolve(null);
            });
        };
        let provideDocumentColors = (document, token) => {
            const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token).then(this.asColorInformations.bind(this), (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, error);
                return Promise.resolve(null);
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerColorProvider(options.documentSelector, {
            provideColorPresentations: (color, context, token) => {
                return middleware.provideColorPresentations
                    ? middleware.provideColorPresentations(color, context, token, provideColorPresentations)
                    : provideColorPresentations(color, context, token);
            },
            provideDocumentColors: (document, token) => {
                return middleware.provideDocumentColors
                    ? middleware.provideDocumentColors(document, token, provideDocumentColors)
                    : provideDocumentColors(document, token);
            }
        });
    }
    asColor(color) {
        return new vscode_1.Color(color.red, color.green, color.blue, color.alpha);
    }
    asColorInformations(colorInformation) {
        if (Array.isArray(colorInformation)) {
            return colorInformation.map(ci => {
                return new vscode_1.ColorInformation(this._client.protocol2CodeConverter.asRange(ci.range), this.asColor(ci.color));
            });
        }
        return [];
    }
    asColorPresentations(colorPresentations) {
        if (Array.isArray(colorPresentations)) {
            return colorPresentations.map(cp => {
                let presentation = new vscode_1.ColorPresentation(cp.label);
                presentation.additionalTextEdits = this._client.protocol2CodeConverter.asTextEdits(cp.additionalTextEdits);
                presentation.textEdit = this._client.protocol2CodeConverter.asTextEdit(cp.textEdit);
                return presentation;
            });
        }
        return [];
    }
}
exports.ColorProviderFeature = ColorProviderFeature;


/***/ }),

/***/ 1877:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_1 = __webpack_require__(7549);
const vscode_languageserver_protocol_1 = __webpack_require__(5310);
class ConfigurationFeature {
    constructor(_client) {
        this._client = _client;
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.configuration = true;
    }
    initialize() {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {
            let configuration = (params) => {
                let result = [];
                for (let item of params.items) {
                    let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : undefined;
                    result.push(this.getConfiguration(resource, item.section !== null ? item.section : undefined));
                }
                return result;
            };
            let middleware = client.clientOptions.middleware.workspace;
            return middleware && middleware.configuration
                ? middleware.configuration(params, token, configuration)
                : configuration(params, token);
        });
    }
    getConfiguration(resource, section) {
        let result = null;
        if (section) {
            let index = section.lastIndexOf('.');
            if (index === -1) {
                result = vscode_1.workspace.getConfiguration(undefined, resource).get(section);
            }
            else {
                let config = vscode_1.workspace.getConfiguration(section.substr(0, index));
                if (config) {
                    result = config.get(section.substr(index + 1));
                }
            }
        }
        else {
            let config = vscode_1.workspace.getConfiguration(undefined, resource);
            result = {};
            for (let key of Object.keys(config)) {
                if (config.has(key)) {
                    result[key] = config.get(key);
                }
            }
        }
        if (!result) {
            return null;
        }
        return result;
    }
}
exports.ConfigurationFeature = ConfigurationFeature;


/***/ }),

/***/ 5874:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const UUID = __webpack_require__(7465);
const Is = __webpack_require__(4797);
const vscode_1 = __webpack_require__(7549);
const vscode_languageserver_protocol_1 = __webpack_require__(5310);
const client_1 = __webpack_require__(7014);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class DeclarationFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DeclarationRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let declarationSupport = ensure(ensure(capabilites, 'textDocument'), 'declaration');
        declarationSupport.dynamicRegistration = true;
        declarationSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.declarationProvider) {
            return;
        }
        if (capabilities.declarationProvider === true) {
            if (!documentSelector) {
                return;
            }
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector })
            });
        }
        else {
            const declCapabilities = capabilities.declarationProvider;
            const id = Is.string(declCapabilities.id) && declCapabilities.id.length > 0 ? declCapabilities.id : UUID.generateUuid();
            const selector = declCapabilities.documentSelector || documentSelector;
            if (selector) {
                this.register(this.messages, {
                    id,
                    registerOptions: Object.assign({}, { documentSelector: selector })
                });
            }
        }
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let provideDeclaration = (document, position, token) => {
            return client.sendRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDeclarationResult, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, error);
                return Promise.resolve(null);
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerDeclarationProvider(options.documentSelector, {
            provideDeclaration: (document, position, token) => {
                return middleware.provideDeclaration
                    ? middleware.provideDeclaration(document, position, token, provideDeclaration)
                    : provideDeclaration(document, position, token);
            }
        });
    }
}
exports.DeclarationFeature = DeclarationFeature;


/***/ }),

/***/ 9882:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const UUID = __webpack_require__(7465);
const Is = __webpack_require__(4797);
const vscode_1 = __webpack_require__(7549);
const vscode_languageserver_protocol_1 = __webpack_require__(5310);
const client_1 = __webpack_require__(7014);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class FoldingRangeFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.FoldingRangeRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let capability = ensure(ensure(capabilites, 'textDocument'), 'foldingRange');
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5000;
        capability.lineFoldingOnly = true;
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.foldingRangeProvider) {
            return;
        }
        const implCapabilities = capabilities.foldingRangeProvider;
        const id = Is.string(implCapabilities.id) && implCapabilities.id.length > 0 ? implCapabilities.id : UUID.generateUuid();
        const selector = implCapabilities.documentSelector || documentSelector;
        if (selector) {
            this.register(this.messages, {
                id,
                registerOptions: Object.assign({}, { documentSelector: selector })
            });
        }
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let provideFoldingRanges = (document, _, token) => {
            const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token).then(this.asFoldingRanges.bind(this), (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, error);
                return Promise.resolve(null);
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerFoldingRangeProvider(options.documentSelector, {
            provideFoldingRanges(document, context, token) {
                return middleware.provideFoldingRanges
                    ? middleware.provideFoldingRanges(document, context, token, provideFoldingRanges)
                    : provideFoldingRanges(document, context, token);
            }
        });
    }
    asFoldingRangeKind(kind) {
        if (kind) {
            switch (kind) {
                case vscode_languageserver_protocol_1.FoldingRangeKind.Comment:
                    return vscode_1.FoldingRangeKind.Comment;
                case vscode_languageserver_protocol_1.FoldingRangeKind.Imports:
                    return vscode_1.FoldingRangeKind.Imports;
                case vscode_languageserver_protocol_1.FoldingRangeKind.Region:
                    return vscode_1.FoldingRangeKind.Region;
            }
        }
        return void 0;
    }
    asFoldingRanges(foldingRanges) {
        if (Array.isArray(foldingRanges)) {
            return foldingRanges.map(r => {
                return new vscode_1.FoldingRange(r.startLine, r.endLine, this.asFoldingRangeKind(r.kind));
            });
        }
        return [];
    }
}
exports.FoldingRangeFeature = FoldingRangeFeature;


/***/ }),

/***/ 1133:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const UUID = __webpack_require__(7465);
const Is = __webpack_require__(4797);
const vscode_1 = __webpack_require__(7549);
const vscode_languageserver_protocol_1 = __webpack_require__(5310);
const client_1 = __webpack_require__(7014);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class ImplementationFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.ImplementationRequest.type);
    }
    fillClientCapabilities(capabilites) {
        let implementationSupport = ensure(ensure(capabilites, 'textDocument'), 'implementation');
        implementationSupport.dynamicRegistration = true;
        implementationSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.implementationProvider) {
            return;
        }
        if (capabilities.implementationProvider === true) {
            if (!documentSelector) {
                return;
            }
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector })
            });
        }
        else {
            const implCapabilities = capabilities.implementationProvider;
            const id = Is.string(implCapabilities.id) && implCapabilities.id.length > 0 ? implCapabilities.id : UUID.generateUuid();
            const selector = implCapabilities.documentSelector || documentSelector;
            if (selector) {
                this.register(this.messages, {
                    id,
                    registerOptions: Object.assign({}, { documentSelector: selector })
                });
            }
        }
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let provideImplementation = (document, position, token) => {
            return client.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, error);
                return Promise.resolve(null);
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerImplementationProvider(options.documentSelector, {
            provideImplementation: (document, position, token) => {
                return middleware.provideImplementation
                    ? middleware.provideImplementation(document, position, token, provideImplementation)
                    : provideImplementation(document, position, token);
            }
        });
    }
}
exports.ImplementationFeature = ImplementationFeature;


/***/ }),

/***/ 3094:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const cp = __webpack_require__(3129);
const fs = __webpack_require__(5747);
const SemVer = __webpack_require__(2751);
const client_1 = __webpack_require__(7014);
const vscode_1 = __webpack_require__(7549);
const vscode_languageserver_protocol_1 = __webpack_require__(5310);
const colorProvider_1 = __webpack_require__(2014);
const configuration_1 = __webpack_require__(1877);
const implementation_1 = __webpack_require__(1133);
const typeDefinition_1 = __webpack_require__(1505);
const workspaceFolders_1 = __webpack_require__(4484);
const foldingRange_1 = __webpack_require__(9882);
const declaration_1 = __webpack_require__(5874);
const Is = __webpack_require__(4797);
const processes_1 = __webpack_require__(4108);
__export(__webpack_require__(7014));
const REQUIRED_VSCODE_VERSION = '^1.30'; // do not change format, updated by `updateVSCode` script
var Executable;
(function (Executable) {
    function is(value) {
        return Is.string(value.command);
    }
    Executable.is = is;
})(Executable || (Executable = {}));
var TransportKind;
(function (TransportKind) {
    TransportKind[TransportKind["stdio"] = 0] = "stdio";
    TransportKind[TransportKind["ipc"] = 1] = "ipc";
    TransportKind[TransportKind["pipe"] = 2] = "pipe";
    TransportKind[TransportKind["socket"] = 3] = "socket";
})(TransportKind = exports.TransportKind || (exports.TransportKind = {}));
var Transport;
(function (Transport) {
    function isSocket(value) {
        let candidate = value;
        return candidate && candidate.kind === TransportKind.socket && Is.number(candidate.port);
    }
    Transport.isSocket = isSocket;
})(Transport || (Transport = {}));
var NodeModule;
(function (NodeModule) {
    function is(value) {
        return Is.string(value.module);
    }
    NodeModule.is = is;
})(NodeModule || (NodeModule = {}));
var StreamInfo;
(function (StreamInfo) {
    function is(value) {
        let candidate = value;
        return candidate && candidate.writer !== void 0 && candidate.reader !== void 0;
    }
    StreamInfo.is = is;
})(StreamInfo || (StreamInfo = {}));
var ChildProcessInfo;
(function (ChildProcessInfo) {
    function is(value) {
        let candidate = value;
        return candidate && candidate.process !== void 0 && typeof candidate.detached === 'boolean';
    }
    ChildProcessInfo.is = is;
})(ChildProcessInfo || (ChildProcessInfo = {}));
class LanguageClient extends client_1.BaseLanguageClient {
    constructor(arg1, arg2, arg3, arg4, arg5) {
        let id;
        let name;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (Is.string(arg2)) {
            id = arg1;
            name = arg2;
            serverOptions = arg3;
            clientOptions = arg4;
            forceDebug = !!arg5;
        }
        else {
            id = arg1.toLowerCase();
            name = arg1;
            serverOptions = arg2;
            clientOptions = arg3;
            forceDebug = arg4;
        }
        if (forceDebug === void 0) {
            forceDebug = false;
        }
        super(id, name, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = forceDebug;
        try {
            this.checkVersion();
        }
        catch (error) {
            if (Is.string(error.message)) {
                this.outputChannel.appendLine(error.message);
            }
            throw error;
        }
    }
    checkVersion() {
        let codeVersion = SemVer.parse(vscode_1.version);
        if (!codeVersion) {
            throw new Error(`No valid VS Code version detected. Version string is: ${vscode_1.version}`);
        }
        // Remove the insider pre-release since we stay API compatible.
        if (codeVersion.prerelease && codeVersion.prerelease.length > 0) {
            codeVersion.prerelease = [];
        }
        if (!SemVer.satisfies(codeVersion, REQUIRED_VSCODE_VERSION)) {
            throw new Error(`The language client requires VS Code version ${REQUIRED_VSCODE_VERSION} but received version ${vscode_1.version}`);
        }
    }
    stop() {
        return super.stop().then(() => {
            if (this._serverProcess) {
                let toCheck = this._serverProcess;
                this._serverProcess = undefined;
                if (this._isDetached === void 0 || !this._isDetached) {
                    this.checkProcessDied(toCheck);
                }
                this._isDetached = undefined;
            }
        });
    }
    checkProcessDied(childProcess) {
        if (!childProcess) {
            return;
        }
        setTimeout(() => {
            // Test if the process is still alive. Throws an exception if not
            try {
                process.kill(childProcess.pid, 0);
                processes_1.terminate(childProcess);
            }
            catch (error) {
                // All is fine.
            }
        }, 2000);
    }
    handleConnectionClosed() {
        this._serverProcess = undefined;
        super.handleConnectionClosed();
    }
    createMessageTransports(encoding) {
        function getEnvironment(env) {
            if (!env) {
                return process.env;
            }
            let result = Object.create(null);
            Object.keys(process.env).forEach(key => result[key] = process.env[key]);
            Object.keys(env).forEach(key => result[key] = env[key]);
            return result;
        }
        function startedInDebugMode() {
            let args = process.execArgv;
            if (args) {
                return args.some((arg) => /^--debug=?/.test(arg) || /^--debug-brk=?/.test(arg) || /^--inspect=?/.test(arg) || /^--inspect-brk=?/.test(arg));
            }
            ;
            return false;
        }
        let server = this._serverOptions;
        // We got a function.
        if (Is.func(server)) {
            return server().then((result) => {
                if (client_1.MessageTransports.is(result)) {
                    this._isDetached = !!result.detached;
                    return result;
                }
                else if (StreamInfo.is(result)) {
                    this._isDetached = !!result.detached;
                    return { reader: new vscode_languageserver_protocol_1.StreamMessageReader(result.reader), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(result.writer) };
                }
                else {
                    let cp;
                    if (ChildProcessInfo.is(result)) {
                        cp = result.process;
                        this._isDetached = result.detached;
                    }
                    else {
                        cp = result;
                        this._isDetached = false;
                    }
                    cp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    return { reader: new vscode_languageserver_protocol_1.StreamMessageReader(cp.stdout), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(cp.stdin) };
                }
            });
        }
        let json;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
            // We are under debugging. So use debug as well.
            if (typeof v8debug === 'object' || this._forceDebug || startedInDebugMode()) {
                json = runDebug.debug;
            }
            else {
                json = runDebug.run;
            }
        }
        else {
            json = server;
        }
        return this._getServerWorkingDir(json.options).then(serverWorkingDir => {
            if (NodeModule.is(json) && json.module) {
                let node = json;
                let transport = node.transport || TransportKind.stdio;
                if (node.runtime) {
                    let args = [];
                    let options = node.options || Object.create(null);
                    if (options.execArgv) {
                        options.execArgv.forEach(element => args.push(element));
                    }
                    args.push(node.module);
                    if (node.args) {
                        node.args.forEach(element => args.push(element));
                    }
                    let execOptions = Object.create(null);
                    execOptions.cwd = serverWorkingDir;
                    execOptions.env = getEnvironment(options.env);
                    let pipeName = undefined;
                    if (transport === TransportKind.ipc) {
                        // exec options not correctly typed in lib
                        execOptions.stdio = [null, null, null, 'ipc'];
                        args.push('--node-ipc');
                    }
                    else if (transport === TransportKind.stdio) {
                        args.push('--stdio');
                    }
                    else if (transport === TransportKind.pipe) {
                        pipeName = vscode_languageserver_protocol_1.generateRandomPipeName();
                        args.push(`--pipe=${pipeName}`);
                    }
                    else if (Transport.isSocket(transport)) {
                        args.push(`--socket=${transport.port}`);
                    }
                    args.push(`--clientProcessId=${process.pid.toString()}`);
                    if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                        let serverProcess = cp.spawn(node.runtime, args, execOptions);
                        if (!serverProcess || !serverProcess.pid) {
                            return Promise.reject(`Launching server using runtime ${node.runtime} failed.`);
                        }
                        this._serverProcess = serverProcess;
                        serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        if (transport === TransportKind.ipc) {
                            serverProcess.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return Promise.resolve({ reader: new vscode_languageserver_protocol_1.IPCMessageReader(serverProcess), writer: new vscode_languageserver_protocol_1.IPCMessageWriter(serverProcess) });
                        }
                        else {
                            return Promise.resolve({ reader: new vscode_languageserver_protocol_1.StreamMessageReader(serverProcess.stdout), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(serverProcess.stdin) });
                        }
                    }
                    else if (transport == TransportKind.pipe) {
                        return vscode_languageserver_protocol_1.createClientPipeTransport(pipeName).then((transport) => {
                            let process = cp.spawn(node.runtime, args, execOptions);
                            if (!process || !process.pid) {
                                return Promise.reject(`Launching server using runtime ${node.runtime} failed.`);
                            }
                            this._serverProcess = process;
                            process.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            process.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return transport.onConnected().then((protocol) => {
                                return { reader: protocol[0], writer: protocol[1] };
                            });
                        });
                    }
                    else if (Transport.isSocket(transport)) {
                        return vscode_languageserver_protocol_1.createClientSocketTransport(transport.port).then((transport) => {
                            let process = cp.spawn(node.runtime, args, execOptions);
                            if (!process || !process.pid) {
                                return Promise.reject(`Launching server using runtime ${node.runtime} failed.`);
                            }
                            this._serverProcess = process;
                            process.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            process.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return transport.onConnected().then((protocol) => {
                                return { reader: protocol[0], writer: protocol[1] };
                            });
                        });
                    }
                }
                else {
                    let pipeName = undefined;
                    return new Promise((resolve, _reject) => {
                        let args = node.args && node.args.slice() || [];
                        if (transport === TransportKind.ipc) {
                            args.push('--node-ipc');
                        }
                        else if (transport === TransportKind.stdio) {
                            args.push('--stdio');
                        }
                        else if (transport === TransportKind.pipe) {
                            pipeName = vscode_languageserver_protocol_1.generateRandomPipeName();
                            args.push(`--pipe=${pipeName}`);
                        }
                        else if (Transport.isSocket(transport)) {
                            args.push(`--socket=${transport.port}`);
                        }
                        args.push(`--clientProcessId=${process.pid.toString()}`);
                        let options = node.options || Object.create(null);
                        options.execArgv = options.execArgv || [];
                        options.cwd = serverWorkingDir;
                        options.silent = true;
                        if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                            let sp = cp.fork(node.module, args || [], options);
                            this._serverProcess = sp;
                            sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            if (transport === TransportKind.ipc) {
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                resolve({ reader: new vscode_languageserver_protocol_1.IPCMessageReader(this._serverProcess), writer: new vscode_languageserver_protocol_1.IPCMessageWriter(this._serverProcess) });
                            }
                            else {
                                resolve({ reader: new vscode_languageserver_protocol_1.StreamMessageReader(sp.stdout), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(sp.stdin) });
                            }
                        }
                        else if (transport === TransportKind.pipe) {
                            vscode_languageserver_protocol_1.createClientPipeTransport(pipeName).then((transport) => {
                                let sp = cp.fork(node.module, args || [], options);
                                this._serverProcess = sp;
                                sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                transport.onConnected().then((protocol) => {
                                    resolve({ reader: protocol[0], writer: protocol[1] });
                                });
                            });
                        }
                        else if (Transport.isSocket(transport)) {
                            vscode_languageserver_protocol_1.createClientSocketTransport(transport.port).then((transport) => {
                                let sp = cp.fork(node.module, args || [], options);
                                this._serverProcess = sp;
                                sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                transport.onConnected().then((protocol) => {
                                    resolve({ reader: protocol[0], writer: protocol[1] });
                                });
                            });
                        }
                    });
                }
            }
            else if (Executable.is(json) && json.command) {
                let command = json;
                let args = command.args || [];
                let options = Object.assign({}, command.options);
                options.cwd = options.cwd || serverWorkingDir;
                let serverProcess = cp.spawn(command.command, args, options);
                if (!serverProcess || !serverProcess.pid) {
                    return Promise.reject(`Launching server using command ${command.command} failed.`);
                }
                serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                this._serverProcess = serverProcess;
                this._isDetached = !!options.detached;
                return Promise.resolve({ reader: new vscode_languageserver_protocol_1.StreamMessageReader(serverProcess.stdout), writer: new vscode_languageserver_protocol_1.StreamMessageWriter(serverProcess.stdin) });
            }
            return Promise.reject(new Error(`Unsupported server configuration ` + JSON.stringify(server, null, 4)));
        });
    }
    registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
    }
    registerBuiltinFeatures() {
        super.registerBuiltinFeatures();
        this.registerFeature(new configuration_1.ConfigurationFeature(this));
        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
        this.registerFeature(new implementation_1.ImplementationFeature(this));
        this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
        this.registerFeature(new workspaceFolders_1.WorkspaceFoldersFeature(this));
        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
        this.registerFeature(new declaration_1.DeclarationFeature(this));
    }
    _mainGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
            return undefined;
        }
        let folder = folders[0];
        if (folder.uri.scheme === 'file') {
            return folder.uri.fsPath;
        }
        return undefined;
    }
    _getServerWorkingDir(options) {
        let cwd = options && options.cwd;
        if (!cwd) {
            cwd = this.clientOptions.workspaceFolder
                ? this.clientOptions.workspaceFolder.uri.fsPath
                : this._mainGetRootPath();
        }
        if (cwd) {
            // make sure the folder exists otherwise creating the process will fail
            return new Promise(s => {
                fs.lstat(cwd, (err, stats) => {
                    s(!err && stats.isDirectory() ? cwd : undefined);
                });
            });
        }
        return Promise.resolve(undefined);
    }
}
exports.LanguageClient = LanguageClient;
class SettingMonitor {
    constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
    }
    start() {
        vscode_1.workspace.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners);
        this.onDidChangeConfiguration();
        return new vscode_1.Disposable(() => {
            if (this._client.needsStop()) {
                this._client.stop();
            }
        });
    }
    onDidChangeConfiguration() {
        let index = this._setting.indexOf('.');
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : undefined;
        let enabled = rest ? vscode_1.workspace.getConfiguration(primary).get(rest, false) : vscode_1.workspace.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
            this._client.start();
        }
        else if (!enabled && this._client.needsStop()) {
            this._client.stop();
        }
    }
}
exports.SettingMonitor = SettingMonitor;
// Exporting proposed protocol.
var ProposedFeatures;
(function (ProposedFeatures) {
    function createAll(_client) {
        let result = [];
        return result;
    }
    ProposedFeatures.createAll = createAll;
})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));


/***/ }),

/***/ 3780:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(7549);
class ProtocolCodeLens extends code.CodeLens {
    constructor(range) {
        super(range);
    }
}
exports.default = ProtocolCodeLens;


/***/ }),

/***/ 3810:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(7549);
class ProtocolCompletionItem extends code.CompletionItem {
    constructor(label) {
        super(label);
    }
}
exports.default = ProtocolCompletionItem;


/***/ }),

/***/ 8899:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(7549);
const ls = __webpack_require__(5310);
const Is = __webpack_require__(4797);
const protocolCompletionItem_1 = __webpack_require__(3810);
const protocolCodeLens_1 = __webpack_require__(3780);
const protocolDocumentLink_1 = __webpack_require__(6380);
var CodeBlock;
(function (CodeBlock) {
    function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.language) && Is.string(candidate.value);
    }
    CodeBlock.is = is;
})(CodeBlock || (CodeBlock = {}));
function createConverter(uriConverter) {
    const nullConverter = (value) => code.Uri.parse(value);
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asDiagnostics(diagnostics) {
        return diagnostics.map(asDiagnostic);
    }
    function asDiagnostic(diagnostic) {
        let result = new code.Diagnostic(asRange(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity));
        if (Is.number(diagnostic.code) || Is.string(diagnostic.code)) {
            result.code = diagnostic.code;
        }
        if (diagnostic.source) {
            result.source = diagnostic.source;
        }
        if (diagnostic.relatedInformation) {
            result.relatedInformation = asRelatedInformation(diagnostic.relatedInformation);
        }
        return result;
    }
    function asRelatedInformation(relatedInformation) {
        return relatedInformation.map(asDiagnosticRelatedInformation);
    }
    function asDiagnosticRelatedInformation(information) {
        return new code.DiagnosticRelatedInformation(asLocation(information.location), information.message);
    }
    function asPosition(value) {
        if (!value) {
            return undefined;
        }
        return new code.Position(value.line, value.character);
    }
    function asRange(value) {
        if (!value) {
            return undefined;
        }
        return new code.Range(asPosition(value.start), asPosition(value.end));
    }
    function asDiagnosticSeverity(value) {
        if (value === void 0 || value === null) {
            return code.DiagnosticSeverity.Error;
        }
        switch (value) {
            case ls.DiagnosticSeverity.Error:
                return code.DiagnosticSeverity.Error;
            case ls.DiagnosticSeverity.Warning:
                return code.DiagnosticSeverity.Warning;
            case ls.DiagnosticSeverity.Information:
                return code.DiagnosticSeverity.Information;
            case ls.DiagnosticSeverity.Hint:
                return code.DiagnosticSeverity.Hint;
        }
        return code.DiagnosticSeverity.Error;
    }
    function asHoverContent(value) {
        if (Is.string(value)) {
            return new code.MarkdownString(value);
        }
        else if (CodeBlock.is(value)) {
            let result = new code.MarkdownString();
            return result.appendCodeblock(value.value, value.language);
        }
        else if (Array.isArray(value)) {
            let result = [];
            for (let element of value) {
                let item = new code.MarkdownString();
                if (CodeBlock.is(element)) {
                    item.appendCodeblock(element.value, element.language);
                }
                else {
                    item.appendMarkdown(element);
                }
                result.push(item);
            }
            return result;
        }
        else {
            let result;
            switch (value.kind) {
                case ls.MarkupKind.Markdown:
                    return new code.MarkdownString(value.value);
                case ls.MarkupKind.PlainText:
                    result = new code.MarkdownString();
                    result.appendText(value.value);
                    return result;
                default:
                    result = new code.MarkdownString();
                    result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);
                    return result;
            }
        }
    }
    function asDocumentation(value) {
        if (Is.string(value)) {
            return value;
        }
        else {
            switch (value.kind) {
                case ls.MarkupKind.Markdown:
                    return new code.MarkdownString(value.value);
                case ls.MarkupKind.PlainText:
                    return value.value;
                default:
                    return `Unsupported Markup content received. Kind is: ${value.kind}`;
            }
        }
    }
    function asHover(hover) {
        if (!hover) {
            return undefined;
        }
        return new code.Hover(asHoverContent(hover.contents), asRange(hover.range));
    }
    function asCompletionResult(result) {
        if (!result) {
            return undefined;
        }
        if (Array.isArray(result)) {
            let items = result;
            return items.map(asCompletionItem);
        }
        let list = result;
        return new code.CompletionList(list.items.map(asCompletionItem), list.isIncomplete);
    }
    function asCompletionItemKind(value) {
        // Protocol item kind is 1 based, codes item kind is zero based.
        if (ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter) {
            return [value - 1, undefined];
        }
        ;
        return [code.CompletionItemKind.Text, value];
    }
    function asCompletionItem(item) {
        let result = new protocolCompletionItem_1.default(item.label);
        if (item.detail) {
            result.detail = item.detail;
        }
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
            result.documentationFormat = Is.string(item.documentation) ? '$string' : item.documentation.kind;
        }
        ;
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        let insertText = asCompletionInsertText(item);
        if (insertText) {
            result.insertText = insertText.text;
            result.range = insertText.range;
            result.fromEdit = insertText.fromEdit;
        }
        if (Is.number(item.kind)) {
            let [itemKind, original] = asCompletionItemKind(item.kind);
            result.kind = itemKind;
            if (original) {
                result.originalItemKind = original;
            }
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (Is.stringArray(item.commitCharacters)) {
            result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.deprecated === true || item.deprecated === false) {
            result.deprecated = item.deprecated;
        }
        if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
        }
        if (item.data !== void 0) {
            result.data = item.data;
        }
        return result;
    }
    function asCompletionInsertText(item) {
        if (item.textEdit) {
            if (item.insertTextFormat === ls.InsertTextFormat.Snippet) {
                return { text: new code.SnippetString(item.textEdit.newText), range: asRange(item.textEdit.range), fromEdit: true };
            }
            else {
                return { text: item.textEdit.newText, range: asRange(item.textEdit.range), fromEdit: true };
            }
        }
        else if (item.insertText) {
            if (item.insertTextFormat === ls.InsertTextFormat.Snippet) {
                return { text: new code.SnippetString(item.insertText), fromEdit: false };
            }
            else {
                return { text: item.insertText, fromEdit: false };
            }
        }
        else {
            return undefined;
        }
    }
    function asTextEdit(edit) {
        if (!edit) {
            return undefined;
        }
        return new code.TextEdit(asRange(edit.range), edit.newText);
    }
    function asTextEdits(items) {
        if (!items) {
            return undefined;
        }
        return items.map(asTextEdit);
    }
    function asSignatureHelp(item) {
        if (!item) {
            return undefined;
        }
        let result = new code.SignatureHelp();
        if (Is.number(item.activeSignature)) {
            result.activeSignature = item.activeSignature;
        }
        else {
            // activeSignature was optional in the past
            result.activeSignature = 0;
        }
        if (Is.number(item.activeParameter)) {
            result.activeParameter = item.activeParameter;
        }
        else {
            // activeParameter was optional in the past
            result.activeParameter = 0;
        }
        if (item.signatures) {
            result.signatures = asSignatureInformations(item.signatures);
        }
        return result;
    }
    function asSignatureInformations(items) {
        return items.map(asSignatureInformation);
    }
    function asSignatureInformation(item) {
        let result = new code.SignatureInformation(item.label);
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
        }
        if (item.parameters) {
            result.parameters = asParameterInformations(item.parameters);
        }
        return result;
    }
    function asParameterInformations(item) {
        return item.map(asParameterInformation);
    }
    function asParameterInformation(item) {
        let result = new code.ParameterInformation(item.label);
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
        }
        ;
        return result;
    }
    function asLocation(item) {
        if (!item) {
            return undefined;
        }
        return new code.Location(_uriConverter(item.uri), asRange(item.range));
    }
    function asDeclarationResult(item) {
        if (!item) {
            return undefined;
        }
        return asLocationResult(item);
    }
    function asDefinitionResult(item) {
        if (!item) {
            return undefined;
        }
        return asLocationResult(item);
    }
    function asLocationLink(item) {
        if (!item) {
            return undefined;
        }
        return {
            targetUri: _uriConverter(item.targetUri),
            targetRange: asRange(item.targetSelectionRange),
            originSelectionRange: asRange(item.originSelectionRange),
            targetSelectionRange: asRange(item.targetSelectionRange)
        };
    }
    function asLocationResult(item) {
        if (!item) {
            return undefined;
        }
        if (Is.array(item)) {
            if (item.length === 0) {
                return [];
            }
            else if (ls.LocationLink.is(item[0])) {
                let links = item;
                return links.map((link) => asLocationLink(link));
            }
            else {
                let locations = item;
                return locations.map((location) => asLocation(location));
            }
        }
        else if (ls.LocationLink.is(item)) {
            return [asLocationLink(item)];
        }
        else {
            return asLocation(item);
        }
    }
    function asReferences(values) {
        if (!values) {
            return undefined;
        }
        return values.map(location => asLocation(location));
    }
    function asDocumentHighlights(values) {
        if (!values) {
            return undefined;
        }
        return values.map(asDocumentHighlight);
    }
    function asDocumentHighlight(item) {
        let result = new code.DocumentHighlight(asRange(item.range));
        if (Is.number(item.kind)) {
            result.kind = asDocumentHighlightKind(item.kind);
        }
        return result;
    }
    function asDocumentHighlightKind(item) {
        switch (item) {
            case ls.DocumentHighlightKind.Text:
                return code.DocumentHighlightKind.Text;
            case ls.DocumentHighlightKind.Read:
                return code.DocumentHighlightKind.Read;
            case ls.DocumentHighlightKind.Write:
                return code.DocumentHighlightKind.Write;
        }
        return code.DocumentHighlightKind.Text;
    }
    function asSymbolInformations(values, uri) {
        if (!values) {
            return undefined;
        }
        return values.map(information => asSymbolInformation(information, uri));
    }
    function asSymbolKind(item) {
        if (item <= ls.SymbolKind.TypeParameter) {
            // Symbol kind is one based in the protocol and zero based in code.
            return item - 1;
        }
        return code.SymbolKind.Property;
    }
    function asSymbolInformation(item, uri) {
        // Symbol kind is one based in the protocol and zero based in code.
        let result = new code.SymbolInformation(item.name, asSymbolKind(item.kind), asRange(item.location.range), item.location.uri ? _uriConverter(item.location.uri) : uri);
        if (item.containerName) {
            result.containerName = item.containerName;
        }
        return result;
    }
    function asDocumentSymbols(values) {
        if (values === void 0 || values === null) {
            return undefined;
        }
        return values.map(asDocumentSymbol);
    }
    function asDocumentSymbol(value) {
        let result = new code.DocumentSymbol(value.name, value.detail || '', asSymbolKind(value.kind), asRange(value.range), asRange(value.selectionRange));
        if (value.children !== void 0 && value.children.length > 0) {
            let children = [];
            for (let child of value.children) {
                children.push(asDocumentSymbol(child));
            }
            result.children = children;
        }
        return result;
    }
    function asCommand(item) {
        let result = { title: item.title, command: item.command };
        if (item.arguments) {
            result.arguments = item.arguments;
        }
        return result;
    }
    function asCommands(items) {
        if (!items) {
            return undefined;
        }
        return items.map(asCommand);
    }
    const kindMapping = new Map();
    kindMapping.set('', code.CodeActionKind.Empty);
    kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix);
    kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor);
    kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract);
    kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline);
    kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite);
    kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source);
    kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);
    function asCodeActionKind(item) {
        if (item === void 0 || item === null) {
            return undefined;
        }
        let result = kindMapping.get(item);
        if (result) {
            return result;
        }
        let parts = item.split('.');
        result = code.CodeActionKind.Empty;
        for (let part of parts) {
            result = result.append(part);
        }
        return result;
    }
    function asCodeActionKinds(items) {
        if (items === void 0 || items === null) {
            return undefined;
        }
        return items.map(kind => asCodeActionKind(kind));
    }
    function asCodeAction(item) {
        if (item === void 0 || item === null) {
            return undefined;
        }
        let result = new code.CodeAction(item.title);
        if (item.kind !== void 0) {
            result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics) {
            result.diagnostics = asDiagnostics(item.diagnostics);
        }
        if (item.edit) {
            result.edit = asWorkspaceEdit(item.edit);
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        return result;
    }
    function asCodeLens(item) {
        if (!item) {
            return undefined;
        }
        let result = new protocolCodeLens_1.default(asRange(item.range));
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.data !== void 0 && item.data !== null) {
            result.data = item.data;
        }
        return result;
    }
    function asCodeLenses(items) {
        if (!items) {
            return undefined;
        }
        return items.map((codeLens) => asCodeLens(codeLens));
    }
    function asWorkspaceEdit(item) {
        if (!item) {
            return undefined;
        }
        let result = new code.WorkspaceEdit();
        if (item.documentChanges) {
            item.documentChanges.forEach(change => {
                if (ls.CreateFile.is(change)) {
                    result.createFile(_uriConverter(change.uri), change.options);
                }
                else if (ls.RenameFile.is(change)) {
                    result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options);
                }
                else if (ls.DeleteFile.is(change)) {
                    result.deleteFile(_uriConverter(change.uri), change.options);
                }
                else if (ls.TextDocumentEdit.is(change)) {
                    result.set(_uriConverter(change.textDocument.uri), asTextEdits(change.edits));
                }
                else {
                    console.error(`Unknown workspace edit change received:\n${JSON.stringify(change, undefined, 4)}`);
                }
            });
        }
        else if (item.changes) {
            Object.keys(item.changes).forEach(key => {
                result.set(_uriConverter(key), asTextEdits(item.changes[key]));
            });
        }
        return result;
    }
    function asDocumentLink(item) {
        let range = asRange(item.range);
        let target = item.target ? asUri(item.target) : undefined;
        // target must be optional in DocumentLink
        let link = new protocolDocumentLink_1.default(range, target);
        if (item.data !== void 0 && item.data !== null) {
            link.data = item.data;
        }
        return link;
    }
    function asDocumentLinks(items) {
        if (!items) {
            return undefined;
        }
        return items.map(asDocumentLink);
    }
    function asColor(color) {
        return new code.Color(color.red, color.green, color.blue, color.alpha);
    }
    function asColorInformation(ci) {
        return new code.ColorInformation(asRange(ci.range), asColor(ci.color));
    }
    function asColorInformations(colorInformation) {
        if (Array.isArray(colorInformation)) {
            return colorInformation.map(asColorInformation);
        }
        return undefined;
    }
    function asColorPresentation(cp) {
        let presentation = new code.ColorPresentation(cp.label);
        presentation.additionalTextEdits = asTextEdits(cp.additionalTextEdits);
        if (cp.textEdit) {
            presentation.textEdit = asTextEdit(cp.textEdit);
        }
        return presentation;
    }
    function asColorPresentations(colorPresentations) {
        if (Array.isArray(colorPresentations)) {
            return colorPresentations.map(asColorPresentation);
        }
        return undefined;
    }
    function asFoldingRangeKind(kind) {
        if (kind) {
            switch (kind) {
                case ls.FoldingRangeKind.Comment:
                    return code.FoldingRangeKind.Comment;
                case ls.FoldingRangeKind.Imports:
                    return code.FoldingRangeKind.Imports;
                case ls.FoldingRangeKind.Region:
                    return code.FoldingRangeKind.Region;
            }
        }
        return void 0;
    }
    function asFoldingRange(r) {
        return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));
    }
    function asFoldingRanges(foldingRanges) {
        if (Array.isArray(foldingRanges)) {
            return foldingRanges.map(asFoldingRange);
        }
        return void 0;
    }
    return {
        asUri,
        asDiagnostics,
        asDiagnostic,
        asRange,
        asPosition,
        asDiagnosticSeverity,
        asHover,
        asCompletionResult,
        asCompletionItem,
        asTextEdit,
        asTextEdits,
        asSignatureHelp,
        asSignatureInformations,
        asSignatureInformation,
        asParameterInformations,
        asParameterInformation,
        asDeclarationResult,
        asDefinitionResult,
        asLocation,
        asReferences,
        asDocumentHighlights,
        asDocumentHighlight,
        asDocumentHighlightKind,
        asSymbolInformations,
        asSymbolInformation,
        asDocumentSymbols,
        asDocumentSymbol,
        asCommand,
        asCommands,
        asCodeAction,
        asCodeActionKind,
        asCodeActionKinds,
        asCodeLens,
        asCodeLenses,
        asWorkspaceEdit,
        asDocumentLink,
        asDocumentLinks,
        asFoldingRangeKind,
        asFoldingRange,
        asFoldingRanges,
        asColor,
        asColorInformation,
        asColorInformations,
        asColorPresentation,
        asColorPresentations
    };
}
exports.createConverter = createConverter;


/***/ }),

/***/ 6380:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(7549);
class ProtocolDocumentLink extends code.DocumentLink {
    constructor(range, target) {
        super(range, target);
    }
}
exports.default = ProtocolDocumentLink;


/***/ }),

/***/ 1505:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const UUID = __webpack_require__(7465);
const Is = __webpack_require__(4797);
const vscode_1 = __webpack_require__(7549);
const vscode_languageserver_protocol_1 = __webpack_require__(5310);
const client_1 = __webpack_require__(7014);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class TypeDefinitionFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);
    }
    fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, 'textDocument'), 'typeDefinition').dynamicRegistration = true;
        let typeDefinitionSupport = ensure(ensure(capabilites, 'textDocument'), 'typeDefinition');
        typeDefinitionSupport.dynamicRegistration = true;
        typeDefinitionSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        if (!capabilities.typeDefinitionProvider) {
            return;
        }
        if (capabilities.typeDefinitionProvider === true) {
            if (!documentSelector) {
                return;
            }
            this.register(this.messages, {
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector })
            });
        }
        else {
            const implCapabilities = capabilities.typeDefinitionProvider;
            const id = Is.string(implCapabilities.id) && implCapabilities.id.length > 0 ? implCapabilities.id : UUID.generateUuid();
            const selector = implCapabilities.documentSelector || documentSelector;
            if (selector) {
                this.register(this.messages, {
                    id,
                    registerOptions: Object.assign({}, { documentSelector: selector })
                });
            }
        }
    }
    registerLanguageProvider(options) {
        let client = this._client;
        let provideTypeDefinition = (document, position, token) => {
            return client.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                client.logFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, error);
                return Promise.resolve(null);
            });
        };
        let middleware = client.clientOptions.middleware;
        return vscode_1.languages.registerTypeDefinitionProvider(options.documentSelector, {
            provideTypeDefinition: (document, position, token) => {
                return middleware.provideTypeDefinition
                    ? middleware.provideTypeDefinition(document, position, token, provideTypeDefinition)
                    : provideTypeDefinition(document, position, token);
            }
        });
    }
}
exports.TypeDefinitionFeature = TypeDefinitionFeature;


/***/ }),

/***/ 4834:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
class Delayer {
    constructor(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.timeout = undefined;
        this.completionPromise = undefined;
        this.onSuccess = undefined;
        this.task = undefined;
    }
    trigger(task, delay = this.defaultDelay) {
        this.task = task;
        if (delay >= 0) {
            this.cancelTimeout();
        }
        if (!this.completionPromise) {
            this.completionPromise = new Promise((resolve) => {
                this.onSuccess = resolve;
            }).then(() => {
                this.completionPromise = undefined;
                this.onSuccess = undefined;
                var result = this.task();
                this.task = undefined;
                return result;
            });
        }
        if (delay >= 0 || this.timeout === void 0) {
            this.timeout = setTimeout(() => {
                this.timeout = undefined;
                this.onSuccess(undefined);
            }, delay >= 0 ? delay : this.defaultDelay);
        }
        return this.completionPromise;
    }
    forceDelivery() {
        if (!this.completionPromise) {
            return undefined;
        }
        this.cancelTimeout();
        let result = this.task();
        this.completionPromise = undefined;
        this.onSuccess = undefined;
        this.task = undefined;
        return result;
    }
    isTriggered() {
        return this.timeout !== void 0;
    }
    cancel() {
        this.cancelTimeout();
        this.completionPromise = undefined;
    }
    cancelTimeout() {
        if (this.timeout !== void 0) {
            clearTimeout(this.timeout);
            this.timeout = undefined;
        }
    }
}
exports.Delayer = Delayer;


/***/ }),

/***/ 4797:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;


/***/ }),

/***/ 4108:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const cp = __webpack_require__(3129);
const path_1 = __webpack_require__(5622);
const isWindows = (process.platform === 'win32');
const isMacintosh = (process.platform === 'darwin');
const isLinux = (process.platform === 'linux');
function terminate(process, cwd) {
    if (isWindows) {
        try {
            // This we run in Atom execFileSync is available.
            // Ignore stderr since this is otherwise piped to parent.stderr
            // which might be already closed.
            let options = {
                stdio: ['pipe', 'pipe', 'ignore']
            };
            if (cwd) {
                options.cwd = cwd;
            }
            cp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    else if (isLinux || isMacintosh) {
        try {
            var cmd = path_1.join(__dirname, 'terminateProcess.sh');
            var result = cp.spawnSync(cmd, [process.pid.toString()]);
            return result.error ? false : true;
        }
        catch (err) {
            return false;
        }
    }
    else {
        process.kill('SIGKILL');
        return true;
    }
}
exports.terminate = terminate;


/***/ }),

/***/ 7465:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

Object.defineProperty(exports, "__esModule", ({ value: true }));
class ValueUUID {
    constructor(_value) {
        this._value = _value;
        // empty
    }
    asHex() {
        return this._value;
    }
    equals(other) {
        return this.asHex() === other.asHex();
    }
}
class V4UUID extends ValueUUID {
    constructor() {
        super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            '4',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
        ].join(''));
    }
    static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
    }
}
V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
/**
 * An empty UUID that contains only zeros.
 */
exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
function v4() {
    return new V4UUID();
}
exports.v4 = v4;
const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(value) {
    return _UUIDPattern.test(value);
}
exports.isUUID = isUUID;
/**
 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
 * @param value A uuid string.
 */
function parse(value) {
    if (!isUUID(value)) {
        throw new Error('invalid uuid');
    }
    return new ValueUUID(value);
}
exports.parse = parse;
function generateUuid() {
    return v4().asHex();
}
exports.generateUuid = generateUuid;


/***/ }),

/***/ 4484:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const UUID = __webpack_require__(7465);
const vscode_1 = __webpack_require__(7549);
const vscode_languageserver_protocol_1 = __webpack_require__(5310);
function access(target, key) {
    if (target === void 0) {
        return undefined;
    }
    return target[key];
}
class WorkspaceFoldersFeature {
    constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    get messages() {
        return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
    }
    fillInitializeParams(params) {
        let folders = vscode_1.workspace.workspaceFolders;
        if (folders === void 0) {
            params.workspaceFolders = null;
        }
        else {
            params.workspaceFolders = folders.map(folder => this.asProtocol(folder));
        }
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
    }
    initialize(capabilities) {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {
            let workspaceFolders = () => {
                let folders = vscode_1.workspace.workspaceFolders;
                if (folders === void 0) {
                    return null;
                }
                let result = folders.map((folder) => {
                    return this.asProtocol(folder);
                });
                return result;
            };
            let middleware = client.clientOptions.middleware.workspace;
            return middleware && middleware.workspaceFolders
                ? middleware.workspaceFolders(token, workspaceFolders)
                : workspaceFolders(token);
        });
        let value = access(access(access(capabilities, 'workspace'), 'workspaceFolders'), 'changeNotifications');
        let id;
        if (typeof value === 'string') {
            id = value;
        }
        else if (value === true) {
            id = UUID.generateUuid();
        }
        if (id) {
            this.register(this.messages, {
                id: id,
                registerOptions: undefined
            });
        }
    }
    register(_message, data) {
        let id = data.id;
        let client = this._client;
        let disposable = vscode_1.workspace.onDidChangeWorkspaceFolders((event) => {
            let didChangeWorkspaceFolders = (event) => {
                let params = {
                    event: {
                        added: event.added.map(folder => this.asProtocol(folder)),
                        removed: event.removed.map(folder => this.asProtocol(folder))
                    }
                };
                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
            };
            let middleware = client.clientOptions.middleware.workspace;
            middleware && middleware.didChangeWorkspaceFolders
                ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders)
                : didChangeWorkspaceFolders(event);
        });
        this._listeners.set(id, disposable);
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable === void 0) {
            return;
        }
        this._listeners.delete(id);
        disposable.dispose();
    }
    dispose() {
        for (let disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    asProtocol(workspaceFolder) {
        if (workspaceFolder === void 0) {
            return null;
        }
        return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri), name: workspaceFolder.name };
    }
}
exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;


/***/ }),

/***/ 5310:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_jsonrpc_1 = __webpack_require__(617);
exports.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;
exports.ResponseError = vscode_jsonrpc_1.ResponseError;
exports.CancellationToken = vscode_jsonrpc_1.CancellationToken;
exports.CancellationTokenSource = vscode_jsonrpc_1.CancellationTokenSource;
exports.Disposable = vscode_jsonrpc_1.Disposable;
exports.Event = vscode_jsonrpc_1.Event;
exports.Emitter = vscode_jsonrpc_1.Emitter;
exports.Trace = vscode_jsonrpc_1.Trace;
exports.TraceFormat = vscode_jsonrpc_1.TraceFormat;
exports.SetTraceNotification = vscode_jsonrpc_1.SetTraceNotification;
exports.LogTraceNotification = vscode_jsonrpc_1.LogTraceNotification;
exports.RequestType = vscode_jsonrpc_1.RequestType;
exports.RequestType0 = vscode_jsonrpc_1.RequestType0;
exports.NotificationType = vscode_jsonrpc_1.NotificationType;
exports.NotificationType0 = vscode_jsonrpc_1.NotificationType0;
exports.MessageReader = vscode_jsonrpc_1.MessageReader;
exports.MessageWriter = vscode_jsonrpc_1.MessageWriter;
exports.ConnectionStrategy = vscode_jsonrpc_1.ConnectionStrategy;
exports.StreamMessageReader = vscode_jsonrpc_1.StreamMessageReader;
exports.StreamMessageWriter = vscode_jsonrpc_1.StreamMessageWriter;
exports.IPCMessageReader = vscode_jsonrpc_1.IPCMessageReader;
exports.IPCMessageWriter = vscode_jsonrpc_1.IPCMessageWriter;
exports.createClientPipeTransport = vscode_jsonrpc_1.createClientPipeTransport;
exports.createServerPipeTransport = vscode_jsonrpc_1.createServerPipeTransport;
exports.generateRandomPipeName = vscode_jsonrpc_1.generateRandomPipeName;
exports.createClientSocketTransport = vscode_jsonrpc_1.createClientSocketTransport;
exports.createServerSocketTransport = vscode_jsonrpc_1.createServerSocketTransport;
__export(__webpack_require__(4970));
__export(__webpack_require__(6161));
function createProtocolConnection(reader, writer, logger, strategy) {
    return vscode_jsonrpc_1.createMessageConnection(reader, writer, logger, strategy);
}
exports.createProtocolConnection = createProtocolConnection;


/***/ }),

/***/ 6807:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_jsonrpc_1 = __webpack_require__(617);
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type [DocumentColorParams](#DocumentColorParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/documentColor');
})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/colorPresentation');
})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));


/***/ }),

/***/ 7772:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_jsonrpc_1 = __webpack_require__(617);
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.type = new vscode_jsonrpc_1.RequestType('workspace/configuration');
})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));


/***/ }),

/***/ 4653:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_jsonrpc_1 = __webpack_require__(617);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)
 * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves
 * to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/declaration');
})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));


/***/ }),

/***/ 7959:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_jsonrpc_1 = __webpack_require__(617);
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the
 * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/foldingRange');
})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));


/***/ }),

/***/ 2685:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_jsonrpc_1 = __webpack_require__(617);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/implementation');
})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));


/***/ }),

/***/ 6161:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Is = __webpack_require__(3379);
const vscode_jsonrpc_1 = __webpack_require__(617);
const protocol_implementation_1 = __webpack_require__(2685);
exports.ImplementationRequest = protocol_implementation_1.ImplementationRequest;
const protocol_typeDefinition_1 = __webpack_require__(936);
exports.TypeDefinitionRequest = protocol_typeDefinition_1.TypeDefinitionRequest;
const protocol_workspaceFolders_1 = __webpack_require__(2899);
exports.WorkspaceFoldersRequest = protocol_workspaceFolders_1.WorkspaceFoldersRequest;
exports.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;
const protocol_configuration_1 = __webpack_require__(7772);
exports.ConfigurationRequest = protocol_configuration_1.ConfigurationRequest;
const protocol_colorProvider_1 = __webpack_require__(6807);
exports.DocumentColorRequest = protocol_colorProvider_1.DocumentColorRequest;
exports.ColorPresentationRequest = protocol_colorProvider_1.ColorPresentationRequest;
const protocol_foldingRange_1 = __webpack_require__(7959);
exports.FoldingRangeRequest = protocol_foldingRange_1.FoldingRangeRequest;
const protocol_declaration_1 = __webpack_require__(4653);
exports.DeclarationRequest = protocol_declaration_1.DeclarationRequest;
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
var DocumentFilter;
(function (DocumentFilter) {
    function is(value) {
        let candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    DocumentFilter.is = is;
})(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */
var RegistrationRequest;
(function (RegistrationRequest) {
    RegistrationRequest.type = new vscode_jsonrpc_1.RequestType('client/registerCapability');
})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */
var UnregistrationRequest;
(function (UnregistrationRequest) {
    UnregistrationRequest.type = new vscode_jsonrpc_1.RequestType('client/unregisterCapability');
})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
var ResourceOperationKind;
(function (ResourceOperationKind) {
    /**
     * Supports creating new files and folders.
     */
    ResourceOperationKind.Create = 'create';
    /**
     * Supports renaming existing files and folders.
     */
    ResourceOperationKind.Rename = 'rename';
    /**
     * Supports deleting existing files and folders.
     */
    ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
var FailureHandlingKind;
(function (FailureHandlingKind) {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    FailureHandlingKind.Abort = 'abort';
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    FailureHandlingKind.Transactional = 'transactional';
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling startegy is abort.
     */
    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
    /**
     * The client tries to undo the operations already executed. But there is no
     * guaruntee that this is succeeding.
     */
    FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
var TextDocumentSyncKind;
(function (TextDocumentSyncKind) {
    /**
     * Documents should not be synced at all.
     */
    TextDocumentSyncKind.None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    TextDocumentSyncKind.Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type [InitializeParams](#InitializeParams)
 * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
 * resolves to such.
 */
var InitializeRequest;
(function (InitializeRequest) {
    InitializeRequest.type = new vscode_jsonrpc_1.RequestType('initialize');
})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
/**
 * Known error codes for an `InitializeError`;
 */
var InitializeError;
(function (InitializeError) {
    /**
     * If the protocol version provided by the client can't be handled by the server.
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */
    InitializeError.unknownProtocolVersion = 1;
})(InitializeError = exports.InitializeError || (exports.InitializeError = {}));
/**
 * The intialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */
var InitializedNotification;
(function (InitializedNotification) {
    InitializedNotification.type = new vscode_jsonrpc_1.NotificationType('initialized');
})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
//---- Shutdown Method ----
/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */
var ShutdownRequest;
(function (ShutdownRequest) {
    ShutdownRequest.type = new vscode_jsonrpc_1.RequestType0('shutdown');
})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
//---- Exit Notification ----
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
var ExitNotification;
(function (ExitNotification) {
    ExitNotification.type = new vscode_jsonrpc_1.NotificationType0('exit');
})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
//---- Configuration notification ----
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
var DidChangeConfigurationNotification;
(function (DidChangeConfigurationNotification) {
    DidChangeConfigurationNotification.type = new vscode_jsonrpc_1.NotificationType('workspace/didChangeConfiguration');
})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
//---- Message show and log notifications ----
/**
 * The message type
 */
var MessageType;
(function (MessageType) {
    /**
     * An error message.
     */
    MessageType.Error = 1;
    /**
     * A warning message.
     */
    MessageType.Warning = 2;
    /**
     * An information message.
     */
    MessageType.Info = 3;
    /**
     * A log message.
     */
    MessageType.Log = 4;
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
var ShowMessageNotification;
(function (ShowMessageNotification) {
    ShowMessageNotification.type = new vscode_jsonrpc_1.NotificationType('window/showMessage');
})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */
var ShowMessageRequest;
(function (ShowMessageRequest) {
    ShowMessageRequest.type = new vscode_jsonrpc_1.RequestType('window/showMessageRequest');
})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */
var LogMessageNotification;
(function (LogMessageNotification) {
    LogMessageNotification.type = new vscode_jsonrpc_1.NotificationType('window/logMessage');
})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
//---- Telemetry notification
/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */
var TelemetryEventNotification;
(function (TelemetryEventNotification) {
    TelemetryEventNotification.type = new vscode_jsonrpc_1.NotificationType('telemetry/event');
})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */
var DidOpenTextDocumentNotification;
(function (DidOpenTextDocumentNotification) {
    DidOpenTextDocumentNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/didOpen');
})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
var DidChangeTextDocumentNotification;
(function (DidChangeTextDocumentNotification) {
    DidChangeTextDocumentNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/didChange');
})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */
var DidCloseTextDocumentNotification;
(function (DidCloseTextDocumentNotification) {
    DidCloseTextDocumentNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/didClose');
})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
var DidSaveTextDocumentNotification;
(function (DidSaveTextDocumentNotification) {
    DidSaveTextDocumentNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/didSave');
})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */
var WillSaveTextDocumentNotification;
(function (WillSaveTextDocumentNotification) {
    WillSaveTextDocumentNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/willSave');
})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */
var WillSaveTextDocumentWaitUntilRequest;
(function (WillSaveTextDocumentWaitUntilRequest) {
    WillSaveTextDocumentWaitUntilRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/willSaveWaitUntil');
})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
//---- File eventing ----
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */
var DidChangeWatchedFilesNotification;
(function (DidChangeWatchedFilesNotification) {
    DidChangeWatchedFilesNotification.type = new vscode_jsonrpc_1.NotificationType('workspace/didChangeWatchedFiles');
})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */
var FileChangeType;
(function (FileChangeType) {
    /**
     * The file got created.
     */
    FileChangeType.Created = 1;
    /**
     * The file got changed.
     */
    FileChangeType.Changed = 2;
    /**
     * The file got deleted.
     */
    FileChangeType.Deleted = 3;
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
var WatchKind;
(function (WatchKind) {
    /**
     * Interested in create events.
     */
    WatchKind.Create = 1;
    /**
     * Interested in change events
     */
    WatchKind.Change = 2;
    /**
     * Interested in delete events
     */
    WatchKind.Delete = 4;
})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
//---- Diagnostic notification ----
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
var PublishDiagnosticsNotification;
(function (PublishDiagnosticsNotification) {
    PublishDiagnosticsNotification.type = new vscode_jsonrpc_1.NotificationType('textDocument/publishDiagnostics');
})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    CompletionTriggerKind.Invoked = 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    CompletionTriggerKind.TriggerCharacter = 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
 * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the [`detail`](#CompletionItem.detail)
 * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */
var CompletionRequest;
(function (CompletionRequest) {
    CompletionRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/completion');
})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type [CompletionItem](#CompletionItem) the response
 * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
 */
var CompletionResolveRequest;
(function (CompletionResolveRequest) {
    CompletionResolveRequest.type = new vscode_jsonrpc_1.RequestType('completionItem/resolve');
})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
//---- Hover Support -------------------------------
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
 * type [Hover](#Hover) or a Thenable that resolves to such.
 */
var HoverRequest;
(function (HoverRequest) {
    HoverRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/hover');
})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
var SignatureHelpRequest;
(function (SignatureHelpRequest) {
    SignatureHelpRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/signatureHelp');
})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
//---- Goto Definition -------------------------------------
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type [Definition](#Definition)
 * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves
 * to such.
 */
var DefinitionRequest;
(function (DefinitionRequest) {
    DefinitionRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/definition');
})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type [ReferenceParams](#ReferenceParams) the response is of type
 * [Location[]](#Location) or a Thenable that resolves to such.
 */
var ReferencesRequest;
(function (ReferencesRequest) {
    ReferencesRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/references');
})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
//---- Document Highlight ----------------------------------
/**
 * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */
var DocumentHighlightRequest;
(function (DocumentHighlightRequest) {
    DocumentHighlightRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/documentHighlight');
})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
//---- Document Symbol Provider ---------------------------
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
 * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
 * that resolves to such.
 */
var DocumentSymbolRequest;
(function (DocumentSymbolRequest) {
    DocumentSymbolRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/documentSymbol');
})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
//---- Workspace Symbol Provider ---------------------------
/**
 * A request to list project-wide symbols matching the query string given
 * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
 * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
 * resolves to such.
 */
var WorkspaceSymbolRequest;
(function (WorkspaceSymbolRequest) {
    WorkspaceSymbolRequest.type = new vscode_jsonrpc_1.RequestType('workspace/symbol');
})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */
var CodeActionRequest;
(function (CodeActionRequest) {
    CodeActionRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/codeAction');
})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */
var CodeLensRequest;
(function (CodeLensRequest) {
    CodeLensRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/codeLens');
})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */
var CodeLensResolveRequest;
(function (CodeLensResolveRequest) {
    CodeLensResolveRequest.type = new vscode_jsonrpc_1.RequestType('codeLens/resolve');
})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
/**
 * A request to to format a whole document.
 */
var DocumentFormattingRequest;
(function (DocumentFormattingRequest) {
    DocumentFormattingRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/formatting');
})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
/**
 * A request to to format a range in a document.
 */
var DocumentRangeFormattingRequest;
(function (DocumentRangeFormattingRequest) {
    DocumentRangeFormattingRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/rangeFormatting');
})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
/**
 * A request to format a document on type.
 */
var DocumentOnTypeFormattingRequest;
(function (DocumentOnTypeFormattingRequest) {
    DocumentOnTypeFormattingRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/onTypeFormatting');
})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
/**
 * A request to rename a symbol.
 */
var RenameRequest;
(function (RenameRequest) {
    RenameRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/rename');
})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 */
var PrepareRenameRequest;
(function (PrepareRenameRequest) {
    PrepareRenameRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/prepareRename');
})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
/**
 * A request to provide document links
 */
var DocumentLinkRequest;
(function (DocumentLinkRequest) {
    DocumentLinkRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/documentLink');
})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type [DocumentLink](#DocumentLink) the response
 * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
 */
var DocumentLinkResolveRequest;
(function (DocumentLinkResolveRequest) {
    DocumentLinkResolveRequest.type = new vscode_jsonrpc_1.RequestType('documentLink/resolve');
})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */
var ExecuteCommandRequest;
(function (ExecuteCommandRequest) {
    ExecuteCommandRequest.type = new vscode_jsonrpc_1.RequestType('workspace/executeCommand');
})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */
var ApplyWorkspaceEditRequest;
(function (ApplyWorkspaceEditRequest) {
    ApplyWorkspaceEditRequest.type = new vscode_jsonrpc_1.RequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));


/***/ }),

/***/ 936:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_jsonrpc_1 = __webpack_require__(617);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.type = new vscode_jsonrpc_1.RequestType('textDocument/typeDefinition');
})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));


/***/ }),

/***/ 2899:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode_jsonrpc_1 = __webpack_require__(617);
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.type = new vscode_jsonrpc_1.RequestType0('workspace/workspaceFolders');
})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.type = new vscode_jsonrpc_1.NotificationType('workspace/didChangeWorkspaceFolders');
})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));


/***/ }),

/***/ 3379:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;


/***/ }),

/***/ 4970:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {
    if ( true && typeof module.exports === "object") {
        var v = factory(__webpack_require__(7492), exports);
        if (v !== undefined) module.exports = v;
    }
    else if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
})(function (require, exports) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The Position namespace provides helper functions to work with
     * [Position](#Position) literals.
     */
    var Position;
    (function (Position) {
        /**
         * Creates a new Position literal from the given line and character.
         * @param line The position's line.
         * @param character The position's character.
         */
        function create(line, character) {
            return { line: line, character: character };
        }
        Position.create = create;
        /**
         * Checks whether the given liternal conforms to the [Position](#Position) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.number(candidate.line) && Is.number(candidate.character);
        }
        Position.is = is;
    })(Position = exports.Position || (exports.Position = {}));
    /**
     * The Range namespace provides helper functions to work with
     * [Range](#Range) literals.
     */
    var Range;
    (function (Range) {
        function create(one, two, three, four) {
            if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {
                return { start: Position.create(one, two), end: Position.create(three, four) };
            }
            else if (Position.is(one) && Position.is(two)) {
                return { start: one, end: two };
            }
            else {
                throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
            }
        }
        Range.create = create;
        /**
         * Checks whether the given literal conforms to the [Range](#Range) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
        }
        Range.is = is;
    })(Range = exports.Range || (exports.Range = {}));
    /**
     * The Location namespace provides helper functions to work with
     * [Location](#Location) literals.
     */
    var Location;
    (function (Location) {
        /**
         * Creates a Location literal.
         * @param uri The location's uri.
         * @param range The location's range.
         */
        function create(uri, range) {
            return { uri: uri, range: range };
        }
        Location.create = create;
        /**
         * Checks whether the given literal conforms to the [Location](#Location) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location.is = is;
    })(Location = exports.Location || (exports.Location = {}));
    /**
     * The LocationLink namespace provides helper functions to work with
     * [LocationLink](#LocationLink) literals.
     */
    var LocationLink;
    (function (LocationLink) {
        /**
         * Creates a LocationLink literal.
         * @param targetUri The definition's uri.
         * @param targetRange The full range of the definition.
         * @param targetSelectionRange The span of the symbol definition at the target.
         * @param originSelectionRange The span of the symbol being defined in the originating source file.
         */
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
            return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
        }
        LocationLink.create = create;
        /**
         * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
                && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))
                && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink.is = is;
    })(LocationLink = exports.LocationLink || (exports.LocationLink = {}));
    /**
     * The Color namespace provides helper functions to work with
     * [Color](#Color) literals.
     */
    var Color;
    (function (Color) {
        /**
         * Creates a new Color literal.
         */
        function create(red, green, blue, alpha) {
            return {
                red: red,
                green: green,
                blue: blue,
                alpha: alpha,
            };
        }
        Color.create = create;
        /**
         * Checks whether the given literal conforms to the [Color](#Color) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.number(candidate.red)
                && Is.number(candidate.green)
                && Is.number(candidate.blue)
                && Is.number(candidate.alpha);
        }
        Color.is = is;
    })(Color = exports.Color || (exports.Color = {}));
    /**
     * The ColorInformation namespace provides helper functions to work with
     * [ColorInformation](#ColorInformation) literals.
     */
    var ColorInformation;
    (function (ColorInformation) {
        /**
         * Creates a new ColorInformation literal.
         */
        function create(range, color) {
            return {
                range: range,
                color: color,
            };
        }
        ColorInformation.create = create;
        /**
         * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
         */
        function is(value) {
            var candidate = value;
            return Range.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation.is = is;
    })(ColorInformation = exports.ColorInformation || (exports.ColorInformation = {}));
    /**
     * The Color namespace provides helper functions to work with
     * [ColorPresentation](#ColorPresentation) literals.
     */
    var ColorPresentation;
    (function (ColorPresentation) {
        /**
         * Creates a new ColorInformation literal.
         */
        function create(label, textEdit, additionalTextEdits) {
            return {
                label: label,
                textEdit: textEdit,
                additionalTextEdits: additionalTextEdits,
            };
        }
        ColorPresentation.create = create;
        /**
         * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.string(candidate.label)
                && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
                && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation.is = is;
    })(ColorPresentation = exports.ColorPresentation || (exports.ColorPresentation = {}));
    /**
     * Enum of known range kinds
     */
    var FoldingRangeKind;
    (function (FoldingRangeKind) {
        /**
         * Folding range for a comment
         */
        FoldingRangeKind["Comment"] = "comment";
        /**
         * Folding range for a imports or includes
         */
        FoldingRangeKind["Imports"] = "imports";
        /**
         * Folding range for a region (e.g. `#region`)
         */
        FoldingRangeKind["Region"] = "region";
    })(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
    /**
     * The folding range namespace provides helper functions to work with
     * [FoldingRange](#FoldingRange) literals.
     */
    var FoldingRange;
    (function (FoldingRange) {
        /**
         * Creates a new FoldingRange literal.
         */
        function create(startLine, endLine, startCharacter, endCharacter, kind) {
            var result = {
                startLine: startLine,
                endLine: endLine
            };
            if (Is.defined(startCharacter)) {
                result.startCharacter = startCharacter;
            }
            if (Is.defined(endCharacter)) {
                result.endCharacter = endCharacter;
            }
            if (Is.defined(kind)) {
                result.kind = kind;
            }
            return result;
        }
        FoldingRange.create = create;
        /**
         * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.number(candidate.startLine) && Is.number(candidate.startLine)
                && (Is.undefined(candidate.startCharacter) || Is.number(candidate.startCharacter))
                && (Is.undefined(candidate.endCharacter) || Is.number(candidate.endCharacter))
                && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange.is = is;
    })(FoldingRange = exports.FoldingRange || (exports.FoldingRange = {}));
    /**
     * The DiagnosticRelatedInformation namespace provides helper functions to work with
     * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
     */
    var DiagnosticRelatedInformation;
    (function (DiagnosticRelatedInformation) {
        /**
         * Creates a new DiagnosticRelatedInformation literal.
         */
        function create(location, message) {
            return {
                location: location,
                message: message
            };
        }
        DiagnosticRelatedInformation.create = create;
        /**
         * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation.is = is;
    })(DiagnosticRelatedInformation = exports.DiagnosticRelatedInformation || (exports.DiagnosticRelatedInformation = {}));
    /**
     * The diagnostic's severity.
     */
    var DiagnosticSeverity;
    (function (DiagnosticSeverity) {
        /**
         * Reports an error.
         */
        DiagnosticSeverity.Error = 1;
        /**
         * Reports a warning.
         */
        DiagnosticSeverity.Warning = 2;
        /**
         * Reports an information.
         */
        DiagnosticSeverity.Information = 3;
        /**
         * Reports a hint.
         */
        DiagnosticSeverity.Hint = 4;
    })(DiagnosticSeverity = exports.DiagnosticSeverity || (exports.DiagnosticSeverity = {}));
    /**
     * The Diagnostic namespace provides helper functions to work with
     * [Diagnostic](#Diagnostic) literals.
     */
    var Diagnostic;
    (function (Diagnostic) {
        /**
         * Creates a new Diagnostic literal.
         */
        function create(range, message, severity, code, source, relatedInformation) {
            var result = { range: range, message: message };
            if (Is.defined(severity)) {
                result.severity = severity;
            }
            if (Is.defined(code)) {
                result.code = code;
            }
            if (Is.defined(source)) {
                result.source = source;
            }
            if (Is.defined(relatedInformation)) {
                result.relatedInformation = relatedInformation;
            }
            return result;
        }
        Diagnostic.create = create;
        /**
         * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate)
                && Range.is(candidate.range)
                && Is.string(candidate.message)
                && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
                && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
                && (Is.string(candidate.source) || Is.undefined(candidate.source))
                && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic.is = is;
    })(Diagnostic = exports.Diagnostic || (exports.Diagnostic = {}));
    /**
     * The Command namespace provides helper functions to work with
     * [Command](#Command) literals.
     */
    var Command;
    (function (Command) {
        /**
         * Creates a new Command literal.
         */
        function create(title, command) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var result = { title: title, command: command };
            if (Is.defined(args) && args.length > 0) {
                result.arguments = args;
            }
            return result;
        }
        Command.create = create;
        /**
         * Checks whether the given literal conforms to the [Command](#Command) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command.is = is;
    })(Command = exports.Command || (exports.Command = {}));
    /**
     * The TextEdit namespace provides helper function to create replace,
     * insert and delete edits more easily.
     */
    var TextEdit;
    (function (TextEdit) {
        /**
         * Creates a replace text edit.
         * @param range The range of text to be replaced.
         * @param newText The new text.
         */
        function replace(range, newText) {
            return { range: range, newText: newText };
        }
        TextEdit.replace = replace;
        /**
         * Creates a insert text edit.
         * @param position The position to insert the text at.
         * @param newText The text to be inserted.
         */
        function insert(position, newText) {
            return { range: { start: position, end: position }, newText: newText };
        }
        TextEdit.insert = insert;
        /**
         * Creates a delete text edit.
         * @param range The range of text to be deleted.
         */
        function del(range) {
            return { range: range, newText: '' };
        }
        TextEdit.del = del;
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate)
                && Is.string(candidate.newText)
                && Range.is(candidate.range);
        }
        TextEdit.is = is;
    })(TextEdit = exports.TextEdit || (exports.TextEdit = {}));
    /**
     * The TextDocumentEdit namespace provides helper function to create
     * an edit that manipulates a text document.
     */
    var TextDocumentEdit;
    (function (TextDocumentEdit) {
        /**
         * Creates a new `TextDocumentEdit`
         */
        function create(textDocument, edits) {
            return { textDocument: textDocument, edits: edits };
        }
        TextDocumentEdit.create = create;
        function is(value) {
            var candidate = value;
            return Is.defined(candidate)
                && VersionedTextDocumentIdentifier.is(candidate.textDocument)
                && Array.isArray(candidate.edits);
        }
        TextDocumentEdit.is = is;
    })(TextDocumentEdit = exports.TextDocumentEdit || (exports.TextDocumentEdit = {}));
    var CreateFile;
    (function (CreateFile) {
        function create(uri, options) {
            var result = {
                kind: 'create',
                uri: uri
            };
            if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
                result.options = options;
            }
            return result;
        }
        CreateFile.create = create;
        function is(value) {
            var candidate = value;
            return candidate && candidate.kind === 'create' && Is.string(candidate.uri) &&
                (candidate.options === void 0 ||
                    ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));
        }
        CreateFile.is = is;
    })(CreateFile = exports.CreateFile || (exports.CreateFile = {}));
    var RenameFile;
    (function (RenameFile) {
        function create(oldUri, newUri, options) {
            var result = {
                kind: 'rename',
                oldUri: oldUri,
                newUri: newUri
            };
            if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
                result.options = options;
            }
            return result;
        }
        RenameFile.create = create;
        function is(value) {
            var candidate = value;
            return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) &&
                (candidate.options === void 0 ||
                    ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));
        }
        RenameFile.is = is;
    })(RenameFile = exports.RenameFile || (exports.RenameFile = {}));
    var DeleteFile;
    (function (DeleteFile) {
        function create(uri, options) {
            var result = {
                kind: 'delete',
                uri: uri
            };
            if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
                result.options = options;
            }
            return result;
        }
        DeleteFile.create = create;
        function is(value) {
            var candidate = value;
            return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) &&
                (candidate.options === void 0 ||
                    ((candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))));
        }
        DeleteFile.is = is;
    })(DeleteFile = exports.DeleteFile || (exports.DeleteFile = {}));
    var WorkspaceEdit;
    (function (WorkspaceEdit) {
        function is(value) {
            var candidate = value;
            return candidate &&
                (candidate.changes !== void 0 || candidate.documentChanges !== void 0) &&
                (candidate.documentChanges === void 0 || candidate.documentChanges.every(function (change) {
                    if (Is.string(change.kind)) {
                        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                    }
                    else {
                        return TextDocumentEdit.is(change);
                    }
                }));
        }
        WorkspaceEdit.is = is;
    })(WorkspaceEdit = exports.WorkspaceEdit || (exports.WorkspaceEdit = {}));
    var TextEditChangeImpl = /** @class */ (function () {
        function TextEditChangeImpl(edits) {
            this.edits = edits;
        }
        TextEditChangeImpl.prototype.insert = function (position, newText) {
            this.edits.push(TextEdit.insert(position, newText));
        };
        TextEditChangeImpl.prototype.replace = function (range, newText) {
            this.edits.push(TextEdit.replace(range, newText));
        };
        TextEditChangeImpl.prototype.delete = function (range) {
            this.edits.push(TextEdit.del(range));
        };
        TextEditChangeImpl.prototype.add = function (edit) {
            this.edits.push(edit);
        };
        TextEditChangeImpl.prototype.all = function () {
            return this.edits;
        };
        TextEditChangeImpl.prototype.clear = function () {
            this.edits.splice(0, this.edits.length);
        };
        return TextEditChangeImpl;
    }());
    /**
     * A workspace change helps constructing changes to a workspace.
     */
    var WorkspaceChange = /** @class */ (function () {
        function WorkspaceChange(workspaceEdit) {
            var _this = this;
            this._textEditChanges = Object.create(null);
            if (workspaceEdit) {
                this._workspaceEdit = workspaceEdit;
                if (workspaceEdit.documentChanges) {
                    workspaceEdit.documentChanges.forEach(function (change) {
                        if (TextDocumentEdit.is(change)) {
                            var textEditChange = new TextEditChangeImpl(change.edits);
                            _this._textEditChanges[change.textDocument.uri] = textEditChange;
                        }
                    });
                }
                else if (workspaceEdit.changes) {
                    Object.keys(workspaceEdit.changes).forEach(function (key) {
                        var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                        _this._textEditChanges[key] = textEditChange;
                    });
                }
            }
        }
        Object.defineProperty(WorkspaceChange.prototype, "edit", {
            /**
             * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
             * use to be returned from a workspace edit operation like rename.
             */
            get: function () {
                return this._workspaceEdit;
            },
            enumerable: true,
            configurable: true
        });
        WorkspaceChange.prototype.getTextEditChange = function (key) {
            if (VersionedTextDocumentIdentifier.is(key)) {
                if (!this._workspaceEdit) {
                    this._workspaceEdit = {
                        documentChanges: []
                    };
                }
                if (!this._workspaceEdit.documentChanges) {
                    throw new Error('Workspace edit is not configured for document changes.');
                }
                var textDocument = key;
                var result = this._textEditChanges[textDocument.uri];
                if (!result) {
                    var edits = [];
                    var textDocumentEdit = {
                        textDocument: textDocument,
                        edits: edits
                    };
                    this._workspaceEdit.documentChanges.push(textDocumentEdit);
                    result = new TextEditChangeImpl(edits);
                    this._textEditChanges[textDocument.uri] = result;
                }
                return result;
            }
            else {
                if (!this._workspaceEdit) {
                    this._workspaceEdit = {
                        changes: Object.create(null)
                    };
                }
                if (!this._workspaceEdit.changes) {
                    throw new Error('Workspace edit is not configured for normal text edit changes.');
                }
                var result = this._textEditChanges[key];
                if (!result) {
                    var edits = [];
                    this._workspaceEdit.changes[key] = edits;
                    result = new TextEditChangeImpl(edits);
                    this._textEditChanges[key] = result;
                }
                return result;
            }
        };
        WorkspaceChange.prototype.createFile = function (uri, options) {
            this.checkDocumentChanges();
            this._workspaceEdit.documentChanges.push(CreateFile.create(uri, options));
        };
        WorkspaceChange.prototype.renameFile = function (oldUri, newUri, options) {
            this.checkDocumentChanges();
            this._workspaceEdit.documentChanges.push(RenameFile.create(oldUri, newUri, options));
        };
        WorkspaceChange.prototype.deleteFile = function (uri, options) {
            this.checkDocumentChanges();
            this._workspaceEdit.documentChanges.push(DeleteFile.create(uri, options));
        };
        WorkspaceChange.prototype.checkDocumentChanges = function () {
            if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
        };
        return WorkspaceChange;
    }());
    exports.WorkspaceChange = WorkspaceChange;
    /**
     * The TextDocumentIdentifier namespace provides helper functions to work with
     * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
     */
    var TextDocumentIdentifier;
    (function (TextDocumentIdentifier) {
        /**
         * Creates a new TextDocumentIdentifier literal.
         * @param uri The document's uri.
         */
        function create(uri) {
            return { uri: uri };
        }
        TextDocumentIdentifier.create = create;
        /**
         * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier.is = is;
    })(TextDocumentIdentifier = exports.TextDocumentIdentifier || (exports.TextDocumentIdentifier = {}));
    /**
     * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
     * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
     */
    var VersionedTextDocumentIdentifier;
    (function (VersionedTextDocumentIdentifier) {
        /**
         * Creates a new VersionedTextDocumentIdentifier literal.
         * @param uri The document's uri.
         * @param uri The document's text.
         */
        function create(uri, version) {
            return { uri: uri, version: version };
        }
        VersionedTextDocumentIdentifier.create = create;
        /**
         * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.number(candidate.version));
        }
        VersionedTextDocumentIdentifier.is = is;
    })(VersionedTextDocumentIdentifier = exports.VersionedTextDocumentIdentifier || (exports.VersionedTextDocumentIdentifier = {}));
    /**
     * The TextDocumentItem namespace provides helper functions to work with
     * [TextDocumentItem](#TextDocumentItem) literals.
     */
    var TextDocumentItem;
    (function (TextDocumentItem) {
        /**
         * Creates a new TextDocumentItem literal.
         * @param uri The document's uri.
         * @param languageId The document's language identifier.
         * @param version The document's version number.
         * @param text The document's text.
         */
        function create(uri, languageId, version, text) {
            return { uri: uri, languageId: languageId, version: version, text: text };
        }
        TextDocumentItem.create = create;
        /**
         * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem.is = is;
    })(TextDocumentItem = exports.TextDocumentItem || (exports.TextDocumentItem = {}));
    /**
     * Describes the content type that a client supports in various
     * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
     *
     * Please note that `MarkupKinds` must not start with a `$`. This kinds
     * are reserved for internal usage.
     */
    var MarkupKind;
    (function (MarkupKind) {
        /**
         * Plain text is supported as a content format
         */
        MarkupKind.PlainText = 'plaintext';
        /**
         * Markdown is supported as a content format
         */
        MarkupKind.Markdown = 'markdown';
    })(MarkupKind = exports.MarkupKind || (exports.MarkupKind = {}));
    (function (MarkupKind) {
        /**
         * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
         */
        function is(value) {
            var candidate = value;
            return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
        }
        MarkupKind.is = is;
    })(MarkupKind = exports.MarkupKind || (exports.MarkupKind = {}));
    var MarkupContent;
    (function (MarkupContent) {
        /**
         * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent.is = is;
    })(MarkupContent = exports.MarkupContent || (exports.MarkupContent = {}));
    /**
     * The kind of a completion entry.
     */
    var CompletionItemKind;
    (function (CompletionItemKind) {
        CompletionItemKind.Text = 1;
        CompletionItemKind.Method = 2;
        CompletionItemKind.Function = 3;
        CompletionItemKind.Constructor = 4;
        CompletionItemKind.Field = 5;
        CompletionItemKind.Variable = 6;
        CompletionItemKind.Class = 7;
        CompletionItemKind.Interface = 8;
        CompletionItemKind.Module = 9;
        CompletionItemKind.Property = 10;
        CompletionItemKind.Unit = 11;
        CompletionItemKind.Value = 12;
        CompletionItemKind.Enum = 13;
        CompletionItemKind.Keyword = 14;
        CompletionItemKind.Snippet = 15;
        CompletionItemKind.Color = 16;
        CompletionItemKind.File = 17;
        CompletionItemKind.Reference = 18;
        CompletionItemKind.Folder = 19;
        CompletionItemKind.EnumMember = 20;
        CompletionItemKind.Constant = 21;
        CompletionItemKind.Struct = 22;
        CompletionItemKind.Event = 23;
        CompletionItemKind.Operator = 24;
        CompletionItemKind.TypeParameter = 25;
    })(CompletionItemKind = exports.CompletionItemKind || (exports.CompletionItemKind = {}));
    /**
     * Defines whether the insert text in a completion item should be interpreted as
     * plain text or a snippet.
     */
    var InsertTextFormat;
    (function (InsertTextFormat) {
        /**
         * The primary text to be inserted is treated as a plain string.
         */
        InsertTextFormat.PlainText = 1;
        /**
         * The primary text to be inserted is treated as a snippet.
         *
         * A snippet can define tab stops and placeholders with `$1`, `$2`
         * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
         * the end of the snippet. Placeholders with equal identifiers are linked,
         * that is typing in one will update others too.
         *
         * See also: https://github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md
         */
        InsertTextFormat.Snippet = 2;
    })(InsertTextFormat = exports.InsertTextFormat || (exports.InsertTextFormat = {}));
    /**
     * The CompletionItem namespace provides functions to deal with
     * completion items.
     */
    var CompletionItem;
    (function (CompletionItem) {
        /**
         * Create a completion item and seed it with a label.
         * @param label The completion item's label
         */
        function create(label) {
            return { label: label };
        }
        CompletionItem.create = create;
    })(CompletionItem = exports.CompletionItem || (exports.CompletionItem = {}));
    /**
     * The CompletionList namespace provides functions to deal with
     * completion lists.
     */
    var CompletionList;
    (function (CompletionList) {
        /**
         * Creates a new completion list.
         *
         * @param items The completion items.
         * @param isIncomplete The list is not complete.
         */
        function create(items, isIncomplete) {
            return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList.create = create;
    })(CompletionList = exports.CompletionList || (exports.CompletionList = {}));
    var MarkedString;
    (function (MarkedString) {
        /**
         * Creates a marked string from plain text.
         *
         * @param plainText The plain text.
         */
        function fromPlainText(plainText) {
            return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&"); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
        }
        MarkedString.fromPlainText = fromPlainText;
        /**
         * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
         */
        function is(value) {
            var candidate = value;
            return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
        }
        MarkedString.is = is;
    })(MarkedString = exports.MarkedString || (exports.MarkedString = {}));
    var Hover;
    (function (Hover) {
        /**
         * Checks whether the given value conforms to the [Hover](#Hover) interface.
         */
        function is(value) {
            var candidate = value;
            return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
                MarkedString.is(candidate.contents) ||
                Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
        }
        Hover.is = is;
    })(Hover = exports.Hover || (exports.Hover = {}));
    /**
     * The ParameterInformation namespace provides helper functions to work with
     * [ParameterInformation](#ParameterInformation) literals.
     */
    var ParameterInformation;
    (function (ParameterInformation) {
        /**
         * Creates a new parameter information literal.
         *
         * @param label A label string.
         * @param documentation A doc string.
         */
        function create(label, documentation) {
            return documentation ? { label: label, documentation: documentation } : { label: label };
        }
        ParameterInformation.create = create;
        ;
    })(ParameterInformation = exports.ParameterInformation || (exports.ParameterInformation = {}));
    /**
     * The SignatureInformation namespace provides helper functions to work with
     * [SignatureInformation](#SignatureInformation) literals.
     */
    var SignatureInformation;
    (function (SignatureInformation) {
        function create(label, documentation) {
            var parameters = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                parameters[_i - 2] = arguments[_i];
            }
            var result = { label: label };
            if (Is.defined(documentation)) {
                result.documentation = documentation;
            }
            if (Is.defined(parameters)) {
                result.parameters = parameters;
            }
            else {
                result.parameters = [];
            }
            return result;
        }
        SignatureInformation.create = create;
    })(SignatureInformation = exports.SignatureInformation || (exports.SignatureInformation = {}));
    /**
     * A document highlight kind.
     */
    var DocumentHighlightKind;
    (function (DocumentHighlightKind) {
        /**
         * A textual occurrence.
         */
        DocumentHighlightKind.Text = 1;
        /**
         * Read-access of a symbol, like reading a variable.
         */
        DocumentHighlightKind.Read = 2;
        /**
         * Write-access of a symbol, like writing to a variable.
         */
        DocumentHighlightKind.Write = 3;
    })(DocumentHighlightKind = exports.DocumentHighlightKind || (exports.DocumentHighlightKind = {}));
    /**
     * DocumentHighlight namespace to provide helper functions to work with
     * [DocumentHighlight](#DocumentHighlight) literals.
     */
    var DocumentHighlight;
    (function (DocumentHighlight) {
        /**
         * Create a DocumentHighlight object.
         * @param range The range the highlight applies to.
         */
        function create(range, kind) {
            var result = { range: range };
            if (Is.number(kind)) {
                result.kind = kind;
            }
            return result;
        }
        DocumentHighlight.create = create;
    })(DocumentHighlight = exports.DocumentHighlight || (exports.DocumentHighlight = {}));
    /**
     * A symbol kind.
     */
    var SymbolKind;
    (function (SymbolKind) {
        SymbolKind.File = 1;
        SymbolKind.Module = 2;
        SymbolKind.Namespace = 3;
        SymbolKind.Package = 4;
        SymbolKind.Class = 5;
        SymbolKind.Method = 6;
        SymbolKind.Property = 7;
        SymbolKind.Field = 8;
        SymbolKind.Constructor = 9;
        SymbolKind.Enum = 10;
        SymbolKind.Interface = 11;
        SymbolKind.Function = 12;
        SymbolKind.Variable = 13;
        SymbolKind.Constant = 14;
        SymbolKind.String = 15;
        SymbolKind.Number = 16;
        SymbolKind.Boolean = 17;
        SymbolKind.Array = 18;
        SymbolKind.Object = 19;
        SymbolKind.Key = 20;
        SymbolKind.Null = 21;
        SymbolKind.EnumMember = 22;
        SymbolKind.Struct = 23;
        SymbolKind.Event = 24;
        SymbolKind.Operator = 25;
        SymbolKind.TypeParameter = 26;
    })(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
    var SymbolInformation;
    (function (SymbolInformation) {
        /**
         * Creates a new symbol information literal.
         *
         * @param name The name of the symbol.
         * @param kind The kind of the symbol.
         * @param range The range of the location of the symbol.
         * @param uri The resource of the location of symbol, defaults to the current document.
         * @param containerName The name of the symbol containing the symbol.
         */
        function create(name, kind, range, uri, containerName) {
            var result = {
                name: name,
                kind: kind,
                location: { uri: uri, range: range }
            };
            if (containerName) {
                result.containerName = containerName;
            }
            return result;
        }
        SymbolInformation.create = create;
    })(SymbolInformation = exports.SymbolInformation || (exports.SymbolInformation = {}));
    /**
     * Represents programming constructs like variables, classes, interfaces etc.
     * that appear in a document. Document symbols can be hierarchical and they
     * have two ranges: one that encloses its definition and one that points to
     * its most interesting range, e.g. the range of an identifier.
     */
    var DocumentSymbol = /** @class */ (function () {
        function DocumentSymbol() {
        }
        return DocumentSymbol;
    }());
    exports.DocumentSymbol = DocumentSymbol;
    (function (DocumentSymbol) {
        /**
         * Creates a new symbol information literal.
         *
         * @param name The name of the symbol.
         * @param detail The detail of the symbol.
         * @param kind The kind of the symbol.
         * @param range The range of the symbol.
         * @param selectionRange The selectionRange of the symbol.
         * @param children Children of the symbol.
         */
        function create(name, detail, kind, range, selectionRange, children) {
            var result = {
                name: name,
                detail: detail,
                kind: kind,
                range: range,
                selectionRange: selectionRange
            };
            if (children !== void 0) {
                result.children = children;
            }
            return result;
        }
        DocumentSymbol.create = create;
        /**
         * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
         */
        function is(value) {
            var candidate = value;
            return candidate &&
                Is.string(candidate.name) && Is.number(candidate.kind) &&
                Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
                (candidate.detail === void 0 || Is.string(candidate.detail)) &&
                (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) &&
                (candidate.children === void 0 || Array.isArray(candidate.children));
        }
        DocumentSymbol.is = is;
    })(DocumentSymbol = exports.DocumentSymbol || (exports.DocumentSymbol = {}));
    exports.DocumentSymbol = DocumentSymbol;
    /**
     * A set of predefined code action kinds
     */
    var CodeActionKind;
    (function (CodeActionKind) {
        /**
         * Base kind for quickfix actions: 'quickfix'
         */
        CodeActionKind.QuickFix = 'quickfix';
        /**
         * Base kind for refactoring actions: 'refactor'
         */
        CodeActionKind.Refactor = 'refactor';
        /**
         * Base kind for refactoring extraction actions: 'refactor.extract'
         *
         * Example extract actions:
         *
         * - Extract method
         * - Extract function
         * - Extract variable
         * - Extract interface from class
         * - ...
         */
        CodeActionKind.RefactorExtract = 'refactor.extract';
        /**
         * Base kind for refactoring inline actions: 'refactor.inline'
         *
         * Example inline actions:
         *
         * - Inline function
         * - Inline variable
         * - Inline constant
         * - ...
         */
        CodeActionKind.RefactorInline = 'refactor.inline';
        /**
         * Base kind for refactoring rewrite actions: 'refactor.rewrite'
         *
         * Example rewrite actions:
         *
         * - Convert JavaScript function to class
         * - Add or remove parameter
         * - Encapsulate field
         * - Make method static
         * - Move method to base class
         * - ...
         */
        CodeActionKind.RefactorRewrite = 'refactor.rewrite';
        /**
         * Base kind for source actions: `source`
         *
         * Source code actions apply to the entire file.
         */
        CodeActionKind.Source = 'source';
        /**
         * Base kind for an organize imports source action: `source.organizeImports`
         */
        CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    })(CodeActionKind = exports.CodeActionKind || (exports.CodeActionKind = {}));
    /**
     * The CodeActionContext namespace provides helper functions to work with
     * [CodeActionContext](#CodeActionContext) literals.
     */
    var CodeActionContext;
    (function (CodeActionContext) {
        /**
         * Creates a new CodeActionContext literal.
         */
        function create(diagnostics, only) {
            var result = { diagnostics: diagnostics };
            if (only !== void 0 && only !== null) {
                result.only = only;
            }
            return result;
        }
        CodeActionContext.create = create;
        /**
         * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));
        }
        CodeActionContext.is = is;
    })(CodeActionContext = exports.CodeActionContext || (exports.CodeActionContext = {}));
    var CodeAction;
    (function (CodeAction) {
        function create(title, commandOrEdit, kind) {
            var result = { title: title };
            if (Command.is(commandOrEdit)) {
                result.command = commandOrEdit;
            }
            else {
                result.edit = commandOrEdit;
            }
            if (kind !== void null) {
                result.kind = kind;
            }
            return result;
        }
        CodeAction.create = create;
        function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.title) &&
                (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
                (candidate.kind === void 0 || Is.string(candidate.kind)) &&
                (candidate.edit !== void 0 || candidate.command !== void 0) &&
                (candidate.command === void 0 || Command.is(candidate.command)) &&
                (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction.is = is;
    })(CodeAction = exports.CodeAction || (exports.CodeAction = {}));
    /**
     * The CodeLens namespace provides helper functions to work with
     * [CodeLens](#CodeLens) literals.
     */
    var CodeLens;
    (function (CodeLens) {
        /**
         * Creates a new CodeLens literal.
         */
        function create(range, data) {
            var result = { range: range };
            if (Is.defined(data))
                result.data = data;
            return result;
        }
        CodeLens.create = create;
        /**
         * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens.is = is;
    })(CodeLens = exports.CodeLens || (exports.CodeLens = {}));
    /**
     * The FormattingOptions namespace provides helper functions to work with
     * [FormattingOptions](#FormattingOptions) literals.
     */
    var FormattingOptions;
    (function (FormattingOptions) {
        /**
         * Creates a new FormattingOptions literal.
         */
        function create(tabSize, insertSpaces) {
            return { tabSize: tabSize, insertSpaces: insertSpaces };
        }
        FormattingOptions.create = create;
        /**
         * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.number(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions.is = is;
    })(FormattingOptions = exports.FormattingOptions || (exports.FormattingOptions = {}));
    /**
     * A document link is a range in a text document that links to an internal or external resource, like another
     * text document or a web site.
     */
    var DocumentLink = /** @class */ (function () {
        function DocumentLink() {
        }
        return DocumentLink;
    }());
    exports.DocumentLink = DocumentLink;
    /**
     * The DocumentLink namespace provides helper functions to work with
     * [DocumentLink](#DocumentLink) literals.
     */
    (function (DocumentLink) {
        /**
         * Creates a new DocumentLink literal.
         */
        function create(range, target, data) {
            return { range: range, target: target, data: data };
        }
        DocumentLink.create = create;
        /**
         * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink.is = is;
    })(DocumentLink = exports.DocumentLink || (exports.DocumentLink = {}));
    exports.DocumentLink = DocumentLink;
    exports.EOL = ['\n', '\r\n', '\r'];
    var TextDocument;
    (function (TextDocument) {
        /**
         * Creates a new ITextDocument literal from the given uri and content.
         * @param uri The document's uri.
         * @param languageId  The document's language Id.
         * @param content The document's content.
         */
        function create(uri, languageId, version, content) {
            return new FullTextDocument(uri, languageId, version, content);
        }
        TextDocument.create = create;
        /**
         * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount)
                && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument.is = is;
        function applyEdits(document, edits) {
            var text = document.getText();
            var sortedEdits = mergeSort(edits, function (a, b) {
                var diff = a.range.start.line - b.range.start.line;
                if (diff === 0) {
                    return a.range.start.character - b.range.start.character;
                }
                return diff;
            });
            var lastModifiedOffset = text.length;
            for (var i = sortedEdits.length - 1; i >= 0; i--) {
                var e = sortedEdits[i];
                var startOffset = document.offsetAt(e.range.start);
                var endOffset = document.offsetAt(e.range.end);
                if (endOffset <= lastModifiedOffset) {
                    text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
                }
                else {
                    throw new Error('Overlapping edit');
                }
                lastModifiedOffset = startOffset;
            }
            return text;
        }
        TextDocument.applyEdits = applyEdits;
        function mergeSort(data, compare) {
            if (data.length <= 1) {
                // sorted
                return data;
            }
            var p = (data.length / 2) | 0;
            var left = data.slice(0, p);
            var right = data.slice(p);
            mergeSort(left, compare);
            mergeSort(right, compare);
            var leftIdx = 0;
            var rightIdx = 0;
            var i = 0;
            while (leftIdx < left.length && rightIdx < right.length) {
                var ret = compare(left[leftIdx], right[rightIdx]);
                if (ret <= 0) {
                    // smaller_equal -> take left to preserve order
                    data[i++] = left[leftIdx++];
                }
                else {
                    // greater -> take right
                    data[i++] = right[rightIdx++];
                }
            }
            while (leftIdx < left.length) {
                data[i++] = left[leftIdx++];
            }
            while (rightIdx < right.length) {
                data[i++] = right[rightIdx++];
            }
            return data;
        }
    })(TextDocument = exports.TextDocument || (exports.TextDocument = {}));
    /**
     * Represents reasons why a text document is saved.
     */
    var TextDocumentSaveReason;
    (function (TextDocumentSaveReason) {
        /**
         * Manually triggered, e.g. by the user pressing save, by starting debugging,
         * or by an API call.
         */
        TextDocumentSaveReason.Manual = 1;
        /**
         * Automatic after a delay.
         */
        TextDocumentSaveReason.AfterDelay = 2;
        /**
         * When the editor lost focus.
         */
        TextDocumentSaveReason.FocusOut = 3;
    })(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
    var FullTextDocument = /** @class */ (function () {
        function FullTextDocument(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = null;
        }
        Object.defineProperty(FullTextDocument.prototype, "uri", {
            get: function () {
                return this._uri;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FullTextDocument.prototype, "languageId", {
            get: function () {
                return this._languageId;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FullTextDocument.prototype, "version", {
            get: function () {
                return this._version;
            },
            enumerable: true,
            configurable: true
        });
        FullTextDocument.prototype.getText = function (range) {
            if (range) {
                var start = this.offsetAt(range.start);
                var end = this.offsetAt(range.end);
                return this._content.substring(start, end);
            }
            return this._content;
        };
        FullTextDocument.prototype.update = function (event, version) {
            this._content = event.text;
            this._version = version;
            this._lineOffsets = null;
        };
        FullTextDocument.prototype.getLineOffsets = function () {
            if (this._lineOffsets === null) {
                var lineOffsets = [];
                var text = this._content;
                var isLineStart = true;
                for (var i = 0; i < text.length; i++) {
                    if (isLineStart) {
                        lineOffsets.push(i);
                        isLineStart = false;
                    }
                    var ch = text.charAt(i);
                    isLineStart = (ch === '\r' || ch === '\n');
                    if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                        i++;
                    }
                }
                if (isLineStart && text.length > 0) {
                    lineOffsets.push(text.length);
                }
                this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
        };
        FullTextDocument.prototype.positionAt = function (offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
                return Position.create(0, offset);
            }
            while (low < high) {
                var mid = Math.floor((low + high) / 2);
                if (lineOffsets[mid] > offset) {
                    high = mid;
                }
                else {
                    low = mid + 1;
                }
            }
            // low is the least x for which the line offset is larger than the current offset
            // or array.length if no line offset is larger than the current offset
            var line = low - 1;
            return Position.create(line, offset - lineOffsets[line]);
        };
        FullTextDocument.prototype.offsetAt = function (position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
                return this._content.length;
            }
            else if (position.line < 0) {
                return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
        };
        Object.defineProperty(FullTextDocument.prototype, "lineCount", {
            get: function () {
                return this.getLineOffsets().length;
            },
            enumerable: true,
            configurable: true
        });
        return FullTextDocument;
    }());
    var Is;
    (function (Is) {
        var toString = Object.prototype.toString;
        function defined(value) {
            return typeof value !== 'undefined';
        }
        Is.defined = defined;
        function undefined(value) {
            return typeof value === 'undefined';
        }
        Is.undefined = undefined;
        function boolean(value) {
            return value === true || value === false;
        }
        Is.boolean = boolean;
        function string(value) {
            return toString.call(value) === '[object String]';
        }
        Is.string = string;
        function number(value) {
            return toString.call(value) === '[object Number]';
        }
        Is.number = number;
        function func(value) {
            return toString.call(value) === '[object Function]';
        }
        Is.func = func;
        function objectLiteral(value) {
            // Strictly speaking class instances pass this check as well. Since the LSP
            // doesn't use classes we ignore this for now. If we do we need to add something
            // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
            return value !== null && typeof value === 'object';
        }
        Is.objectLiteral = objectLiteral;
        function typedArray(value, check) {
            return Array.isArray(value) && value.every(check);
        }
        Is.typedArray = typedArray;
    })(Is || (Is = {}));
});


/***/ }),

/***/ 7776:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.config = exports.loadMessageBundle = exports.localize = exports.format = exports.setPseudo = exports.isPseudo = exports.isDefined = exports.BundleFormat = exports.MessageFormat = void 0;
var ral_1 = __webpack_require__(1070);
var MessageFormat;
(function (MessageFormat) {
    MessageFormat["file"] = "file";
    MessageFormat["bundle"] = "bundle";
    MessageFormat["both"] = "both";
})(MessageFormat = exports.MessageFormat || (exports.MessageFormat = {}));
var BundleFormat;
(function (BundleFormat) {
    // the nls.bundle format
    BundleFormat["standalone"] = "standalone";
    BundleFormat["languagePack"] = "languagePack";
})(BundleFormat = exports.BundleFormat || (exports.BundleFormat = {}));
var LocalizeInfo;
(function (LocalizeInfo) {
    function is(value) {
        var candidate = value;
        return candidate && isDefined(candidate.key) && isDefined(candidate.comment);
    }
    LocalizeInfo.is = is;
})(LocalizeInfo || (LocalizeInfo = {}));
function isDefined(value) {
    return typeof value !== 'undefined';
}
exports.isDefined = isDefined;
exports.isPseudo = false;
function setPseudo(pseudo) {
    exports.isPseudo = pseudo;
}
exports.setPseudo = setPseudo;
function format(message, args) {
    var result;
    if (exports.isPseudo) {
        // FF3B and FF3D is the Unicode zenkaku representation for [ and ]
        message = '\uFF3B' + message.replace(/[aouei]/g, '$&$&') + '\uFF3D';
    }
    if (args.length === 0) {
        result = message;
    }
    else {
        result = message.replace(/\{(\d+)\}/g, function (match, rest) {
            var index = rest[0];
            var arg = args[index];
            var replacement = match;
            if (typeof arg === 'string') {
                replacement = arg;
            }
            else if (typeof arg === 'number' || typeof arg === 'boolean' || arg === void 0 || arg === null) {
                replacement = String(arg);
            }
            return replacement;
        });
    }
    return result;
}
exports.format = format;
function localize(_key, message) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    return format(message, args);
}
exports.localize = localize;
function loadMessageBundle(file) {
    return ral_1.default().loadMessageBundle(file);
}
exports.loadMessageBundle = loadMessageBundle;
function config(opts) {
    return ral_1.default().config(opts);
}
exports.config = config;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ 1070:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error("No runtime abstraction layer installed");
    }
    return _ral;
}
(function (RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error("No runtime abstraction layer provided");
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
exports.default = RAL;
//# sourceMappingURL=ral.js.map

/***/ }),

/***/ 3463:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.config = exports.loadMessageBundle = void 0;
var path = __webpack_require__(5622);
var fs = __webpack_require__(5747);
var ral_1 = __webpack_require__(1070);
var common_1 = __webpack_require__(7776);
var common_2 = __webpack_require__(7776);
Object.defineProperty(exports, "MessageFormat", ({ enumerable: true, get: function () { return common_2.MessageFormat; } }));
Object.defineProperty(exports, "BundleFormat", ({ enumerable: true, get: function () { return common_2.BundleFormat; } }));
var toString = Object.prototype.toString;
function isNumber(value) {
    return toString.call(value) === '[object Number]';
}
function isString(value) {
    return toString.call(value) === '[object String]';
}
function isBoolean(value) {
    return value === true || value === false;
}
function readJsonFileSync(filename) {
    return JSON.parse(fs.readFileSync(filename, 'utf8'));
}
var resolvedBundles;
var options;
function initializeSettings() {
    options = { locale: undefined, language: undefined, languagePackSupport: false, cacheLanguageResolution: true, messageFormat: common_1.MessageFormat.bundle };
    if (isString(process.env.VSCODE_NLS_CONFIG)) {
        try {
            var vscodeOptions_1 = JSON.parse(process.env.VSCODE_NLS_CONFIG);
            var language = void 0;
            if (vscodeOptions_1.availableLanguages) {
                var value = vscodeOptions_1.availableLanguages['*'];
                if (isString(value)) {
                    language = value;
                }
            }
            if (isString(vscodeOptions_1.locale)) {
                options.locale = vscodeOptions_1.locale.toLowerCase();
            }
            if (language === undefined) {
                options.language = options.locale;
            }
            else if (language !== 'en') {
                options.language = language;
            }
            if (isBoolean(vscodeOptions_1._languagePackSupport)) {
                options.languagePackSupport = vscodeOptions_1._languagePackSupport;
            }
            if (isString(vscodeOptions_1._cacheRoot)) {
                options.cacheRoot = vscodeOptions_1._cacheRoot;
            }
            if (isString(vscodeOptions_1._languagePackId)) {
                options.languagePackId = vscodeOptions_1._languagePackId;
            }
            if (isString(vscodeOptions_1._translationsConfigFile)) {
                options.translationsConfigFile = vscodeOptions_1._translationsConfigFile;
                try {
                    options.translationsConfig = readJsonFileSync(options.translationsConfigFile);
                }
                catch (error) {
                    // We can't read the translation config file. Mark the cache as corrupted.
                    if (vscodeOptions_1._corruptedFile) {
                        var dirname = path.dirname(vscodeOptions_1._corruptedFile);
                        fs.exists(dirname, function (exists) {
                            if (exists) {
                                fs.writeFile(vscodeOptions_1._corruptedFile, 'corrupted', 'utf8', function (err) {
                                    console.error(err);
                                });
                            }
                        });
                    }
                }
            }
        }
        catch (_a) {
            // Do nothing.
        }
    }
    common_1.setPseudo(options.locale === 'pseudo');
    resolvedBundles = Object.create(null);
}
initializeSettings();
function supportsLanguagePack() {
    return options.languagePackSupport === true && options.cacheRoot !== undefined && options.languagePackId !== undefined && options.translationsConfigFile !== undefined
        && options.translationsConfig !== undefined;
}
function createScopedLocalizeFunction(messages) {
    return function (key, message) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        if (isNumber(key)) {
            if (key >= messages.length) {
                console.error("Broken localize call found. Index out of bounds. Stacktrace is\n: " + new Error('').stack);
                return;
            }
            return common_1.format(messages[key], args);
        }
        else {
            if (isString(message)) {
                console.warn("Message " + message + " didn't get externalized correctly.");
                return common_1.format(message, args);
            }
            else {
                console.error("Broken localize call found. Stacktrace is\n: " + new Error('').stack);
            }
        }
    };
}
function resolveLanguage(file) {
    var resolvedLanguage;
    if (options.cacheLanguageResolution && resolvedLanguage) {
        resolvedLanguage = resolvedLanguage;
    }
    else {
        if (common_1.isPseudo || !options.language) {
            resolvedLanguage = '.nls.json';
        }
        else {
            var locale = options.language;
            while (locale) {
                var candidate = '.nls.' + locale + '.json';
                if (fs.existsSync(file + candidate)) {
                    resolvedLanguage = candidate;
                    break;
                }
                else {
                    var index = locale.lastIndexOf('-');
                    if (index > 0) {
                        locale = locale.substring(0, index);
                    }
                    else {
                        resolvedLanguage = '.nls.json';
                        locale = null;
                    }
                }
            }
        }
        if (options.cacheLanguageResolution) {
            resolvedLanguage = resolvedLanguage;
        }
    }
    return file + resolvedLanguage;
}
function findInTheBoxBundle(root) {
    var language = options.language;
    while (language) {
        var candidate = path.join(root, "nls.bundle." + language + ".json");
        if (fs.existsSync(candidate)) {
            return candidate;
        }
        else {
            var index = language.lastIndexOf('-');
            if (index > 0) {
                language = language.substring(0, index);
            }
            else {
                language = undefined;
            }
        }
    }
    // Test if we can reslove the default bundle.
    if (language === undefined) {
        var candidate = path.join(root, 'nls.bundle.json');
        if (fs.existsSync(candidate)) {
            return candidate;
        }
    }
    return undefined;
}
function mkdir(directory) {
    try {
        fs.mkdirSync(directory);
    }
    catch (err) {
        if (err.code === 'EEXIST') {
            return;
        }
        else if (err.code === 'ENOENT') {
            var parent = path.dirname(directory);
            if (parent !== directory) {
                mkdir(parent);
                fs.mkdirSync(directory);
            }
        }
        else {
            throw err;
        }
    }
}
function createDefaultNlsBundle(folder) {
    var metaData = readJsonFileSync(path.join(folder, 'nls.metadata.json'));
    var result = Object.create(null);
    for (var module_1 in metaData) {
        var entry = metaData[module_1];
        result[module_1] = entry.messages;
    }
    return result;
}
function createNLSBundle(header, metaDataPath) {
    var languagePackLocation = options.translationsConfig[header.id];
    if (!languagePackLocation) {
        return undefined;
    }
    var languagePack = readJsonFileSync(languagePackLocation).contents;
    var metaData = readJsonFileSync(path.join(metaDataPath, 'nls.metadata.json'));
    var result = Object.create(null);
    for (var module_2 in metaData) {
        var entry = metaData[module_2];
        var translations = languagePack[header.outDir + "/" + module_2];
        if (translations) {
            var resultMessages = [];
            for (var i = 0; i < entry.keys.length; i++) {
                var messageKey = entry.keys[i];
                var key = isString(messageKey) ? messageKey : messageKey.key;
                var translatedMessage = translations[key];
                if (translatedMessage === undefined) {
                    translatedMessage = entry.messages[i];
                }
                resultMessages.push(translatedMessage);
            }
            result[module_2] = resultMessages;
        }
        else {
            result[module_2] = entry.messages;
        }
    }
    return result;
}
function touch(file) {
    var d = new Date();
    fs.utimes(file, d, d, function () {
        // Do nothing. Ignore
    });
}
function cacheBundle(key, bundle) {
    resolvedBundles[key] = bundle;
    return bundle;
}
function loadNlsBundleOrCreateFromI18n(header, bundlePath) {
    var result;
    var bundle = path.join(options.cacheRoot, header.id + "-" + header.hash + ".json");
    var useMemoryOnly = false;
    var writeBundle = false;
    try {
        result = JSON.parse(fs.readFileSync(bundle, { encoding: 'utf8', flag: 'r' }));
        touch(bundle);
        return result;
    }
    catch (err) {
        if (err.code === 'ENOENT') {
            writeBundle = true;
        }
        else if (err instanceof SyntaxError) {
            // We have a syntax error. So no valid JSON. Use
            console.log("Syntax error parsing message bundle: " + err.message + ".");
            fs.unlink(bundle, function (err) {
                if (err) {
                    console.error("Deleting corrupted bundle " + bundle + " failed.");
                }
            });
            useMemoryOnly = true;
        }
        else {
            throw err;
        }
    }
    result = createNLSBundle(header, bundlePath);
    if (!result || useMemoryOnly) {
        return result;
    }
    if (writeBundle) {
        try {
            fs.writeFileSync(bundle, JSON.stringify(result), { encoding: 'utf8', flag: 'wx' });
        }
        catch (err) {
            if (err.code === 'EEXIST') {
                return result;
            }
            throw err;
        }
    }
    return result;
}
function loadDefaultNlsBundle(bundlePath) {
    try {
        return createDefaultNlsBundle(bundlePath);
    }
    catch (err) {
        console.log("Generating default bundle from meta data failed.", err);
        return undefined;
    }
}
function loadNlsBundle(header, bundlePath) {
    var result;
    // Core decided to use a language pack. Do the same in the extension
    if (supportsLanguagePack()) {
        try {
            result = loadNlsBundleOrCreateFromI18n(header, bundlePath);
        }
        catch (err) {
            console.log("Load or create bundle failed ", err);
        }
    }
    if (!result) {
        // No language pack found, but core is running in language pack mode
        // Don't try to use old in the box bundles since the might be stale
        // Fall right back to the default bundle.
        if (options.languagePackSupport) {
            return loadDefaultNlsBundle(bundlePath);
        }
        var candidate = findInTheBoxBundle(bundlePath);
        if (candidate) {
            try {
                return readJsonFileSync(candidate);
            }
            catch (err) {
                console.log("Loading in the box message bundle failed.", err);
            }
        }
        result = loadDefaultNlsBundle(bundlePath);
    }
    return result;
}
function tryFindMetaDataHeaderFile(file) {
    var result;
    var dirname = path.dirname(file);
    while (true) {
        result = path.join(dirname, 'nls.metadata.header.json');
        if (fs.existsSync(result)) {
            break;
        }
        var parent = path.dirname(dirname);
        if (parent === dirname) {
            result = undefined;
            break;
        }
        else {
            dirname = parent;
        }
    }
    return result;
}
function loadMessageBundle(file) {
    if (!file) {
        // No file. We are in dev mode. Return the default
        // localize function.
        return common_1.localize;
    }
    // Remove extension since we load json files.
    var ext = path.extname(file);
    if (ext) {
        file = file.substr(0, file.length - ext.length);
    }
    if (options.messageFormat === common_1.MessageFormat.both || options.messageFormat === common_1.MessageFormat.bundle) {
        var headerFile = tryFindMetaDataHeaderFile(file);
        if (headerFile) {
            var bundlePath = path.dirname(headerFile);
            var bundle = resolvedBundles[bundlePath];
            if (bundle === undefined) {
                try {
                    var header = JSON.parse(fs.readFileSync(headerFile, 'utf8'));
                    try {
                        var nlsBundle = loadNlsBundle(header, bundlePath);
                        bundle = cacheBundle(bundlePath, nlsBundle ? { header: header, nlsBundle: nlsBundle } : null);
                    }
                    catch (err) {
                        console.error('Failed to load nls bundle', err);
                        bundle = cacheBundle(bundlePath, null);
                    }
                }
                catch (err) {
                    console.error('Failed to read header file', err);
                    bundle = cacheBundle(bundlePath, null);
                }
            }
            if (bundle) {
                var module_3 = file.substr(bundlePath.length + 1).replace(/\\/g, '/');
                var messages = bundle.nlsBundle[module_3];
                if (messages === undefined) {
                    console.error("Messages for file " + file + " not found. See console for details.");
                    return function () {
                        return 'Messages not found.';
                    };
                }
                return createScopedLocalizeFunction(messages);
            }
        }
    }
    if (options.messageFormat === common_1.MessageFormat.both || options.messageFormat === common_1.MessageFormat.file) {
        // Try to load a single file bundle
        try {
            var json = readJsonFileSync(resolveLanguage(file));
            if (Array.isArray(json)) {
                return createScopedLocalizeFunction(json);
            }
            else {
                if (common_1.isDefined(json.messages) && common_1.isDefined(json.keys)) {
                    return createScopedLocalizeFunction(json.messages);
                }
                else {
                    console.error("String bundle '" + file + "' uses an unsupported format.");
                    return function () {
                        return 'File bundle has unsupported format. See console for details';
                    };
                }
            }
        }
        catch (err) {
            if (err.code !== 'ENOENT') {
                console.error('Failed to load single file bundle', err);
            }
        }
    }
    console.error("Failed to load message bundle for file " + file);
    return function () {
        return 'Failed to load message bundle. See console for details.';
    };
}
exports.loadMessageBundle = loadMessageBundle;
function config(opts) {
    if (opts) {
        if (isString(opts.locale)) {
            options.locale = opts.locale.toLowerCase();
            options.language = options.locale;
            resolvedBundles = Object.create(null);
        }
        if (opts.messageFormat !== undefined) {
            options.messageFormat = opts.messageFormat;
        }
        if (opts.bundleFormat === common_1.BundleFormat.standalone && options.languagePackSupport === true) {
            options.languagePackSupport = false;
        }
    }
    common_1.setPseudo(options.locale === 'pseudo');
    return loadMessageBundle;
}
exports.config = config;
ral_1.default.install(Object.freeze({
    loadMessageBundle: loadMessageBundle,
    config: config
}));
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 2579:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
Object.defineProperty(exports, "__esModule", ({ value: true }));
var VSCodeTasClient_1 = __webpack_require__(2050);
exports.getExperimentationService = VSCodeTasClient_1.getExperimentationService;
exports.getExperimentationServiceAsync = VSCodeTasClient_1.getExperimentationServiceAsync;
var VSCodeFilterProvider_1 = __webpack_require__(4978);
exports.TargetPopulation = VSCodeFilterProvider_1.TargetPopulation;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4091:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class MementoKeyValueStorage {
    constructor(mementoGlobalStorage) {
        this.mementoGlobalStorage = mementoGlobalStorage;
    }
    async getValue(key, defaultValue) {
        const value = await this.mementoGlobalStorage.get(key);
        return value || defaultValue;
    }
    setValue(key, value) {
        this.mementoGlobalStorage.update(key, value);
    }
}
exports.MementoKeyValueStorage = MementoKeyValueStorage;
//# sourceMappingURL=MementoKeyValueStorage.js.map

/***/ }),

/***/ 2545:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class TelemetryDisabledExperimentationService {
    constructor() {
        this.initializePromise = Promise.resolve();
        this.initialFetch = Promise.resolve();
    }
    isFlightEnabled(flight) {
        return false;
    }
    isCachedFlightEnabled(flight) {
        return Promise.resolve(false);
    }
    isFlightEnabledAsync(flight) {
        return Promise.resolve(false);
    }
    getTreatmentVariable(configId, name) {
        return undefined;
    }
    getTreatmentVariableAsync(configId, name) {
        return Promise.resolve(undefined);
    }
}
exports.default = TelemetryDisabledExperimentationService;
//# sourceMappingURL=TelemetryDisabledExperimentationService.js.map

/***/ }),

/***/ 4978:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode = __webpack_require__(7549);
/**
 * Here is where we are going to define the filters we will set.
 */
class VSCodeFilterProvider {
    constructor(extensionName, extensionVersion, targetPopulation) {
        this.extensionName = extensionName;
        this.extensionVersion = extensionVersion;
        this.targetPopulation = targetPopulation;
    }
    /**
     * Returns a version string that can be parsed into a .NET Build object
     * by removing the tag suffix (for example -dev).
     *
     * @param version Version string to be trimmed.
     */
    static trimVersionSuffix(version) {
        const regex = /\-[a-zA-Z0-9]+$/;
        const result = version.split(regex);
        return result[0];
    }
    getFilterValue(filter) {
        switch (filter) {
            case Filters.ApplicationVersion:
                return VSCodeFilterProvider.trimVersionSuffix(vscode.version);
            case Filters.Build:
                return vscode.env.appName;
            case Filters.ClientId:
                return vscode.env.machineId;
            case Filters.ExtensionName:
                return this.extensionName;
            case Filters.ExtensionVersion:
                return VSCodeFilterProvider.trimVersionSuffix(this.extensionVersion);
            case Filters.Language:
                return vscode.env.language;
            case Filters.TargetPopulation:
                return this.targetPopulation;
            default:
                return '';
        }
    }
    getFilters() {
        let filters = new Map();
        let filterValues = Object.values(Filters);
        for (let value of filterValues) {
            filters.set(value, this.getFilterValue(value));
        }
        return filters;
    }
}
exports.VSCodeFilterProvider = VSCodeFilterProvider;
/*
Based upon the official VSCode currently existing filters in the
ExP backend for the VSCode cluster.
https://experimentation.visualstudio.com/Analysis%20and%20Experimentation/_git/AnE.ExP.TAS.TachyonHost.Configuration?path=%2FConfigurations%2Fvscode%2Fvscode.json&version=GBmaster
"X-MSEdge-Market": "detection.market",
"X-FD-Corpnet": "detection.corpnet",
"X-VSCode–AppVersion": "appversion",
"X-VSCode-Build": "build",
"X-MSEdge-ClientId": "clientid",
"X-VSCode-ExtensionName": "extensionname",
"X-VSCode-ExtensionVersion": "extensionversion",
"X-VSCode-TargetPopulation": "targetpopulation",
"X-VSCode-Language": "language"
*/
/**
 * All available filters, can be updated.
 */
var Filters;
(function (Filters) {
    /**
     * The market in which the extension is distributed.
     */
    Filters["Market"] = "X-MSEdge-Market";
    /**
     * The corporation network.
     */
    Filters["CorpNet"] = "X-FD-Corpnet";
    /**
     * Version of the application which uses experimentation service.
     */
    Filters["ApplicationVersion"] = "X-VSCode-AppVersion";
    /**
     * Insiders vs Stable.
     */
    Filters["Build"] = "X-VSCode-Build";
    /**
     * Client Id which is used as primary unit for the experimentation.
     */
    Filters["ClientId"] = "X-MSEdge-ClientId";
    /**
     * Extension header.
     */
    Filters["ExtensionName"] = "X-VSCode-ExtensionName";
    /**
     * The version of the extension.
     */
    Filters["ExtensionVersion"] = "X-VSCode-ExtensionVersion";
    /**
     * The language in use by VS Code
     */
    Filters["Language"] = "X-VSCode-Language";
    /**
     * The target population.
     * This is used to separate internal, early preview, GA, etc.
     */
    Filters["TargetPopulation"] = "X-VSCode-TargetPopulation";
})(Filters = exports.Filters || (exports.Filters = {}));
/**
 * Specifies the target population for the experimentation filter.
 */
var TargetPopulation;
(function (TargetPopulation) {
    TargetPopulation["Team"] = "team";
    TargetPopulation["Internal"] = "internal";
    TargetPopulation["Insiders"] = "insider";
    TargetPopulation["Public"] = "public";
})(TargetPopulation = exports.TargetPopulation || (exports.TargetPopulation = {}));
//# sourceMappingURL=VSCodeFilterProvider.js.map

/***/ }),

/***/ 2050:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const VSCodeFilterProvider_1 = __webpack_require__(4978);
const tas_client_1 = __webpack_require__(4248);
const vscode = __webpack_require__(7549);
const MementoKeyValueStorage_1 = __webpack_require__(4091);
const TelemetryDisabledExperimentationService_1 = __webpack_require__(2545);
const endpoint = 'https://default.exp-tas.com/vscode/ab';
const telemetryEventName = 'query-expfeature';
const featuresTelemetryPropertyName = 'VSCode.ABExp.Features';
const assignmentContextTelemetryPropertyName = 'abexp.assignmentcontext';
const storageKey = 'VSCode.ABExp.FeatureData';
const refetchInterval = 1000 * 60 * 30; // By default it's set up to 30 minutes.
/**
 *
 * @param extensionName The name of the extension.
 * @param extensionVersion The version of the extension.
 * @param telemetry Telemetry implementation.
 * @param targetPopulation An enum containing the target population ('team', 'internal', 'insiders', 'public').
 * @param memento The memento state to be used for cache.
 * @param filterProviders The filter providers.
 */
function getExperimentationService(extensionName, extensionVersion, targetPopulation, telemetry, memento, ...filterProviders) {
    if (!memento) {
        throw new Error('Memento storage was not provided.');
    }
    const config = vscode.workspace.getConfiguration('telemetry');
    const telemetryEnabled = vscode.env.isTelemetryEnabled === undefined
        ? config.get('enableTelemetry', true)
        : vscode.env.isTelemetryEnabled;
    if (!telemetryEnabled) {
        return new TelemetryDisabledExperimentationService_1.default();
    }
    const extensionFilterProvider = new VSCodeFilterProvider_1.VSCodeFilterProvider(extensionName, extensionVersion, targetPopulation);
    const providerList = [extensionFilterProvider, ...filterProviders];
    const keyValueStorage = new MementoKeyValueStorage_1.MementoKeyValueStorage(memento);
    return new tas_client_1.ExperimentationService({
        filterProviders: providerList,
        telemetry: telemetry,
        storageKey: storageKey,
        keyValueStorage: keyValueStorage,
        featuresTelemetryPropertyName: featuresTelemetryPropertyName,
        assignmentContextTelemetryPropertyName: assignmentContextTelemetryPropertyName,
        telemetryEventName: telemetryEventName,
        endpoint: endpoint,
        refetchInterval: refetchInterval,
    });
}
exports.getExperimentationService = getExperimentationService;
/**
 * Returns the experimentation service after waiting on initialize.
 *
 * @param extensionName The name of the extension.
 * @param extensionVersion The version of the extension.
 * @param telemetry Telemetry implementation.
 * @param targetPopulation An enum containing the target population ('team', 'internal', 'insiders', 'public').
 * @param memento The memento state to be used for cache.
 * @param filterProviders The filter providers.
 */
async function getExperimentationServiceAsync(extensionName, extensionVersion, targetPopulation, telemetry, memento, ...filterProviders) {
    const experimentationService = getExperimentationService(extensionName, extensionVersion, targetPopulation, telemetry, memento, ...filterProviders);
    await experimentationService.initializePromise;
    return experimentationService;
}
exports.getExperimentationServiceAsync = getExperimentationServiceAsync;
//# sourceMappingURL=VSCodeTasClient.js.map

/***/ }),

/***/ 8750:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isWindows = process.platform === 'win32' ||
    process.env.OSTYPE === 'cygwin' ||
    process.env.OSTYPE === 'msys'

const path = __webpack_require__(5622)
const COLON = isWindows ? ';' : ':'
const isexe = __webpack_require__(4219)

const getNotFoundError = (cmd) =>
  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })

const getPathInfo = (cmd, opt) => {
  const colon = opt.colon || COLON

  // If it has a slash, then we don't bother searching the pathenv.
  // just check the file itself, and that's it.
  const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? ['']
    : (
      [
        // windows always checks the cwd first
        ...(isWindows ? [process.cwd()] : []),
        ...(opt.path || process.env.PATH ||
          /* istanbul ignore next: very unusual */ '').split(colon),
      ]
    )
  const pathExtExe = isWindows
    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'
    : ''
  const pathExt = isWindows ? pathExtExe.split(colon) : ['']

  if (isWindows) {
    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')
      pathExt.unshift('')
  }

  return {
    pathEnv,
    pathExt,
    pathExtExe,
  }
}

const which = (cmd, opt, cb) => {
  if (typeof opt === 'function') {
    cb = opt
    opt = {}
  }
  if (!opt)
    opt = {}

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)
  const found = []

  const step = i => new Promise((resolve, reject) => {
    if (i === pathEnv.length)
      return opt.all && found.length ? resolve(found)
        : reject(getNotFoundError(cmd))

    const ppRaw = pathEnv[i]
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw

    const pCmd = path.join(pathPart, cmd)
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd

    resolve(subStep(p, i, 0))
  })

  const subStep = (p, i, ii) => new Promise((resolve, reject) => {
    if (ii === pathExt.length)
      return resolve(step(i + 1))
    const ext = pathExt[ii]
    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
      if (!er && is) {
        if (opt.all)
          found.push(p + ext)
        else
          return resolve(p + ext)
      }
      return resolve(subStep(p, i, ii + 1))
    })
  })

  return cb ? step(0).then(res => cb(null, res), cb) : step(0)
}

const whichSync = (cmd, opt) => {
  opt = opt || {}

  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)
  const found = []

  for (let i = 0; i < pathEnv.length; i ++) {
    const ppRaw = pathEnv[i]
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw

    const pCmd = path.join(pathPart, cmd)
    const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd
      : pCmd

    for (let j = 0; j < pathExt.length; j ++) {
      const cur = p + pathExt[j]
      try {
        const is = isexe.sync(cur, { pathExt: pathExtExe })
        if (is) {
          if (opt.all)
            found.push(cur)
          else
            return cur
        }
      } catch (ex) {}
    }
  }

  if (opt.all && found.length)
    return found

  if (opt.nothrow)
    return null

  throw getNotFoundError(cmd)
}

module.exports = which
which.sync = whichSync


/***/ }),

/***/ 7534:
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ 8798:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var fs = __webpack_require__(5747);
var zlib = __webpack_require__(8761);
var fd_slicer = __webpack_require__(2530);
var crc32 = __webpack_require__(7791);
var util = __webpack_require__(1669);
var EventEmitter = __webpack_require__(8614).EventEmitter;
var Transform = __webpack_require__(2413).Transform;
var PassThrough = __webpack_require__(2413).PassThrough;
var Writable = __webpack_require__(2413).Writable;

exports.open = open;
exports.fromFd = fromFd;
exports.fromBuffer = fromBuffer;
exports.fromRandomAccessReader = fromRandomAccessReader;
exports.dosDateTimeToDate = dosDateTimeToDate;
exports.validateFileName = validateFileName;
exports.ZipFile = ZipFile;
exports.Entry = Entry;
exports.RandomAccessReader = RandomAccessReader;

function open(path, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = true;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  fs.open(path, "r", function(err, fd) {
    if (err) return callback(err);
    fromFd(fd, options, function(err, zipfile) {
      if (err) fs.close(fd, defaultCallback);
      callback(err, zipfile);
    });
  });
}

function fromFd(fd, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = false;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  fs.fstat(fd, function(err, stats) {
    if (err) return callback(err);
    var reader = fd_slicer.createFromFd(fd, {autoClose: true});
    fromRandomAccessReader(reader, stats.size, options, callback);
  });
}

function fromBuffer(buffer, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  options.autoClose = false;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  // limit the max chunk size. see https://github.com/thejoshwolfe/yauzl/issues/87
  var reader = fd_slicer.createFromBuffer(buffer, {maxChunkSize: 0x10000});
  fromRandomAccessReader(reader, buffer.length, options, callback);
}

function fromRandomAccessReader(reader, totalSize, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = true;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  var decodeStrings = !!options.decodeStrings;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  if (typeof totalSize !== "number") throw new Error("expected totalSize parameter to be a number");
  if (totalSize > Number.MAX_SAFE_INTEGER) {
    throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
  }

  // the matching unref() call is in zipfile.close()
  reader.ref();

  // eocdr means End of Central Directory Record.
  // search backwards for the eocdr signature.
  // the last field of the eocdr is a variable-length comment.
  // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.
  // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.
  // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.
  var eocdrWithoutCommentSize = 22;
  var maxCommentSize = 0xffff; // 2-byte size
  var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
  var buffer = newBuffer(bufferSize);
  var bufferReadStart = totalSize - buffer.length;
  readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
    if (err) return callback(err);
    for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
      if (buffer.readUInt32LE(i) !== 0x06054b50) continue;
      // found eocdr
      var eocdrBuffer = buffer.slice(i);

      // 0 - End of central directory signature = 0x06054b50
      // 4 - Number of this disk
      var diskNumber = eocdrBuffer.readUInt16LE(4);
      if (diskNumber !== 0) {
        return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
      }
      // 6 - Disk where central directory starts
      // 8 - Number of central directory records on this disk
      // 10 - Total number of central directory records
      var entryCount = eocdrBuffer.readUInt16LE(10);
      // 12 - Size of central directory (bytes)
      // 16 - Offset of start of central directory, relative to start of archive
      var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
      // 20 - Comment length
      var commentLength = eocdrBuffer.readUInt16LE(20);
      var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
      if (commentLength !== expectedCommentLength) {
        return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
      }
      // 22 - Comment
      // the encoding is always cp437.
      var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false)
                                  : eocdrBuffer.slice(22);

      if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {
        return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
      }

      // ZIP64 format

      // ZIP64 Zip64 end of central directory locator
      var zip64EocdlBuffer = newBuffer(20);
      var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
      readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err) {
        if (err) return callback(err);

        // 0 - zip64 end of central dir locator signature = 0x07064b50
        if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) {
          return callback(new Error("invalid zip64 end of central directory locator signature"));
        }
        // 4 - number of the disk with the start of the zip64 end of central directory
        // 8 - relative offset of the zip64 end of central directory record
        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
        // 16 - total number of disks

        // ZIP64 end of central directory record
        var zip64EocdrBuffer = newBuffer(56);
        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err) {
          if (err) return callback(err);

          // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)
          if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) {
            return callback(new Error("invalid zip64 end of central directory record signature"));
          }
          // 4 - size of zip64 end of central directory record                8 bytes
          // 12 - version made by                                             2 bytes
          // 14 - version needed to extract                                   2 bytes
          // 16 - number of this disk                                         4 bytes
          // 20 - number of the disk with the start of the central directory  4 bytes
          // 24 - total number of entries in the central directory on this disk         8 bytes
          // 32 - total number of entries in the central directory            8 bytes
          entryCount = readUInt64LE(zip64EocdrBuffer, 32);
          // 40 - size of the central directory                               8 bytes
          // 48 - offset of start of central directory with respect to the starting disk number     8 bytes
          centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
          // 56 - zip64 extensible data sector                                (variable size)
          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
        });
      });
      return;
    }
    callback(new Error("end of central directory record signature not found"));
  });
}

util.inherits(ZipFile, EventEmitter);
function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
  var self = this;
  EventEmitter.call(self);
  self.reader = reader;
  // forward close events
  self.reader.on("error", function(err) {
    // error closing the fd
    emitError(self, err);
  });
  self.reader.once("close", function() {
    self.emit("close");
  });
  self.readEntryCursor = centralDirectoryOffset;
  self.fileSize = fileSize;
  self.entryCount = entryCount;
  self.comment = comment;
  self.entriesRead = 0;
  self.autoClose = !!autoClose;
  self.lazyEntries = !!lazyEntries;
  self.decodeStrings = !!decodeStrings;
  self.validateEntrySizes = !!validateEntrySizes;
  self.strictFileNames = !!strictFileNames;
  self.isOpen = true;
  self.emittedError = false;

  if (!self.lazyEntries) self._readEntry();
}
ZipFile.prototype.close = function() {
  if (!this.isOpen) return;
  this.isOpen = false;
  this.reader.unref();
};

function emitErrorAndAutoClose(self, err) {
  if (self.autoClose) self.close();
  emitError(self, err);
}
function emitError(self, err) {
  if (self.emittedError) return;
  self.emittedError = true;
  self.emit("error", err);
}

ZipFile.prototype.readEntry = function() {
  if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
  this._readEntry();
};
ZipFile.prototype._readEntry = function() {
  var self = this;
  if (self.entryCount === self.entriesRead) {
    // done with metadata
    setImmediate(function() {
      if (self.autoClose) self.close();
      if (self.emittedError) return;
      self.emit("end");
    });
    return;
  }
  if (self.emittedError) return;
  var buffer = newBuffer(46);
  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
    if (err) return emitErrorAndAutoClose(self, err);
    if (self.emittedError) return;
    var entry = new Entry();
    // 0 - Central directory file header signature
    var signature = buffer.readUInt32LE(0);
    if (signature !== 0x02014b50) return emitErrorAndAutoClose(self, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
    // 4 - Version made by
    entry.versionMadeBy = buffer.readUInt16LE(4);
    // 6 - Version needed to extract (minimum)
    entry.versionNeededToExtract = buffer.readUInt16LE(6);
    // 8 - General purpose bit flag
    entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
    // 10 - Compression method
    entry.compressionMethod = buffer.readUInt16LE(10);
    // 12 - File last modification time
    entry.lastModFileTime = buffer.readUInt16LE(12);
    // 14 - File last modification date
    entry.lastModFileDate = buffer.readUInt16LE(14);
    // 16 - CRC-32
    entry.crc32 = buffer.readUInt32LE(16);
    // 20 - Compressed size
    entry.compressedSize = buffer.readUInt32LE(20);
    // 24 - Uncompressed size
    entry.uncompressedSize = buffer.readUInt32LE(24);
    // 28 - File name length (n)
    entry.fileNameLength = buffer.readUInt16LE(28);
    // 30 - Extra field length (m)
    entry.extraFieldLength = buffer.readUInt16LE(30);
    // 32 - File comment length (k)
    entry.fileCommentLength = buffer.readUInt16LE(32);
    // 34 - Disk number where file starts
    // 36 - Internal file attributes
    entry.internalFileAttributes = buffer.readUInt16LE(36);
    // 38 - External file attributes
    entry.externalFileAttributes = buffer.readUInt32LE(38);
    // 42 - Relative offset of local file header
    entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);

    if (entry.generalPurposeBitFlag & 0x40) return emitErrorAndAutoClose(self, new Error("strong encryption is not supported"));

    self.readEntryCursor += 46;

    buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
    readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {
      if (err) return emitErrorAndAutoClose(self, err);
      if (self.emittedError) return;
      // 46 - File name
      var isUtf8 = (entry.generalPurposeBitFlag & 0x800) !== 0;
      entry.fileName = self.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8)
                                          : buffer.slice(0, entry.fileNameLength);

      // 46+n - Extra field
      var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
      var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
      entry.extraFields = [];
      var i = 0;
      while (i < extraFieldBuffer.length - 3) {
        var headerId = extraFieldBuffer.readUInt16LE(i + 0);
        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
        var dataStart = i + 4;
        var dataEnd = dataStart + dataSize;
        if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self, new Error("extra field length exceeds extra field buffer size"));
        var dataBuffer = newBuffer(dataSize);
        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
        entry.extraFields.push({
          id: headerId,
          data: dataBuffer,
        });
        i = dataEnd;
      }

      // 46+n+m - File comment
      entry.fileComment = self.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8)
                                             : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
      // compatibility hack for https://github.com/thejoshwolfe/yauzl/issues/47
      entry.comment = entry.fileComment;

      self.readEntryCursor += buffer.length;
      self.entriesRead += 1;

      if (entry.uncompressedSize            === 0xffffffff ||
          entry.compressedSize              === 0xffffffff ||
          entry.relativeOffsetOfLocalHeader === 0xffffffff) {
        // ZIP64 format
        // find the Zip64 Extended Information Extra Field
        var zip64EiefBuffer = null;
        for (var i = 0; i < entry.extraFields.length; i++) {
          var extraField = entry.extraFields[i];
          if (extraField.id === 0x0001) {
            zip64EiefBuffer = extraField.data;
            break;
          }
        }
        if (zip64EiefBuffer == null) {
          return emitErrorAndAutoClose(self, new Error("expected zip64 extended information extra field"));
        }
        var index = 0;
        // 0 - Original Size          8 bytes
        if (entry.uncompressedSize === 0xffffffff) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include uncompressed size"));
          }
          entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
        // 8 - Compressed Size        8 bytes
        if (entry.compressedSize === 0xffffffff) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include compressed size"));
          }
          entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
        // 16 - Relative Header Offset 8 bytes
        if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self, new Error("zip64 extended information extra field does not include relative header offset"));
          }
          entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
        // 24 - Disk Start Number      4 bytes
      }

      // check for Info-ZIP Unicode Path Extra Field (0x7075)
      // see https://github.com/thejoshwolfe/yauzl/issues/33
      if (self.decodeStrings) {
        for (var i = 0; i < entry.extraFields.length; i++) {
          var extraField = entry.extraFields[i];
          if (extraField.id === 0x7075) {
            if (extraField.data.length < 6) {
              // too short to be meaningful
              continue;
            }
            // Version       1 byte      version of this extra field, currently 1
            if (extraField.data.readUInt8(0) !== 1) {
              // > Changes may not be backward compatible so this extra
              // > field should not be used if the version is not recognized.
              continue;
            }
            // NameCRC32     4 bytes     File Name Field CRC32 Checksum
            var oldNameCrc32 = extraField.data.readUInt32LE(1);
            if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
              // > If the CRC check fails, this UTF-8 Path Extra Field should be
              // > ignored and the File Name field in the header should be used instead.
              continue;
            }
            // UnicodeName   Variable    UTF-8 version of the entry File Name
            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
            break;
          }
        }
      }

      // validate file size
      if (self.validateEntrySizes && entry.compressionMethod === 0) {
        var expectedCompressedSize = entry.uncompressedSize;
        if (entry.isEncrypted()) {
          // traditional encryption prefixes the file data with a header
          expectedCompressedSize += 12;
        }
        if (entry.compressedSize !== expectedCompressedSize) {
          var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
          return emitErrorAndAutoClose(self, new Error(msg));
        }
      }

      if (self.decodeStrings) {
        if (!self.strictFileNames) {
          // allow backslash
          entry.fileName = entry.fileName.replace(/\\/g, "/");
        }
        var errorMessage = validateFileName(entry.fileName, self.validateFileNameOptions);
        if (errorMessage != null) return emitErrorAndAutoClose(self, new Error(errorMessage));
      }
      self.emit("entry", entry);

      if (!self.lazyEntries) self._readEntry();
    });
  });
};

ZipFile.prototype.openReadStream = function(entry, options, callback) {
  var self = this;
  // parameter validation
  var relativeStart = 0;
  var relativeEnd = entry.compressedSize;
  if (callback == null) {
    callback = options;
    options = {};
  } else {
    // validate options that the caller has no excuse to get wrong
    if (options.decrypt != null) {
      if (!entry.isEncrypted()) {
        throw new Error("options.decrypt can only be specified for encrypted entries");
      }
      if (options.decrypt !== false) throw new Error("invalid options.decrypt value: " + options.decrypt);
      if (entry.isCompressed()) {
        if (options.decompress !== false) throw new Error("entry is encrypted and compressed, and options.decompress !== false");
      }
    }
    if (options.decompress != null) {
      if (!entry.isCompressed()) {
        throw new Error("options.decompress can only be specified for compressed entries");
      }
      if (!(options.decompress === false || options.decompress === true)) {
        throw new Error("invalid options.decompress value: " + options.decompress);
      }
    }
    if (options.start != null || options.end != null) {
      if (entry.isCompressed() && options.decompress !== false) {
        throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
      }
      if (entry.isEncrypted() && options.decrypt !== false) {
        throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
      }
    }
    if (options.start != null) {
      relativeStart = options.start;
      if (relativeStart < 0) throw new Error("options.start < 0");
      if (relativeStart > entry.compressedSize) throw new Error("options.start > entry.compressedSize");
    }
    if (options.end != null) {
      relativeEnd = options.end;
      if (relativeEnd < 0) throw new Error("options.end < 0");
      if (relativeEnd > entry.compressedSize) throw new Error("options.end > entry.compressedSize");
      if (relativeEnd < relativeStart) throw new Error("options.end < options.start");
    }
  }
  // any further errors can either be caused by the zipfile,
  // or were introduced in a minor version of yauzl,
  // so should be passed to the client rather than thrown.
  if (!self.isOpen) return callback(new Error("closed"));
  if (entry.isEncrypted()) {
    if (options.decrypt !== false) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
  }
  // make sure we don't lose the fd before we open the actual read stream
  self.reader.ref();
  var buffer = newBuffer(30);
  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
    try {
      if (err) return callback(err);
      // 0 - Local file header signature = 0x04034b50
      var signature = buffer.readUInt32LE(0);
      if (signature !== 0x04034b50) {
        return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
      }
      // all this should be redundant
      // 4 - Version needed to extract (minimum)
      // 6 - General purpose bit flag
      // 8 - Compression method
      // 10 - File last modification time
      // 12 - File last modification date
      // 14 - CRC-32
      // 18 - Compressed size
      // 22 - Uncompressed size
      // 26 - File name length (n)
      var fileNameLength = buffer.readUInt16LE(26);
      // 28 - Extra field length (m)
      var extraFieldLength = buffer.readUInt16LE(28);
      // 30 - File name
      // 30+n - Extra field
      var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
      var decompress;
      if (entry.compressionMethod === 0) {
        // 0 - The file is stored (no compression)
        decompress = false;
      } else if (entry.compressionMethod === 8) {
        // 8 - The file is Deflated
        decompress = options.decompress != null ? options.decompress : true;
      } else {
        return callback(new Error("unsupported compression method: " + entry.compressionMethod));
      }
      var fileDataStart = localFileHeaderEnd;
      var fileDataEnd = fileDataStart + entry.compressedSize;
      if (entry.compressedSize !== 0) {
        // bounds check now, because the read streams will probably not complain loud enough.
        // since we're dealing with an unsigned offset plus an unsigned size,
        // we only have 1 thing to check for.
        if (fileDataEnd > self.fileSize) {
          return callback(new Error("file data overflows file bounds: " +
              fileDataStart + " + " + entry.compressedSize + " > " + self.fileSize));
        }
      }
      var readStream = self.reader.createReadStream({
        start: fileDataStart + relativeStart,
        end: fileDataStart + relativeEnd,
      });
      var endpointStream = readStream;
      if (decompress) {
        var destroyed = false;
        var inflateFilter = zlib.createInflateRaw();
        readStream.on("error", function(err) {
          // setImmediate here because errors can be emitted during the first call to pipe()
          setImmediate(function() {
            if (!destroyed) inflateFilter.emit("error", err);
          });
        });
        readStream.pipe(inflateFilter);

        if (self.validateEntrySizes) {
          endpointStream = new AssertByteCountStream(entry.uncompressedSize);
          inflateFilter.on("error", function(err) {
            // forward zlib errors to the client-visible stream
            setImmediate(function() {
              if (!destroyed) endpointStream.emit("error", err);
            });
          });
          inflateFilter.pipe(endpointStream);
        } else {
          // the zlib filter is the client-visible stream
          endpointStream = inflateFilter;
        }
        // this is part of yauzl's API, so implement this function on the client-visible stream
        endpointStream.destroy = function() {
          destroyed = true;
          if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);
          readStream.unpipe(inflateFilter);
          // TODO: the inflateFilter may cause a memory leak. see Issue #27.
          readStream.destroy();
        };
      }
      callback(null, endpointStream);
    } finally {
      self.reader.unref();
    }
  });
};

function Entry() {
}
Entry.prototype.getLastModDate = function() {
  return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
};
Entry.prototype.isEncrypted = function() {
  return (this.generalPurposeBitFlag & 0x1) !== 0;
};
Entry.prototype.isCompressed = function() {
  return this.compressionMethod === 8;
};

function dosDateTimeToDate(date, time) {
  var day = date & 0x1f; // 1-31
  var month = (date >> 5 & 0xf) - 1; // 1-12, 0-11
  var year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108

  var millisecond = 0;
  var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)
  var minute = time >> 5 & 0x3f; // 0-59
  var hour = time >> 11 & 0x1f; // 0-23

  return new Date(year, month, day, hour, minute, second, millisecond);
}

function validateFileName(fileName) {
  if (fileName.indexOf("\\") !== -1) {
    return "invalid characters in fileName: " + fileName;
  }
  if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
    return "absolute path: " + fileName;
  }
  if (fileName.split("/").indexOf("..") !== -1) {
    return "invalid relative path: " + fileName;
  }
  // all good
  return null;
}

function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
  if (length === 0) {
    // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file
    return setImmediate(function() { callback(null, newBuffer(0)); });
  }
  reader.read(buffer, offset, length, position, function(err, bytesRead) {
    if (err) return callback(err);
    if (bytesRead < length) {
      return callback(new Error("unexpected EOF"));
    }
    callback();
  });
}

util.inherits(AssertByteCountStream, Transform);
function AssertByteCountStream(byteCount) {
  Transform.call(this);
  this.actualByteCount = 0;
  this.expectedByteCount = byteCount;
}
AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
  this.actualByteCount += chunk.length;
  if (this.actualByteCount > this.expectedByteCount) {
    var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
    return cb(new Error(msg));
  }
  cb(null, chunk);
};
AssertByteCountStream.prototype._flush = function(cb) {
  if (this.actualByteCount < this.expectedByteCount) {
    var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
    return cb(new Error(msg));
  }
  cb();
};

util.inherits(RandomAccessReader, EventEmitter);
function RandomAccessReader() {
  EventEmitter.call(this);
  this.refCount = 0;
}
RandomAccessReader.prototype.ref = function() {
  this.refCount += 1;
};
RandomAccessReader.prototype.unref = function() {
  var self = this;
  self.refCount -= 1;

  if (self.refCount > 0) return;
  if (self.refCount < 0) throw new Error("invalid unref");

  self.close(onCloseDone);

  function onCloseDone(err) {
    if (err) return self.emit('error', err);
    self.emit('close');
  }
};
RandomAccessReader.prototype.createReadStream = function(options) {
  var start = options.start;
  var end = options.end;
  if (start === end) {
    var emptyStream = new PassThrough();
    setImmediate(function() {
      emptyStream.end();
    });
    return emptyStream;
  }
  var stream = this._readStreamForRange(start, end);

  var destroyed = false;
  var refUnrefFilter = new RefUnrefFilter(this);
  stream.on("error", function(err) {
    setImmediate(function() {
      if (!destroyed) refUnrefFilter.emit("error", err);
    });
  });
  refUnrefFilter.destroy = function() {
    stream.unpipe(refUnrefFilter);
    refUnrefFilter.unref();
    stream.destroy();
  };

  var byteCounter = new AssertByteCountStream(end - start);
  refUnrefFilter.on("error", function(err) {
    setImmediate(function() {
      if (!destroyed) byteCounter.emit("error", err);
    });
  });
  byteCounter.destroy = function() {
    destroyed = true;
    refUnrefFilter.unpipe(byteCounter);
    refUnrefFilter.destroy();
  };

  return stream.pipe(refUnrefFilter).pipe(byteCounter);
};
RandomAccessReader.prototype._readStreamForRange = function(start, end) {
  throw new Error("not implemented");
};
RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
  var readStream = this.createReadStream({start: position, end: position + length});
  var writeStream = new Writable();
  var written = 0;
  writeStream._write = function(chunk, encoding, cb) {
    chunk.copy(buffer, offset + written, 0, chunk.length);
    written += chunk.length;
    cb();
  };
  writeStream.on("finish", callback);
  readStream.on("error", function(error) {
    callback(error);
  });
  readStream.pipe(writeStream);
};
RandomAccessReader.prototype.close = function(callback) {
  setImmediate(callback);
};

util.inherits(RefUnrefFilter, PassThrough);
function RefUnrefFilter(context) {
  PassThrough.call(this);
  this.context = context;
  this.context.ref();
  this.unreffedYet = false;
}
RefUnrefFilter.prototype._flush = function(cb) {
  this.unref();
  cb();
};
RefUnrefFilter.prototype.unref = function(cb) {
  if (this.unreffedYet) return;
  this.unreffedYet = true;
  this.context.unref();
};

var cp437 = '\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';
function decodeBuffer(buffer, start, end, isUtf8) {
  if (isUtf8) {
    return buffer.toString("utf8", start, end);
  } else {
    var result = "";
    for (var i = start; i < end; i++) {
      result += cp437[buffer[i]];
    }
    return result;
  }
}

function readUInt64LE(buffer, offset) {
  // there is no native function for this, because we can't actually store 64-bit integers precisely.
  // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.
  // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.
  var lower32 = buffer.readUInt32LE(offset);
  var upper32 = buffer.readUInt32LE(offset + 4);
  // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.
  return upper32 * 0x100000000 + lower32;
  // as long as we're bounds checking the result of this function against the total file size,
  // we'll catch any overflow errors, because we already made sure the total file size was within reason.
}

// Node 10 deprecated new Buffer().
var newBuffer;
if (typeof Buffer.allocUnsafe === "function") {
  newBuffer = function(len) {
    return Buffer.allocUnsafe(len);
  };
} else {
  newBuffer = function(len) {
    return new Buffer(len);
  };
}

function defaultCallback(err) {
  if (err) throw err;
}


/***/ }),

/***/ 2357:
/***/ ((module) => {

"use strict";
module.exports = require("assert");;

/***/ }),

/***/ 7303:
/***/ ((module) => {

"use strict";
module.exports = require("async_hooks");;

/***/ }),

/***/ 4293:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");;

/***/ }),

/***/ 3129:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");;

/***/ }),

/***/ 7082:
/***/ ((module) => {

"use strict";
module.exports = require("console");;

/***/ }),

/***/ 7619:
/***/ ((module) => {

"use strict";
module.exports = require("constants");;

/***/ }),

/***/ 6417:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");;

/***/ }),

/***/ 881:
/***/ ((module) => {

"use strict";
module.exports = require("dns");;

/***/ }),

/***/ 8614:
/***/ ((module) => {

"use strict";
module.exports = require("events");;

/***/ }),

/***/ 5747:
/***/ ((module) => {

"use strict";
module.exports = require("fs");;

/***/ }),

/***/ 8605:
/***/ ((module) => {

"use strict";
module.exports = require("http");;

/***/ }),

/***/ 7211:
/***/ ((module) => {

"use strict";
module.exports = require("https");;

/***/ }),

/***/ 2282:
/***/ ((module) => {

"use strict";
module.exports = require("module");;

/***/ }),

/***/ 1631:
/***/ ((module) => {

"use strict";
module.exports = require("net");;

/***/ }),

/***/ 2087:
/***/ ((module) => {

"use strict";
module.exports = require("os");;

/***/ }),

/***/ 5622:
/***/ ((module) => {

"use strict";
module.exports = require("path");;

/***/ }),

/***/ 630:
/***/ ((module) => {

"use strict";
module.exports = require("perf_hooks");;

/***/ }),

/***/ 1058:
/***/ ((module) => {

"use strict";
module.exports = require("readline");;

/***/ }),

/***/ 2413:
/***/ ((module) => {

"use strict";
module.exports = require("stream");;

/***/ }),

/***/ 8213:
/***/ ((module) => {

"use strict";
module.exports = require("timers");;

/***/ }),

/***/ 4016:
/***/ ((module) => {

"use strict";
module.exports = require("tls");;

/***/ }),

/***/ 3867:
/***/ ((module) => {

"use strict";
module.exports = require("tty");;

/***/ }),

/***/ 8835:
/***/ ((module) => {

"use strict";
module.exports = require("url");;

/***/ }),

/***/ 1669:
/***/ ((module) => {

"use strict";
module.exports = require("util");;

/***/ }),

/***/ 7549:
/***/ ((module) => {

"use strict";
module.exports = require("vscode");;

/***/ }),

/***/ 8761:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(7114);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=main.js.map